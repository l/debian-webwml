#use wml::debian::template title="Debian GNU/Hurd --- Udvikling" NOHEADER="yes"
#use wml::debian::translation-check translation="1.31"
#include "$(ENGLISHDIR)/ports/hurd/menu.inc"

<h1>Debian GNU/Hurd</h1>

<h2>Udvikling af distributionen</h2>

<h3>Startdisketter</h3>

<p>Pt. arbejder vi ikke på "native" startdisketter.  Vi er dog i gang med de
foretage de indledende forberedelser, og tilpasser nogle gange nødvendige
individuelle pakker.  Hvis du vil hjælpe til, så arbejd på projektet 
debian-installer og forvis dig om at dets komponenter kører under Hurd.</p>

<h3>Tilpasning af Debian-pakker</h3>

<p>Hvis du vil hjælpe til med tilpasningen af Debian GNU/Hurd, skal du gøre dig
bekendt med Debians pakningssystem.  Når det er gjort, ved at læse tilgængelig
dokumentation og besøge <a href="$(HOME)/devel/">udviklerhjørnet</a> skulle du
vide hvordan man udpakker Debians-kildekodepakker og opbygger en Debian-pakke.
Her er et lynkursus til glæde for de meget dovne:</p>

<h3>Anskaffelse af kildekode og opbygning af pakker</h3>

<p>Udpakning af Debian-kildekodepakker kræver filen 
<code>package_version.dsc</code> og filerne anført i den.  Man oprette Debians
opbygningsmappe med kommandoen <code>dpkg-source -x 
package_version.dsc</code></p>

<p>Opbygning af en pakke foretages i det nu oprettede Debian-opbygningsmappe
<code>package-version</code> med kommandoen <code>dpkg-buildpackage -B -rsudo
"-mMitNavn &lt;MinEmail&gt;"</code>. I stedet for <code>-B</code> kan man bruge
<code>-b</code>, hvis man også ønsker at opbygge de arkitekturuafhængige dele 
af pakken.  Man kan bruge <code>-rfakeroot</code> i stedet for 
<code>-rsudo</code> hvis man bruger pakken fakeroot.  <code>-r</code> er ikke 
nødvendig hvis man bygger pakker som brugeren root.  Man kan tilføje 
<code>-uc</code> for at undgå signering af pakken med ens pgp-nøgle.</p>

<h3>Vælg en pakke</h3>

<p>Hvilken pakke skal der arbejdes på?  Enhver pakke som endnu ikke er 
tilpasset, men skal tilpasses.  Dette ændrer sig hele tiden, så vælg enten en
tilfældig pakke eller vær på udkig efter oplysninger om den automatiske 
opbygningsproces på postlisten debian-hurd.</p>

<h4>Pakker der ikke skal tilpasses</h4>

<p>Nogle af disse paker, eller dele af dem, kan måske tilpasses senere, men pt.
vurderes de om ikke andet til at være umulige at tilpasse.</p>

<ul>
  <li><code>base/update</code>, fordi Hurd ikke har brug for en update-dæmon
      (filsystemerne synkroniserer sig selv).  For at ældre 
      synkroniseringsintervallet kan man bruge <code>fsysopts</code> for at 
      justere på parameteret <code>--sync</code>.  Man kan opsætte forskellige
      synkroniseringsintervaller for hvert enkelt filsystem!  For at gøre det
      manuelt anvendes et <a href="hurd-doc-utils#syncfs">\
      <code>syncfs</code>-værktøj</a>.</li>
  <li><code>base/makedev</code>, fordi Hurd har sin egen version af dette 
      scipt.  Debians kildekodepakke indeholder kun en Linux-specifik 
      version.</li>
  <li><code>base/ld.so</code>, fordi Hurd bruger den linker som leveres med
      GNU C-biblioteket.</li>
  <li><code>base/modconf</code> og <code>base/modutils</code>, fordi moduler er
      et Linux-specifikt koncept.</li>
  <li><code>base/netbase</code>, fordi de resterende ting er meget specifikt
      rettet med Linux-kernen.  Hurd bruger i stedet 
      <code>inetutils</code>.</li>
  <li><code>base/pcmcia-cs</code>, fordi Hurd ikke understøtter PCMCIA (og hvis
      den gjorde, ville denne pakke formentlig være Linux-specifik).</li>
  <li><code>base/procps</code>, fordi denne kode er specifikt rettet mod Linux'
      proc-filsystem.</li>
  <li><code>base/ppp</code> og <code>base/pppconfig</code>, fordi Hurd ikke
      understøtter PPP (og hvis den gjorde, ville denne pakke formentlig være
      Linux-specifik).</li>
  <li><code>base/setserial</code>, fordi den er specifikt rettet mod 
      Linux-kernen.  Dog vil vi måske kunne bruge den da Linux' char-drivere er 
      tilpasset til GNU Mach.</li>
</ul>

<h3>Generelle tilpasningsproblemstillinger</h3>

<p>Her er en liste over fælles inkompatibiliteter som man kan støde ind i når 
man oversætter programmel som ikke er tilstrækkeligt tilpasningsvenligt, under 
Hurd.</p>

<ul>
  <li><code>Bad File Descriptor</code>
    <p>Hvis du får fejlen <code>Bad File Descriptor</code> når programmet 
    prøver at læse fra en fil (eller bare tilgå den), så undersøg kaldet af 
    <code>open()</code>. Det andet parameter er tilgangsmetoden. Hvis tallet er
    hårdtkodet i stedet for et symbol defineret i standard-headerfilerne, er 
    koden forkert og bør rettes til enten at bruge 
    <code>O_RDONLY</code>, <code>O_WRONLY</code> eller
    <code>O_RDWR</code>. Denne fejl blev blandt andre fundet i pakkerne
    <code>fortunes</code> og <code>mtools</code></p></li>
  <li><code>PATH_MAX</code>
    <p>Enhver ubetinget anvendelse af <code>PATH_MAX</code> er inkompatibel med
    POSIX. Hvis der ikke er en øvre grænse på længen af en sti, er dette symbol
    ikke defineret i nogen headerfil.  I stedet skal du enten anvende en anden
    implementering som ikke er afhængig af længden på en streng, eller bruge
    <code>sysconf()</code> for at finde frem til længden under kørslen. Hvis
    <code>sysconf()</code> returnerer <code>-1</code> skal du bruge 
    <code>realloc()</code> for dynamisk at allokere den nødvendige 
    hukommelse.</p></li>
  <li><code>MAXHOSTNAMELEN</code>
    <p>se <code>PATH_MAX</code></p></li>
  <li><code>MAXPATHLEN</code>
    <p>se <code>PATH_MAX</code></p></li>
  <li><code>NOFILE</code>
    <p>se <code>PATH_MAX</code></p></li>
  <li>Hurd-specifik <code>#define</code>
    <p>Hvis du er nødt til at inkludere Hurd-specifik kode ved hjælp af 
    <code>#if...#endif</code>, så kan du bruge symbolet <code>__GNU__</code>
    for at gøre dette.  Men tænk dig om (mindst) tre! gange før du gør det. I
    de <em>fleste</em> tilfælde er det fuldstændig unødvendigt og vil give 
    flere problemer end det måske kan løse. Spørg hellere på postlisten hvordan
    dette gøres på den rigtige måde, hvis du ikke kan finde på en bedre 
    løsning.</p></li>
  <li><code>sys_errlist[]</code> mod <code>strerror()</code>
    <p>Hvis et program kun understøtter <code>sys_errlist[]</code> er du nødt 
    til at arbejde for at få det til at oversætte under Hurd, som har smidt
    understøttelse for det væk og kun tilbyder <code>strerror()</code>. Steinar
    Hamre skriver følgende om <code>strerror()</code>:</p>
    <blockquote class="documentquote">
      <p><code>strerror()</code> bør anvendes fordi:
      <ul>
	<li>Det der den moderne og POSIX-måde.</li>
	<li>Den er lokaliseret.</li>
	<li>Den håndterer ukorrekte signaler/number som er udenfor rækkefølge.
	    (Bedre fejlhåndtering og ikke en kandidat til et bufferoverløb 
	    eller en sikkerhedsrisiko.)</li>
	</ul>
	<p><code>strerror()</code> bør altid anvendes hvis den er tilgængelig.
	Desværre er der stadig nogle <em>gamle</em> ikke-POSIX-systemer der ikke
	har <code>strerror()</code>, men kun <code>sys_errlist[]</code>.</p>	
	<p>I dag er det meget bedre kun at understøtte <code>strerror()</code>,
	end kun at understøtte <code>sys_errlist[]</code>. Det bedste (fra et
	tilpasningssyspunkt), er dog at understøtte dem begge.  
	Til <code>configure.in</code> skal man bruge:</p>
	<p><code>AC_CHECK_FUNCS(strerror)</code></p>
	<p>Til <code>config.h.in</code> skal man tilføje:</p>
	<p><code>#undef HAVE_STRERROR</code></p>
	<p>Og dernæst noget i retning af:
	<pre>
	    \#ifndef HAVE_STRERROR
	    static char *
	    private_strerror (errnum)
	         int errnum;
	    {
	      extern char *sys_errlist[];
	      extern int sys_nerr;

              if (errnum &gt; 0 &amp;&amp; errnum &lt;= sys_nerr)
	        return sys_errlist[errnum];
	      return "Unknown system error";
	    }
	    \#define strerror private_strerror
	    \#endif /* HAVE_STRERROR */
	</pre>
	<p>Man kan for eksempel kigge i den seneste fileutils (ovenstående er
	en forenklet version af hvad jeg fandt dér).  Rettelser (patches) bør
	selvfølgelig sendes til opstrømsvedligeholdere, dette er meget nyttigt,
	selv på systemer med en fungerende <code>sys_errlist[]</code>.</p>
      </blockquote></li>
  <li>Filnavne som slutter på en skråstreg, "/"
      <p>Disse er ondskabsfulde hvis de ikke eksisterer og du ønsker at 
      navngive en mappe på denne måde.  For eksempel fungerer <code>mkdir 
      foobar/</code> <em>ikke</em> under Hurd.  Dette er POSIX-kompatiblet.
      POSIX siger at en mappes sti kan slutte med en skråstreg.  Men 
      mappen findes ikke endnu, hvorfor stien ikke refererer til en mappe,
      og derfor er der ikke garanti for at afsluttede skråstreger vil
      fungere.  Smid skråstregerne væk og der vil ikke være problemer.</p>
</ul>

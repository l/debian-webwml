#use wml::debian::ctime


<define-tag noitemsforthisyear whitespace=delete>
  <gettext>No items for this year.</gettext>
</define-tag>

<define-tag proposed whitespace=delete>
  <gettext>proposed</gettext>
</define-tag>

<define-tag discussed whitespace=delete>
  <gettext>discussed</gettext>
</define-tag>

<define-tag votedon whitespace=delete>
  <gettext>voted on</gettext>
</define-tag>

<define-tag finished whitespace=delete>
  <gettext>finished</gettext>
</define-tag>
<define-tag withdrawn whitespace=delete>
  <gettext>withdrawn</gettext>
</define-tag>

<define-tag future_events whitespace=delete>
  <gettext>Future events</gettext>
</define-tag>
<define-tag past_events whitespace=delete>
  <gettext>Past events</gettext>
</define-tag>

# DO NOT translate anything below here. If you feel something needs to be changed, write to
# debian-www first

<perl>

# get_recent_list grabs the date and title of the last $number special files
# $from directory year. The special files can be news, events, security
# advisories and vote summaries.
#
# If $number is zero then all the news items are shown.
#
# The format parameter specifies the type of output: numbered, definition
# and bulleted list, a table, or a RDF file.
#
# The match parameter is a regexp used to determine if the file is special,
# i.e. that it should be parsed.
# 
# example usage:
# get_recent_list ('1998', '0', '$(ENGLISHDIR)/News', '', '\d+\w*')

# Events will be sorted in normal order instead of reverse

sub get_recent_list {
  my ($year, $number, $eng_dir, $format, $match) = @_;

  if ($format =~ order) {
    $listhead = '<ol>';
    $listfoot = '</ol>';
    $elemhead = '<li>';
    $elemfoot = '- ';
    $elemrealfoot = '';
  } elsif ($format =~ bullet) {
    $listhead = '<ul>';
    $listfoot = '</ul>';
    $elemhead = '<li>';
    $elemfoot = '- ';
    $elemrealfoot = '';
  } elsif ($format =~ list) {
    $listhead = '<dl>';
    $listhead = '<dl compact>' if $format eq cdeflist;
    $listfoot = '</dl>';
    $elemhead = '<dt>';
    $elemfoot = '<dd>';
    $elemrealfoot = '';
  } elsif ($format =~ table) {
    $listhead = '<table>';
    $listfoot = '</table>';
    $elemhead = '<tr><td>';
    $elemdate = '</td><td>';
    $elemfoot = '';
    $elemrealfoot = '</td></tr>';
  } else {
    $listhead = '';
    $listfoot = '';
    $elemhead = '';
    $elemfoot = '- ';
    $elemrealfoot = '';
  }

  my $str = $listhead;

  opendir DIR, "$eng_dir/$year";
  @files = grep { /^$match.wml$/ && -f "$eng_dir/$year/$_" } readdir(DIR);
  @files = sort {$b cmp $a} @files;
  @files = reverse @files if ($eng_dir =~ m,/events/\d{4}$,);
  closedir DIR;

#  warn "files: " . join " ", @files; warn "\n";
#  warn "year=$year number=$number eng_dir=$eng_dir format=$format match=$match\n";
  $count = 0;
  $str .= grab_titles($year, $number, $eng_dir, $format, $match);

  if ($count < $number && $number ne 0) {
    @tmp = split('/', $year);
    $tmp[$#tmp]--;
    # $year--;
    $year = join('/', @tmp);
    if (-d "$eng_dir/$year") {
      opendir DIR, "$eng_dir/$year" or warn "couldn't open dir $eng_dir/$year\n";
      @files = grep { /^$match.wml$/ && -f "$eng_dir/$year/$_" } readdir(DIR);
      @files = sort {$b cmp $a} @files;
      closedir DIR;
      $str .= grab_titles($year, $number, $eng_dir, $format, $match);
    }
  }
  if ($count eq 0) {
    $str .= "<noitemsforthisyear/>\n";
  }
  $str .= $listfoot;
  # these two lines are a dumb kludge, happens with events/
  $str =~ s/$listhead(.+)\n$listhead/$1\n$listhead/;
  $str =~ s/$listfoot\n$listfoot/$listfoot/;
  return $str;
}

# grab_titles is an auxiliary function to get_recent_list, which actually
# does the real work. It is separated to avoid duplication.

sub grab_titles {
my ($year, $number, $eng_dir, $format, $match) = @_;
my $over = $current = $base = $str1 = $str = "";
my $is_events = 0;

foreach $file (@files) {
  ($trans_title = $file) =~ s/wml/title/;
  $count++;
  open FILE, "$year/$file" or open FILE, "$year/$trans_title" or open FILE, "$eng_dir/$year/$file" or warn "couldn't open $eng_dir/$year/$file: $!\n";
  $base = $1 if ($file =~ /($match).wml/);
  my $event = '';
  if ($WML_SRC_DIRNAME =~ /events/) { # shouldn't waste time if it's not events
    $is_events = 1;
<protect pass=2>
    foreach (<FILE>) {
      if (/^#use wml::debian::past_event$/) {
        $event = "past";
      } elsif (/^#use wml::debian::event$/) {
        $event = "current";
      }
    }
</protect>
    seek FILE, 0, SEEK_SET;
  }
#  warn (stat FILE)[7]; warn "\n";
  $title = ''; $date = ''; $rdate = ''; $desc = ''; $status = ''; $where = '';
<protect pass=2>
  foreach $line (<FILE>) {
       if ($line =~ /^<define-tag pagetitle>\s*(.*)\s*<\/define-tag>$/) { $title = qq/$1/; }   # all
    elsif ($line =~ /^<define-tag release_date>(.*)<\/define-tag>$/) { $date = qq/$1/; } # News
    elsif ($line =~ /^<define-tag where>(.*)<\/define-tag>$/) { $where = qq/$1/; }       # events
    elsif ($line =~ /^<define-tag date>(.*)<\/define-tag>$/) { $date = qq/$1/; }         # events
    elsif ($line =~ /^<define-tag description>(.*)<\/define-tag>$/) { $desc = qq/$1/; }  # security
    elsif ($line =~ /^<define-tag status>(.*)<\/define-tag>$/) { $status = qq/$1/; }     # vote
</protect>
    if ($title && $date && $where) { # for events/
      $str1 = "$elemhead<tt>[$date]</tt>$elemdate <strong><a href=\"$year/$base\">$title</a></strong>, $elemfoot$where<br />$elemrealfoot\n";
      last;
    }
    elsif ($desc) { # for security/
      open DATAFILE, "$eng_dir/$year/$base.data" or warn "couldn't open $eng_dir/$year/$base.data: $!\n";
<protect pass=2>
      foreach $l (<DATAFILE>) {
           if ($l =~ /^<define-tag pagetitle>(.*)<\/define-tag>$/) { $title = qq/$1/; }
        elsif ($l =~ /^<define-tag report_date>(.*)<\/define-tag>$/) { $rdate = qq/$1/; }
      }
</protect>
      close DATAFILE;
#      warn "title: $title rdate: $rdate\n";
      $rdate = newsdate($rdate);
      $title =~ s/(DSA-\d{3})-\d{1}/$1/; # strip off the revision in the DSA number
      if ($format =~ rdf) {
        $str1 = "
<item rdf:about=\"http://www.debian.org/security/$year/$base\">
  <title>$title</title>
  <link>http://www.debian.org/security/$year/$base</link>
  <description>
$desc
  </description>
</item>
";
      } else {
        $str1 = "$elemhead<tt>[$rdate]</tt> <strong><a href=\"$year/$base\">$title</a></strong> $elemfoot$desc<br />$elemrealfoot\n";
      }
      last;
    }
    elsif ($title && $date && !$is_events) { # for News/ and not events/
      $date = newsdate($date);
      $str1 = "$elemhead<tt>[$date]</tt> <strong><a href=\"$year/$base\">$title</a></strong><br />$elemrealfoot\n";
      last;
    }
    elsif ($title && $status) { # for vote/
      $str1 = "$elemhead<a href=\"$year/$base\">$title</a> &mdash; ";
         if ( $status eq "P" ) { $str1 .= "<proposed/>"; }
      elsif ( $status eq "D" ) { $str1 .= "<discussed/>"; }
      elsif ( $status eq "V" ) { $str1 .= "<votedon/>"; }
      elsif ( $status eq "F" ) { $str1 .= "<finished/>"; }
      elsif ( $status eq "W" ) { $str1 .= "<withdrawn/>"; }
      else { $str1 .= "$status"; }
      $str1 .= "<br />$elemrealfoot\n";
      last;
    }
  } # for each line in file
  close FILE;

  if ($event ne "") { # this file was for an event
       if ( $event eq "past" ) { $over .= $str1; }
    elsif ( $event eq "current" ) { $current .= $str1;  }
  } else {
    $str .= $str1;
  }
  if ($count eq $number) { last; }
} # for each file

if ($WML_SRC_DIRNAME =~ /events/) {
  $str = "";
  if ($current) {
    $str .= "<h2><future_events/></h2>\n$listhead\n$current\n$listfoot\n";
  }
  if ($over) {
    $str .= "<h2><past_events/></h2>\n$listhead\n$over\n$listfoot\n";
  }
}

return $str;
}

# rdf_item_list outputs stuff to be used in a <rdf:Seq> section of a RDF
# file. Accepted parameters include all of get_recent_list's except for
# the format, as that is not variable.

sub rdf_item_list {
  my ($year, $number, $eng_dir, $match) = @_;
  my $count = 0;

  opendir DIR, "$eng_dir/$year";
  @files = grep { /^$match.wml$/ && -f "$eng_dir/$year/$_" } readdir(DIR);
  @files = sort {$b cmp $a} @files;
  @files = reverse @files if ($eng_dir =~ /\/events\/\d{4}$/);
  closedir DIR;

  $count += scalar @files;

  foreach my $file (@files) {
    $n++;
    last if ($n > $number && $number ne 0);
    (my $f = $file) =~ s/.wml$//;
<protect pass=2>
    print "<rdf:li resource=\"http://www.debian.org/security/$year/$f\" />\n";
</protect>
  }

  if ($count < $number && $number ne 0) {
    @tmp = split('/', $year);
    $tmp[$#tmp]--;
    $year = join('/', @tmp);
    if (-d "$eng_dir/$year") {
      opendir DIR, "$eng_dir/$year" or warn "couldn't open dir $eng_dir/$year\n";
      @files = grep { /^$match.wml$/ && -f "$eng_dir/$year/$_" } readdir(DIR);
      @files = sort {$b cmp $a} @files;
      closedir DIR;
      foreach my $file (@files) {
        $n++;
        last if ($n > $number && $number ne 0);
        (my $f = $file) =~ s/.wml$//;
<protect pass=2>
        print "<rdf:li resource=\"http://www.debian.org/security/$year/$f\" />\n";
</protect>
      }
    }
  }
}

</perl>

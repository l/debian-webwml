#use wml::debian::ctime
#use wml::debian::common_tags


<define-tag noitemsforthisyear whitespace=delete>
  <gettext>No items for this year.</gettext>
</define-tag>

<define-tag proposed whitespace=delete>
  <gettext>proposed</gettext>
</define-tag>

<define-tag discussed whitespace=delete>
  <gettext>discussed</gettext>
</define-tag>

<define-tag votedon whitespace=delete>
  <gettext>voted on</gettext>
</define-tag>

<define-tag finished whitespace=delete>
  <gettext>finished</gettext>
</define-tag>
<define-tag withdrawn whitespace=delete>
  <gettext>withdrawn</gettext>
</define-tag>

<define-tag future_events whitespace=delete>
  <gettext>Future events</gettext>
</define-tag>
<define-tag past_events whitespace=delete>
  <gettext>Past events</gettext>
</define-tag>

<perl>

# get_recent_list grabs the date and title of the last $number special files
# $from directory year. The special files can be news, events, security
# advisories and vote summaries.
#
# If $number is zero then all the news items are shown.
#
# The format parameter specifies the type of output: numbered, definition
# and bulleted list, a table, or a RDF file (rdf or rdflong).
#
# The match parameter is a regexp used to determine if the file is special,
# i.e. that it should be parsed.
# 
# example usage:
# get_recent_list ('1998', '0', '$(ENGLISHDIR)/News', '', '\d+\w*')

# Events will be sorted in normal order instead of reverse

sub get_recent_list {
  my ($year, $number, $eng_dir, $format, $match) = @_;

  if ($format =~ order) {
    $listhead = '<ol>';
    $listfoot = '</ol>';
    $elemhead = '<li>';
    $elemfoot = '- ';
    $elemrealfoot = '';
  } elsif ($format =~ bullet) {
    $listhead = '<ul>';
    $listfoot = '</ul>';
    $elemhead = '<li>';
    $elemfoot = '- ';
    $elemrealfoot = '';
  } elsif ($format =~ list) {
    $listhead = '<dl>';
    $listhead = '<dl compact>' if $format eq cdeflist;
    $listfoot = '</dl>';
    $elemhead = '<dt>';
    $elemfoot = '<dd>';
    $elemrealfoot = '';
  } elsif ($format =~ table) {
    $listhead = '<table>';
    $listfoot = '</table>';
    $elemhead = '<tr><td>';
    $elemdate = '</td><td>';
    $elemfoot = '';
    $elemrealfoot = '</td></tr>';
  } else {
    $listhead = '';
    $listfoot = '';
    $elemhead = '';
    $elemfoot = '- ';
    $elemrealfoot = '';
  }

  my $str = $listhead;

  opendir DIR, "$eng_dir/$year";
  @files = grep { /^$match.wml$/ && -f "$eng_dir/$year/$_" } readdir(DIR);
  @files = sort {$b cmp $a} @files;
  @files = reverse @files if ($eng_dir =~ m,/events/\d{4}$,);
  closedir DIR;

#  warn "files: " . join " ", @files; warn "\n";
#  warn "year=$year number=$number eng_dir=$eng_dir format=$format match=$match\n";
  $count = 0;
  $str .= grab_titles($year, $number, $eng_dir, $format, $match);

  if ($count < $number && $number ne 0) {
    @tmp = split('/', $year);
    $tmp[$#tmp]--;
    # $year--;
    $year = join('/', @tmp);
    if (-d "$eng_dir/$year") {
      opendir DIR, "$eng_dir/$year" or warn "couldn't open dir $eng_dir/$year\n";
      @files = grep { /^$match.wml$/ && -f "$eng_dir/$year/$_" } readdir(DIR);
      @files = sort {$b cmp $a} @files;
      closedir DIR;
      $str .= grab_titles($year, $number, $eng_dir, $format, $match);
    }
  }
  if ($count eq 0) {
    $str .= "<noitemsforthisyear/>\n";
  }
  $str .= $listfoot;
  # these two lines are a dumb kludge, happens with events/
  $str =~ s/$listhead(.+)\n$listhead/$1\n$listhead/;
  $str =~ s/$listfoot\n$listfoot/$listfoot/;
  return $str;
}

# grab_titles is an auxiliary function to get_recent_list, which actually
# does the real work. It is separated to avoid duplication.

sub grab_titles {
my ($year, $number, $eng_dir, $format, $match) = @_;
my $over = $current = $base = $str1 = $str = "";
my $is_events = 0;

foreach $file (@files) {
  ($trans_title = $file) =~ s/wml/title/;
  $count++;
  open FILE, "$year/$file" or open FILE, "$year/$trans_title" or open FILE, "$eng_dir/$year/$file" or warn "couldn't open $eng_dir/$year/$file: $!\n";
  $base = $1 if ($file =~ /($match).wml/);
  my $content;
  {
    local $/;
    $content = <FILE>;
  }
  close FILE;

  my $event = '';

  if ($WML_SRC_DIRNAME =~ /events/) { # shouldn't waste time if it's not events
    $is_events = 1;
<protect pass=2>
    if ($content =~ /^#use wml::debian::past_event$/m) {
      $event = "past";
    } elsif ($content =~ /^#use wml::debian::event$/m) {
      $event = "current";
    }
</protect>
  }

  $title = ''; $date = ''; $rdate = ''; $desc = ''; $status = ''; $where = '';
  $moreinfo = ''; $startdate = ''; $enddate = '';
  $repfile = '';
<protect pass=2>
  if ($content =~ /^<define-tag pagetitle>\s*(.*?)\s*<\/define-tag>$/ms) {
    $title = qq/$1/; }      # all
  if ($content =~ /^<define-tag release_date>(.*?)<\/define-tag>$/ms) {
    $date = qq/$1/; }       # News
  if ($content =~ /^<define-tag where>(.*?)<\/define-tag>$/ms) {
    $where = qq/$1/; }      # events
  if ($content =~ /^<define-tag date>(.*?)<\/define-tag>$/ms) {
    $date = qq/$1/; }       # events
  if ($content =~ /^<define-tag description>(.*?)<\/define-tag>$/ms) {
    $desc = qq/$1/; }       # security
  if ($content =~ /^<define-tag moreinfo>(?:(.*?<\/p>)|(.*?)<\/define-tag>)$/ms) {
    $moreinfo = qq/$1/; }   # dsa-long.XX.rdf
  if ($content =~ /^<define-tag status>(.*?)<\/define-tag>$/ms) {
    $status = qq/$1/; }     # vote
  if ($content =~ /^<define-tag startdate>(.*?)<\/define-tag>$/ms) {
    $startdate = qq/$1/; }	# startdate (events)
  if ($content =~ /^<define-tag enddate>(.*?)<\/define-tag>$/ms) {
    $enddate = $1; }        # enddate (events)
  my ($shortfile) = $file =~ /^(.*)\.wml$/;
  if ($content =~ /<a\s+href="($shortfile-report)"\s*>/ms) {
    $repfile = $1; }        # Report (events)
  if ($content =~ /<rep\s+href="([^"]*)"\s*\/?>/ms) {
    $repfile = $1; }        # Report (events)
</protect>
  if ($startdate && $enddate) { # Convert date range into printable string
    $date = &daterange($startdate, $enddate);
  }
  if ($title && $date && $where) { # for events/
    $report = ($repfile)
            ? " [<a href=\"$repfile\"><gettext>Report</gettext></a>]"
            : '';
    $str1 = "$elemhead<tt>[$date]</tt>$elemdate <strong><a href=\"$year/$base\">$title</a></strong>, $elemfoot$where$report<br />$elemrealfoot\n";
  }
  elsif ($desc) { # for security/
    open DATAFILE, "$eng_dir/$year/$base.data" or warn "couldn't open $eng_dir/$year/$base.data: $!\n";
<protect pass=2>
    foreach $l (<DATAFILE>) {
         if ($l =~ /^<define-tag pagetitle>(.*)<\/define-tag>$/) { $title = qq/$1/; }
      elsif ($l =~ /^<define-tag report_date>(.*)<\/define-tag>$/) { $rdate = qq/$1/; }
    }
</protect>
    close DATAFILE;
#    warn "title: $title rdate: $rdate\n";
    $rdate = newsdate($rdate);
    $title =~ s/(DSA-\d{3})-\d{1}/$1/; # strip off the revision in the DSA number
    if ($format eq 'rdf') {
      $str1 = "
<item rdf:about=\"http://www.debian.org/security/$year/$base\">
  <title>$title</title>
  <link>http://www.debian.org/security/$year/$base</link>
  <description>
    $desc
  </description>
</item>
";
    } elsif ($format eq 'rdflong') {
      $str1 = "
<item rdf:about=\"http://www.debian.org/security/$year/$base\">
  <title>$title - $desc</title>
  <link>http://www.debian.org/security/$year/$base</link>
  <description>
    $moreinfo
  </description>
</item>
";
    } else {
      $str1 = "$elemhead<tt>[$rdate]</tt> <strong><a href=\"$year/$base\">$title</a></strong> $elemfoot$desc<br />$elemrealfoot\n";
    }
  }
  elsif ($title && $date && !$is_events) { # for News/ and not events/
    $date = newsdate($date);
    $str1 = "$elemhead<tt>[$date]</tt> <strong><a href=\"$year/$base\">$title</a></strong><br />$elemrealfoot\n";
  }
  elsif ($title && $status) { # for vote/
    $str1 = "$elemhead<a href=\"$year/$base\">$title</a> &mdash; ";
       if ( $status eq "P" ) { $str1 .= "<proposed/>"; }
    elsif ( $status eq "D" ) { $str1 .= "<discussed/>"; }
    elsif ( $status eq "V" ) { $str1 .= "<votedon/>"; }
    elsif ( $status eq "F" ) { $str1 .= "<finished/>"; }
    elsif ( $status eq "W" ) { $str1 .= "<withdrawn/>"; }
    else { $str1 .= "$status"; }
    $str1 .= "<br />$elemrealfoot\n";
  }

  if ($event ne "") { # this file was for an event
       if ( $event eq "past" ) { $over .= $str1; }
    elsif ( $event eq "current" ) { $current .= $str1;  }
  } else {
    $str .= $str1;
  }
  if ($count eq $number) { last; }
} # for each file

if ($WML_SRC_DIRNAME =~ /events/) {
  $str = "";
  if ($current) {
    $str .= "<h2><future_events/></h2>\n$listhead\n$current\n$listfoot\n";
  }
  if ($over) {
    $str .= "<h2><past_events/></h2>\n$listhead\n$over\n$listfoot\n";
  }
}

return $str;
}

# rdf_item_list outputs stuff to be used in a <rdf:Seq> section of a RDF
# file. Accepted parameters include all of get_recent_list's except for
# the format, as that is not variable.

sub rdf_item_list {
  my ($year, $number, $eng_dir, $match) = @_;
  my $count = 0;

  opendir DIR, "$eng_dir/$year";
  @files = grep { /^$match.wml$/ && -f "$eng_dir/$year/$_" } readdir(DIR);
  @files = sort {$b cmp $a} @files;
  @files = reverse @files if ($eng_dir =~ /\/events\/\d{4}$/);
  closedir DIR;

  $count += scalar @files;

  foreach my $file (@files) {
    $n++;
    last if ($n > $number && $number ne 0);
    (my $f = $file) =~ s/.wml$//;
<protect pass=2>
    print "<rdf:li resource=\"http://www.debian.org/security/$year/$f\" />\n";
</protect>
  }

  if ($count < $number && $number ne 0) {
    @tmp = split('/', $year);
    $tmp[$#tmp]--;
    $year = join('/', @tmp);
    if (-d "$eng_dir/$year") {
      opendir DIR, "$eng_dir/$year" or warn "couldn't open dir $eng_dir/$year\n";
      @files = grep { /^$match.wml$/ && -f "$eng_dir/$year/$_" } readdir(DIR);
      @files = sort {$b cmp $a} @files;
      closedir DIR;
      foreach my $file (@files) {
        $n++;
        last if ($n > $number && $number ne 0);
        (my $f = $file) =~ s/.wml$//;
<protect pass=2>
        print "<rdf:li resource=\"http://www.debian.org/security/$year/$f\" />\n";
</protect>
      }
    }
  }
}

</perl>

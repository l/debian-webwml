#use wml::debian::ctime

# Please keep slices sorted alphabetically with the exception of English.

<define-tag noitemsforthisyear whitespace=delete>
	[EN:No items for this year.:]
	[AR:ÍÊøì ÚäÕÑ åÐÇ ÇáÚÇã:]
	[CA:Cap ítem per aquest any:]
	[DA:Ingen i dette år.:]
	[DE:Keine Einträge für dieses Jahr.:]
	[EL:Ôßðïôá ãéá áõôüí ôï ÷ñüíï.:]
	[EO:Estas nenio por æi tiu jaro.:]
	[ES:No hay elementos para este año.:]
	[FI:Ei otsikoita tältä vuodelta:]
	[FR:Pas d'éléments cette année.:]
	[HR:Za ovu godinu nema èlanaka.:]
	[ID:Untuk tahun ini tidak ada:]
	[IT:Nessun articolo per quest'anno.:]
	[JA:º£Ç¯ÅÙ¤Î¹àÌÜ¤Ï¤¢¤ê¤Þ¤»¤ó¡£:]
	[KO:No items for this year.:]
	[NL:Geen items voor dit jaar.:]
	[NO:Ingen begivenheter dette året:]
	[PL:Brak wydarzeñ w tym roku.:]
	[PT:Sem ítens neste ano.:]
	[RO:Nu sînt articole pentru anul acesta.:]
	[RU:îÅÔ ÎÉÞÅÇÏ ÚÁ ÜÔÏÔ ÇÏÄ.:]
	[SV:Ingenting detta år.:]
	[TR:Bu yIl iCin bilgi yok:]
	[ZH:¥»¦~«×¤ºÁÙ¥¼¦³¥ô¦ó·s®ø®§¡C:]
</define-tag>

<define-tag proposed whitespace=delete>
	[EN:proposed:]
	[AR:proposed:]
	[CA:proposat:]
	[DA:foreslået:]
	[DE:vorgeschlagen:]
	[EL:ðñüôáóç:]
	[EO:proponita:]
	[ES:propuesto:]
	[FI:ehdotettu:]
	[FR:proposé:]
	[HR:predlo¾eno:]
	[HU:proposed:]
	[ID:telah diajukan:]
	[IT:proposto:]
	[JA:proposed:]
	[KO:proposed:]
	[NL:voorgesteld:]
	[NO:foreslått:]
	[PL:proposed:]
	[PT:proposto:]
	[RO:propuse:]
	[RU:proposed:]
	[SV:föreslagen:]
	[TR:proposed:]
	[ZH:proposed:]
</define-tag>

<define-tag discussed whitespace=delete>
	[EN:discussed:]
	[AR:discussed:]
	[CA:Discutit:]
	[DA:diskuteret:]
	[DE:diskutiert:]
	[EL:Ý÷ïõí óõæçôçèåß:]
	[EO:diskutita:]
	[ES:discutido:]
	[FI:keskusteltu:]
	[FR:en discussion:]
	[HR:diskutirano:]
	[HU:discussed:]
	[ID:telah didiskusikan:]
	[IT:discusso:]
	[JA:discussed:]
	[KO:discussed:]
	[NL:besproken:]
	[NO:diskutert:]
	[PL:discussed:]
	[PT:discutido:]
	[RO:discutate:]
	[RU:discussed:]
	[SV:diskuterad:]
	[TR:discussed:]
	[ZH:discussed:]
</define-tag>

<define-tag votedon whitespace=delete>
	[EN:voted on:]
	[AR:voted on:]
	[CA:Votat el:]
	[DA:afstemt:]
	[DE:abgestimmt:]
	[EL:øçößóôçêå óôßò:]
	[EO:vocxdonita je la:]
	[ES:votado el:]
	[FI:äänestetty:]
	[FR:en cours de vote:]
	[HR:glasano:]
	[HU:voted on:]
	[ID:dipilih pada:]
	[IT:votato il:]
	[JA:voted on:]
	[KO:voted on:]
	[NL:op gestemd:]
	[NO:avstemt:]
	[PL:voted on:]
	[PT:votado em:]
	[RO:votate:]
	[RU:voted on:]
	[SV:omröstad:]
	[TR:voted on:]
	[ZH:voted on:]
</define-tag>

<define-tag finished whitespace=delete>
	[EN:finished:]
	[AR:finished:]
	[CA:acabat:]
	[DA:afsluttet:]
	[DE:abgelaufen:]
	[EL:ôåëåßùóå:]
	[EO:finita:]
	[ES:terminado:]
	[FI:päätetty:]
	[FR:terminé:]
	[HR:zavr¹eno:]
	[HU:finished:]
	[ID:selesai:]
	[IT:terminato:]
	[JA:finished:]
	[KO:finished:]
	[NL:afgelopen:]
	[NO:avsluttet:]
	[PL:finished:]
	[PT:acabado:]
	[RO:terminate:]
	[RU:finished:]
	[SV:avslutad:]
	[TR:finished:]
	[ZH:finished:]
</define-tag>
<define-tag withdrawn whitespace=delete>
	[EN:withdrawn:]
	[AR:withdrawn:]
	[CA:withdrawn:]
	[DA:tilbagetrukket:]
	[DE:withdrawn:]
	[EL:withdrawn:]
	[EO:withdrawn:]
	[ES:withdrawn:]
	[FI:withdrawn:]
	[FR:withdrawn:]
	[HR:withdrawn:]
	[HU:withdrawn:]
	[ID:withdrawn:]
	[IT:withdrawn:]
	[JA:withdrawn:]
	[KO:withdrawn:]
	[NL:withdrawn:]
	[NO:tilbaketrukket:]
	[PL:withdrawn:]
	[PT:withdrawn:]
	[RO:withdrawn:]
	[RU:withdrawn:]
	[SV:tillbakadraget:]
	[TR:withdrawn:]
	[ZH:withdrawn:]
</define-tag>

<define-tag future_events whitespace=delete>
	[EN:Future events:]
	[AR:Future events:]
	[CA:Esdeveniments futurs:]
	[DA:Kommende begivenheder:]
	[DE:Kommende Veranstaltungen:]
	[EL:Future events:]
	[EO:Future events:]
	[ES:Eventos futuros:]
	[FI:Tulevia tapahtumia:]
	[FR:Événements à venir:]
	[HR:Buduæi dogaðaji:]
	[HU:Eljövendõ események:]
	[ID:Acara mendatang:]
	[IT:Eventi futuri:]
	[JA:Future events:]
	[KO:Future events:]
	[NL:Future events:]
	[NO:Kommende begivenheter:]
	[PL:Future events:]
	[PT:Eventos seguintes:]
	[RO:Evenimente viitoare:]
	[RU:Future events:]
	[SV:Kommande evenemang:]
	[TR:Future events:]
	[ZH:Future events:]
</define-tag>
<define-tag past_events whitespace=delete>
	[EN:Past events:]
	[AR:Past events:]
	[CA:Esdeveniments passats:]
	[DA:Tidligere begivenheder:]
	[DE:Vergangene Veranstaltungen:]
	[EL:Past events:]
	[EO:Past events:]
	[ES:Eventos pasados:]
	[FI:Menneitä tapahtumia:]
	[FR:Événements passés:]
	[HR:Pro¹li dogaðaji:]
	[HU:Régebbi események:]
	[ID:Acara yang lalu:]
	[IT:Eventi passati:]
	[JA:Past events:]
	[KO:Past events:]
	[NL:Past events:]
	[NO:Tidligere begivenheter:]
	[PL:Past events:]
	[PT:Eventos anteriores:]
	[RO:Evenimente trecute:]
	[RU:Past events:]
	[SV:Tidigare evenemang:]
	[TR:Past events:]
	[ZH:Past events:]
</define-tag>

# DO NOT translate anything below here. If you feel something needs to be changed, write to
# debian-www first

<perl>

# get_recent_list grabs the date and title of the last $number special files
# $from directory year. The special files can be news, events, security
# advisories and vote summaries.
#
# If $number is zero then all the news items are shown.
#
# The format parameter specifies the type of output: numbered, definition
# and bulleted list, a table, or a RDF file.
#
# The match parameter is a regexp used to determine if the file is special,
# i.e. that it should be parsed.
# 
# example usage:
# get_recent_list ('1998', '0', '$(ENGLISHDIR)/News', '', '\d+\w*')

# Events will be sorted in normal order instead of reverse

sub get_recent_list {
  my ($year, $number, $eng_dir, $format, $match) = @_;

  if ($format =~ order) {
    $listhead = '<ol>';
    $listfoot = '</ol>';
    $elemhead = '<li>';
    $elemfoot = '- ';
  } elsif ($format =~ bullet) {
    $listhead = '<ul>';
    $listfoot = '</ul>';
    $elemhead = '<li>';
    $elemfoot = '- ';
  } elsif ($format =~ list) {
    $listhead = '<dl>';
    $listhead = '<dl compact>' if $format eq cdeflist;
    $listfoot = '</dl>';
    $elemhead = '<dt>';
    $elemfoot = '<dd>';
  } elsif ($format =~ table) {
    $listhead = '<table>';
    $listfoot = '</table>';
    $elemhead = '<tr><td>';
    $elemdate = '</td><td>';
    $elemfoot = '';
  } else {
    $listhead = '';
    $listfoot = '';
    $elemhead = '';
    $elemfoot = '- ';
  }

  my $str = $listhead;

  opendir DIR, "$eng_dir/$year";
  @files = grep { /^$match.wml$/ && -f "$eng_dir/$year/$_" } readdir(DIR);
  @files = sort {$b cmp $a} @files;
  @files = reverse @files if ($eng_dir =~ m,/events/\d{4}$,);
  closedir DIR;

#  warn "files: " . join " ", @files; warn "\n";
#  warn "year=$year number=$number eng_dir=$eng_dir format=$format match=$match\n";
  $count = 0;
  $str .= grab_titles($year, $number, $eng_dir, $format, $match);

  if ($count < $number && $number ne 0) {
    @tmp = split('/', $year);
    $tmp[$#tmp]--;
    # $year--;
    $year = join('/', @tmp);
    if (-d "$eng_dir/$year") {
      opendir DIR, "$eng_dir/$year" or warn "couldn't open dir $eng_dir/$year\n";
      @files = grep { /^$match.wml$/ && -f "$eng_dir/$year/$_" } readdir(DIR);
      @files = sort {$b cmp $a} @files;
      closedir DIR;
      $str .= grab_titles($year, $number, $eng_dir, $format, $match);
    }
  }
  if ($count eq 0) {
    $str .= "<noitemsforthisyear/>\n";
  }
  $str .= $listfoot;
  # these two lines are a dumb kludge, happens with events/
  $str =~ s/$listhead(.+)\n$listhead/$1\n$listhead/;
  $str =~ s/$listfoot\n$listfoot/$listfoot/;
  return $str;
}

# grab_titles is an auxiliary function to get_recent_list, which actually
# does the real work. It is separated to avoid duplication.

sub grab_titles {
my ($year, $number, $eng_dir, $format, $match) = @_;
my $over = $current = $base = $str1 = $str = "";
my $is_events = 0;

foreach $file (@files) {
  ($trans_title = $file) =~ s/wml/title/;
  $count++;
  open FILE, "$year/$file" or open FILE, "$year/$trans_title" or open FILE, "$eng_dir/$year/$file" or warn "couldn't open $eng_dir/$year/$file: $!\n";
  $base = $1 if ($file =~ /($match).wml/);
  my $event = '';
  if ($WML_SRC_DIRNAME =~ /events/) { # shouldn't waste time if it's not events
    $is_events = 1;
<protect pass=2>
    foreach (<FILE>) {
      if (/^#use wml::debian::past_event$/) {
        $event = "past";
      } elsif (/^#use wml::debian::event$/) {
        $event = "current";
      }
    }
</protect>
    seek FILE, 0, SEEK_SET;
  }
#  warn (stat FILE)[7]; warn "\n";
  $title = ''; $date = ''; $rdate = ''; $desc = ''; $status = ''; $where = '';
<protect pass=2>
  foreach $line (<FILE>) {
       if ($line =~ /^<define-tag pagetitle>\s*(.*)\s*<\/define-tag>$/) { $title = qq/$1/; }   # all
    elsif ($line =~ /^<define-tag release_date>(.*)<\/define-tag>$/) { $date = qq/$1/; } # News
    elsif ($line =~ /^<define-tag where>(.*)<\/define-tag>$/) { $where = qq/$1/; }       # events
    elsif ($line =~ /^<define-tag date>(.*)<\/define-tag>$/) { $date = qq/$1/; }         # events
    elsif ($line =~ /^<define-tag description>(.*)<\/define-tag>$/) { $desc = qq/$1/; }  # security
    elsif ($line =~ /^<define-tag status>(.*)<\/define-tag>$/) { $status = qq/$1/; }     # vote
</protect>
    if ($title && $date && $where) { # for events/
      $str1 = "$elemhead<tt>[$date]</tt>$elemdate <strong><a href=\"$year/$base\">$title</a></strong>, $elemfoot$where<br />\n";
      last;
    }
    elsif ($desc) { # for security/
      open DATAFILE, "$eng_dir/$year/$base.data" or warn "couldn't open $eng_dir/$year/$base.data: $!\n";
<protect pass=2>
      foreach $l (<DATAFILE>) {
           if ($l =~ /^<define-tag pagetitle>(.*)<\/define-tag>$/) { $title = qq/$1/; }
        elsif ($l =~ /^<define-tag report_date>(.*)<\/define-tag>$/) { $rdate = qq/$1/; }
      }
</protect>
      close DATAFILE;
#      warn "title: $title rdate: $rdate\n";
      $rdate = newsdate($rdate);
      $title =~ s/(DSA-\d{3})-\d{1}/$1/; # strip off the revision in the DSA number
      if ($format =~ rdf) {
        $str1 = "
<item rdf:about=\"http://www.debian.org/security/$year/$base\">
  <title>$title</title>
  <link>http://www.debian.org/security/$year/$base</link>
  <description>
$desc
  </description>
</item>
";
      } else {
        $str1 = "$elemhead<tt>[$rdate]</tt> <strong><a href=\"$year/$base\">$title</a></strong> $elemfoot$desc<br />\n";
      }
      last;
    }
    elsif ($title && $date && !$is_events) { # for News/ and not events/
      $date = newsdate($date);
      $str1 = "$elemhead<tt>[$date]</tt> <strong><a href=\"$year/$base\">$title</a></strong><br />\n";
      last;
    }
    elsif ($title && $status) { # for vote/
      $str1 = "$elemhead<a href=\"$year/$base\">$title</a> &mdash; ";
         if ( $status eq "P" ) { $str1 .= "<proposed/>"; }
      elsif ( $status eq "D" ) { $str1 .= "<discussed/>"; }
      elsif ( $status eq "V" ) { $str1 .= "<votedon/>"; }
      elsif ( $status eq "F" ) { $str1 .= "<finished/>"; }
      elsif ( $status eq "W" ) { $str1 .= "<withdrawn/>"; }
      else { $str1 .= "$status"; }
      $str1 .= "<br />\n";
      last;
    }
  } # for each line in file
  close FILE;

  if ($event ne "") { # this file was for an event
       if ( $event eq "past" ) { $over .= $str1; }
    elsif ( $event eq "current" ) { $current .= $str1;  }
  } else {
    $str .= $str1;
  }
  if ($count eq $number) { last; }
} # for each file

if ($WML_SRC_DIRNAME =~ /events/) {
  $str = "";
  if ($current) {
    $str .= "<h2><future_events/></h2>\n$listhead\n$current\n$listfoot\n";
  }
  if ($over) {
    $str .= "<h2><past_events/></h2>\n$listhead\n$over\n$listfoot\n";
  }
}

return $str;
}

# rdf_item_list outputs stuff to be used in a <rdf:Seq> section of a RDF
# file. Accepted parameters include all of get_recent_list's except for
# the format, as that is not variable.

sub rdf_item_list {
  my ($year, $number, $eng_dir, $match) = @_;
  my $count = 0;

  opendir DIR, "$eng_dir/$year";
  @files = grep { /^$match.wml$/ && -f "$eng_dir/$year/$_" } readdir(DIR);
  @files = sort {$b cmp $a} @files;
  @files = reverse @files if ($eng_dir =~ /\/events\/\d{4}$/);
  closedir DIR;

  $count += scalar @files;

  foreach my $file (@files) {
    $n++;
    last if ($n > $number && $number ne 0);
    (my $f = $file) =~ s/.wml$//;
<protect pass=2>
    print "<rdf:li resource=\"http://www.debian.org/security/$year/$f\" />\n";
</protect>
  }

  if ($count < $number && $number ne 0) {
    @tmp = split('/', $year);
    $tmp[$#tmp]--;
    $year = join('/', @tmp);
    if (-d "$eng_dir/$year") {
      opendir DIR, "$eng_dir/$year" or warn "couldn't open dir $eng_dir/$year\n";
      @files = grep { /^$match.wml$/ && -f "$eng_dir/$year/$_" } readdir(DIR);
      @files = sort {$b cmp $a} @files;
      closedir DIR;
      foreach my $file (@files) {
        $n++;
        last if ($n > $number && $number ne 0);
        (my $f = $file) =~ s/.wml$//;
<protect pass=2>
        print "<rdf:li resource=\"http://www.debian.org/security/$year/$f\" />\n";
</protect>
      }
    }
  }
}

</perl>

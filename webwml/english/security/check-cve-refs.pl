#!/usr/bin/perl -w
# Compare the CVE cross-reference with the information of DSAs in 
# the website.
#
# This is a hack (based on the cross reference map) that uses the
# information posted at CVE to determine if DSAs include the proper
# references. Code is klunky and there's quite a lot of room for 
# improvement (be my guest).
#
# Usage:
# (for the brave of heart)
#  lynx -source http://cve.mitre.org/cve/refs/refmap/source-DEBIAN.html | \
#      perl check-cve-refs.pl [-v]
#  
#
#  TODO
#  - download automatically the Mitre reference (instead of STDIN)
#  - output nice patches (+<define-tag secrefs>XXXX</secrefs>) instead
#    of the current format. This would allow the security/web team to
#    automatically update the information (after a proper review, of course)
#  - -v output should be trimmed down (i.e. provide different levels of debug)
#  - references ok! output should be omitted
#  - Ask Mitre to fix their references :-) 
#  - Since there's a lot of shared code from the make-cross-ref script have
#    them _share_ it
#  - Attempt to make it useful for Bugtraq too
#
# (c) 2003 Javier Fernandez-Sanguino 
# License : GPL


# Format of data files is:
#<define-tag pagetitle>DSA-###-# PACKAGE</define-tag>
#<define-tag report_date>yyyy-mm-dd</define-tag>
#<define-tag secrefs>CAN|CVE-XXXX-XXXX</define-tag>
#<define-tag packages>PACKAGE</define-tag>
#<define-tag isvulnerable>yes|no</define-tag>
#<define-tag fixed>yes|no</define-tag>


use Getopt::Std;
use IO::File;
# Stdin options
# -v verbose
my $opt_v = 0;
getopts('v');

# Read first all the DSA information from the current directory
# (should be english/security/ BTW to parse all the data files)
parsedirs (".", "data", 2);

# We just print for the time being only CVE references
# (and the URL is not used, yet)
comparecvererefs("CVE|CAN","http://cve.mitre.org/cve/refs/refmap/source-DEBIAN.html");

exit 0;

sub loadcverefs   {
# This should take the url  and convert it properly
# For the time being it will only take STDIN

# Finite-state machine
	my $state=0;
	while (<STDIN> ){
		chomp;
		$state = 0 if  /\<\/TR\>/ ;
		if ( $state == 1 ) {
			while ( m/((CVE|CAN)-[\d-]+)/g ) {
				my $cveref = $1;
				print STDERR "Found CVE reference $cveref for DSA $dsaref\n" if $opt_v;
				if ( ! defined $dsacverefs{$dsaref} ) {
					$dsacverefs{$dsaref} = $cveref;
				} elsif ( $dsacverefs{$dsaref} !~ /$cveref/ ) {
					$dsacverefs{$dsaref} .= " ".$cveref ;
				}
			}
		}
# Note: Old advisories have both numbers and letters! That's
# why this is \w and not \d
		if ( /\<TD\>DEBIAN:(\d+\w+)/ || /\<TD\>DEBIAN:DSA-(\d+)/ ) {
			$dsaref = $1;
			print STDERR "Found DSA $dsaref\n" if $opt_v;
			$state = 1;
		}
	}
	return 0;
}

sub comparecvedsa {
	my ($dsa,$type) = @_ ;
	my $nok=0;
	print  "Comparing references for DSA $dsa: $dsaref{$dsa}{'secrefs'}\n" if $opt_v;
	my (@references) = split(' ', $dsaref{$dsa}{'secrefs'});
	foreach $ref ( pop (@references) ) {
		if ( $ref =~ /^$type/  ) {
#Compare against those in dsacverefs
			my $notexist = 0 ;
			my $promoted = 0 ;
			if  ( defined $dsacverefs{$dsa} ) {
				my $cveprom = $ref;
				$cveprom =~ s/CAN/CVE/;
				$notexist = 1 if  $dsacverefs{$dsa} !~/$ref/;
				$promoted = 1 if  $dsacverefs{$dsa} =~/$cveprom/ and $ref =~ /^CAN/;
			} else {
				$notexist =1;
			}
			if ( $notexist ) {
				if ( $promoted )  {
					print "DSA $dsa holds candidate that needs to be promoted to CVE: $ref\n";
				} else {
					print "DSA $dsa holds reference $ref from CVE but it's not in Mitre's reference map\n";
				}
				$nok=1;
			}
		}
	}
# And viceversa
# this is quite klunky  since we are doing the same test twice.
# oh well...
	if  ( defined $dsacverefs{$dsa} ) {
		@references = split(' ', $dsacverefs{$dsa});
		foreach $ref ( pop (@references) ) {
			if ( $ref =~ /^$type/  ) { 
				my $notexist = 0 ;
				my $promoted = 0 ;
				if  ( defined $dsaref{$dsa}{'secrefs'} )  {
					my $cand = $ref;
					$cand =~ s/CVE/CAN/;
					$notexist = 1 if  $dsaref{$dsa}{'secrefs'} !~/$ref/;
					$promoted = 1 if  $dsaref{$dsa}{'secrefs'} =~ /$cand/ and $ref !~ /^CAN/;
				} else {
					$notexist =1;
				}
				if ( $notexist ) {
					if ( $promoted ) {
						print "Mitre holds a promoted reference $ref for DSA $dsa (Debian holds a candidate)\n" ;
					} else { 
						print "Mitre holds reference $ref for DSA $dsa but it's not in Debian references\n" ;
					}
					$nok=1;
				}

			} else {
				print "Mitre does not hold any information for DSA $dsa\n";
				$nok=0;
			}
		} # of foreach ref
	} # of if defined

	return $nok;

} # of sub comparecve

sub comparecvererefs {
# Compares local references to external references
	my ($text,$url) = @_;

# First load in the external references
	my %dsacverefs;
	loadcverefs();
# We take the input and compare it
	foreach $dsa (sort(keys %dsaref)) {
		print STDERR "Checking DSA $dsa\n" if $opt_v;
		if ( defined $dsaref{$dsa}{'secrefs'}) {
			my $nok = comparecvedsa($dsa,$text);
			print "DSA  $dsa and Mitre hold the same information (references ok!)\n" if ! $nok;
		} elsif ( defined $dsacverefs{$dsa} ) {
			print "Mitre holds the following references for DSA $dsa: $dsacverefs{$dsa}\n";
		}
	} #of foreach dsa

	return 0;
} #of sub

sub parsefile {
	my ($file,$filename) = @_ ;
# The filename gives us the DSA we are parsing
	if ( $filename =~ /dsa\-(\d+)/ || $filename =~ /(\d+\w+)/ ) {
		$dsa=$1;
	} else {
		print STDERR "File $file does not look like a proper DSA, not checking\n" if $opt_v;
		return 1;
	}
	print STDERR "Parsing DSA $dsa from file $file\n" if $opt_v;

	open (DATAFILE , $file) || die ("Cannot read $file: $!");
	while ($line=<DATAFILE>) {
		chomp $line;
		print STDERR "Reading $line\n" if $opt_v > 2;
		# Redefine the dsa value  if there is a pagetitle
		if ( $line =~ /pagetitle\>DSA-(\d+).*?\<\/define-tag/ ) {
			$dsa=$1;
			print STDERR "Redefined DSA to $dsa (from $file)\n" if $opt_v;
		}
		$dsaref{$dsa}{'date'}=$1 if ( $line =~ /report_date\>(.*?)\<\/define-tag/ ) ;
		$dsaref{$dsa}{'secrefs'}=$1 if ( $line =~ /secrefs\>(.*?)\<\/define-tag/ ) ;
		$dsaref{$dsa}{'packages'}=$1 if ( $line =~ /packages\>(.*?)\<\/define-tag/ ) ;
		$dsaref{$dsa}{'vulnerable'}=$1 if ( $line =~ /isvulnerable\>(.*?)\<\/define-tag/ ) ;
		$dsaref{$dsa}{'fixed'}=$1 if ( $line =~ /fixed\>(.*?)\<\/define-tag/ ) ;
	}
	close DATAFILE;
	return 0;
}

sub parsedirs {
	my ($directory, $postfix, $depth) = @_ ;
	my $dir = new IO::File;
	if ( $depth == 0 ) {
		print STDERR "Maximum depth reached ($depth) at $directory\n" if $opt_v;
		return 0;
	}
	opendir ($dir , $directory) || die ("Cannot read $directory: $!");
	while ( my $file = readdir ($dir) ) {
		print STDERR "Checking $file (for $postfix at $depth)\n" if $opt_v;
		if ( -d "${directory}/${file}"  and ! -l "${directory}/${file}" && $file !~ /^\./ ) {
			print STDERR "Entering directory ${directory}/${file}\n" if $opt_v;
			parsedirs ( "${directory}/${file}", $postfix, $depth - 1 );
		} 
		if ( -r "${directory}/${file}" && $file =~ /$postfix/ && $file !~ /^[\.\#]/ ) {
			parsefile($directory."/".$file,$file);
		}
	} # of the while
	closedir $dir;
	return 0;
}



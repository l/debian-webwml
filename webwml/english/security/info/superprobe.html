<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>Debian GNU/Linux - Security Information</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso-8859-1">
<META HTTP-EQUIV="Pragma" CONTENT="no-cache">
</HEAD>

<BODY BGCOLOR="#FFFFFF">
<H1><IMG SRC="../../Pics/debian.jpg" WIDTH=114 HEIGHT=140 ALIGN="middle" ALT="Debian GNU/Linux - ">Security Information</H1>
<HR>
Debian takes security very seriously.  Most <a href="../index.html">security problems</a> brought
to our attention are corrected within 48 hours.

<P> Please send security-related bug reports to <a href="mailto:security@debian.org">security@debian.org</a><P>

<blockquote>
<b>Date: 	Tue, 4 Mar 1997 23:24:28 -0500</b> <br>
<b>From: solar@IDEAL.RU</b> <p>

Hi! <p>

SuperProbe is a program supplied with XFree86 (to determine the type of video
hardware installed in the machine), and it is installed setuid root in many
Linux distributions. It has already been discussed here that SuperProbe got
some buffer overflows, but there still seems to be no exploit. The reason for
this might be that the exploit has to be a bit unusual. That's why I decided
to post the exploit, as an example of exploiting an overflow without dealing
with the return address. <p>

The overflow I'm exploiting is in the TestChip function: <p>

<pre>
   static Bool TestChip(chip_p, Chipset)
   Chip_Descriptor *chip_p;
   int *Chipset;
   {
       char *p, *p1, name[64];

  [...]

		   (void)strcpy(name, p);
	       }
	       if (StrCaseCmp(name, chip_p->name) == 0)

  [...]

       if (chip_p->f(Chipset))
       {
	   return(TRUE);
       }
       return(FALSE);
   }

</pre>

Chip_Descriptor is defined like this: <p>

<pre>
   typedef Bool (*ProbeFunc) __STDCARGS((int *));

[...]

  typedef struct {
           char            *name;          /* Chipset vendor/class name    */
           ProbeFunc       f;              /* Probe function               */
[...]
   } Chip_Descriptor;
</pre>


It is possible to overwrite the return address by the strcpy, but one byte of
chip_p would get zeroed out (since chip_p is located right after the return
address, and the string is ASCIIZ). This would cause the program to crash when
trying to access chip_p->name for passing it to StrCaseCmp, before the return
address is used. <p>

That's why I overwrite chip_p to point into an environment variable (well, the
return address gets overwritten also, but it's never used), which has an array
of pointers to the shellcode (located at the end of the same variable's value)
in it. One of these is first used by StrCaseCmp, so it doesn't crash, and the
next one is used as the probe function pointer, so the shellcode gets executed
when calling chip_p->f() (it might be required to adjust the alignment in my
exploit, try values 0 to 3 if the default does't work). <p>

<a href="probe.c">probe.c</a>
</blockquote>

<P><SMALL>Last Modified: 10 Jan 1998.
Copyright &copy;1997 SPI; See
<A HREF="../../license.html">license terms.</A></SMALL>
<HR>
</BODY>
</HTML>



#use wml::debian::template title="Debian GNU/Hurd" NOHEADER="yes"
[ <a href="..">Ports</a> ]
[ <a href="index">Debian GNU/Hurd</a> ]
[ <a href="hurd-news">News</a> ]
[ <a href="hurd-install">Installation</a> ]
[ <a href="hurd-doc">Documentation</a> ]
[ <a href="hurd-port">Porting</a> ]
[ <a href="hurd-task">Task Lists</a> ]
[ <a href="hurd-links">Links</a> ]
[ <a href="hurd-contact">Contact</a> ]<p>

<h1>Debian GNU/Hurd</h1>
<h2>Frequently Asked Questions (FAQ)</h2>

<h3>"General"</h3>
<p>
<b>Question</b>:
Is the Hurd under development, or is it a dead project?</p>
<p><b>Answer</b>:
It is under active development these days. We are fixing bugs to get more
stability and port many common software packages. We also add small to
medium sized features. We would like to get more developers on board, too.
There are a lot of very interesting features tobe implemented, and you
seldom get the chance to design and implement parts of an exciting
operating system!</p>

<p><b>Question</b>:
Does it run at all?</p>
<p><b>Answer:</b>
Yeah.
</p>

<h3>... At Installation Time</h3>
<P>
<B>Question</B>:
Which partition type should I use for my GNU/Hurd partition?</P>
<p><b>Answer</b>:
You should use an ext2 file system. Alternatively, you may
use BSD style ufs. The partition type number for ext2fs is 0x83 (same as Linux),
<em>not</em> 0x63 (GNU HURD). Thomas explains why 0x63 is the wrong choice:
<blockquote>
One day we may have a new filesystem format, which would probably be
called the GNU Hurd filesystem format, and might well use that
partition code.  Regardless, it is always an error to use that code
for an ext2fs partition, as Roland points out.
</blockquote>

<p><b>Question</b>:
What is my partition name/number?</p>
<p><b>Answer</b>:
I knew you would ask this. If I had to reduce this FAQ to only one question,
I'd choose this one. It is pretty easy, but you have to know that there are
actually three naming convention we face here.</p>
<p>
All naming conventions use <code>hd</code> for IDE and <code>sd</code> for
SCSI disks. So far the commonalities. Now for the differences.</p>
<p>
First, figure out the disk number. If it is a SCSI disk, you need to know
the SCSI disk number. If it is an IDE disk, you need to know on which
controller it is and if it is a master or slave. For Linux, the master
disks on the primary controller has the letter "a", the slave
on the same controller the letter "b". Master and slave on the secondary
controller have the letters "c" and "d" respectively. The Hurd does use BSD
style notation and does use "0", "1", "2" and "3" instead "a", "b", "c" and
"d". So it is <code>/dev/hdc</code> under Linux, but <code>/dev/hd2</code>
under the Hurd. Got it? Good. GRUB does it differently! GRUB is doing it
like the BIOS and enumerates all installed disks it can boot from starting
from "0" incrementing by 1. So "hd(0,?)" is a partition on the first disk it
can boot from, regardless if this is a master or slave or whatever. The
second disk it finds has "hd(1,?)" etc. Luckily, the BIOS is searching in the well
defined order primary controller master/slave, secondary controller
master/slave.</p>
<p>
Now figure out the partition number. The partition number for DOS style
partitions is the same under Linux and the Hurd, but the Hurd does use BSD
style notation with slices. So it is <code>/dev/hdc3</code> under Linux, but
<code>/dev/hd2s3</code> under the Hurd. If you use BSD partitions, you
already know what the Hurd name for this partition is. GRUB does it, again,
differently: It starts counting from "0", so <code>/dev/hd0s3</code> is
<code>hd(0,2)</code> in GRUB, <em>not</em> <code>hd(0,3)</code>!</p>

<p><b>Question</b>:
How do I add a swap partition?</p>
<p><b>Answer</b>:
A swap partition is also called a paging file. Usually, it is sufficient to
add the swap partition to <tt>/etc/fstab</tt> just as you would under Linux.
You can swap to a Linux swap partition, and the Hurd will honour the Linux
swap signature (both versions). But the Hurd will just as happily swap to
any other raw disk space and overwrite anything it finds, so be careful!
</p>
<p>If you want to swap to a file, or make sure that it checks the Linux swap
signature before, you need to edit <tt>/boot/servers.boot</tt>. The syntax
is the partition device file name, plus optionally the swap file inside an
ext2fs, followed by a space and then one of
<tt>$(add-raw-paging-file)</tt>, </tt>$(add-linux-paging-file)</tt>,
<tt>$(add-paging-file)</tt>. The first works with any partition/file and
does not honour any swap sigature or other data. The second has a safety
check and only works if a Linux swap signature can be found. The third looks
for a swap signature first and falls back to raw paging if it couldn't find
one. This is also the default for entries in <tt>/etc/fstab</tt>.
</p>

<p><b>Question</b>:
I get <code>Operation not permitted</code> error at installation time!</p>
<p><b>Answer</b>:
You forgot to set the file system owner of the Hurd partition to
<code>hurd</code>. The Hurd does use additional information in inodes to set
translators, to make this work the partition must be marked as "owned by the
Hurd". You can do this with <code>mke2fs -o hurd /dev/XXX</code> when
creating the partition or afterwards using the <code>e2os</code> script.</p>

<p><b>Question</b>:
Why is <code>/usr</code> a symbolic link to <code>.</code>?
<p><b>Answer</b>:
The distinction between <code>/</code> and <code>/usr</code> has historical
reasons, back when Unix systems were booted from two tapes, a small root
tapes an big user tape. Today, we like to use different partitions for these
two spaces. The Hurd throws this historical garbage away, as we think that
we have found a more flexible solution, shadow filesystems. Unfortunately,
shadowfs is not yet implemented.</P>

<p><b>Question</b>:
What about X?
<p><b>Answer</b>:
Don't ask.</p>

<p><b>Question</b>:
Why?
<p><b>Answer</b>:
The problem is not X, most of X is ported. The complete X distribution
compiles and the programs run. Even the server seem to run just fine.
However, we need to port the Linux character devices to GNU Mach, so we have
a fancy keyboard server and PS/2 mouse support etc. Until then, the servers
are not useful. But you can run the clients with a remote display.</p>

<p><b>Question</b>:
My X clients won't work!
<p><b>Answer</b>:
Try <code>export LD_LIBRARY_PATH=/usr/X11R6</code>. This is a linker issue.
The Hurd systems wants to use <code>RPATH</code>, and Debian does avoid
<code>RPATH</code>. Sorry, there is no solution for this currently but
setting <code>LD_LIBRARY_PATH</code> to a list of all libraries in unusual
places.</p>

<h3>Translators</h3>

<p><b>Question</b>:
What's a translator?</p>
<p><b>Answer</b>:
The translator concept is what makes the Hurd different from other operating
systems. It is really powerful. Think of a translator as a program that sits
between you and the rest of the system, on top of a directory entry (inode).
Whenever you access the directory entry through the C library, the
translator gets notified and asked what to return back. This will happen
completely transparently, the program accessing the inode won't see a
difference to a normal file or directory.</p>
<p>
For example, file system server are really translators in the Hurd. Imagine
someone listing the directory content below the mount point. The
<code>ls</code> program will ask the C library about it, which in turn
asks the file system translator of the root file system about it. This
program returns whatever it finds in the file system of the partition in
question.</p>
<p>
Device files are another example. If you use them, you really communicate
with the translator behind them. You can see which translator belongs to an
inode with the <a href="hurd-doc-utils#showtrans"><code>showtrans</code></a>
command. This will only show you the passive translator though.</p>

<p><b>Question</b>:
Passive translator?</p>
<p><b>Answer</b>:
Yep. The passive translator is simply the command which shall be run when an
inode is accessed. The command is written down verbatim in the inode,
including all options it shall be started with. As long as the inode is not
accessed, the command is not run, it will simply be static data in the file
system. Only when the inode is accessed, the passive translator will be read
and the command executed.</p>
<p>
As an example, think of the automounter feature. An automounter is a piece
of software that can mount file systems automatically when needed.
Unmounting is usually implemented with a timeout. On the Hurd, you don't
need special software for this (an automounter is usually a kernel extension
in monolithic kernels). It's all there as an integral part of the system.
You set the passive translator using
<a href="reference-manual/hurd_7.html#SEC49"><code>settrans</code></a>, and
when you access the mount point by any file system operation, an active
translator will be started.</p>
<p>
Because the passive translator is written directly into the file system, it
is transient, that means, it will stay during reboots.</p>

<p><b>Question</b>:
Active Translator?</p>
<p><b>Answer</b>:
Yep again. The active translator is simply the currently running translator.
Don't mix them up, they can be completely different or can have different
command line options (configuration). You can change the options of an
active translator with <code>fsysopts</code> without actually
restarting it. This is very convenient. For example, you can do what is
called "remounting a partition read-only" under Linux simply by running
<code>fsysopts /mntpoint --readonly</code>. The running active translator
will change its behaviour according to your wish dynamically.
<code>fsysopts</code> without a parameter shows you the current
settings.</p>
<p>
You can start up an active translator again using the
<code>settrans</code> command, but with the <code>-a</code> option. Because
an active translator is only a running task, it will be lost when the
machine is rebooted.</p>

<p><b>Question</b>:
What was a translator again?
<p><b>Answer</b>:
Do you mean a passive or an active translator? <tt>:)</tt></p>
<p>
A <em>passive translator</em> is a command line, consisting of the server
to be started and necessary options. It is stored transiently inside an inode
of the file system. This command is not run until the passive translator is
used to start an active translator. You can write and read passive translators
to an inode with <code>settrans</code> and <code>showtrans</code>
respectively.</p>
<p>
An <em>active translator</em> is a running translator task that is currently
serving an inode. It can be different from the underlying passive
translator, but if there isn't an active translator already it will be
started using the command line that is actually the passive translator.
You can query and change the current options of an active translator using
the <code>fsysopts</code> command, and you can set active translators with
<code>settrans -a</code>.</p>

<p><b>Question</b>:
How can I play with translators without breaking anything?
<p><b>Answer</b>:
I recommend that you start by reading the <code>/bin/mount</code> command,
it is only a small script. Because setting file system translators is
similar to mounting partitions, you can easily grasp the concept this way.
Make a file system image with <code>dd if=/dev/zero of=dummy.fs bs=1024k
count=8; mke2fs dummy.fs</code> and "mount" it with <code>settrans -c dummy
/hurd/ext2fs `pwd`/dummy.fs</code>. Note that the translator is not started
yet, no new <code>ext2fs</code> process is running (verify with <code>ps
Aux</code>). Check that everything is correct using <code>showtrans</code></p>
<p>
Now type <code>ls dummy</code> and you will notice the short delay that
occurs while the translator is started. After that, there will be no more
delays accessing dummy. Under Linux, one would say that you automounted a
loop file system. Check with <code>ps Aux</code> that there is an <code>ext2fs
dummy</code> process up and running now. Now put some files into the new
directory. Try to make the filesystem read-only with <code>fsysopts</code>.
Note how further write attempts fail now. Try to kill the active translator
with <code>settrans -g</code>.</p>
<p>
You should have some understanding of what is going on now. Now remember
that this was only <em>one</em> special server, the Hurd Ext2fs server.
There are many more server in the <code/hurd</code> directory. Some of them
are for filesystems. Some are needed for file system features like links.
Some are needed for device files. Some are useful for networking. Imagine
"mounting" an FTP Server with <code>settrans</code> and downloading files
simply with the standard <code>cp</code> command. Or editing your web sites
with <code>emacs /ftp/homepage.my.server.org/index.html</code>!</p>

<h3>... When Something Breaks</h3>

<p><b>Question</b>:
What is a <tt>default pager</tt>, <tt>paging</tt>, or a
<tt>pager request</tt>?</p>
<p><b>Answer</b>:
The default pager handles the virtual memory allocation. If it can't
allocate a new memory page, because you are out of memory, some terrible
things may happen. Whenever you get such errors you either need more memory
or you have found a memory leak. Always add a swap partition.</p>

<p><b>Question</b>:
What is a <tt>Gratuitous error</tt>?</p>
<p><b>Answer</b>:
This is coming from <tt>strerror(EGRATUITOUS)</tt>. If you check glibc's
documentation, it will say that this error code has no purpose <tt>:)</tt>.
However, this is not quite true. You only get this when something terrible
happened. Thomas explains:
<blockquote>
More precisely EGRATUITOUS officially means that some server has
responded in an impossible or protocol-violating fashion.  There are
some cases in the Hurd where EGRATUITOUS is returned and probably
something else should be chosen instead.
</blockquote>
If you can reproduce this error message, please report it. But <em>do
not</em> report this for accessing <tt>/dev/fd</tt>, we already know that.
</p>

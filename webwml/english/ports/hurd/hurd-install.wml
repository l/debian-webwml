#use wml::debian::template title="Debian GNU/Hurd --- Installation" NOHEADER="yes"
#include "$(ENGLISHDIR)/ports/hurd/menu.inc"

<h1>Debian GNU/Hurd Installation</h1>
<p>
This document aims to provide an easy and relatively painless set of
instructions on how to get Debian GNU/Hurd up and running with a minimum amount
of effort.
</p>

<p>It is based in Neal H. Walfield's
<a href="http://web.walfield.org/pub/people/neal/papers/hurd-installation-guide/english/hurd-install-guide.html">
"The Hurd Installation Guide"</a>. Many thanks to Neal for his contribution.
</p>

<p>
Note that some points in this manual are a bit inconvenient because they take a
lot of time and may cause problems. You may prefer the installation over the
<a href="hurd-cd">prepared CD images</a>, especially if you are a beginner.
Even if they are outdated, they usually work. You can still get updates from
the online repositories.
</p>

<h2> 1. Overview </h2>

<p>
The Debian GNU/Hurd distribution, unlike distributions of other operating
systems, does not have a nice installation program. One day it will and maybe
you will help design and implement it; however, until that day, installing
Debian GNU/Hurd requires another operating system, specifically, another
Unix-like system. Users have indicated successful installations using different
flavors of GNU/Linux as well as the BSDs. The minimum requirements of the
bootstrap operating system are the ability: to create an ext2 file system; to
extract a tar archive on to it; and to install GNU Grub.
</p>

<p>
GNU is similar in nature to any Unix-like system: after logging in, the user is
presented with a shell and the familiar Unix VFS, virtual filesystem. Although
GNU tries to be POSIX compliant, it is "Not Unix". GNU/Hurd builds upon many of
the Unix concepts and extends them to either add new functionality or to fix
what has been perceived as flaws in the original design. The most noticeable
difference is translators, user space programs which interact with the VFS.
These filesystems do not live living in the kernel nor do they need to be run
as root; they only need access to the backing store and the <CODE>mount
point</CODE>. Another difference is that processes, rather having a single
user identity fixed at creation time, have identity tokens which are disjoint
from the process, i.e. they may be added with the appropriate permission from
an authority or destroyed.
</p>

<p>
Being familiar with the Unix environment (and specialy GNU userland, found in
popular variants such as GNU/Linux) is an imperative for feeling at ease in
GNU. Having experience with the Debian tools will also prove invaluable to the
configuration and maintenance of a GNU/Hurd box.
</p>

<p>
This guide endeavors to make installing GNU/Hurd as painless a process as
possible. If there are errors, they are most certainly the author's. Please
report them, along with any other suggestions or criticisms, to him; all are
gladly accepted.
</p>


<h2> 2. Real Estate or Finding A Home </h2>

<p>
If you do not have an available partition or an extra hard drive, this can be
the longest step. In this case, you will need to repartition the hard drive.
One solution is to use GNU's partition editor, Parted. It features not only
basic partition editing but also partition resizing and moving functionality.
It can be found at <url "http://www.gnu.org/software/parted">. The manual is
quite complete and includes several tutorials.
</p>

<p>
The Hurd can only support partition sizes of up to approximately two gigabytes;
anything larger than this will not work. This limitation is due to a design
decision that was made several years ago in which the filesystem server maps
the entire filesystem into virtual memory. As the amount of virtual memory
available on an ia32 is only four gigabytes of which Mach allocates three
gigabytes to the application and, of that, a significant portion is reserved
for the code, the stack and the heap, the final, maximum contiguous virtual
memory area that remains is generally about two gigabytes. This limitation is
scheduled to be removed.
</p>

<p>
Having said that, a single two gigabyte filesystem is more than enough for a
working system. Many, however, prefer at least two filesystems: a root
filesystem and a second for <TT>`/home'</TT>. This latter scheme is highly
advised for developers: compiling the Hurd can take up quite a bit of space.
</p>

<p>
The Hurd supports several extensions to the ext2fs filesystem format. Foremost
among these are passive translators and a fourth set of permission bits for
unknown users (users without an identity--not the other user). To use these
extensions, the owner of the partition must be set to <CODE>hurd</CODE>.
<CODE>mke2fs</CODE>, unless specifically overridden on the command line, will
set the owner to whatever kernel it is running on. As the Hurd will diligently
respect this setting, care must be taken to set this appropriately or the Hurd
will fail in subtle ways. Be aware that even if a file system is owned by a
particular kernel, others may still use it; they just may not be able to use
certain extensions.
</p>

<p>
To create a filesystem, use <CODE>mke2fs</CODE> and pass it <SAMP>`-o hurd'
</SAMP> to designate the Hurd as the owner of the new file system. For
instance, assuming the parition is <TT>`/dev/hda2'</TT>:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre> # mke2fs -o hurd /dev/hda2
</pre></td></tr></table>


<h2> 3. The Boot Loader </h2>

<p>
The bootloader of the GNU system is Grub, the GRand Unified Boot loader,
and it is its main purpose to boot the GNU system core (Mach and the Hurd).
Any boot loader that supports the multiboot standard, though, may be used to
load Mach and the Hurd. At the moment (that we're aware of), GNU Grub is the
only bootloader that supports such standard.
</p>

<p>
A word about Grub. Unlike traditional boot loaders on the x86, such as LILO,
Grub is very powerful. It has a command line interface, bootp, dummy terminal
support and a plethora of other features. In addition, it can boot most any
kernel. If you have ever booted an alpha or sparc, you will understand what
Grub can do. Therefore, do not be scared: Grub is better. You will like it.
You will not go back.
</p>

<p>
To find Grub, visit <url "http://www.gnu.org/software/grub/">. Here, there is
a source tarball and a floppy image. If you choose to download the tarball, it
is a normal <CODE>configure</CODE>, <CODE>make</CODE> and <CODE>make install
</CODE>. Included is a wonderfully complete manual on how Grub works. Read it.
 If, on the other hand, you choose to download the floppy image, it is
sufficient to dump it to a floppy disk to get a working Grub, for example:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre> # dd if=grub-boot-image of=/dev/fd0
</pre></td></tr></table>

<p>
You can always install Grub onto your hard drive at a later date.
</p>


<h2> 4. Cross Install </h2>

<p>
The next step is to get a base system. There are several alternatives, if you
are running a Debian system you can use the package crosshurd. Otherwise you
can get an updated base system tarball from
<url "http://eu.hurd.gnuab.org/pub/debian/base/"> for Europe or
<url "http://na.hurd.gnuab.org/pub/debian/base/"> for North America.
</p>

<p>
The tarball is setup to extract everything into the current directory.
After the filesystem is mounted, the archive can be extracted.
Assuming that the filesystem is on <TT>`/dev/hda2'</TT>, the mount point
is <TT>`/gnu'</TT> and archive is in current user's home directory, the
following is required:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre> # mount -t ext2 /dev/hda2 /gnu
 \# cd /gnu
 \# tar --same-owner -xvjpf ~/gnu.tar.bz2
</pre></td></tr></table>


<h2> 5. Booting GNU/Hurd </h2>

<p>
All is now in readiness to boot GNU/Hurd for the first time. After verifying
that the Grub boot disk is in the drive, reboot. If all goes well, either a
Grub menu or command line will be displayed. If presented with a menu, press
<KBD>c</KBD> to go to the command line.
</p>

<p>
First, GNU Mach needs to be loaded. This requires knowing the filesystem and
the path to GNU Mach. Grub uses a partition nomenclature that is a bit
different from both Linux and the Hurd:
both IDE and SCSI drives are named <TT>`(hdN,M)'</TT>. <CODE>N</CODE> is the
drive number (zero based) as enumerated by the BIOS. That is, Grub makes no
distinction between IDE and SCSI disks. <CODE>M</CODE> identifies the partition
on the drive. It is also zero based index. If this sounds confusing, relax:
Grub is also helpful.
</p>

<p>
To determine on which filesystem a particular file resides, Grub provides the
<CODE>find</CODE> command. When this command is issued along with a filename,
Grub searches on each filesystem for the specified file and prints where it was
found. For example, to search for the kernel, <TT>`/boot/gnumach.gz'</TT>:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>  grub&#62; find /boot/gnumach.gz
   (hd0,0)
</pre></td></tr></table>

<p>
Here, Grub is indicates that <TT>`/boot/gnumach.gz'</TT> is on
<TT>`(hd0,0)'</TT>.
</p>

<p>
Before loading the kernel, at least one option, the root partition, must be
specified on the command line. This will be used by the Hurd itself (i.e. not
Grub). As such, it must be in terms that the Hurd can understand.
</p>

<p>
GNU Mach enumerates disks starting at zero. IDE drives are prefixed with
<CODE>hd</CODE>, while SCSI disks are prefixed with <CODE>sd</CODE>. Like
Linux, drives are number by their position on the controller. For instance, the
primary master is <CODE>hd0</CODE> and the secondary slave is <CODE>hd3</CODE>.
Partitions use the BSD slice naming convention and append <CODE>sM</CODE> to
the drive name to indicate a given partition. Note that <CODE>M</CODE> is a
one, not zero, based index. The slice number is simple to calculate: just
increment what was used for Grub by one.
</p>

<p>
Since the Hurd has not yet been configured, it must be started in single user
mode. Adding a <SAMP>`-s'</SAMP> to the kernel command line is all that is
required.
</p>

<p>
Assuming that the first drive (i.e. <TT>`(hd0)'</TT>) is the master on the
secondary controller, we would have:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>  grub&#62; kernel (hd0,0)/boot/gnumach.gz root=device:hd2s1 -s
   [Multiboot-elf, ...]
</pre></td></tr></table>

<p>
Next, the root filesystem server and the <CODE>exec</CODE> server must be
loaded. This is done using Grub's boot module capability. The ${var} are
filled in by GNU Mach. The arguments are used by the Hurd to indicate what
type of information is being provided. Since the ext2fs command line is very
long, it can be broken up by escaping the newline character in the normal Unix
fashion. Be sure that there is not space after the slash at the end of each
line. Also be sure to differentiate <KBD>{</KBD> and <KBD>}</KBD> from <KBD>
(</KBD> and <KBD>)</KBD>.
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>  grub&#62; module (hd0,0)/hurd/ext2fs.static \
   --multiboot-command-line=${kernel-command-line} \
   --host-priv-port=${host-port} \
   --device-master-port=${device-port} \
   --exec-server-task=${exec-task} -T typed ${root} \
   $(task-create) $(task-resume)
    [Multiboot-module  0x1c4000, 0x2cfe6a bytes]
  grub&#62; module (hd0,0)/lib/ld.so.1 /hurd/exec $(exec-task=task-create)
    [Multiboot-module  0x494000, 0x27afe bytes]
</pre></td></tr></table>

<p>
Once the Hurd is running, process can be automated by adding the appropriate
commands to Grub's <TT>`/boot/grub/menu.lst'</TT> configuration file.
</p>

<p>
GNU/Hurd can be now booted:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>grub&#62; boot
</pre></td></tr></table>

<p>
Sit back and watch the messages. This is actually more important than most
people believe: there is a bug in GNU Mach whereby hitting a key during the
boot process causes the kernel to panic.
</p>

<p>
If GNU/Hurd fails to boot, it could be due to shared IRQs: GNU Mach does not
play well with these. You can verify your situation by looking at, for
instance, the <TT>`/proc/interrupts'</TT> file under GNU/Linux. Also, as GNU
Mach does not support loadable kernel modules, many of the drivers are compiled
into the default kernel. If there are old peripherals, this can be a problem: a
device may incorrectly respond to a probe intended for a completely unrelated
device and thereby cause a crash. Building a new kernel with only the required
device drivers will usually solve this problem. GNU Mach is easily cross
compiled. If you are running Debian, try installing the <TT>`gcc-i386-gnu'</TT>
package.
</p>

<p>
If this does not help, explore the resources listed at the end of this
document. Finally, ask on the appropriate mailing list.
</p>


<h2> 6. Native Install </h2>

<p>
Once you are presented with a shell prompt, and any time that the Hurd is in
single user mode, it is necessary to set the terminal type:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre> # export TERM=mach
</pre></td></tr></table>

<p>
Be warned that <KBD>CONTROL-C</KBD> and family will not work in single user
mode.
</p>

<p>
We can now run the <CODE>native-install</CODE> script. This will configure the
packages and set up several important translators:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre> # ./native-install
</pre></td></tr></table>

<p>
Before the script terminates, it will indicate that it needs to be run a second
time. Follow its instructions and reboot using the <CODE>reboot</CODE> command.
Again, go into single user mode and run <CODE>./native-install</CODE>.
</p>


<h2> 7. Configuration </h2>


<h3> 7.1 The Network </h3>

<p>
To configure the network, the pfinet translator must be configured. This is
done using the <CODE>settrans</CODE> command to attach a translator to a given
filesystem node. When programs access the node by, for example sending an RPC,
the operating system will transparently start the server to handle the request.
</p>

<table><tr><td>&nbsp;</td><td class=example><pre> # settrans -fgap /servers/socket/2 /hurd/pfinet -i eth0 \
   -a a.b.c.d -g e.f.g.h -m i.j.k.l
</pre></td></tr></table>

<p>
Here, <CODE>settrans</CODE> is passed several options. The first two,
<SAMP>`fg'</SAMP>, force any existing translator to go away. The next two,
<SAMP>`ap'</SAMP>, make both active and passive translators. By making the
translator active, we will immediately see any error messages on
<TT>`stderr'</TT>. The latter, saves the translator and arguments in the node
so it can be transparently restarted later (i.e. making the setting persistent
across reboots). The options are followed by the node to which the translator
is to be attached, then the program (i.e. translator) to run and any arguments
to give it. The <SAMP>`-i'</SAMP> option is the interface <CODE>pfinet</CODE>
will listen on, <SAMP>`-a'</SAMP> is the ip address, <SAMP>`-g'</SAMP> is the
gateway and <SAMP>`-m'</SAMP> is the network mask.
</p>

<p>
Be sure to add name servers to your <TT>`/etc/resolv.conf'</TT> file:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>  nameserver 192.168.1.1
</pre></td></tr></table>

<p>
To test the configuration, <CODE>ping -c2 gateway</CODE>. The
<SAMP>`-c'</SAMP> is important to limit the number of pings; recall,
<KBD>CONTROL-C</KBD> does not work in single user mode.
</p>

<p>
DHCP does not yet work on the Hurd. This is due to limitations of pfinet: it is
based on the Linux' TCP/IP code and unable to listen on <TT>`0.0.0.0'</TT>.
</p>

<p>
Help on <CODE>settrans</CODE> can be obtained by passing it the
<SAMP>`--help'</SAMP> option. Help on a specific translator can be gotten by
invoking it from the command line with the same argument, e.g.:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre> # /hurd/pfinet --help
</pre></td></tr></table>

<p>
As there can be a lot of output, consider piping this through a pager such as
<CODE>less</CODE>.
</p>


<h3> 7.2 Other File Systems </h3>

<p>
Next, edit <TT>`/etc/fstab'</TT> to add any additional filesystems as well as
swap space. It is <EM>very important</EM> that swap space be used; the Hurd
will be an order of magnitude more stable. Note that the Hurd can transparently
share a swap partition with Linux but will happily page to any device including
a raw partition such as your home partition. By default, <CODE>nano</CODE> is
the only editor installed by the the base distribution.
</p>

<p>
Here is an example <TT>`/etc/fstab'</TT> file:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre># &#60;file system&#62; &#60;mount point&#62;   &#60;type&#62;  &#60;options&#62;  &#60;dump&#62;  &#60;pass&#62;
/dev/hd2s1      /               ext2    rw         0       1
/dev/hd2s2      /home           ext2    rw         0       2
/dev/hd2s3      none            swap    sw         0       0
</pre></td></tr></table>

<p>
Remember to create any devices using the <CODE>MAKEDEV</CODE> command:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre> # cd /dev
 \# ./MAKEDEV hd2s1 hd2s2 hd2s3
</pre></td></tr></table>

<p>
To mount an nfs filesystem, <CODE>/hurd/nfs</CODE> translator is used. When
run as non-root, the translator will connect to the server using a port above
1023. By default, GNU/Linux will reject this. To tell GNU/Linux to accept
connections originating from a non-reserved port, add the
<SAMP>`insecure'</SAMP> option to the export line. Here is an example
<TT>`/etc/exports'</TT> file assuming the client's ip address is
<TT>`192.168.1.2'</TT>:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>  /home  192.168.1.2(rw,insecure)
</pre></td></tr></table>

<p>
To mount this from a GNU box and assuming that nfs server's ip address is
<TT>`192.168.1.1'</TT>:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre># settrans -cgap /mount/point /hurd/nfs 192.168.1.1:/home
</pre></td></tr></table>


<h3> 7.3 Rebooting </h3>

<p>
Finally, reboot into multiuser mode, i.e. in the same way single user mode was
brought up minus the <SAMP>`-s'</SAMP> option when loading the kernel. For
details, refer to See section 5. Booting GNU/Hurd.
</p>

<p>
Happy Hacking!
</p>


<h2> 8. Final Words </h2>


<h3> 8.1 The Grub Menu </h3>

<p>
Having to always load the kernel by hand can be very tedious. Edit the
<TT>`/boot/grub/menu.lst'</TT> and tailor it appropriately; booting will
become much quicker and easier.
</p>


<h3> 8.2 Adding Devices </h3>

<p>
By default, only a few devices are created in the <TT>`/dev'</TT> directory.
Use the <CODE>MAKEDEV</CODE> script to create any needed device nodes.
</p>


<h3> 8.3 Installing More Packages </h3>
<p>
There are several ways to add packages. Downloading and using
<CODE>dpkg -i</CODE> works but is very inconvenient. The easiest method
is to use <CODE>apt-get</CODE>. Edit <TT>`/etc/apt/sources.list'</TT> and
add the following two entries:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
deb http://ftp.gnuab.org/debian unreleased main
deb http://ftp.debian.org/debian unstable main
</pre></td></tr></table>

<p>
<url "http://ftp.gnuab.org"> contains packages that have hacks or patches that
have not yet been integrated upstream. There are no mirror sites. To use a
local Debian mirror, visit <url "http://www.debian.org/distrib/ftplist">.
</p>

<p>
If GNU Mach does not recognize your network card or you use a modem, the only
way to upgrade will be to download the packages and then transfer them to the
GNU system. The easiest way to do this is to use apt off-line. Refer to
<TT>`/usr/share/doc/apt/offline'</TT> for detailed instructions.
</p>


<h3> 8.4 XFree86 </h3>

<p>
XFree86 has been ported and all video cards, which it supports that do not
require a kernel module should work.
</p>

<p>
First, set up the keyboard translator:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre> # cd /dev
 \# ./MAKEDEV kbd
</pre></td></tr></table>

<p>
And then the mouse translator. For a serial port mouse, run the following
replace <TT>`com0'</TT> with the appropriate communication port:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre> # settrans -cap /dev/mouse /hurd/mouse --device=com0 --protocol=microsoft
</pre></td></tr></table>

<p>
Make sure that <TT>`/dev/com0'</TT> actually exists. If it does not, create it
using <CODE>MAKEDEV</CODE> in the usual fashion.
</p>

<p>
PS/2 so not require a device node. It is simple a matter of:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre> # settrans -cap /dev/mouse /hurd/mouse --protocol=ps/2
</pre></td></tr></table>

<p>
Other mice can be used; run <TT>`/hurd/mouse'</TT> with the
<SAMP>`--help'</SAMP> option for details.
</p>

<p>
You will need several X packages. x-window-system-core, rxvt and twm or fvwm
are a good start.
</p>

<p>
Debconf can be used to configure XFree86, however, it is not Hurd aware and
the configuration file will need to be tweaked. Change the pointer section to
read:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>Section "Pointer"
  Protocol "osmouse"
  Device "/dev/mouse"
EndSection
</pre></td></tr></table>

<p>
<SAMP>`Emulate3Buttons'</SAMP> may be optionally added. Nothing else will
work.
</p>

<p>
GNU/Hurd does not use ld.so.conf. Since <TT>`/X11R6/lib'</TT> is not in the
default library search path, it is necessary to add the following to either
<TT>`/etc/profile'</TT> or each user's <TT>`.profile'</TT>:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>export LD_LIBRARY_PATH=/X11R6/lib:$LD_LIBRARY_PATH
</pre></td></tr></table>

<p>
Finally, run <CODE>startx</CODE>.
</p>

<p>
There are several caveats to be aware of. <CODE>xterm</CODE> does not work
correctly as it is SETGID (and thus ignores LD_LIBRARY_PATH and fails to load
the appropriate shared libraries); try <CODE>rxvt</CODE>.
<CODE>update-menu</CODE> has not yet been ported. As such, there are no fine
Debian menus. Although a <CODE>pthreads</CODE> implementation exists not all
pthread packages have been ported: do not expect Gnome and KDE to work.
</p>


<h3> 8.5 Virtual Terminals </h3>

<p>
GNU/Hurd does not have virtual terminals although it is in development. Use
the <CODE>screen</CODE> package in the interim.
</p>

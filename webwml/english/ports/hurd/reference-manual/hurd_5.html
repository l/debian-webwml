<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from hurd.texi on 29 June 1999 -->

<TITLE>Hurd Reference Manual - Foundations</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="hurd_1.html">first</A>, <A HREF="hurd_4.html">previous</A>, <A HREF="hurd_6.html">next</A>, <A HREF="hurd_17.html">last</A> section, <A HREF="hurd_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC21" HREF="hurd_toc.html#TOC21">Foundations</A></H1>

<P>
Every Hurd program accepts the following optional arguments:


<DL COMPACT>

<DT><SAMP>`--help'</SAMP>
<DD>
Display a brief usage message, then exit.  This message is not a
substitute for reading program documentation; rather, it provides useful
reminders about specific command-line options that a program
understands.

<DT><SAMP>`--version'</SAMP>
<DD>
Output program version information and exit.
</DL>

<P>
The rest of this chapter provides a programmer's introduction to the
Hurd.  If you are not a programmer, then this chapter will not make much
sense to you... you should consider skipping to descriptions of
specific Hurd programs (see section <A HREF="hurd_1.html#SEC2">Audience</A>).


<P>
The Hurd distribution includes many libraries in order to provide a
useful set of tools for writing Hurd utilities and servers.  Several of
these libraries are useful not only for the Hurd, but also for writing
microkernel-based programs in general.  These fundamental libraries are
not difficult to understand, and they are a good starting point, because
the rest of the Hurd relies upon them quite heavily.




<H2><A NAME="SEC22" HREF="hurd_toc.html#TOC22">Threads Library</A></H2>
<P>
<A NAME="IDX8"></A>
<A NAME="IDX9"></A>


<P>
All Hurd servers and libraries are aggressively multithreaded in order
to take full advantage of any multiprocessing capabilities provided by
the microkernel and the underlying hardware.  The Hurd threads library,
<CODE>libthreads</CODE>, contains the default Hurd thread implementation, which
is declared in <CODE>&#60;cthreads.h&#62;</CODE>.


<P>
Currently (April 1998), the Hurd uses cthreads, which have already been
documented thoroughly by CMU.  Eventually, it will be migrated to use
POSIX pthreads, which are documented in a lot of places.


<P>
Every single library in the Hurd distribution (including the GNU C
library) is completely thread-safe, and the Hurd servers themselves are
aggressively multithreaded.




<H2><A NAME="SEC23" HREF="hurd_toc.html#TOC23">Microkernel Object Library</A></H2>
<P>
<A NAME="IDX10"></A>
<A NAME="IDX11"></A>


<P>
A commonly asked question is whether the Hurd has been ported to the
Open Group's version of the Mach microkernel.  The answer is "no".


<P>
Currently (April 1998), the Hurd is quite dependent on the GNU Mach
microkernel, which is a derivative of the University of Utah's Mach 4.
However, the Hurd developers are all too aware of the limitations of
Mach.


<P>
<A NAME="IDX12"></A>
<A NAME="IDX13"></A>
<CODE>libmom</CODE> is the first of several steps that need to be taken in
order to make the Hurd portable to other message-passing microkernels.
<EM>MOM</EM> stands for <EM>Microkernel Object Model</EM>, and is an
abstraction of the basic services provided by common message-passing
microkernels.  It will provide the necessary insulation so that Hurd
servers and the C library can avoid making microkernel-dependent kernel
calls.


<P>
At the present, though, <CODE>libmom</CODE> is still evolving, and will take
some time to be fully incorporated into the Hurd.




<H2><A NAME="SEC24" HREF="hurd_toc.html#TOC24">Ports Library</A></H2>
<P>
<A NAME="IDX14"></A>
<A NAME="IDX15"></A>


<P>
Ports are communication channels that are held by the kernel.


<P>
A port has separate send rights and receive rights, which may be
transferred from task to task via the kernel.  Port rights are similar
to Unix file descriptors: they are per-task integers which are used to
identify ports when making kernel calls.  Send rights are required in
order to send an RPC request down a port, and receive rights are
required to serve the RPC request.  Receive rights may be aggregated
into a single <EM>portset</EM>, which serve as useful organizational units.


<P>
In a single-threaded RPC client, managing and categorizing ports is not
a difficult process.  However, in a complex multithreaded server, it is
useful to have a more abstract interface to managing portsets, as well
as maintaining server metadata.


<P>
The Hurd ports library, <CODE>libports</CODE>, fills that need.  The
<CODE>libports</CODE> functions are declared in <CODE>&#60;hurd/ports.h&#62;</CODE>.




<H3><A NAME="SEC25" HREF="hurd_toc.html#TOC25">Buckets and Classes</A></H3>

<P>
The <CODE>libports</CODE> <EM>bucket</EM> is simply a port set, with some
metadata and a lock.  All of the <CODE>libports</CODE> functions operate on
buckets.


<P>
<DL>
<DT><U>Function:</U> struct port_bucket * <B>ports_create_bucket</B> <I>(void)</I>
<DD><A NAME="IDX16"></A>
Create and return a new, empty bucket.
</DL>


<P>
A port <EM>class</EM> is a collection of individual ports, which can be
manipulated conveniently, and have enforced deallocation routines.
Buckets and classes are entirely orthogonal: there is no requirement
that all the ports in a class be in the same bucket, nor is there a
requirement that all the ports in a bucket be in the same class.


<P>
<DL>
<DT><U>Function:</U> struct port_class <B>ports_create_class</B> <I>(void (*<VAR>clean_routine</VAR>) (void *<VAR>port</VAR>), void (*<VAR>dropweak_routine</VAR>) (void *<VAR>port</VAR>))</I>
<DD><A NAME="IDX17"></A>
Create and return a new port class.  If nonzero, <VAR>clean_routine</VAR>
will be called for each allocated port object in this class when it is
being destroyed.  If nonzero, <VAR>dropweak_routine</VAR> will be called to
request weak references to be dropped.  (If <VAR>dropweak_routine</VAR> is
null, then weak references and hard references will be identical for
ports of this class.)
</DL>


<P>
Once you have created at least one bucket and class, you may create new
ports, and store them in those buckets.  There are a few different
functions for port creation, depending on your application's
requirements:


<P>
<DL>
<DT><U>Function:</U> error_t <B>ports_create_port</B> <I>(struct port_class *<VAR>class</VAR>, struct port_bucket *<VAR>bucket</VAR>, size_t <VAR>size</VAR>, void *<VAR>result</VAR>)</I>
<DD><A NAME="IDX18"></A>
Create and return in <VAR>result</VAR> a new port in <VAR>class</VAR> and
<VAR>bucket</VAR>; <VAR>size</VAR> bytes will be allocated to hold the port
structure and whatever private data the user desires.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ports_create_port_noinstall</B> <I>(struct port_class *<VAR>class</VAR>, struct port_bucket *<VAR>bucket</VAR>, size_t <VAR>size</VAR>, void *<VAR>result</VAR>)</I>
<DD><A NAME="IDX19"></A>
Just like <CODE>ports_create_port</CODE>, except don't actually put the port
into the portset underlying <VAR>bucket</VAR>.  This is intended to be used
for cases where the port right must be given out before the port is
fully initialized; with this call you are guaranteed that no RPC service
will occur on the port until you have finished initializing it and
installed it into the portset yourself.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ports_import_port</B> <I>(struct port_class *<VAR>class</VAR>, struct port_bucket *<VAR>bucket</VAR>, mach_port_t <VAR>port</VAR>, size_t <VAR>size</VAR>, void *<VAR>result</VAR>)</I>
<DD><A NAME="IDX20"></A>
For an existing <EM>receive</EM> right, create and return in <VAR>result</VAR>
a new port structure; <VAR>bucket</VAR>, <VAR>size</VAR>, and <VAR>class</VAR> args are
as for <CODE>ports_create_port</CODE>.
</DL>




<H3><A NAME="SEC26" HREF="hurd_toc.html#TOC26">Port Rights</A></H3>

<P>
The following functions move port receive rights to and from the port
structure:


<P>
<DL>
<DT><U>Function:</U> void <B>ports_reallocate_port</B> <I>(void *<VAR>port</VAR>)</I>
<DD><A NAME="IDX21"></A>
Destroy the receive right currently associated with <VAR>port</VAR> and
allocate a new one.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_reallocate_from_external</B> <I>(void *<VAR>port</VAR>, mach_port_t <VAR>receive</VAR>)</I>
<DD><A NAME="IDX22"></A>
Destroy the receive right currently associated with <VAR>port</VAR> and
designate <VAR>receive</VAR> as the new one.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_destroy_right</B> <I>(void *<VAR>port</VAR>)</I>
<DD><A NAME="IDX23"></A>
Destroy the receive right currently associated with <VAR>port</VAR>.  After
this call, <CODE>ports_reallocate_port</CODE> and
<CODE>ports_reallocate_from_external</CODE> may not be used.
</DL>


<P>
<DL>
<DT><U>Function:</U> mach_port_t <B>ports_claim_right</B> <I>(void *<VAR>port</VAR>)</I>
<DD><A NAME="IDX24"></A>
Return the receive right currently associated with <VAR>port</VAR>.  The
effects on <VAR>port</VAR> are the same as in <CODE>ports_destroy_right</CODE>,
except that the receive right itself is not affected.  Note that in
multi-threaded servers, messages might already have been dequeued for
this port before it gets removed from the portset; such messages will
get <CODE>EOPNOTSUPP</CODE> errors.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ports_transfer_right</B> <I>(void *<VAR>topt</VAR>, void *<VAR>frompt</VAR>)</I>
<DD><A NAME="IDX25"></A>
Transfer the receive right from <VAR>frompt</VAR> to <VAR>topt</VAR>.
<VAR>frompt</VAR> ends up with a destroyed right (as if
<CODE>ports_destroy_right</CODE> were called) and <VAR>topt</VAR>'s old right is
destroyed (as if <CODE>ports_reallocate_from_external</CODE> were called).
</DL>


<P>
<DL>
<DT><U>Function:</U> mach_port_t <B>ports_get_right</B> <I>(void *<VAR>port</VAR>)</I>
<DD><A NAME="IDX26"></A>
Return the name of the receive right associated with <VAR>port</VAR>.  The
user is responsible for creating an ordinary send right from this name.
</DL>




<H3><A NAME="SEC27" HREF="hurd_toc.html#TOC27">Port Metadata</A></H3>

<P>
It is important to point out that the <VAR>port</VAR> argument to each of
the <CODE>libports</CODE> functions is a <CODE>void *</CODE> and not a <CODE>struct
port_info *</CODE>.  This is done so that you may add arbitrary
meta-information to your <CODE>libports</CODE>-managed ports.  Simply define
your own structure whose first element is a <CODE>struct port_info</CODE>, and
then you can use pointers to these structures as the <VAR>port</VAR> argument
to any <CODE>libports</CODE> function.


<P>
The following functions are useful for maintaining metadata that is
stored in your own custom ports structure:


<P>
<DL>
<DT><U>Function:</U> void * <B>ports_lookup_port</B> <I>(struct port_bucket *<VAR>bucket</VAR>, mach_port_t <VAR>port</VAR>, struct port_class *<VAR>class</VAR>)</I>
<DD><A NAME="IDX27"></A>
Look up <VAR>port</VAR> and return the associated port structure, allocating
a reference.  If the call fails, return zero.  If <VAR>bucket</VAR> is nonzero,
then it specifies a bucket to search; otherwise all buckets will be
searched.  If <VAR>class</VAR> is nonzero, then the lookup will fail if
<VAR>port</VAR> is not in <VAR>class</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ports_bucket_iterate</B> <I>(struct port_bucket *<VAR>bucket</VAR>, error_t (*<VAR>fun</VAR>) (void *<VAR>port</VAR>))</I>
<DD><A NAME="IDX28"></A>
Call <VAR>fun</VAR> once for each port in <VAR>bucket</VAR>.
</DL>




<H3><A NAME="SEC28" HREF="hurd_toc.html#TOC28">Port References</A></H3>

<P>
These functions maintain references to ports so that the port
information structures may be freed if and only if they are no longer
needed.  It is your responsibility to tell <CODE>libports</CODE> when
references to ports change.


<P>
<DL>
<DT><U>Function:</U> void <B>ports_port_ref</B> <I>(void *<VAR>port</VAR>)</I>
<DD><A NAME="IDX29"></A>
Allocate a hard reference to <VAR>port</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_port_deref</B> <I>(void *<VAR>port</VAR>)</I>
<DD><A NAME="IDX30"></A>
Drop a hard reference to <VAR>port</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_no_senders</B> <I>(void *<VAR>port</VAR>, mach_port_mscount_t <VAR>mscount</VAR>)</I>
<DD><A NAME="IDX31"></A>
The user is responsible for listening for no senders notifications; when
one arrives, call this routine for the <VAR>port</VAR> the message was sent
to, providing the <VAR>mscount</VAR> from the notification.
</DL>


<P>
<DL>
<DT><U>Function:</U> int <B>ports_count_class</B> <I>(struct port_class *<VAR>class</VAR>)</I>
<DD><A NAME="IDX32"></A>
Block creation of new ports in <VAR>class</VAR>.  Return the number of ports
currently in <VAR>class</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> int <B>ports_count_bucket</B> <I>(struct port_bucket *<VAR>bucket</VAR>)</I>
<DD><A NAME="IDX33"></A>
Block creation of new ports in <VAR>bucket</VAR>.  Return the number of ports
currently in <VAR>bucket</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_enable_class</B> <I>(struct port_class *<VAR>class</VAR>)</I>
<DD><A NAME="IDX34"></A>
Permit suspended port creation (blocked by <CODE>ports_count_class</CODE>) to
continue.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_enable_bucket</B> <I>(struct port_bucket *<VAR>bucket</VAR>)</I>
<DD><A NAME="IDX35"></A>
Permit suspended port creation (blocked by <CODE>ports_count_bucket</CODE>) to
continue.
</DL>


<P>
Weak references are not often used, as they are the same as hard
references for port classes where <VAR>dropweak_routine</VAR> is null.
See section <A HREF="hurd_5.html#SEC25">Buckets and Classes</A>.


<P>
<DL>
<DT><U>Function:</U> void <B>ports_port_ref_weak</B> <I>(void *<VAR>port</VAR>)</I>
<DD><A NAME="IDX36"></A>
Allocate a weak reference to <VAR>port</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_port_deref_weak</B> <I>(void *<VAR>port</VAR>)</I>
<DD><A NAME="IDX37"></A>
Drop a weak reference to <VAR>port</VAR>.
</DL>




<H3><A NAME="SEC29" HREF="hurd_toc.html#TOC29">RPC Management</A></H3>

<P>
The rest of the <CODE>libports</CODE> functions are dedicated to controlling
RPC operations.  These functions help you do all the locking and thread
cancellations that are required in order to build robust servers.


<P>
<DL>
<DT><U>Typedef:</U> typedef int (* <B>ports_demuxer_type</B> <I>) (mach_msg_header_t *<VAR>inp</VAR>, mach_msg_header_t *<VAR>outp</VAR>)</I>
<DD><A NAME="IDX38"></A>
Type of MiG demuxer routines.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ports_begin_rpc</B> <I>(void *<VAR>port</VAR>, mach_msg_id_t <VAR>msg_id</VAR>, struct rpc_info *<VAR>info</VAR>)</I>
<DD><A NAME="IDX39"></A>
Call this when an RPC is beginning on <VAR>port</VAR>.  <VAR>info</VAR> should be
allocated by the caller and will be used to hold dynamic state.  If this
RPC should be abandoned, return <CODE>EDIED</CODE>; otherwise we return zero.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_end_rpc</B> <I>(void *<VAR>port</VAR>, struct rpc_info *<VAR>info</VAR>)</I>
<DD><A NAME="IDX40"></A>
Call this when an RPC is concluding.  The arguments must match the ones
passed to the paired call to <CODE>ports_begin_rpc</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_manage_port_operations_one_thread</B> <I>(struct port_bucket *<VAR>bucket</VAR>, ports_demuxer_type <VAR>demuxer</VAR>, int <VAR>timeout</VAR>)</I>
<DD><A NAME="IDX41"></A>
Begin handling operations for the ports in <VAR>bucket</VAR>, calling
<VAR>demuxer</VAR> for each incoming message.  Return if <VAR>timeout</VAR> is
nonzero and no messages have been received for <VAR>timeout</VAR>
milliseconds.  Use only one thread (the calling thread).
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_manage_port_operations_multithread</B> <I>(struct port_bucket *<VAR>bucket</VAR>, ports_demuxer_type <VAR>demuxer</VAR>, int <VAR>thread_timeout</VAR>, int <VAR>global_timeout</VAR>, void (*<VAR>hook</VAR>) (void))</I>
<DD><A NAME="IDX42"></A>
Begin handling operations for the ports in <VAR>bucket</VAR>, calling
<VAR>demuxer</VAR> for each incoming message.  Return if <VAR>global_timeout</VAR>
is nonzero and no messages have been received for <VAR>global_timeout</VAR>
milliseconds.  Create threads as necessary to handle incoming messages
so that no port is starved because of sluggishness on another port.  If
<VAR>thread_timeout</VAR> is nonzero, then individual threads will die off
if they handle no incoming messages for <VAR>local_timeout</VAR>
milliseconds.  If non-null, <VAR>hook</VAR> will be called in each new thread
immediately after it is created.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ports_inhibit_port_rpcs</B> <I>(void *<VAR>port</VAR>)</I>
<DD><A NAME="IDX43"></A>
Interrupt any pending RPC on <VAR>port</VAR>.  Wait for all pending RPCs to
finish, and then block any new RPCs starting on that port.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ports_inhibit_class_rpcs</B> <I>(struct port_class *<VAR>class</VAR>)</I>
<DD><A NAME="IDX44"></A>
Similar to <CODE>ports_inhibit_port_rpcs</CODE>, but affects all ports in
<VAR>class</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ports_inhibit_bucket_rpcs</B> <I>(struct port_bucket *<VAR>bucket</VAR>)</I>
<DD><A NAME="IDX45"></A>
Similar to <CODE>ports_inhibit_port_rpcs</CODE>, but affects all ports in
<VAR>bucket</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ports_inhibit_all_rpcs</B> <I>(void)</I>
<DD><A NAME="IDX46"></A>
Similar to <CODE>ports_inhibit_port_rpcs</CODE>, but affects all ports
whatsoever.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_resume_port_rpcs</B> <I>(void *<VAR>port</VAR>)</I>
<DD><A NAME="IDX47"></A>
Reverse the effect of a previous <CODE>ports_inhibit_port_rpcs</CODE> for this
<VAR>port</VAR>, allowing blocked RPCs to continue.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_resume_class_rpcs</B> <I>(struct port_class *<VAR>class</VAR>)</I>
<DD><A NAME="IDX48"></A>
Reverse the effect of a previous <CODE>ports_inhibit_class_rpcs</CODE> for
<VAR>class</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_resume_bucket_rpcs</B> <I>(struct port_bucket *<VAR>bucket</VAR>)</I>
<DD><A NAME="IDX49"></A>
Reverse the effect of a previous <CODE>ports_inhibit_bucket_rpcs</CODE> for
<VAR>bucket</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_resume_all_rpcs</B> <I>(void)</I>
<DD><A NAME="IDX50"></A>
Reverse the effect of a previous <CODE>ports_inhibit_all_rpcs</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_interrupt_rpcs</B> <I>(void *<VAR>port</VAR>)</I>
<DD><A NAME="IDX51"></A>
Cancel (with <CODE>thread_cancel</CODE>) any RPCs in progress on <VAR>port</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> int <B>ports_self_interrupted</B> <I>(void)</I>
<DD><A NAME="IDX52"></A>
If the current thread's RPC has been interrupted with
<CODE>ports_interrupt_rpcs</CODE>, return nonzero and clear the interrupted
flag.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ports_interrupt_rpc_on_notification</B> <I>(void *<VAR>object</VAR>, struct rpc_info *<VAR>rpc</VAR>, mach_port_t <VAR>port</VAR>, mach_msg_id_t <VAR>what</VAR>)</I>
<DD><A NAME="IDX53"></A>
Arrange for <CODE>hurd_cancel</CODE> to be called on <VAR>rpc</VAR>'s thread if
<VAR>object</VAR> gets notified that any of the things in <VAR>what</VAR> have
happened to <VAR>port</VAR>.  <VAR>rpc</VAR> should be an RPC on <VAR>object</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ports_interrupt_self_on_notification</B> <I>(void *<VAR>object</VAR>, mach_port_t <VAR>port</VAR>, mach_msg_id_t <VAR>what</VAR>)</I>
<DD><A NAME="IDX54"></A>
Arrange for <CODE>hurd_cancel</CODE> to be called on the current thread, which
should be an RPC on <VAR>object</VAR>, if <VAR>port</VAR> gets notified with the
condition <VAR>what</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ports_interrupt_self_on_port_death</B> <I>(void *<VAR>object</VAR>, mach_port_t <VAR>port</VAR>)</I>
<DD><A NAME="IDX55"></A>
Same as calling <CODE>ports_interrupt_self_on_notification</CODE> with
<VAR>what</VAR> set to <CODE>MACH_NOTIFY_DEAD_NAME</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_interrupt_notified_rpcs</B> <I>(void *<VAR>object</VAR>, mach_port_t <VAR>port</VAR>, mach_msg_id_t <VAR>what</VAR>)</I>
<DD><A NAME="IDX56"></A>
Interrupt any RPCs on <VAR>object</VAR> that have requested such.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_dead_name</B> <I>(void *<VAR>object</VAR>, mach_port_t <VAR>port</VAR>)</I>
<DD><A NAME="IDX57"></A>
Same as calling <CODE>ports_interrupt_notified_rpcs</CODE> with <VAR>what</VAR> set
to <CODE>MACH_NOTIFY_DEAD_NAME</CODE>.
</DL>




<H2><A NAME="SEC30" HREF="hurd_toc.html#TOC30">Integer Hash Library</A></H2>
<P>
<A NAME="IDX58"></A>
<A NAME="IDX59"></A>


<P>
<CODE>libihash</CODE> provides integer-keyed hash tables, for arbitrary
element data types.  Such hash tables are frequently used when
implementing sparse arrays or buffer caches.


<P>
The following functions are declared in <CODE>&#60;hurd/ihash.h&#62;</CODE>:


<P>
<DL>
<DT><U>Function:</U> error_t <B>ihash_create</B> <I>(ihash_t *<VAR>ht</VAR>)</I>
<DD><A NAME="IDX60"></A>
Create an integer hash table and return it in <VAR>ht</VAR>.  If a memory
allocation error occurs, <CODE>ENOMEM</CODE> is returned, otherwise zero.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ihash_free</B> <I>(ihash_t <VAR>ht</VAR>)</I>
<DD><A NAME="IDX61"></A>
Free <VAR>ht</VAR> and all resources it consumes.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ihash_set_cleanup</B> <I>(ihash_t <VAR>ht</VAR>, void (*<VAR>cleanup</VAR>) (void *<VAR>value</VAR>, void *<VAR>arg</VAR>), void *<VAR>arg</VAR>)</I>
<DD><A NAME="IDX62"></A>
Sets <VAR>ht</VAR>'s element cleanup function to <VAR>cleanup</VAR>, and its
second argument to <VAR>arg</VAR>.  <VAR>cleanup</VAR> will be called on every
element <VAR>value</VAR> to be subsequently overwritten or deleted, with
<VAR>arg</VAR> as the second argument.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ihash_add</B> <I>(ihash_t <VAR>ht</VAR>, int <VAR>id</VAR>, void *<VAR>item</VAR>, void ***<VAR>locp</VAR>)</I>
<DD><A NAME="IDX63"></A>
Add <VAR>item</VAR> to the hash table <VAR>ht</VAR> under the integer key
<VAR>id</VAR>.  <VAR>locp</VAR> is the address of a pointer located in <VAR>item</VAR>;
If non-null, <VAR>locp</VAR> should point to a variable of type <CODE>void
**</CODE>, and will be filled with a pointer that may be used as an argument
to <CODE>ihash_locp_remove</CODE>.  The variable pointed to by <VAR>locp</VAR> may
be overwritten sometime between this call and when the element is
deleted, so you cannot stash its value elsewhere and hope to use the
stashed value with <CODE>ihash_locp_remove</CODE>.  If a memory allocation
error occurs, <CODE>ENOMEM</CODE> is returned, otherwise zero.
</DL>


<P>
<DL>
<DT><U>Function:</U> void * <B>ihash_find</B> <I>(ihash_t <VAR>ht</VAR>, int <VAR>id</VAR>)</I>
<DD><A NAME="IDX64"></A>
Find and return the item in hash table <VAR>ht</VAR> with key <VAR>id</VAR>.
Returns null if the specified item doesn't exist.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ihash_iterate</B> <I>(ihash_t <VAR>ht</VAR>, error_t (*<VAR>fun</VAR>) (void *<VAR>value</VAR>))</I>
<DD><A NAME="IDX65"></A>
Call function <VAR>fun</VAR> on every element of <VAR>ht</VAR>.  <VAR>fun</VAR>'s only
arg, <VAR>value</VAR>, is a pointer to the value stored in the hash table.  If
<VAR>fun</VAR> ever returns nonzero, then iteration stops and
<CODE>ihash_iterate</CODE> returns that value, otherwise it (eventually)
returns 0.
</DL>


<P>
<DL>
<DT><U>Function:</U> int <B>ihash_remove</B> <I>(ihash_t <VAR>ht</VAR>, int <VAR>id</VAR>)</I>
<DD><A NAME="IDX66"></A>
Remove the entry with a key of <VAR>id</VAR> from <VAR>ht</VAR>.  If there was no
such element, then return zero, otherwise nonzero.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ihash_locp_remove</B> <I>(ihash_t <VAR>ht</VAR>, void **<VAR>ht_locp</VAR>)</I>
<DD><A NAME="IDX67"></A>
Remove the entry at <VAR>locp</VAR> from the hashtable <VAR>ht</VAR>.  <VAR>locp</VAR>
is as returned from an earlier call to <CODE>ihash_add</CODE>.  This call
should be faster than <CODE>ihash_remove</CODE>.  <VAR>ht</VAR> can be null, in
which case the call still succeeds, but no cleanup is done.
</DL>




<H2><A NAME="SEC31" HREF="hurd_toc.html#TOC31">Misc Library</A></H2>
<P>
<A NAME="IDX68"></A>


<P>
The GNU C library is constantly developing to meet the needs of the
Hurd.  However, because the C library needs to be very stable, it is
irresponsible to add new functions to it without carefully specifying
their interface, and testing them thoroughly.


<P>
The Hurd distribution includes a library called
<CODE>libshouldbeinlibc</CODE>, which serves as a proving ground for additions
to the GNU C library.  This library is in flux, as some functions are
added to it by the Hurd developers and others are moved to the official
C library.


<P>
These functions aren't currently documented (other than in their header
files), but complete documentation will be added to
<EM>The GNU C Library Reference Manual</EM>
when these functions become part of the GNU C library.




<H2><A NAME="SEC32" HREF="hurd_toc.html#TOC32">Bug Address Library</A></H2>
<P>
<A NAME="IDX69"></A>


<P>
<CODE>libhurdbugaddr</CODE> exists only to define a single variable:


<P>
<DL>
<DT><U>Variable:</U> char * <B>argp_program_bug_address</B>
<DD><A NAME="IDX70"></A>
<CODE>argp_program_bug_address</CODE> is the default Hurd bug-reporting e-mail
address, <A HREF="mailto:bug-hurd@gnu.org">bug-hurd@gnu.org</A>.  This address is displayed to the
user when any of the standard Hurd servers and utilities are invoked
using the <SAMP>`--help'</SAMP> option.
</DL>


<P><HR><P>
Go to the <A HREF="hurd_1.html">first</A>, <A HREF="hurd_4.html">previous</A>, <A HREF="hurd_6.html">next</A>, <A HREF="hurd_17.html">last</A> section, <A HREF="hurd_toc.html">table of contents</A>.
</BODY>
</HTML>

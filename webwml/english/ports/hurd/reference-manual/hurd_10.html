<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from hurd.texi on 29 June 1999 -->

<TITLE>Hurd Reference Manual - Stored Filesystems</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="hurd_1.html">first</A>, <A HREF="hurd_9.html">previous</A>, <A HREF="hurd_11.html">next</A>, <A HREF="hurd_17.html">last</A> section, <A HREF="hurd_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC101" HREF="hurd_toc.html#TOC101">Stored Filesystems</A></H1>
<P>
<A NAME="IDX304"></A>
<A NAME="IDX305"></A>


<P>
Stored filesystems allow users to save and load persistent data from any
random-access storage media, such as hard disks, floppy diskettes, and
CD-ROMs.  Stored filesystems are required for bootstrapping standalone
workstations, as well.




<H2><A NAME="SEC102" HREF="hurd_toc.html#TOC102">Repairing Filesystems</A></H2>
<P>
<A NAME="IDX306"></A>


<P>
FIXME: finish




<H2><A NAME="SEC103" HREF="hurd_toc.html#TOC103">Linux Extended 2 FS</A></H2>
<P>
<A NAME="IDX307"></A>


<P>
FIXME: finish




<H2><A NAME="SEC104" HREF="hurd_toc.html#TOC104">BSD Unix FS</A></H2>
<P>
<A NAME="IDX308"></A>


<P>
FIXME: finish




<H2><A NAME="SEC105" HREF="hurd_toc.html#TOC105">ISO-9660 CD-ROM FS</A></H2>
<P>
<A NAME="IDX309"></A>


<P>
FIXME: finish




<H2><A NAME="SEC106" HREF="hurd_toc.html#TOC106">Diskfs Library</A></H2>
<P>
<A NAME="IDX310"></A>
<A NAME="IDX311"></A>


<P>
The diskfs library is declared in <CODE>&#60;hurd/diskfs.h&#62;</CODE>, and does a lot
of the work of implementing stored filesystems.  <CODE>libdiskfs</CODE>
requires the threads, ports, iohelp, fshelp, and store libraries.  You
should understand all these libraries before you attempt to use diskfs,
and you should also be familiar with the pager library (see section <A HREF="hurd_6.html#SEC37">Pager Library</A>).


<P>
<A NAME="IDX312"></A>
For historical reasons, the library for implementing stored filesystems
is called <CODE>libdiskfs</CODE> instead of <CODE>libstorefs</CODE>.  Keep in mind,
however, that diskfs is useful for filesystems which are implemented on
any block-addressed storage device, since it uses the store library to
do I/O.


<P>
Note that stored filesystems can be tricky to implement, since the
diskfs callback interfaces are not trivial.  It really is best if you
examine the source code of a similar existing filesystem server, and
follow its example rather than trying to write your own from scratch.




<H3><A NAME="SEC107" HREF="hurd_toc.html#TOC107">Diskfs Startup</A></H3>

<P>
This subsection gives an outline of the general steps involved in
implementing a filesystem server, to help refresh your memory and to
offer explanations rather than to serve as a tutorial.


<P>
The first thing a filesystem server should do is parse its command-line
arguments (see section <A HREF="hurd_10.html#SEC108">Diskfs Arguments</A>).  Then, the standard output and
error streams should be redirected to the console, so that error
messages are not lost if this is the bootstrap filesystem:


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_console_stdio</B> <I>(void)</I>
<DD><A NAME="IDX313"></A>
Redirect error messages to the console, so that they can be seen by
users.
</DL>


<P>
The following is a list of the relevant functions which would be called
during the rest of the server initialization.  Again, you should refer
to the implementation of an already-working filesystem if you have any
questions about how these functions should be used:


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_init_diskfs</B> <I>(void)</I>
<DD><A NAME="IDX314"></A>
Call this function after arguments have been parsed to initialize the
library.  You must call this before calling any other diskfs functions,
and after parsing diskfs options.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_spawn_first_thread</B> <I>(void)</I>
<DD><A NAME="IDX315"></A>
Call this after all format-specific initialization is done (except for
setting <CODE>diskfs_root_node</CODE>); at this point the pagers should be
ready to go.
</DL>


<P>
<DL>
<DT><U>Function:</U> mach_port_t <B>diskfs_startup_diskfs</B> <I>(mach_port_t <VAR>bootstrap</VAR>, int <VAR>flags</VAR>)</I>
<DD><A NAME="IDX316"></A>
Call this once the filesystem is fully initialized, to advertise the new
filesystem control port to our parent filesystem.  If <VAR>bootstrap</VAR> is set,
diskfs will call <CODE>fsys_startup</CODE> on that port as appropriate and return
the <VAR>realnode</VAR> from that call; otherwise we call
<CODE>diskfs_start_bootstrap</CODE> and return <CODE>MACH_PORT_NULL</CODE>.
<VAR>flags</VAR> specifies how to open <VAR>realnode</VAR> (from the O_* set).
</DL>


<P>
You should not need to call the following function directly, since
<CODE>diskfs_startup_diskfs</CODE> will do it for you, when appropriate:


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_start_bootstrap</B> <I>(void)</I>
<DD><A NAME="IDX317"></A>
Start the Hurd bootstrap sequence as if we were the bootstrap filesystem
(that is, <CODE>diskfs_boot_flags</CODE> is nonzero).  All filesystem
initialization must be complete before you call this function.
</DL>




<H3><A NAME="SEC108" HREF="hurd_toc.html#TOC108">Diskfs Arguments</A></H3>

<P>
The following functions implement standard diskfs command-line and
runtime argument parsing, using argp (see section `Argp' in <CITE>The GNU C Library Reference Manual</CITE>):


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_set_options</B> <I>(char *<VAR>argz</VAR>, size_t <VAR>argz_len</VAR>)</I>
<DD><A NAME="IDX318"></A>
Parse and execute the runtime options specified by <VAR>argz</VAR> and
<VAR>argz_len</VAR>.  <CODE>EINVAL</CODE> is returned if some option is
unrecognized.  The default definition of this routine will parse them
using <CODE>diskfs_runtime_argp</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_append_args</B> <I>(char **<VAR>argz</VAR>, unsigned *<VAR>argz_len</VAR>)</I>
<DD><A NAME="IDX319"></A>
Append to the malloced string <CODE>*<VAR>argz</VAR></CODE> of length
<CODE>*<VAR>argz_len</VAR></CODE> a NUL-separated list of the arguments to this
translator.  The default definition of this routine simply calls
<CODE>diskfs_append_std_options</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_append_std_options</B> <I>(char **<VAR>argz</VAR>, unsigned *<VAR>argz_len</VAR>)</I>
<DD><A NAME="IDX320"></A>
<EM>Appends</EM> NUL-separated options describing the standard diskfs
option state to <VAR>argz</VAR> and increments <VAR>argz_len</VAR> appropriately.
Note that unlike <CODE>diskfs_get_options</CODE>, <VAR>argz</VAR> and
<VAR>argz_len</VAR> must already have sane values.
</DL>


<P>
<DL>
<DT><U>Variable:</U> struct argp * <B>diskfs_runtime_argp</B>
<DD><A NAME="IDX321"></A>
If this is defined or set to an argp structure, it will be used by the
default <CODE>diskfs_set_options</CODE> to handle runtime option parsing.  The
default definition is initialized to a pointer to
<CODE>diskfs_std_runtime_argp</CODE>.
</DL>


<P>
<DL>
<DT><U>Variable:</U> const struct argp <B>diskfs_std_runtime_argp</B>
<DD><A NAME="IDX322"></A>
An argp for the standard diskfs runtime options.  The default definition
of <CODE>diskfs_runtime_argp</CODE> points to this, although the user can
redefine that to chain this onto his own argp.
</DL>


<P>
<DL>
<DT><U>Variable:</U> const struct argp <B>diskfs_startup_argp</B>
<DD><A NAME="IDX323"></A>
An argp structure for the standard diskfs command line arguments.  The
user may call <CODE>argp_parse</CODE> on this to parse the command line, chain
it onto the end of his own argp structure, or ignore it completely.
</DL>


<P>
<DL>
<DT><U>Variable:</U> const struct argp <B>diskfs_store_startup_argp</B>
<DD><A NAME="IDX324"></A>
An argp structure for the standard diskfs command line arguments plus a
store specification.  The address of a location in which to return the
resulting <CODE>struct store_parsed</CODE> structure should be passed as the
input argument to <CODE>argp_parse</CODE>; FIXME xref the declaration for
STORE_ARGP.
</DL>




<H3><A NAME="SEC109" HREF="hurd_toc.html#TOC109">Diskfs Globals</A></H3>

<P>
The following functions and variables control the overall behaviour of
the library.  Your callback functions may need to refer to these, but
you should not need to modify or redefine them.


<P>
<DL>
<DT><U>Variable:</U> mach_port_t <B>diskfs_default_pager</B>
<DD><A NAME="IDX325"></A>
<DT><U>Variable:</U> mach_port_t <B>diskfs_exec_ctl</B>
<DD><A NAME="IDX326"></A>
<DT><U>Variable:</U> mach_port_t <B>diskfs_exec</B>
<DD><A NAME="IDX327"></A>
<DT><U>Variable:</U> auth_t <B>diskfs_auth_server_port</B>
<DD><A NAME="IDX328"></A>
These are the respective send rights to the default pager, execserver
control port, execserver itself, and authserver.
</DL>


<P>
<DL>
<DT><U>Variable:</U> mach_port_t <B>diskfs_fsys_identity</B>
<DD><A NAME="IDX329"></A>
The <CODE>io_identity</CODE> identity port for the filesystem.
</DL>


<P>
<DL>
<DT><U>Variable:</U> char ** <B>diskfs_argv</B>
<DD><A NAME="IDX330"></A>
The command line with which diskfs was started, set by the default argument parser.
If you don't use it, set this yourself.  This is only used for bootstrap
file systems, to give the procserver.
</DL>


<P>
<DL>
<DT><U>Variable:</U> char * <B>diskfs_boot_flags</B>
<DD><A NAME="IDX331"></A>
When this is a bootstrap filesystem, the command line options passed from
the kernel.  If not a bootstrap filesystem, it is zero, so it can be used to
distinguish between the two cases.
</DL>


<P>
<DL>
<DT><U>Variable:</U> struct rwlock <B>diskfs_fsys_lock</B>
<DD><A NAME="IDX332"></A>
Hold this lock while doing filesystem-level operations.  Innocuous users
can just hold a reader lock, but operations that might corrupt other
threads should hold a writer lock.
</DL>


<P>
<DL>
<DT><U>Variable:</U> volatile struct mapped_time_value * <B>diskfs_mtime</B>
<DD><A NAME="IDX333"></A>
The current system time, as used by the diskfs routines.  This is
converted into a <CODE>struct timeval</CODE> by the <CODE>maptime_read</CODE>
C library function (FIXME xref).
</DL>


<P>
<DL>
<DT><U>Variable:</U> int <B>diskfs_synchronous</B>
<DD><A NAME="IDX334"></A>
True if and only if we should do every operation synchronously.  It
is the format-specific code's responsibility to keep allocation
information permanently in sync if this is set; the rest will
be done by format-independent code.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_set_sync_interval</B> <I>(int <VAR>interval</VAR>)</I>
<DD><A NAME="IDX335"></A>
Establish a thread to sync the filesystem every <VAR>interval</VAR> seconds,
or never, if <VAR>interval</VAR> is zero.  If an error occurs creating the
thread, it is returned, otherwise zero.  Subsequent calls will create a
new thread and (eventually) get rid of the old one; the old thread won't
do any more syncs, regardless.
</DL>


<P>
<DL>
<DT><U>Variable:</U> spin_lock_t <B>diskfs_node_refcnt_lock</B>
<DD><A NAME="IDX336"></A>
Pager reference count lock.
</DL>


<P>
<DL>
<DT><U>Variable:</U> int <B>diskfs_readonly</B>
<DD><A NAME="IDX337"></A>
Set to zero if the filesystem is currently writable.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_set_readonly</B> <I>(int <VAR>readonly</VAR>)</I>
<DD><A NAME="IDX338"></A>
Change an active filesystem between read-only and writable modes,
setting the global variable <VAR>diskfs_readonly</VAR> to reflect the current
mode.  If an error is returned, nothing will have changed.
<VAR>diskfs_fsys_lock</VAR> should be held while calling this routine.
</DL>


<P>
<DL>
<DT><U>Function:</U> int <B>diskfs_check_readonly</B> <I>(void)</I>
<DD><A NAME="IDX339"></A>
Check if the filesystem is readonly before an operation that writes it.
Return nonzero if readonly, otherwise zero.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_remount</B> <I>(void)</I>
<DD><A NAME="IDX340"></A>
Reread all in-core data structures from disk.  This function can only be
successful if <VAR>diskfs_readonly</VAR> is true.  <VAR>diskfs_fsys_lock</VAR>
should be held while calling this routine.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_shutdown</B> <I>(int <VAR>flags</VAR>)</I>
<DD><A NAME="IDX341"></A>
Shutdown the filesystem; <VAR>flags</VAR> are as for <CODE>fsys_shutdown</CODE>.
</DL>




<H3><A NAME="SEC110" HREF="hurd_toc.html#TOC110">Diskfs Node Management</A></H3>

<P>
Every file or directory is a diskfs <EM>node</EM>.  The following functions
help your diskfs callbacks manage nodes and their references:


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_drop_node</B> <I>(struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX342"></A>
Node <VAR>np</VAR> now has no more references; clean all state.  The
<VAR>diskfs_node_refcnt_lock</VAR> must be held, and will be released upon
return.  <VAR>np</VAR> must be locked.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_node_update</B> <I>(struct node *<VAR>np</VAR>, int <VAR>wait</VAR>)</I>
<DD><A NAME="IDX343"></A>
Set disk fields from <CODE><VAR>np</VAR>-&#62;dn_stat</CODE>; update ctime, atime, and mtime
if necessary.  If <VAR>wait</VAR> is true, then return only after the
physical media has been completely updated.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_nref</B> <I>(struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX344"></A>
Add a hard reference to node <VAR>np</VAR>.  If there were no hard references
previously, then the node cannot be locked (because you must hold a hard
reference to hold the lock).
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_nput</B> <I>(struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX345"></A>
Unlock node <VAR>np</VAR> and release a hard reference; if this is the last
hard reference and there are no links to the file then request light
references to be dropped.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_nrele</B> <I>(struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX346"></A>
Release a hard reference on <VAR>np</VAR>.  If <VAR>np</VAR> is locked by anyone,
then this cannot be the last hard reference (because you must hold a
hard reference in order to hold the lock).  If this is the last hard
reference and there are no links, then request light references to be
dropped.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_nref_light</B> <I>(struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX347"></A>
Add a light reference to a node.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_nput_light</B> <I>(struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX348"></A>
Unlock node <VAR>np</VAR> and release a light reference.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_nrele_light</B> <I>(struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX349"></A>
Release a light reference on <VAR>np</VAR>.  If <VAR>np</VAR> is locked by anyone,
then this cannot be the last reference (because you must hold a hard
reference in order to hold the lock).
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_node_rdwr</B> <I>(struct node *<VAR>np</VAR>, char *<VAR>data</VAR>, off_t <VAR>off</VAR>, size_t <VAR>amt</VAR>, int <VAR>direction</VAR>, struct protid *<VAR>cred</VAR>, size_t *<VAR>amtread</VAR>)</I>
<DD><A NAME="IDX350"></A>
This is called by other filesystem routines to read or write files, and
extends them automatically, if necessary.  <VAR>np</VAR> is the node to be
read or written, and must be locked.  <VAR>data</VAR> will be written or
filled.  <VAR>off</VAR> identifies where in the file the I/O is to take place
(negative values are not allowed).  <VAR>amt</VAR> is the size of <VAR>data</VAR>
and tells how much to copy.  <VAR>dir</VAR> is zero for reading or nonzero
for writing.  <VAR>cred</VAR> is the user doing the access (only used to
validate attempted file extension).  For reads, <CODE>*<VAR>amtread</VAR></CODE> is
filled with the amount actually read.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_notice_dirchange</B> <I>(struct node *<VAR>dp</VAR>, enum dir_changed_type <VAR>type</VAR>, char *<VAR>name</VAR>)</I>
<DD><A NAME="IDX351"></A>
Send notifications to users who have requested them for directory
<VAR>dp</VAR> with <CODE>dir_notice_changes</CODE>.  The type of modification and
affected name are <VAR>type</VAR> and <VAR>name</VAR> respectively.  This should
be called by <CODE>diskfs_direnter</CODE>, <CODE>diskfs_dirremove</CODE>,
<CODE>diskfs_dirrewrite</CODE>, and anything else that changes the directory,
after the change is fully completed.
</DL>


<P>
<DL>
<DT><U>Function:</U> struct node * <B>diskfs_make_node</B> <I>(struct disknode *<VAR>dn</VAR>)</I>
<DD><A NAME="IDX352"></A>
Create a new node structure with <VAR>ds</VAR> as its physical disknode.  The
new node will have one hard reference and no light references.
</DL>


<P>
These next node manipulation functions are not generally useful, but may
come in handy if you need to redefine any diskfs functions.


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_create_node</B> <I>(struct node *<VAR>dir</VAR>, char *<VAR>name</VAR>, mode_t <VAR>mode</VAR>, struct node **<VAR>newnode</VAR>, struct protid *<VAR>cred</VAR>, struct dirstat *<VAR>ds</VAR>)</I>
<DD><A NAME="IDX353"></A>
Create a new node.  Give it <VAR>mode</VAR>: if <VAR>mode</VAR> includes
<CODE>IFDIR</CODE>, also initialize <TT>`.'</TT> and <TT>`..'</TT> in the new
directory.  Return the node in <VAR>npp</VAR>.  <VAR>cred</VAR> identifies the
user responsible for the call.  If <VAR>name</VAR> is nonzero, then link the
new node into <VAR>dir</VAR> with name <VAR>name</VAR>; <VAR>ds</VAR> is the result of
a prior <CODE>diskfs_lookup</CODE> for creation (and <VAR>dir</VAR> has been held
locked since).  <VAR>dir</VAR> must always be provided as at least a hint for
disk allocation strategies.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_set_node_times</B> <I>(struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX354"></A>
If <CODE><VAR>np</VAR>-&#62;dn_set_ctime</CODE> is set, then modify
<CODE><VAR>np</VAR>-&#62;dn_stat.st_ctime</CODE> appropriately; do the analogous
operations for atime and mtime as well.
</DL>


<P>
<DL>
<DT><U>Function:</U> struct node * <B>diskfs_check_lookup_cache</B> <I>(struct node *<VAR>dir</VAR>, char *<VAR>name</VAR>)</I>
<DD><A NAME="IDX355"></A>
Scan the cache looking for <VAR>name</VAR> inside <VAR>dir</VAR>.  If we don't
know any entries at all, then return zero.  If the entry is confirmed to
not exist, then return -1.  Otherwise, return <VAR>np</VAR> for the entry,
with a newly-allocated reference.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_cached_lookup</B> <I>(int <VAR>cache_id</VAR>, struct node **<VAR>npp</VAR>)</I>
<DD><A NAME="IDX356"></A>
Return the node corresponding to <VAR>cache_id</VAR> in <CODE>*<VAR>npp</VAR></CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_enter_lookup_cache</B> <I>(struct node *<VAR>dir</VAR>, struct node *<VAR>np</VAR>, char *<VAR>name</VAR>)</I>
<DD><A NAME="IDX357"></A>
Node <VAR>np</VAR> has just been found in <VAR>dir</VAR> with <VAR>name</VAR>.  If
<VAR>np</VAR> is null, that means that this name has been confirmed as absent
in the directory.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_purge_lookup_cache</B> <I>(struct node *<VAR>dp</VAR>, struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX358"></A>
Purge all references in the cache to <VAR>np</VAR> as a node inside directory
<VAR>dp</VAR>.
</DL>




<H3><A NAME="SEC111" HREF="hurd_toc.html#TOC111">Diskfs Callbacks</A></H3>

<P>
Like several other Hurd libraries, <CODE>libdiskfs</CODE> depends on you to
implement application-specific callback functions.  You <EM>must</EM>
define the following functions and variables, but you should also look
at section <A HREF="hurd_10.html#SEC112">Diskfs Options</A>, as there are several defaults which should be
modified to provide good filesystem support:


<P>
<DL>
<DT><U>Structure:</U> struct <B>dirstat</B>
<DD><A NAME="IDX359"></A>
You must define this type, which will hold information between a call to
<CODE>diskfs_lookup</CODE> and a call to one of <CODE>diskfs_direnter</CODE>,
<CODE>diskfs_dirremove</CODE>, or <CODE>diskfs_dirrewrite</CODE>.  It must contain
enough information so that those calls work as described below.
</DL>


<P>
<DL>
<DT><U>Variable:</U> size_t <B>diskfs_dirstat_size</B>
<DD><A NAME="IDX360"></A>
This must be the size in bytes of a <CODE>struct dirstat</CODE>.
</DL>


<P>
<DL>
<DT><U>Variable:</U> int <B>diskfs_link_max</B>
<DD><A NAME="IDX361"></A>
This is the maximum number of links to any one file, which must be a
positive integer.  The implementation of <CODE>dir_rename</CODE> does not know
how to succeed if this is only one allowed link; on such formats you
need to reimplement <CODE>dir_rename</CODE> yourself.
</DL>


<P>
<DL>
<DT><U>Variable:</U> int <B>diskfs_maxsymlinks</B>
<DD><A NAME="IDX362"></A>
This variable is a positive integer which is the maximum number of
symbolic links which can be traversed within a single call to
<CODE>dir_pathtrans</CODE>.  If this is exceeded, <CODE>dir_pathtrans</CODE> will
return <CODE>ELOOP</CODE>.
</DL>


<P>
<DL>
<DT><U>Variable:</U> struct node * <B>diskfs_root_node</B>
<DD><A NAME="IDX363"></A>
Set this to be the node of the root of the filesystem.
</DL>


<P>
<DL>
<DT><U>Variable:</U> char * <B>diskfs_server_name</B>
<DD><A NAME="IDX364"></A>
Set this to the name of the filesystem server.
</DL>


<P>
<DL>
<DT><U>Variable:</U> char * <B>diskfs_server_version</B>
<DD><A NAME="IDX365"></A>
Set this to be the server version string.
</DL>


<P>
<DL>
<DT><U>Variable:</U> char * <B>diskfs_disk_name</B>
<DD><A NAME="IDX366"></A>
This should be a string that somehow identifies the particular disk this
filesystem is interpreting.  It is generally only used to print messages
or to distinguish instances of the same filesystem type from one
another.  If this filesystem accesses no external media, then define
this to be zero.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_set_statfs</B> <I>(fsys_statfsbuf_t *<VAR>statfsbuf</VAR>)</I>
<DD><A NAME="IDX367"></A>
Set <CODE>*<VAR>statfsbuf</VAR></CODE> with appropriate values to reflect the
current state of the filesystem.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_lookup</B> <I>(struct node *<VAR>dp</VAR>, char *<VAR>name</VAR>, enum lookup_type <VAR>type</VAR>, struct node **<VAR>np</VAR>, struct dirstat *<VAR>ds</VAR>, struct protid *<VAR>cred</VAR>)</I>
<DD><A NAME="IDX368"></A>
<DT><U>Function:</U> error_t <B>diskfs_lookup_hard</B> <I>(struct node *<VAR>dp</VAR>, char *<VAR>name</VAR>, enum lookup_type <VAR>type</VAR>, struct node **<VAR>np</VAR>, struct dirstat *<VAR>ds</VAR>, struct protid *<VAR>cred</VAR>)</I>
<DD><A NAME="IDX369"></A>
You should not define <CODE>diskfs_lookup</CODE>, because it is simply a
wrapper for <CODE>diskfs_lookup_hard</CODE>, and is already defined in
<CODE>libdiskfs</CODE>.


<P>
Lookup in directory <VAR>dp</VAR> (which is locked) the name <VAR>name</VAR>.
<VAR>type</VAR> will either be <CODE>LOOKUP</CODE>, <CODE>CREATE</CODE>, <CODE>RENAME</CODE>,
or <CODE>REMOVE</CODE>.  <VAR>cred</VAR> identifies the user making the call.


<P>
If the name is found, return zero, and (if <VAR>np</VAR> is nonzero) set
<CODE>*<VAR>np</VAR></CODE> to point to the node for it, which should be locked.
If the name is not found, return <CODE>ENOENT</CODE>, and (if <VAR>np</VAR> is
nonzero) set <CODE>*<VAR>np</VAR></CODE> to zero.  If <VAR>np</VAR> is zero, then the
node found must not be locked, not even transitorily.  Lookups for
<CODE>REMOVE</CODE> and <CODE>RENAME</CODE> (which must often check permissions on
the node being found) will always set <VAR>np</VAR>.


<P>
If <VAR>ds</VAR> is nonzero then the behaviour varies depending on the
requested lookup <VAR>type</VAR>:


<DL COMPACT>

<DT><CODE>LOOKUP</CODE>
<DD>
Set <CODE>*<VAR>ds</VAR></CODE> to be ignored by <CODE>diskfs_drop_dirstat</CODE>

<DT><CODE>CREATE</CODE>
<DD>
On success, set <CODE>*<VAR>ds</VAR></CODE> to be ignored by
<CODE>diskfs_drop_dirstat</CODE>. <BR>
On failure, set <CODE>*<VAR>ds</VAR></CODE> for a future call to
<CODE>diskfs_direnter</CODE>.

<DT><CODE>RENAME</CODE>
<DD>
On success, set <CODE>*<VAR>ds</VAR></CODE> for a future call to
<CODE>diskfs_dirrewrite</CODE>. <BR>
On failure, set <CODE>*<VAR>ds</VAR></CODE> for a future call to
<CODE>diskfs_direnter</CODE>.

<DT><CODE>REMOVE</CODE>
<DD>
On success, set <CODE>*<VAR>ds</VAR></CODE> for a future call to
<CODE>diskfs_dirremove</CODE>. <BR>
On failure, set <CODE>*<VAR>ds</VAR></CODE> to be ignored by
<CODE>diskfs_drop_dirstat</CODE>.
</DL>

<P>
The caller of this function guarantees that if <VAR>ds</VAR> is nonzero, then
either the appropriate call listed above or <CODE>diskfs_drop_dirstat</CODE>
will be called with <VAR>ds</VAR> before the directory <VAR>dp</VAR> is unlocked,
and guarantees that no lookup calls will be made on this directory
between this lookup and the use (or destruction) of *DS.


<P>
If you use the library's versions of <CODE>diskfs_rename_dir</CODE>,
<CODE>diskfs_clear_directory</CODE>, and <CODE>diskfs_init_dir</CODE>, then lookups
for <TT>`..'</TT> might have the flag <CODE>SPEC_DOTDOT</CODE> ORed in.  This has a
special meaning depending on the requested lookup <VAR>type</VAR>:


<DL COMPACT>

<DT><CODE>LOOKUP</CODE>
<DD>
<VAR>dp</VAR> should be unlocked and its reference dropped before returning.

<DT><CODE>CREATE</CODE>
<DD>
Ignore this case, because <CODE>SPEC_DOTDOT</CODE> is guaranteed not to be
given.

<DT><CODE>RENAME</CODE>
<DD>
<DT><CODE>REMOVE</CODE>
<DD>
In both of these cases, the node being found (<CODE>*<VAR>np</VAR></CODE>) is
already held locked, so don't lock it or add a reference to it.
</DL>

<P>
Return <CODE>ENOENT</CODE> if <VAR>name</VAR> isn't in the directory.  Return
<CODE>EAGAIN</CODE> if <VAR>name</VAR> refers to the <TT>`..'</TT> of this filesystem's
root.  Return <CODE>EIO</CODE> if appropriate.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_direnter</B> <I>(struct node *<VAR>dp</VAR>, char *<VAR>name</VAR>, struct node *<VAR>np</VAR>, struct dirstat *<VAR>ds</VAR>, struct protid *<VAR>cred</VAR>)</I>
<DD><A NAME="IDX370"></A>
<DT><U>Function:</U> error_t <B>diskfs_direnter_hard</B> <I>(struct node *<VAR>dp</VAR>, char *<VAR>name</VAR>, struct node *<VAR>np</VAR>, struct dirstat *<VAR>ds</VAR>, struct protid *<VAR>cred</VAR>)</I>
<DD><A NAME="IDX371"></A>
You should not define <CODE>diskfs_direnter</CODE>, because it is simply a
wrapper for <CODE>diskfs_direnter_hard</CODE>, and is already defined in
<CODE>libdiskfs</CODE>.


<P>
Add <VAR>np</VAR> to directory <VAR>dp</VAR> under the name <VAR>name</VAR>.  This will
only be called after an unsuccessful call to <CODE>diskfs_lookup</CODE> of type
<CODE>CREATE</CODE> or <CODE>RENAME</CODE>; <VAR>dp</VAR> has been locked continuously
since that call and <VAR>ds</VAR> is as that call set it, <VAR>np</VAR> is locked.
<VAR>cred</VAR> identifies the user responsible for the call (to be used only
to validate directory growth).
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_dirrewrite</B> <I>(struct node *<VAR>dp</VAR>, struct node *<VAR>oldnp</VAR>, struct node *<VAR>np</VAR>, char *<VAR>name</VAR>, struct dirstat *<VAR>ds</VAR>)</I>
<DD><A NAME="IDX372"></A>
<DT><U>Function:</U> error_t <B>diskfs_dirrewrite_hard</B> <I>(struct node *<VAR>dp</VAR>, struct node *<VAR>np</VAR>, struct dirstat *<VAR>ds</VAR>)</I>
<DD><A NAME="IDX373"></A>
You should not define <CODE>diskfs_dirrewrite</CODE>, because it is simply a
wrapper for <CODE>diskfs_dirrewrite_hard</CODE>, and is already defined in
<CODE>libdiskfs</CODE>.


<P>
This will only be called after a successful call to <CODE>diskfs_lookup</CODE>
of type <CODE>RENAME</CODE>; this call should change the name found in
directory <VAR>dp</VAR> to point to node <VAR>np</VAR> instead of its previous
referent.  <VAR>dp</VAR> has been locked continuously since the call to
<CODE>diskfs_lookup</CODE> and <VAR>ds</VAR> is as that call set it; <VAR>np</VAR> is
locked.


<P>
<CODE>diskfs_dirrewrite</CODE> has some additional specifications: <VAR>name</VAR>
is the name within <VAR>dp</VAR> which used to correspond to the previous
referent, <VAR>oldnp</VAR>; it is this reference which is being rewritten.
<CODE>diskfs_dirrewrite</CODE> also calls <CODE>diskfs_notice_dirchange</CODE> if
<CODE><VAR>dp</VAR>-&#62;dirmod_reqs</CODE> is nonzero.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_dirremove</B> <I>(struct node *<VAR>dp</VAR>, struct node *<VAR>np</VAR>, char *<VAR>name</VAR>, struct dirstat *<VAR>ds</VAR>)</I>
<DD><A NAME="IDX374"></A>
<DT><U>Function:</U> error_t <B>diskfs_dirremove_hard</B> <I>(struct node *<VAR>dp</VAR>, struct dirstat *<VAR>ds</VAR>)</I>
<DD><A NAME="IDX375"></A>
You should not define <CODE>diskfs_dirremove</CODE>, because it is simply a
wrapper for <CODE>diskfs_dirremove_hard</CODE>, and is already defined in
<CODE>libdiskfs</CODE>.


<P>
This will only be called after a successful call to <CODE>diskfs_lookup</CODE>
of type <CODE>REMOVE</CODE>; this call should remove the name found from the
directory <VAR>ds</VAR>.  <VAR>dp</VAR> has been locked continuously since the
call to <CODE>diskfs_lookup</CODE> and <VAR>ds</VAR> is as that call set it.


<P>
<CODE>diskfs_dirremove</CODE> has some additional specifications: this routine
should call <CODE>diskfs_notice_dirchange</CODE> if
<CODE><VAR>dp</VAR>-&#62;dirmod_reqs</CODE> is nonzero.  The entry being removed has
name <VAR>name</VAR> and refers to <VAR>np</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_drop_dirstat</B> <I>(struct node *<VAR>dp</VAR>, struct dirstat *<VAR>ds</VAR>)</I>
<DD><A NAME="IDX376"></A>
<VAR>ds</VAR> has been set by a previous call to <CODE>diskfs_lookup</CODE> on
directory <VAR>dp</VAR>; this function is guaranteed to be called if
<CODE>diskfs_direnter</CODE>, <CODE>diskfs_dirrewrite</CODE>, and
<CODE>diskfs_dirremove</CODE> have not been called, and should free any state
retained by a <CODE>struct dirstat</CODE>.  <VAR>dp</VAR> has been locked
continuously since the call to <CODE>diskfs_lookup</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_null_dirstat</B> <I>(struct dirstat *<VAR>ds</VAR>)</I>
<DD><A NAME="IDX377"></A>
Initialize <VAR>ds</VAR> such that <CODE>diskfs_drop_dirstat</CODE> will ignore it.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_get_directs</B> <I>(struct node *<VAR>dp</VAR>, int <VAR>entry</VAR>, int <VAR>n</VAR>, char **<VAR>data</VAR>, u_int *<VAR>datacnt</VAR>, vm_size_t <VAR>bufsiz</VAR>, int *<VAR>amt</VAR>)</I>
<DD><A NAME="IDX378"></A>
Return <VAR>n</VAR> directory entries starting at <VAR>entry</VAR> from locked
directory node <VAR>dp</VAR>.  Fill <CODE>*<VAR>data</VAR></CODE> with the entries;
which currently points to <CODE>*<VAR>datacnt</VAR></CODE> bytes.  If it isn't big
enough, <CODE>vm_allocate</CODE> into <CODE>*<VAR>data</VAR></CODE>.  Set
<CODE>*<VAR>datacnt</VAR></CODE> with the total size used.  Fill <VAR>amt</VAR> with the
number of entries copied.  Regardless, never copy more than <VAR>bufsiz</VAR>
bytes.  If <VAR>bufsiz</VAR> is zero, then there is no limit on
<CODE>*<VAR>datacnt</VAR></CODE>; if <VAR>n</VAR> is -1, then there is no limit on
<VAR>amt</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> int <B>diskfs_dirempty</B> <I>(struct node *<VAR>dp</VAR>, struct protid *<VAR>cred</VAR>)</I>
<DD><A NAME="IDX379"></A>
Return nonzero if locked directory <VAR>dp</VAR> is empty.  If the user has
not redefined <CODE>diskfs_clear_directory</CODE> and
<CODE>diskfs_init_directory</CODE>, then `empty' means `only possesses entries
labelled <TT>`.'</TT> and <TT>`..'</TT>.  <VAR>cred</VAR> identifies the user making
the call... if this user cannot search the directory, then this
routine should fail.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_get_translator</B> <I>(struct node *<VAR>np</VAR>, char **<VAR>namep</VAR>, u_int *<VAR>namelen</VAR>)</I>
<DD><A NAME="IDX380"></A>
For locked node <VAR>np</VAR> (for which <CODE>diskfs_node_translated</CODE> is
true) look up the name of its translator.  Store the name into newly
malloced storage and set <CODE>*<VAR>namelen</VAR></CODE> to the total length.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_set_translator</B> <I>(struct node *<VAR>np</VAR>, char *<VAR>name</VAR>, u_int <VAR>namelen</VAR>, struct protid *<VAR>cred</VAR>)</I>
<DD><A NAME="IDX381"></A>
For locked node <VAR>np</VAR>, set the name of the translating program to be
<VAR>name</VAR>, which is <VAR>namelen</VAR> bytes long.  <VAR>cred</VAR> identifies
the user responsible for the call.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_truncate</B> <I>(struct node *<VAR>np</VAR>, off_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX382"></A>
Truncate locked node <VAR>np</VAR> to be <VAR>size</VAR> bytes long.  If <VAR>np</VAR>
is already less than or equal to <VAR>size</VAR> bytes long, do nothing.  If
this is a symlink (and <CODE>diskfs_shortcut_symlink</CODE> is set) then this
should clear the symlink, even if <CODE>diskfs_create_symlink_hook</CODE>
stores the link target elsewhere.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_grow</B> <I>(struct node *<VAR>np</VAR>, off_t <VAR>size</VAR>, struct protid *<VAR>cred</VAR>)</I>
<DD><A NAME="IDX383"></A>
Grow the disk allocated to locked node <VAR>np</VAR> to be at least
<VAR>size</VAR> bytes, and set <CODE><VAR>np</VAR>-&#62;allocsize</CODE> to the actual
allocated size.  If the allocated size is already <VAR>size</VAR> bytes, do
nothing.  <VAR>cred</VAR> identifies the user responsible for the call.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_node_reload</B> <I>(struct node *<VAR>node</VAR>)</I>
<DD><A NAME="IDX384"></A>
This function must reread all data specific to <VAR>node</VAR> from disk,
without writing anything.  It is always called with
<VAR>diskfs_readonly</VAR> set to true.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_reload_global_state</B> <I>(void)</I>
<DD><A NAME="IDX385"></A>
This function must invalidate all cached global state, and reread it as
necessary from disk, without writing anything.  It is always called with
<VAR>diskfs_readonly</VAR> set to true.  <CODE>diskfs_node_reload</CODE> is
subsequently called on all active nodes, so this call doesn't need to
reread any node-specific data.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_node_iterate</B> <I>(error_t (*<VAR>fun</VAR>) (struct node *<VAR>np</VAR>))</I>
<DD><A NAME="IDX386"></A>
For each active node <VAR>np</VAR>, call <VAR>fun</VAR>.  The node is to be locked
around the call to <VAR>fun</VAR>.  If <VAR>fun</VAR> returns nonzero for any
node, then stop immediately, and return that value.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_alloc_node</B> <I>(struct node *<VAR>dp</VAR>, mode_t <VAR>mode</VAR>, struct node **<VAR>np</VAR>)</I>
<DD><A NAME="IDX387"></A>
Allocate a new node to be of mode <VAR>mode</VAR> in locked directory
<VAR>dp</VAR>, but don't actually set the mode or modify the directory, since
that will be done by the caller.  The user responsible for the request
can be identified with <VAR>cred</VAR>.  Set <CODE>*<VAR>np</VAR></CODE> to be the newly
allocated node.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_free_node</B> <I>(struct node *<VAR>np</VAR>, mode_t <VAR>mode</VAR>)</I>
<DD><A NAME="IDX388"></A>
Free node <VAR>np</VAR>; the on-disk copy has already been synchronized with
<CODE>diskfs_node_update</CODE> (where <CODE><VAR>np</VAR>-&#62;dn_stat.st_mode</CODE> was
zero).  <VAR>np</VAR>'s mode used to be <VAR>mode</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_lost_hardrefs</B> <I>(struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX389"></A>
Locked node <VAR>np</VAR> has some light references but has just lost its
last hard reference.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_new_hardrefs</B> <I>(struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX390"></A>
Locked node <VAR>np</VAR> has just acquired a hard reference where it had
none previously.  Therefore, it is okay again to have light references
without real users.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_try_dropping_softrefs</B> <I>(struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX391"></A>
Node <VAR>np</VAR> has some light references, but has just lost its last hard
references.  Take steps so that if any light references can be freed,
they are.  Both <VAR>diskfs_node_refcnt_lock</VAR> and <VAR>np</VAR> are locked.
This function will be called after <CODE>diskfs_lost_hardrefs</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_node_norefs</B> <I>(struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX392"></A>
Node <VAR>np</VAR> has no more references; free local state, including
<CODE>*<VAR>np</VAR></CODE> if it shouldn't be retained.
<VAR>diskfs_node_refcnt_lock</VAR> is held.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_set_hypermetadata</B> <I>(int <VAR>wait</VAR>, int <VAR>clean</VAR>)</I>
<DD><A NAME="IDX393"></A>
Write any non-paged metadata from format-specific buffers to disk,
asynchronously unless <VAR>wait</VAR> is nonzero.  If <VAR>clean</VAR> is nonzero,
then after this is written the filesystem will be absolutely clean, and
it must be possible for the non-paged metadata to indicate that fact.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_write_disknode</B> <I>(struct node *<VAR>np</VAR>, int <VAR>wait</VAR>)</I>
<DD><A NAME="IDX394"></A>
Write the information in <CODE><VAR>np</VAR>-&#62;dn_stat</CODE> and any associated
format-specific information to the disk.  If <VAR>wait</VAR> is true, then
return only after the physical media has been completely updated.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_file_update</B> <I>(struct node *<VAR>np</VAR>, int <VAR>wait</VAR>)</I>
<DD><A NAME="IDX395"></A>
Write the contents and all associated metadata of file NP to disk.
Generally, this will involve calling <CODE>diskfs_node_update</CODE> for much
of the metadata.  If <VAR>wait</VAR> is true, then return only after the
physical media has been completely updated.
</DL>


<P>
<DL>
<DT><U>Function:</U> mach_port_t <B>diskfs_get_filemap</B> <I>(struct node *<VAR>np</VAR>, vm_prot_t <VAR>prot</VAR>)</I>
<DD><A NAME="IDX396"></A>
Return a memory object port (send right) for the file contents of
<VAR>np</VAR>.  <VAR>prot</VAR> is the maximum allowable access.  On errors,
return <CODE>MACH_PORT_NULL</CODE> and set <CODE>errno</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> struct pager * <B>diskfs_get_filemap_pager_struct</B> <I>(struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX397"></A>
Return a <CODE>struct pager *</CODE> that refers to the pager returned by
diskfs_get_filemap for locked node NP, suitable for use as an argument
to <CODE>pager_memcpy</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> vm_prot_t <B>diskfs_max_user_pager_prot</B> <I>(void)</I>
<DD><A NAME="IDX398"></A>
Return the bitwise OR of the maximum <CODE>prot</CODE> parameter (the second
argument to <CODE>diskfs_get_filemap</CODE>) for all active user pagers.
</DL>


<P>
<DL>
<DT><U>Function:</U> int <B>diskfs_pager_users</B> <I>(void)</I>
<DD><A NAME="IDX399"></A>
Return nonzero if there are pager ports exported that might be in use by
users.  Further pager creation should be blocked before this function
returns zero.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_sync_everything</B> <I>(int <VAR>wait</VAR>)</I>
<DD><A NAME="IDX400"></A>
Sync all the pagers and write any data belonging on disk except for the
hypermetadata.  If <VAR>wait</VAR> is true, then return only after the
physical media has been completely updated.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_shutdown_pager</B> <I>(void)</I>
<DD><A NAME="IDX401"></A>
Shut down all pagers.  This is irreversible, and is done when the
filesystem is exiting.
</DL>




<H3><A NAME="SEC112" HREF="hurd_toc.html#TOC112">Diskfs Options</A></H3>

<P>
The functions and variables described in this subsection already have
default definitions in <CODE>libdiskfs</CODE>, so you are not forced to define
them; rather, they may be redefined on a case-by-case basis.


<P>
You should set the values of any option variables as soon as your program
starts (before you make any calls to diskfs, such as argument parsing).


<P>
<DL>
<DT><U>Variable:</U> int <B>diskfs_hard_readonly</B>
<DD><A NAME="IDX402"></A>
You should set this variable to nonzero if the filesystem media can
never be made writable.
</DL>


<P>
<DL>
<DT><U>Variable:</U> char * <B>diskfs_extra_version</B>
<DD><A NAME="IDX403"></A>
Set this to be any additional version specification that should be
printed for --version.
</DL>


<P>
<DL>
<DT><U>Variable:</U> int <B>diskfs_shortcut_symlink</B>
<DD><A NAME="IDX404"></A>
This should be nonzero if and only if the filesystem format supports
shortcutting symbolic link translation.  The library guarantees that
users will not be able to read or write the contents of the node
directly, and the library will only do so if the symlink hook functions
(<CODE>diskfs_create_symlink_hook</CODE> and <CODE>diskfs_read_symlink_hook</CODE>)
return <CODE>EINVAL</CODE> or are not defined.  The library knows that the
<CODE>dn_stat.st_size</CODE> field is the length of the symlink, even if the
hook functions are used.
</DL>


<P>
<DL>
<DT><U>Variable:</U> int <B>diskfs_shortcut_chrdev</B>
<DD><A NAME="IDX405"></A>
<DT><U>Variable:</U> int <B>diskfs_shortcut_blkdev</B>
<DD><A NAME="IDX406"></A>
<DT><U>Variable:</U> int <B>diskfs_shortcut_fifo</B>
<DD><A NAME="IDX407"></A>
<DT><U>Variable:</U> int <B>diskfs_shortcut_ifsock</B>
<DD><A NAME="IDX408"></A>
These variables should be nonzero if and only if the filesystem format
supports shortcutting character device node, block device node, FIFO, or
Unix-domain socket translation, respectively.
</DL>


<P>
<DL>
<DT><U>Variable:</U> int <B>diskfs_default_sync_interval</B>
<DD><A NAME="IDX409"></A>
<CODE>diskfs_set_sync_interval</CODE> is called with this value when the first
diskfs thread is started up (in <CODE>diskfs_spawn_first_thread</CODE>).  This
variable has a default default value of 30, which causes disk buffers to
be flushed at least every 30 seconds.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_validate_mode_change</B> <I>(struct node *<VAR>np</VAR>, mode_t <VAR>mode</VAR>)</I>
<DD><A NAME="IDX410"></A>
<DT><U>Function:</U> error_t <B>diskfs_validate_owner_change</B> <I>(struct node *<VAR>np</VAR>, uid_t <VAR>uid</VAR>)</I>
<DD><A NAME="IDX411"></A>
<DT><U>Function:</U> error_t <B>diskfs_validate_group_change</B> <I>(struct node *<VAR>np</VAR>, gid_t <VAR>gid</VAR>)</I>
<DD><A NAME="IDX412"></A>
<DT><U>Function:</U> error_t <B>diskfs_validate_author_change</B> <I>(struct node *<VAR>np</VAR>, uid_t <VAR>author</VAR>)</I>
<DD><A NAME="IDX413"></A>
<DT><U>Function:</U> error_t <B>diskfs_validate_flags_change</B> <I>(struct node *<VAR>np</VAR>, int <VAR>flags</VAR>)</I>
<DD><A NAME="IDX414"></A>
<DT><U>Function:</U> error_t <B>diskfs_validate_rdev_change</B> <I>(struct node *<VAR>np</VAR>, dev_t <VAR>rdev</VAR>)</I>
<DD><A NAME="IDX415"></A>
Return zero if for the node <VAR>np</VAR> can be changed as requested.  That
is, if <VAR>np</VAR>'s mode can be changed to <VAR>mode</VAR>, owner to <VAR>uid</VAR>,
group to <VAR>gid</VAR>, author to <VAR>author</VAR>, flags to <VAR>flags</VAR>, or raw
device number to <VAR>rdev</VAR>, respectively.  Otherwise, return an error
code.


<P>
It must always be possible to clear the mode or the flags; diskfs will
not ask for permission before doing so.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_readonly_changed</B> <I>(int <VAR>readonly</VAR>)</I>
<DD><A NAME="IDX416"></A>
This is called when the disk has been changed from read-only to
read-write mode or vice-versa.  <VAR>readonly</VAR> is the new state (which
is also reflected in <VAR>diskfs_readonly</VAR>).  This function is also
called during initial startup if the filesystem is to be writable.
</DL>


<P>
<DL>
<DT><U>Variable:</U> error_t (* <B>diskfs_create_symlink_hook</B> <I>) (struct node *<VAR>np</VAR>, char *<VAR>target</VAR>)</I>
<DD><A NAME="IDX417"></A>
If this function pointer is nonzero (and <CODE>diskfs_shortcut_symlink</CODE>
is set) it is called to set a symlink.  If it returns <CODE>EINVAL</CODE> or
isn't set, then the normal method (writing the contents into the file
data) is used.  If it returns any other error, it is returned to the
user.
</DL>


<P>
<DL>
<DT><U>Variable:</U> error_t (* <B>diskfs_read_symlink_hook</B> <I>) (struct node *<VAR>np</VAR>, char *<VAR>target</VAR>)</I>
<DD><A NAME="IDX418"></A>
If this function pointer is nonzero (and <CODE>diskfs_shortcut_symlink</CODE>
is set) it is called to read the contents of a symlink.  If it returns
<CODE>EINVAL</CODE> or isn't set, then the normal method (reading from the
file data) is used.  If it returns any other error, it is returned to
the user.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_rename_dir</B> <I>(struct node *<VAR>fdp</VAR>, struct node *<VAR>fnp</VAR>, char *<VAR>fromname</VAR>, struct node *<VAR>tdp</VAR>, char *<VAR>toname</VAR>, struct protid *<VAR>fromcred</VAR>, struct protid *<VAR>tocred</VAR>)</I>
<DD><A NAME="IDX419"></A>
Rename directory node <VAR>fnp</VAR> (whose parent is <VAR>fdp</VAR>, and which
has name <VAR>fromname</VAR> in that directory) to have name <VAR>toname</VAR>
inside directory <VAR>tdp</VAR>.  None of these nodes are locked, and none
should be locked upon return.  This routine is serialized, so it doesn't
have to be reentrant.  Directories will never be renamed except by this
routine.  <VAR>fromcred</VAR> is the user responsible for <VAR>fdp</VAR> and
<VAR>fnp</VAR>.  <VAR>tocred</VAR> is the user responsible for <VAR>tdp</VAR>.  This
routine assumes the usual convention where <TT>`.'</TT>  and <TT>`..'</TT> are
represented by ordinary links; if that is not true for your format, you
have to redefine this function.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_clear_directory</B> <I>(struct node *<VAR>dp</VAR>, struct node *<VAR>pdp</VAR>, struct protid *<VAR>cred</VAR>)</I>
<DD><A NAME="IDX420"></A>
Clear the <TT>`.'</TT> and <TT>`..'</TT> entries from directory <VAR>dp</VAR>.  Its
parent is <VAR>pdp</VAR>, and the user responsible for this is identified by
<VAR>cred</VAR>.  Both directories must be locked.  This routine assumes the
usual convention where <TT>`.'</TT> and <TT>`..'</TT> are represented by
ordinary links; if that is not true for your format, you have to
redefine this function.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_init_dir</B> <I>(struct node *<VAR>dp</VAR>, struct node *<VAR>pdp</VAR>, struct protid *<VAR>cred</VAR>)</I>
<DD><A NAME="IDX421"></A>
Locked node <VAR>dp</VAR> is a new directory; add whatever links are
necessary to give it structure; its parent is the (locked) node
<VAR>pdp</VAR>.  This routine may not call <CODE>diskfs_lookup</CODE> on <VAR>pdp</VAR>.
The new directory must be clear within the meaning of
<CODE>diskfs_dirempty</CODE>.  This routine assumes the usual convention where
<TT>`.'</TT> and <TT>`..'</TT> are represented by ordinary links; if that is not
true for your format, you have to redefine this function.  <VAR>cred</VAR>
identifies the user making the call.
</DL>




<H3><A NAME="SEC113" HREF="hurd_toc.html#TOC113">Diskfs Internals</A></H3>

<P>
The library also exports the following functions, but they are not
generally useful unless you are redefining other functions the library
provides.


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_create_protid</B> <I>(struct peropen *<VAR>po</VAR>, struct iouser *<VAR>user</VAR>, struct protid **<VAR>cred</VAR>)</I>
<DD><A NAME="IDX422"></A>
Create and return a protid for an existing peropen <VAR>po</VAR> in
<VAR>cred</VAR>, referring to user <VAR>user</VAR>.  The node <CODE><VAR>po</VAR>-&#62;np</CODE>
must be locked.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_start_protid</B> <I>(struct peropen *<VAR>po</VAR>, struct protid **<VAR>cred</VAR>)</I>
<DD><A NAME="IDX423"></A>
Build and return in <VAR>cred</VAR> a protid which has no user
identification, for peropen <VAR>po</VAR>.  The node <CODE><VAR>po</VAR>-&#62;np</CODE> must
be locked.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_finish_protid</B> <I>(struct protid *<VAR>cred</VAR>, struct iouser *<VAR>user</VAR>)</I>
<DD><A NAME="IDX424"></A>
Finish building protid <VAR>cred</VAR> started with <CODE>diskfs_start_protid</CODE>;
the user to install is <VAR>user</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_protid_rele</B> <I>(void *<VAR>arg</VAR>)</I>
<DD><A NAME="IDX425"></A>
Called when a protid <VAR>cred</VAR> has no more references.  Because
references to protids are maintained by the port management library,
this is installed in the clean routines list.  The ports library will
free the structure.
</DL>


<P>
<DL>
<DT><U>Function:</U> struct peropen * <B>diskfs_make_peropen</B> <I>(struct node *<VAR>np</VAR>, int <VAR>flags</VAR>, struct peropen *<VAR>context</VAR>)</I>
<DD><A NAME="IDX426"></A>
Create and return a new peropen structure on node <VAR>np</VAR> with open
flags <VAR>flags</VAR>.  The initial values for the <CODE>root_parent</CODE>,
<CODE>shadow_root</CODE>, and <CODE>shadow_root_parent</CODE> fields are copied from
<VAR>context</VAR> if it is nonzero, otherwise each of these values are
set to zero.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_release_peropen</B> <I>(struct peropen *<VAR>po</VAR>)</I>
<DD><A NAME="IDX427"></A>
Decrement the reference count on <VAR>po</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_execboot_fsys_startup</B> <I>(mach_port_t <VAR>port</VAR>, int <VAR>flags</VAR>, mach_port_t <VAR>ctl</VAR>, mach_port_t *<VAR>real</VAR>, mach_msg_type_name_t *<VAR>realpoly</VAR>)</I>
<DD><A NAME="IDX428"></A>
This function is called by <CODE>S_fsys_startup</CODE> for execserver
bootstrap.  The execserver is able to function without a real node,
hence this fraud.  Arguments are as for <CODE>fsys_startup</CODE> in
<CODE>&#60;hurd/fsys.defs&#62;</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> int <B>diskfs_demuxer</B> <I>(mach_msg_header_t *<VAR>inp</VAR>, mach_msg_header_t *<VAR>outp</VAR>)</I>
<DD><A NAME="IDX429"></A>
Demultiplex incoming <CODE>libports</CODE> messages on diskfs ports.
</DL>


<P>
<A NAME="IDX430"></A>
The diskfs library also provides functions to demultiplex the fs, io,
fsys, interrupt, and notify interfaces.  All the server routines have
the prefix <CODE>diskfs_S_</CODE>.  For those routines, <CODE>in</CODE> arguments of
type <CODE>file_t</CODE> or <CODE>io_t</CODE> appear as <CODE>struct protid *</CODE> to
the stub.


<P><HR><P>
Go to the <A HREF="hurd_1.html">first</A>, <A HREF="hurd_9.html">previous</A>, <A HREF="hurd_11.html">next</A>, <A HREF="hurd_17.html">last</A> section, <A HREF="hurd_toc.html">table of contents</A>.
</BODY>
</HTML>

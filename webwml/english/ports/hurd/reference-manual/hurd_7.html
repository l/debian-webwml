<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from hurd.texi on 29 June 1999 -->

<TITLE>Hurd Reference Manual - Files</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="hurd_1.html">first</A>, <A HREF="hurd_6.html">previous</A>, <A HREF="hurd_8.html">next</A>, <A HREF="hurd_17.html">last</A> section, <A HREF="hurd_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC47" HREF="hurd_toc.html#TOC47">Files</A></H1>

<P>
A file is traditionally thought of as a quantity of disk storage.  In
the Hurd, files are an extension of the I/O interface, but they do not
necessarily correspond to disk storage.


<P>
Every file in the Hurd is represented by a port, which is connected to
the server that manages the file.  When a client wants to operate on a
file, it makes RPC requests via a file port to its server process, which
is commonly called a <EM>translator</EM>.




<H2><A NAME="SEC48" HREF="hurd_toc.html#TOC48">Translators</A></H2>

<P>
The Hurd filesystem allows you to set translators on any file or
directory that you own.  A <EM>translator</EM> is any Hurd server which
provides the basic filesystem interface.  Translated nodes are somewhat
like a cross between Unix symbolic links and mount points.


<P>
Whenever a program tries to access the contents of a translated node,
the filesystem server redirects the request to the appropriate
translator (starting it if necessary).  Then, the new translator
services the client's request.  The GNU C library makes this behaviour
seamless from the client's perspective, so that standard Unix programs
behave correctly under the Hurd.


<P>
Translators run with the privileges of the translated node's
<EM>owner</EM>, so they cannot be used to compromise the security of the
system.  This also means that <EM>any</EM> user can write their own
translators, and provide other users with arbitrary
filesystem-structured data, regardless of the data's actual source.
Other chapters in this manual describe existing translators, and how you
can modify them or write your own.


<P>
The standard Hurd filesystem servers are constantly evolving to provide
innovative features that users want.  Here are a few examples of
existing translators:



<UL>
<LI>

Disk-based filesystem formats, such as <CODE>ext2fs</CODE>, <CODE>ufs</CODE>, and
<CODE>isofs</CODE> (see section <A HREF="hurd_10.html#SEC101">Stored Filesystems</A>).

<LI>

Network filesystems, such as <CODE>nfs</CODE> and <CODE>ftpfs</CODE>
(see section <A HREF="hurd_12.html#SEC118">Distributed Filesystems</A>).

<LI>

Single files with dynamic content, such as FIXME: we need a good
example.

<LI>

Hurd servers which translate rendezvous filesystem nodes in standard
locations, so that other programs can easily find them and use
server-specific interfaces.  For example, <CODE>pflocal</CODE> implements the
filesystem interfaces, but it also provides a special Unix-domain socket
RPC interface (FIXME xref).  Programs can fetch a port to this
translator simply by calling <CODE>file_name_lookup</CODE> (FIXME xref) on
<TT>`/servers/socket/1'</TT><A NAME="DOCF7" HREF="hurd_foot.html#FOOT7">(7)</A>, then use Unix
socket-specific RPCs on that port, rather than adhering to the file
protocol.
</UL>

<P>
This section focuses on the generic programs that you need to understand
in order to use existing translators.  Many other parts of this manual
describe how you can write your own translators.




<H3><A NAME="SEC49" HREF="hurd_toc.html#TOC49">Invoking <CODE>settrans</CODE></A></H3>
<P>
<A NAME="IDX129"></A>


<P>
The <CODE>settrans</CODE> program allows you to set a translator on a file or
directory.  By default, the passive translator is set (see the
<SAMP>`--passive'</SAMP> option).


<P>
The <CODE>settrans</CODE> program has the following synopsis:



<PRE>
settrans [<VAR>option</VAR>]... <VAR>node</VAR> [<VAR>translator</VAR> <VAR>arg</VAR>...]
</PRE>

<P>
where <VAR>translator</VAR> is the absolute filename of the new translator
program.  Each <VAR>arg</VAR> is passed to <VAR>translator</VAR> when it starts.
If <VAR>translator</VAR> is not specified, then <CODE>settrans</CODE> clears the
existing translator rather than setting a new one.


<P>
<CODE>settrans</CODE> accepts the following options:


<DL COMPACT>

<DT><SAMP>`-a'</SAMP>
<DD>
<DT><SAMP>`--active'</SAMP>
<DD>
Set <VAR>node</VAR>'s active translator.  <EM>Active translators</EM> are
started immediately and are not persistent: if the system is rebooted
then they are lost.

<DT><SAMP>`-c'</SAMP>
<DD>
<DT><SAMP>`--create'</SAMP>
<DD>
Create <VAR>node</VAR> as a zero-length file if it doesn't already exist.

<DT><SAMP>`-L'</SAMP>
<DD>
<DT><SAMP>`--dereference'</SAMP>
<DD>
If <VAR>node</VAR> is already translated, stack the new translator on top of
it (rather than replacing the existing translator).

<DT><SAMP>`--help'</SAMP>
<DD>
Display a brief usage message, then exit.

<DT><SAMP>`-p'</SAMP>
<DD>
<DT><SAMP>`--passive'</SAMP>
<DD>
Set <VAR>node</VAR>'s passive translator.  <EM>Passive translators</EM> are only
activated by the underlying filesystem when clients try to use the
<VAR>node</VAR>, and they shut down automatically after they are no longer
active in order to conserve system resources.

Passive translators are stored on the underlying filesystem media, and
so they persist between system reboots.  Not all filesystems support
passive translators, due to limitations in their underlying media.
Consult the filesystem-specific documentation to see if they are
supported.

If you are setting the passive translator, and <VAR>node</VAR> already has an
active translator, then the following options apply:

<DL COMPACT>

<DT><SAMP>`-g'</SAMP>
<DD>
<DT><SAMP>`--goaway'</SAMP>
<DD>
Tell the active translator to go away.  In this case, the following
additional options apply:

<DL COMPACT>

<DT><SAMP>`-f'</SAMP>
<DD>
<DT><SAMP>`--force'</SAMP>
<DD>
If the active translator doesn't go away, then force it.

<DT><SAMP>`-S'</SAMP>
<DD>
<DT><SAMP>`--nosync'</SAMP>
<DD>
Don't flush its contents to disk before terminating.

<DT><SAMP>`-R'</SAMP>
<DD>
<DT><SAMP>`--recursive'</SAMP>
<DD>
Shut down all of the active translator's children, too.
</DL>

<DT><SAMP>`-k'</SAMP>
<DD>
<DT><SAMP>`--keep-active'</SAMP>
<DD>
Leave the existing active translator running.  The new translator will
not be started unless the active translator has stopped.
</DL>

<DT><SAMP>`-P'</SAMP>
<DD>
<DT><SAMP>`--pause'</SAMP>
<DD>
When starting an active translator, prompt and wait for a newline on
standard input before completing the startup handshake.  This is useful
when debugging a translator, as it gives you time to start the debugger.

<DT><SAMP>`-t <VAR>sec</VAR>'</SAMP>
<DD>
<DT><SAMP>`--timeout=<VAR>sec</VAR>'</SAMP>
<DD>
If the translator does not start up in <VAR>sec</VAR> seconds (the default is
60), then return an error; if <VAR>sec</VAR> is 0, then never timeout.

<DT><SAMP>`--version'</SAMP>
<DD>
Output program version information and exit.

<DT><SAMP>`-x'</SAMP>
<DD>
<DT><SAMP>`--exclusive'</SAMP>
<DD>
Only set the translator if there is none already.
</DL>

<P>
FIXME: finish


<H3><A NAME="SEC50" HREF="hurd_toc.html#TOC50">Invoking <CODE>showtrans</CODE></A></H3>


<H3><A NAME="SEC51" HREF="hurd_toc.html#TOC51">Invoking <CODE>mount</CODE></A></H3>


<H3><A NAME="SEC52" HREF="hurd_toc.html#TOC52">Invoking <CODE>fsysopts</CODE></A></H3>



<H2><A NAME="SEC53" HREF="hurd_toc.html#TOC53">Trivfs Library</A></H2>
<P>
<A NAME="IDX130"></A>
<A NAME="IDX131"></A>


<P>
Certain translators do not need to be very complex, because they
represent a single file rather than an entire directory hierarchy.  The
trivfs library, which is declared in <CODE>&#60;hurd/trivfs.h&#62;</CODE>, does most of
the work of implementing this kind of translator.  This library requires
the iohelp and ports libraries.




<H3><A NAME="SEC54" HREF="hurd_toc.html#TOC54">Trivfs Startup</A></H3>

<P>
In order to use the trivfs library, you will need to define the
appropriate callbacks (see section <A HREF="hurd_7.html#SEC55">Trivfs Callbacks</A>).  As with all Hurd
servers, your trivfs-based translator should first parse any
command-line options, in case the user is just asking for help.  Trivfs
uses argp (see section `Argp' in <CITE>The GNU C Library Reference Manual</CITE>)
for parsing command-line arguments.


<P>
Your translator should redefine the following functions and variables as
necessary, and then call <CODE>argp_parse</CODE> with the relevant arguments:


<P>
<DL>
<DT><U>Variable:</U> extern struct argp * <B>trivfs_runtime_argp</B>
<DD><A NAME="IDX132"></A>
If this is defined or set to an argp structure, it will be used by the
default <CODE>trivfs_set_options</CODE> to handle runtime options parsing.
Redefining this is the normal way to add option parsing to a trivfs
program.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>trivfs_set_options</B> <I>(struct trivfs_control *<VAR>fsys</VAR>, char *<VAR>argz</VAR>, size_t <VAR>argz_len</VAR>)</I>
<DD><A NAME="IDX133"></A>
Set runtime options for <VAR>fsys</VAR> to <VAR>argz</VAR> and <VAR>argz_len</VAR>.
The default definition for this routine simply uses
<VAR>trivfs_runtime_argp</VAR> (supplying <VAR>fsys</VAR> as the argp input
field).
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>trivfs_append_args</B> <I>(struct trivfs_control *<VAR>fsys</VAR>, char **<VAR>argz</VAR>, size_t *<VAR>argz_len</VAR>)</I>
<DD><A NAME="IDX134"></A>
Append to the malloced string <CODE>*<VAR>argz</VAR></CODE> of length
<CODE>*<VAR>argz_len</VAR></CODE> a NUL-separated list of the arguments to this
translator.
</DL>


<P>
After your translator parses its command-line arguments, it should fetch
its bootstrap port by using <CODE>task_get_bootstrap_port</CODE>.  If this
port is <CODE>MACH_PORT_NULL</CODE>, then your program wasn't started as a
translator.  Otherwise, you can use the bootstrap port to create a new
control structure (and advertise its port) with <CODE>trivfs_startup</CODE>:


<P>
<DL>
<DT><U>Function:</U> error_t <B>trivfs_startup</B> <I>(mach_port_t <VAR>bootstrap</VAR>, int <VAR>flags</VAR>, struct port_class *<VAR>control_class</VAR>, struct port_bucket *<VAR>control_bucket</VAR>, struct port_class *<VAR>protid_class</VAR>, struct port_bucket *<VAR>protid_bucket</VAR>, struct trivfs_control **<VAR>control</VAR>)</I>
<DD><A NAME="IDX135"></A>
<DT><U>Function:</U> error_t <B>trivfs_create_control</B> <I>(mach_port_t <VAR>bootstrap</VAR>, struct port_class *<VAR>control_class</VAR>, struct port_bucket *<VAR>control_bucket</VAR>, struct port_class *<VAR>protid_class</VAR>, struct port_bucket *<VAR>protid_bucket</VAR>, struct trivfs_control **<VAR>control</VAR>)</I>
<DD><A NAME="IDX136"></A>
<CODE>trivfs_startup</CODE> creates a new trivfs control port, advertises it
to the underlying node <VAR>bootstrap</VAR> with <CODE>fsys_startup</CODE>,
returning the results of this call, and places its control structure in
<CODE>*<VAR>control</VAR></CODE>.  <CODE>trivfs_create_control</CODE> does the same
thing, except it doesn't advertise the control port to the underlying
node.  <VAR>control_class</VAR> and <VAR>control_bucket</VAR> are passed to
<CODE>libports</CODE> to create the control port, and <VAR>protid_class</VAR> and
<VAR>protid_bucket</VAR> are used when creating ports representing opens of
this node; any of these may be zero, in which case an appropriate port
class/bucket is created.  If <VAR>control</VAR> is non-null, the trivfs
control port is returned in it.  <VAR>flags</VAR> (a bitmask of the
appropriate <CODE>O_*</CODE> constants) specifies how to open the underlying
node.
</DL>


<P>
If you did not supply zeros as the class and bucket arguments to
<CODE>trivfs_startup</CODE>, you will probably need to use the trivfs port
management functions (see section <A HREF="hurd_7.html#SEC57">Trivfs Ports</A>).


<P>
Once you have successfully called <CODE>trivfs_startup</CODE>, and have a
pointer to the control structure stored in, say, the <VAR>fsys</VAR>
variable, you are ready to call one of the
<CODE>ports_manage_port_operations_*</CODE> functions using
<CODE><VAR>fsys</VAR>-&#62;pi.bucket</CODE> and <CODE>trivfs_demuxer</CODE>.  This will
handle any incoming filesystem requests, invoking your callbacks when
necessary.


<P>
<DL>
<DT><U>Function:</U> int <B>trivfs_demuxer</B> <I>(mach_msg_header_t *<VAR>inp</VAR>, mach_msg_header_t *<VAR>outp</VAR>)</I>
<DD><A NAME="IDX137"></A>
Demultiplex incoming <CODE>libports</CODE> messages on trivfs ports.
</DL>


<P>
The following functions are not usually necessary, but they allow you to
use the trivfs library even when it is not possible to turn
message-handling over to <CODE>trivfs_demuxer</CODE> and <CODE>libports</CODE>:


<P>
<DL>
<DT><U>Function:</U> struct trivfs_control * <B>trivfs_begin_using_control</B> <I>(mach_port_t <VAR>port</VAR>)</I>
<DD><A NAME="IDX138"></A>
<DT><U>Function:</U> struct trivfs_protid * <B>trivfs_begin_using_protid</B> <I>(mach_port_t <VAR>port</VAR>)</I>
<DD><A NAME="IDX139"></A>
These functions can be used as <CODE>intran</CODE> functions for a MiG port
type to have the stubs called with either the control or protid pointer.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>trivfs_end_using_control</B> <I>(struct trivfs_control *<VAR>port</VAR>)</I>
<DD><A NAME="IDX140"></A>
<DT><U>Function:</U> void <B>trivfs_end_using_protid</B> <I>(struct trivfs_protid *<VAR>port</VAR>)</I>
<DD><A NAME="IDX141"></A>
These can be used as `destructor' functions for a MiG port type, to have
the stubs called with the control or protid pointer.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>trivfs_open</B> <I>(struct trivfs_control *<VAR>fsys</VAR>, struct iouser *<VAR>user</VAR>, unsigned <VAR>flags</VAR>, mach_port_t <VAR>realnode</VAR>, struct trivfs_protid **<VAR>cred</VAR>)</I>
<DD><A NAME="IDX142"></A>
Return a new protid (that is, a port representing an open of this node)
pointing to a new peropen in <VAR>cred</VAR>, with <VAR>realnode</VAR> as the
underlying node reference, with the given identity, and open flags in
<VAR>flags</VAR>.  <VAR>cntl</VAR> is the trivfs control object.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>trivfs_protid_dup</B> <I>(struct trivfs_protid *<VAR>cred</VAR>, struct trivfs_protid **<VAR>dup</VAR>)</I>
<DD><A NAME="IDX143"></A>
Return a duplicate of <VAR>cred</VAR> in <VAR>dup</VAR>, sharing the same peropen
and hook.  A non-null protid <VAR>hook</VAR> indicates that
<VAR>trivfs_peropen_create_hook</VAR> created this protid (see section <A HREF="hurd_7.html#SEC56">Trivfs Options</A>).
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>trivfs_set_atime</B> <I>(struct trivfs_control *<VAR>cntl</VAR>)</I>
<DD><A NAME="IDX144"></A>
<DT><U>Function:</U> error_t <B>trivfs_set_mtime</B> <I>(struct trivfs_control *<VAR>cntl</VAR>)</I>
<DD><A NAME="IDX145"></A>
Call these to set atime or mtime for the node to the current time.
</DL>




<H3><A NAME="SEC55" HREF="hurd_toc.html#TOC55">Trivfs Callbacks</A></H3>

<P>
Like several other Hurd libraries, <CODE>libtrivfs</CODE> requires that you
define a number of application-specific callback functions and
configuration variables.  You <EM>must</EM> define the following variables
and functions:


<P>
<DL>
<DT><U>Variable:</U> extern int <B>trivfs_fstype</B>
<DD><A NAME="IDX146"></A>
<DT><U>Variable:</U> extern int <B>trivfs_fsid</B>
<DD><A NAME="IDX147"></A>
These variables are returned in the <VAR>st_fstype</VAR> and <VAR>st_fsid</VAR>
fields of <CODE>struct stat</CODE>.  <VAR>trivfs_fstype</VAR> should be chosen
from the <CODE>FSTYPE_*</CODE> constants found in <CODE>&#60;hurd/hurd_types.h&#62;</CODE>.
</DL>


<P>
<DL>
<DT><U>Variable:</U> extern int <B>trivfs_allow_open</B>
<DD><A NAME="IDX148"></A>
Set this to some bitwise OR combination of <CODE>O_READ</CODE>,
<CODE>O_WRITE</CODE>, and <CODE>O_EXEC</CODE>; trivfs will only allow opens of the
specified modes.
</DL>


<P>
<DL>
<DT><U>Variable:</U> extern int <B>trivfs_support_read</B>
<DD><A NAME="IDX149"></A>
<DT><U>Variable:</U> extern int <B>trivfs_support_write</B>
<DD><A NAME="IDX150"></A>
<DT><U>Variable:</U> extern int <B>trivfs_support_exec</B>
<DD><A NAME="IDX151"></A>
Set these to nonzero if trivfs should allow read, write, or execute of
the file.  These variables are necessary because <VAR>trivfs_allow_open</VAR>
is used only to validate opens, not actual operations.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>trivfs_modify_stat</B> <I>(struct trivfs_protid *<VAR>cred</VAR>, struct stat *<VAR>stbuf</VAR>)</I>
<DD><A NAME="IDX152"></A>
This should modify a <CODE>struct stat</CODE> (as returned from the underlying
node) for presentation to callers of <CODE>io_stat</CODE>.  It is permissible
for this function to do nothing, but it must still be defined.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>trivfs_goaway</B> <I>(struct trivfs_control *<VAR>cntl</VAR>, int <VAR>flags</VAR>)</I>
<DD><A NAME="IDX153"></A>
This function is called when someone wants the filesystem <VAR>cntl</VAR> to
go away.  <VAR>flags</VAR> are from the set <CODE>FSYS_GOAWAY_*</CODE> found in
<CODE>&#60;hurd/hurd_types.h&#62;</CODE>.
</DL>




<H3><A NAME="SEC56" HREF="hurd_toc.html#TOC56">Trivfs Options</A></H3>

<P>
The functions and variables described in this subsection already have
default definitions in <CODE>libtrivfs</CODE>, so you are not forced to define
them; rather, they may be redefined on a case-by-case basis.


<P>
<DL>
<DT><U>Variable:</U> extern struct port_class * <B>trivfs_protid_portclasses[]</B>
<DD><A NAME="IDX154"></A>
<DT><U>Variable:</U> extern int <B>trivfs_protid_nportclasses</B>
<DD><A NAME="IDX155"></A>
<DT><U>Variable:</U> extern struct port_class * <B>trivfs_cntl_portclasses[]</B>
<DD><A NAME="IDX156"></A>
<DT><U>Variable:</U> extern int <B>trivfs_cntl_nportclasses</B>
<DD><A NAME="IDX157"></A>
If you define these, they should be vectors (and the associated sizes)
of port classes that will be translated into control and protid pointers
for passing to RPCs, in addition to those passed to or created by
<CODE>trivfs_create_control</CODE> (or <CODE>trivfs_startup</CODE>), which will
automatically be recognized.
</DL>


<P>
<DL>
<DT><U>Variable:</U> error_t (* <B>trivfs_check_open_hook</B> <I>) (struct trivfs_control *<VAR>cntl</VAR>, struct iouser *<VAR>user</VAR>, int <VAR>flags</VAR>)</I>
<DD><A NAME="IDX158"></A>
If this variable is non-zero, it will be called every time an open happens.
<VAR>user</VAR> and <VAR>flags</VAR> are from the open; <VAR>cntl</VAR> identifies the
node being opened.  This call need not check permissions on the
underlying node.  This call can block as necessary, unless
<CODE>O_NONBLOCK</CODE> is set in <VAR>flags</VAR>.  Any desired error can be
returned, which will be reflected to the user and will prevent the open from
succeeding.
</DL>


<P>
<DL>
<DT><U>Variable:</U> error_t (* <B>trivfs_protid_create_hook</B> <I>) (struct trivfs_protid *<VAR>prot</VAR>)</I>
<DD><A NAME="IDX159"></A>
<DT><U>Variable:</U> error_t (* <B>trivfs_peropen_create_hook</B> <I>) (struct trivfs_peropen *<VAR>perop</VAR>)</I>
<DD><A NAME="IDX160"></A>
If these variables are non-zero, they will be called every time a new protid or
peropen structure is created and initialized.
</DL>


<P>
<DL>
<DT><U>Variable:</U> void (* <B>trivfs_protid_destroy_hook</B> <I>) (struct trivfs_protid *<VAR>prot</VAR>)</I>
<DD><A NAME="IDX161"></A>
<DT><U>Variable:</U> void (* <B>trivfs_peropen_destroy_hook</B> <I>) (struct trivfs_peropen *<VAR>perop</VAR>)</I>
<DD><A NAME="IDX162"></A>
If these variables is non-zero, they will be called every time a protid or
peropen structure is about to be destroyed.
</DL>


<P>
<DL>
<DT><U>Variable:</U> error_t (* <B>trivfs_getroot_hook</B> <I>) (struct trivfs_control *<VAR>cntl</VAR>, mach_port_t <VAR>reply_port</VAR>, mach_msg_type_name_t <VAR>reply_port_type</VAR>, mach_port_t <VAR>dotdot</VAR>, uid_t *<VAR>uids</VAR>, u_int <VAR>nuids</VAR>, uid_t *<VAR>gids</VAR>, u_int <VAR>ngids</VAR>, int <VAR>flags</VAR>, retry_type *<VAR>do_retry</VAR>, char *<VAR>retry_name</VAR>, mach_port_t *<VAR>node</VAR>, mach_msg_type_name_t *<VAR>node_type</VAR>)</I>
<DD><A NAME="IDX163"></A>
If this variable is set, it will be called by <CODE>trivfs_S_fsys_getroot</CODE>
before any other processing takes place.  If the return value is
<CODE>EAGAIN</CODE>, normal trivfs getroot processing continues, otherwise the
RPC returns with that return value.
</DL>




<H3><A NAME="SEC57" HREF="hurd_toc.html#TOC57">Trivfs Ports</A></H3>

<P>
If you choose to allocate your own trivfs port classes and buckets, the
following functions may come in handy:


<P>
<DL>
<DT><U>Function:</U> error_t <B>trivfs_add_port_bucket</B> <I>(struct port_bucket **<VAR>bucket</VAR>)</I>
<DD><A NAME="IDX164"></A>
Add the port bucket <CODE>*<VAR>bucket</VAR></CODE> to the list of dynamically-
allocated port buckets; if <CODE>*<VAR>bucket</VAR></CODE> is zero, an attempt is
made to allocate a new port bucket, which is then stored in
<CODE>*<VAR>bucket</VAR></CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>trivfs_remove_port_bucket</B> <I>(struct port_bucket *<VAR>bucket</VAR>)</I>
<DD><A NAME="IDX165"></A>
Remove the previously added dynamic port bucket <VAR>bucket</VAR>, freeing it
if it was allocated by <CODE>trivfs_add_port_bucket</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>trivfs_add_control_port_class</B> <I>(struct port_class **<VAR>class</VAR>)</I>
<DD><A NAME="IDX166"></A>
<DT><U>Function:</U> error_t <B>trivfs_add_protid_port_class</B> <I>(struct port_class **<VAR>class</VAR>)</I>
<DD><A NAME="IDX167"></A>
Add the port class <CODE>*<VAR>class</VAR></CODE> to the list of control or protid port
classes recognized by trivfs; if <CODE>*<VAR>class</VAR></CODE> is zero, an attempt is
made to allocate a new port class, which is stored in <CODE>*<VAR>class</VAR></CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>trivfs_remove_control_port_class</B> <I>(struct port_class *<VAR>class</VAR>)</I>
<DD><A NAME="IDX168"></A>
<DT><U>Function:</U> void <B>trivfs_remove_protid_port_class</B> <I>(struct port_class *<VAR>class</VAR>)</I>
<DD><A NAME="IDX169"></A>
Remove the previously added dynamic control or protid port class
<VAR>class</VAR>, freeing it if it was allocated by
<CODE>trivfs_add_control_port_class</CODE> or
<CODE>trivfs_add_protid_port_class</CODE>.
</DL>


<P>
Even if you do not use the above allocation functions, you may still be
able to use the default trivfs cleanroutines:


<P>
<DL>
<DT><U>Function:</U> void <B>trivfs_clean_cntl</B> <I>(void *<VAR>port</VAR>)</I>
<DD><A NAME="IDX170"></A>
<DT><U>Function:</U> void <B>trivfs_clean_protid</B> <I>(void *<VAR>port</VAR>)</I>
<DD><A NAME="IDX171"></A>
These functions should be installed as <CODE>libports</CODE> cleanroutines for
control port classes and protid port classes, respectively.
</DL>




<H2><A NAME="SEC58" HREF="hurd_toc.html#TOC58">Fshelp Library</A></H2>
<P>
<A NAME="IDX172"></A>
<A NAME="IDX173"></A>


<P>
The fshelp library implements various things that are useful to most
implementors of the file protocol.  It presumes that you are using the
iohelp library as well.  <CODE>libfshelp</CODE> is divided into separate
facilities which may be used independently.  These functions are
declared in <CODE>&#60;hurd/fshelp.h&#62;</CODE>.




<H3><A NAME="SEC59" HREF="hurd_toc.html#TOC59">Passive Translator Linkage</A></H3>

<P>
These routines are self-contained and start passive translators,
returning the control port.  They do not require multithreading or the
ports library.


<P>
<DL>
<DT><U>Typedef:</U> typedef error_t (* <B>fshelp_open_fn_t</B> <I>) (int <VAR>flags</VAR>, file_t *<VAR>node</VAR>, mach_msg_type_name_t *<VAR>node_type</VAR>)</I>
<DD><A NAME="IDX174"></A>
A callback used by the translator starting functions.
Given some open flags, opens the appropriate file, and
returns the node port.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>fshelp_start_translator_long</B> <I>(fshelp_open_fn_t <VAR>underlying_open_fn</VAR>, char *<VAR>name</VAR>, char *<VAR>argz</VAR>, int <VAR>argz_len</VAR>, mach_port_t *<VAR>fds</VAR>, mach_msg_type_name_t <VAR>fds_type</VAR>, int <VAR>fds_len</VAR>, mach_port_t *<VAR>ports</VAR>, mach_msg_type_name_t <VAR>ports_type</VAR>, int <VAR>ports_len</VAR>, int *<VAR>ints</VAR>, int <VAR>ints_len</VAR>, int <VAR>timeout</VAR>, fsys_t *<VAR>control</VAR>)</I>
<DD><A NAME="IDX175"></A>
Start a passive translator <VAR>name</VAR> with arguments <VAR>argz</VAR> (length
<VAR>argz_len</VAR>).  Initialize the initports to <VAR>ports</VAR> (length
<VAR>ports_len</VAR>), the initints to <VAR>ints</VAR> (length <VAR>ints_len</VAR>),
and the file descriptor table to <VAR>fds</VAR> (length <VAR>fds_len</VAR>).
Return the control port in <CODE>*<VAR>control</VAR></CODE>.  If the translator doesn't
respond or die in <VAR>timeout</VAR> milliseconds (if <VAR>timeout</VAR> is
greater than zero), return an appropriate error.  If the translator dies
before responding, return <CODE>EDIED</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>fshelp_start_translator</B> <I>(fshelp_open_fn_t <VAR>underlying_open_fn</VAR>, char *<VAR>name</VAR>, char *<VAR>argz</VAR>, int <VAR>argz_len</VAR>, int <VAR>timeout</VAR>, fsys_t *<VAR>control</VAR>)</I>
<DD><A NAME="IDX176"></A>
Same as <CODE>fshelp_start_translator_long</CODE>, except the initports and
ints are copied from our own state, <VAR>fd[2]</VAR> is copied from our own
stderr, and the other fds are cleared.  For full-service filesystems, it
is almost always wrong to use <CODE>fshelp_start_translator</CODE>, because
the current working directory of the translator will not then be as
normally expected.  (Current working directories of passive translators
should be the directory they were found in.)  In fact, full-service
filesystems should usually start passive translators as a side-effect of
calling <CODE>fshelp_fetch_root</CODE> (see section <A HREF="hurd_7.html#SEC60">Active Translator Linkage</A>).
</DL>




<H3><A NAME="SEC60" HREF="hurd_toc.html#TOC60">Active Translator Linkage</A></H3>

<P>
These routines implement the linkage to active translators needed
by any filesystem which supports them.  They require the threads
library and use the passive translator routines above, but they don't
require the ports library at all.


<P>
This interface is complex, because creating the ports and state
necessary for <CODE>start_translator_long</CODE> is expensive.  The caller to
<CODE>fshelp_fetch_root</CODE> should not need to create them on every call,
since usually there will be an existing active translator.


<P>
<DL>
<DT><U>Function:</U> void <B>fshelp_transbox_init</B> <I>(struct transbox *<VAR>transbox</VAR>, struct mutex *<VAR>lock</VAR>, void *<VAR>cookie</VAR>)</I>
<DD><A NAME="IDX177"></A>
Initialize a transbox, which contains state information for active
translators.
</DL>


<P>
<DL>
<DT><U>Typedef:</U> typedef error_t (* <B>fshelp_fetch_root_callback1_t</B> <I>) (void *<VAR>cookie1</VAR>, void *<VAR>cookie2</VAR>, uid_t *<VAR>uid</VAR>, gid_t *<VAR>gid</VAR>, char **<VAR>argz</VAR>, size_t *<VAR>argz_len</VAR>)</I>
<DD><A NAME="IDX178"></A>
This routine is called by <CODE>fshelp_fetch_root</CODE> to fetch more
information.  Return the owner and group of the underlying translated
file in <CODE>*<VAR>uid</VAR></CODE> and <CODE>*<VAR>gid</VAR></CODE>; point
<CODE>*<VAR>argz</VAR></CODE> at the entire passive translator specification for
the file (setting <CODE>*<VAR>argz_len</VAR></CODE> to the length).  If there is no
passive translator, then return <CODE>ENOENT</CODE>.  <VAR>cookie1</VAR> is the
cookie passed in <CODE>fshelp_transbox_init</CODE>.  <VAR>cookie2</VAR> is the
cookie passed in the call to <CODE>fshelp_fetch_root</CODE>.
</DL>


<P>
<DL>
<DT><U>Typedef:</U> typedef error_t (* <B>fshelp_fetch_root_callback2_t</B> <I>) (void *<VAR>cookie1</VAR>, void *<VAR>cookie2</VAR>, int <VAR>flags</VAR>, mach_port_t *<VAR>underlying</VAR>, mach_msg_type_name_t *<VAR>underlying_type</VAR>)</I>
<DD><A NAME="IDX179"></A>
This routine is called by <CODE>fshelp_fetch_root</CODE> to fetch more
information.  Return an unauthenticated node for the file itself in
<CODE>*<VAR>underlying</VAR></CODE> and <CODE>*<VAR>underlying_type</VAR></CODE> (opened with
<VAR>flags</VAR>).  <VAR>cookie1</VAR> is the cookie passed in
<CODE>fshelp_transbox_init</CODE>.  <VAR>cookie2</VAR> is the cookie passed in the
call to <CODE>fshelp_fetch_root</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>fshelp_fetch_root</B> <I>(struct transbox *<VAR>transbox</VAR>, void *<VAR>cookie</VAR>, file_t <VAR>dotdot</VAR>, struct iouser *<VAR>user</VAR>, int <VAR>flags</VAR>, fshelp_fetch_root_callback1_t <VAR>callback1</VAR>, fshelp_fetch_root_callback2_t <VAR>callback2</VAR>, retry_type *<VAR>retry</VAR>, char *<VAR>retryname</VAR>, mach_port_t *<VAR>root</VAR>)</I>
<DD><A NAME="IDX180"></A>
Fetch the root from <VAR>transbox</VAR>.  <VAR>dotdot</VAR> is an unauthenticated
port for the directory in which we are looking; <VAR>user</VAR> specifies the
ids of the user responsible for the call.  <VAR>flags</VAR> are as for
<CODE>dir_pathtrans</CODE> (but <CODE>O_CREAT</CODE> and <CODE>O_EXCL</CODE> are not
meaningful and are ignored).  The transbox lock (as set by
<CODE>fshelp_transbox_init</CODE>) must be held before the call, and will be
held upon return, but may be released during the operation of the call.
</DL>


<P>
<DL>
<DT><U>Function:</U> int <B>fshelp_translated</B> <I>(struct transbox *<VAR>box</VAR>)</I>
<DD><A NAME="IDX181"></A>
Return true if and only if there is an active translator on this box.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>fshelp_set_active</B> <I>(struct transbox *<VAR>box</VAR>, fsys_t <VAR>newactive</VAR>, int <VAR>excl</VAR>)</I>
<DD><A NAME="IDX182"></A>
Atomically replace the existing active translator port for this box with
<VAR>newactive</VAR>.  If <VAR>excl</VAR> is non-zero then don't modify an
existing active transbox; return <CODE>EBUSY</CODE> instead.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>fshelp_fetch_control</B> <I>(struct transbox *<VAR>box</VAR>, mach_port_t *<VAR>control</VAR>)</I>
<DD><A NAME="IDX183"></A>
Fetch the control port to make a request on it.  It's a bad idea to use
<CODE>fsys_getroot</CODE> with the result; use <CODE>fshelp_fetch_root</CODE>
instead.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>fshelp_drop_transbox</B> <I>(struct transbox *<VAR>box</VAR>)</I>
<DD><A NAME="IDX184"></A>
Clean transbox state so that deallocation or reuse is possible.
</DL>




<H3><A NAME="SEC61" HREF="hurd_toc.html#TOC61">Fshelp Locking</A></H3>

<P>
The <CODE>flock</CODE> call is in flux, as the current Hurd interface (as of
version 0.2) is not suitable for implementing the POSIX
record-locking semantics.




<H3><A NAME="SEC62" HREF="hurd_toc.html#TOC62">Fshelp Permissions</A></H3>

<P>
These functions are designed to aid with user permission checking.  It
is a good idea to use these routines rather than to roll your own, so
that Hurd users see consistent handling of file and directory permission
bits.


<P>
<DL>
<DT><U>Function:</U> error_t <B>fshelp_isowner</B> <I>(struct stat *<VAR>st</VAR>, struct iouser *<VAR>user</VAR>)</I>
<DD><A NAME="IDX185"></A>
Check to see whether <VAR>user</VAR> should be considered the owner of the
file identified by <VAR>st</VAR>.  If so, return zero; otherwise return an
appropriate error code.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>fshelp_access</B> <I>(struct stat *<VAR>st</VAR>, int <VAR>op</VAR>, struct iouser *<VAR>user</VAR>)</I>
<DD><A NAME="IDX186"></A>
Check to see whether the user <VAR>user</VAR> can operate on the file
identified by <VAR>st</VAR>.  <VAR>op</VAR> is one of <CODE>S_IREAD</CODE>,
<CODE>S_IWRITE</CODE>, and <CODE>S_IEXEC</CODE>.  If the access is permitted, return
zero; otherwise return an appropriate error code.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>fshelp_checkdirmod</B> <I>(struct stat *<VAR>dir</VAR>, struct stat *<VAR>st</VAR>, struct iouser *<VAR>user</VAR>)</I>
<DD><A NAME="IDX187"></A>
Check to see whether <VAR>user</VAR> is allowed to modify <VAR>dir</VAR> with respect to
existing file <VAR>st</VAR>.  If there is no existing file, then <VAR>st</VAR>
should be set to zero.  If the access is permissible, return zero;
otherwise return an appropriate error code.
</DL>




<H3><A NAME="SEC63" HREF="hurd_toc.html#TOC63">Fshelp Misc</A></H3>

<P>
The following functions are completely standalone:


<P>
<DL>
<DT><U>Function:</U> error_t <B>fshelp_delegate_translation</B> <I>(char *<VAR>server_name</VAR>, mach_port_t <VAR>requestor</VAR>, char **<VAR>argv</VAR>)</I>
<DD><A NAME="IDX188"></A>
Try to hand off responsibility from a translator to the server located
on the node <VAR>server_name</VAR>.  <VAR>requestor</VAR> is the translator's
bootstrap port, and <VAR>argv</VAR> is the command line.  If
<VAR>server_name</VAR> is null, then a name is concocted by prepending
<CODE>_servers</CODE> to <CODE>argv[0]</CODE> .
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>fshelp_exec_reauth</B> <I>(int <VAR>suid</VAR>, uid_t <VAR>uid</VAR>, int <VAR>sgid</VAR>, gid_t <VAR>gid</VAR>, auth_t <VAR>auth</VAR>, error_t (*<VAR>get_file_ids</VAR>) (struct idvec *<VAR>uids</VAR>, struct idvec *<VAR>gids</VAR>), mach_port_t *<VAR>ports</VAR>, mach_msg_type_number_t <VAR>num_ports</VAR>, mach_port_t *<VAR>fds</VAR>, mach_msg_type_number_t <VAR>num_fds</VAR>, int *<VAR>secure</VAR>)</I>
<DD><A NAME="IDX189"></A>
If <VAR>suid</VAR> or <VAR>sgid</VAR> is true, adds <VAR>uid</VAR> and/or <VAR>gid</VAR>
respectively to the authentication in
<CODE><VAR>ports</VAR>[INIT_PORT_AUTH]</CODE>, and replaces it with the result.
All the other ports in <VAR>ports</VAR> and <VAR>fds</VAR> are then
reauthenticated, using any privileges available through <VAR>auth</VAR>.  If
the auth port in <CODE><VAR>ports</VAR>[INIT_PORT_AUTH]</CODE> is bogus, and
<VAR>get_file_ids</VAR> is non-null, it is called to get a list
of uids and gids from the file to use as a replacement.  If <VAR>secure</VAR>
is non-null and any added ids are new, then the variable it points to is
set to nonzero, otherwise zero.  If either the uid or gid case fails,
then the other may still apply.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>fshelp_get_identity</B> <I>(struct port_bucket *<VAR>bucket</VAR>, ino_t <VAR>fileno</VAR>, mach_port_t *<VAR>pt</VAR>)</I>
<DD><A NAME="IDX190"></A>
Return an identity port in <CODE>*<VAR>pt</VAR></CODE> for the node numbered
<VAR>fileno</VAR>, suitable for returning from <CODE>io_identity</CODE>; exactly
one send right must be created from the returned value.  <VAR>fileno</VAR>
should be the same value returned as the <VAR>fileno</VAR> out-parameter in
<CODE>io_identity</CODE>, and in the enclosing directory (except for mount
points), and in the <CODE>st_ino</CODE> stat field.  <VAR>bucket</VAR> should be a
<CODE>libports</CODE> port bucket; fshelp requires the caller to make sure
port operations (for no-senders notifications) are used.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>fshelp_return_malloced_buffer</B> <I>(char *<VAR>buf</VAR>, size_t <VAR>len</VAR>, char **<VAR>rbuf</VAR>, mach_msg_type_number_t *<VAR>rlen</VAR>)</I>
<DD><A NAME="IDX191"></A>
Put data from the malloced buffer <VAR>buf</VAR>, <VAR>len</VAR> bytes long, into
<VAR>rbuf</VAR> (which is <VAR>rlen</VAR> bytes long), suitable for returning from
an RPC.  If <VAR>len</VAR> is greater than zero, <VAR>buf</VAR> is freed,
regardless of whether an error is returned or not.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>fshelp_set_options</B> <I>(struct argp *<VAR>argp</VAR>, int <VAR>flags</VAR>, char *<VAR>argz</VAR>, size_t <VAR>argz_len</VAR>, void *<VAR>input</VAR>)</I>
<DD><A NAME="IDX192"></A>
Invoke <CODE>argp_parse</CODE> in the standard way, with data from <VAR>argz</VAR>
and <VAR>argz_len</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>fshelp_touch</B> <I>(struct stat *<VAR>st</VAR>, unsigned <VAR>what</VAR>, volatile struct mapped_time_value *<VAR>maptime</VAR>)</I>
<DD><A NAME="IDX193"></A>
Change the stat times of <VAR>node</VAR> as indicated by <VAR>what</VAR> to
the current time.  <VAR>what</VAR> is a bitmask of one or more of
the <CODE>TOUCH_ATIME</CODE>, <CODE>TOUCH_MTIME</CODE>, and <CODE>TOUCH_CTIME</CODE>
constants.
</DL>




<H2><A NAME="SEC64" HREF="hurd_toc.html#TOC64">File Interface</A></H2>
<P>
<A NAME="IDX194"></A>


<P>
This section documents the interface for operating on files.




<H3><A NAME="SEC65" HREF="hurd_toc.html#TOC65">File Overview</A></H3>

<P>
The file interface is a superset of the I/O interface (see section <A HREF="hurd_6.html#SEC40">I/O Interface</A>).  Servers which provide the file interface are required to
support the I/O interface as well.  All objects reachable in the
filesystem are expected to provide the file interface, even if they do
not contain data.  (The <CODE>trivfs</CODE> library makes it easy to do so for
ordinary sorts of cases.  See section <A HREF="hurd_7.html#SEC53">Trivfs Library</A>.)


<P>
The interface definitions for the file interface are found in
<CODE>&#60;hurd/fs.defs&#62;</CODE>.


<P>
Files have various pieces of status information which are returned by
<CODE>io_stat</CODE> (see section <A HREF="hurd_6.html#SEC45">Information Queries</A>).  Most of this status
information can be directly changed by various calls in the file
interface; some of it should vary implicitly as the contents of the file
change.


<P>
Many of these calls have general rules associated with them describing
how security and privilege should operate.  The <CODE>diskfs</CODE> library
(see section <A HREF="hurd_10.html#SEC106">Diskfs Library</A>) implements these rules for stored filesystems.
These rules have also been implemented in the fshelp library
(see section <A HREF="hurd_7.html#SEC58">Fshelp Library</A>).  Trivfs-based servers generally have no need
to implement these rules at all.


<P>
In special cases, there may be a reason to implement a different
security check from that specified here, or to implement a call to do
something slightly different.  But such cases must be carefully
considered; make sure that you will not confuse innocent user programs
through excessive cleverness.


<P>
If some operation cannot be implemented (for example, <CODE>chauthor</CODE>
over FTP), then the call should return <CODE>EOPNOTSUPP</CODE>.  If it is
merely difficult to implement a call, it is much better to figure out a
way to implement it as a series of operations rather than to return
errors to the user.




<H3><A NAME="SEC66" HREF="hurd_toc.html#TOC66">Changing Status</A></H3>

<P>
There are several RPCs available for users to change much of the status
information associated with a file.  (The information is returned by the
<CODE>io_stat</CODE> RPC; see section <A HREF="hurd_6.html#SEC45">Information Queries</A>.)


<P>
All these operations are restricted to root and the owner of the file.
When attempted by another user, they should return <CODE>EPERM</CODE>.


<P>
<A NAME="IDX195"></A>
The <CODE>file_chown</CODE> RPC changes the owner and group of the file.  Only
root should be able to change the owner, and changing the group to a
group the caller is not in should also be prohibited.  Violating either
of these conditions should return <CODE>EPERM</CODE>.


<P>
<A NAME="IDX196"></A>
The <CODE>file_chauthor</CODE> RPC changes the author of the file.  It should
be legitimate to change the author to any value without restriction.


<P>
<A NAME="IDX197"></A>
The <CODE>file_chmod</CODE> RPC changes the file permission mode bits.


<P>
<A NAME="IDX198"></A>
The <CODE>file_chflags</CODE> RPC changes the flags of the file.  It should be
legitimate to change the flags to any value without restriction.  No
standard meanings have been assigned to the flags yet, but we intend to
do so.  Do not assume that the flags format we choose will map
identically to that of some existing filesystem format.


<P>
<A NAME="IDX199"></A>
The <CODE>file_utimes</CODE> RPC changes the <VAR>atime</VAR> and <VAR>mtime</VAR> of
the file.  Making this call must cause the <VAR>ctime</VAR> to be updated as
well, even if no actual change to either the <VAR>mtime</VAR> or the
<VAR>atime</VAR> occurs.


<P>
<A NAME="IDX200"></A>
The <CODE>file_set_size</CODE> RPC is special; not only does it change the
status word specifying the size of the file, but it also changes the
actual contents of the file.  If the file size is being reduced it
should release secondary storage associated with the previous contents
of the file.  If the file is being extended, the new region added to the
file must be zero-filled.  Unlike the other RPCs in this section,
<CODE>file_set_size</CODE> should be permitted to any user who is allowed to
write the file.




<H3><A NAME="SEC67" HREF="hurd_toc.html#TOC67">Program Execution</A></H3>

<P>
<A NAME="IDX201"></A>
Execution of programs on the Hurd is done through fileservers with the
<CODE>file_exec</CODE> RPC.  The fileserver is expected to verify that the
user is allowed to execute the file, make whatever modifications to the
ports are necessary for setuid execution, and then invoke the standard
execserver found on <TT>`/servers/exec'</TT>.


<P>
This section specifically addresses what fileservers are expected to do,
with minimal attention to the other parts of the process.  See section <A HREF="hurd_15.html#SEC134">Running Programs</A>, for more general information.


<P>
The file must be opened for execution; if it is not, <CODE>EBADF</CODE> should
be returned.  In addition, at least one of the execute bits must be on.  A
failure of this check should result in <CODE>EACCES</CODE>---not
<CODE>ENOEXEC</CODE>.  It is not proper for the fileserver ever to respond to
the <CODE>file_exec</CODE> RPC with <CODE>ENOEXEC</CODE>.


<P>
If either the setuid or setgid bits are set, the server needs to
construct a new authentication handle with the additional new ID's.
Then all the ports passed to <CODE>file_exec</CODE> need to be reauthenticated
with the new handle.  If the fileserver is unable to make the new
authentication handle (for example, because it is not running as root)
it is not acceptable to return an error; in such a case the server
should simply silently fail to implement the setuid/setgid semantics.


<P>
If the setuid/setgid transformation adds a new uid or gid to the user's
authentication handle that was not previously present (as opposed to
merely reordering them), then the <CODE>EXEC_SECURE</CODE> and
<CODE>EXEC_NEWTASK</CODE> flags should both be added in the call to
<CODE>exec_exec</CODE>.


<P>
The server then needs to open a new port onto the executed file which
will not share any file pointers with the port the user passed in,
opened with <CODE>O_READ</CODE>.  Finally, all the information (mutated
appropriately for setuid/setgid) should be sent to the execserver with
<CODE>exec_exec</CODE>.  Whatever error code <CODE>exec_exec</CODE> returns should
returned to the caller of <CODE>file_exec</CODE>.




<H3><A NAME="SEC68" HREF="hurd_toc.html#TOC68">File Locking</A></H3>

<P>
The <CODE>flock</CODE> call is in flux, as the current Hurd interface (as of
version 0.2) is not suitable for implementing the POSIX
record-locking semantics.


<P>
<A NAME="IDX202"></A>
<A NAME="IDX203"></A>
You should ignore the <CODE>file_lock</CODE> and <CODE>file_lock_stat</CODE> calls
until the new record-locking interface is implemented.




<H3><A NAME="SEC69" HREF="hurd_toc.html#TOC69">File Frobbing</A></H3>

<P>
FIXME: Other active calls on files


<P>
<CODE>file_sync</CODE>


<P>
<CODE>file_getfh</CODE>


<P>
<CODE>file_getlinknode</CODE>


<P>
<CODE>file_check_access</CODE>


<P>
These manipulate meta-information:


<P>
<CODE>file_reparent</CODE>


<P>
<CODE>file_statfs</CODE>


<P>
<CODE>file_syncfs</CODE>


<P>
<CODE>file_getcontrol</CODE>


<P>
<CODE>file_get_storage_info</CODE>


<P>
<CODE>file_get_fs_options</CODE>




<H3><A NAME="SEC70" HREF="hurd_toc.html#TOC70">Opening Files</A></H3>

<P>
FIXME: Looking up files in directories


<P>
<CODE>dir_lookup</CODE>


<P>
<CODE>dir_readdir</CODE>




<H3><A NAME="SEC71" HREF="hurd_toc.html#TOC71">Modifying Directories</A></H3>

<P>
FIXME: Creating and deleting nodes


<P>
<CODE>dir_mkfile</CODE>


<P>
<CODE>dir_mkdir</CODE>


<P>
<CODE>dir_rmdir</CODE>


<P>
<CODE>dir_unlink</CODE>


<P>
<CODE>dir_link</CODE>


<P>
<CODE>dir_rename</CODE>




<H3><A NAME="SEC72" HREF="hurd_toc.html#TOC72">Notifications</A></H3>

<P>
FIXME: File and directory change callbacks


<P>
File change notifications are not yet implemented, but directory
notifications are.


<P>
<CODE>file_notice_changes</CODE>


<P>
<CODE>dir_notice_changes</CODE>




<H3><A NAME="SEC73" HREF="hurd_toc.html#TOC73">File Translators</A></H3>

<P>
FIXME: How to set and get translators


<P>
<CODE>file_set_translator</CODE>


<P>
<CODE>file_get_translator</CODE>


<P>
<CODE>file_get_translator_cntl</CODE>




<H2><A NAME="SEC74" HREF="hurd_toc.html#TOC74">Filesystem Interface</A></H2>
<P>
<A NAME="IDX204"></A>


<P>
The filesystem interface (described in <CODE>&#60;hurd/fsys.defs&#62;</CODE>) is
supported by translator control ports.


<P>
FIXME: finish


<P><HR><P>
Go to the <A HREF="hurd_1.html">first</A>, <A HREF="hurd_6.html">previous</A>, <A HREF="hurd_8.html">next</A>, <A HREF="hurd_17.html">last</A> section, <A HREF="hurd_toc.html">table of contents</A>.
</BODY>
</HTML>

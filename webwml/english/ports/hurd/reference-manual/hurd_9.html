<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from hurd.texi on 29 June 1999 -->

<TITLE>Hurd Reference Manual - Stores</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="hurd_1.html">first</A>, <A HREF="hurd_8.html">previous</A>, <A HREF="hurd_10.html">next</A>, <A HREF="hurd_17.html">last</A> section, <A HREF="hurd_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC80" HREF="hurd_toc.html#TOC80">Stores</A></H1>

<P>
A <EM>store</EM> is a fixed-size block of storage, which can be read and
perhaps written to.  A store is more general than a file: it refers to
any type of storage such as devices, files, memory, tasks, etc.  Stores
can also be representations of other stores, which may be combined and
filtered in various ways.




<H2><A NAME="SEC81" HREF="hurd_toc.html#TOC81">storeinfo, storecat, storeread</A></H2>


<H2><A NAME="SEC82" HREF="hurd_toc.html#TOC82">storeio</A></H2>

<P>
FIXME: finish




<H2><A NAME="SEC83" HREF="hurd_toc.html#TOC83">Store Library</A></H2>
<P>
<A NAME="IDX205"></A>
<A NAME="IDX206"></A>


<P>
The store library (which is declared in <CODE>&#60;hurd/store.h&#62;</CODE>)
implements many different backends which support the store abstraction.
Hurd programs use <CODE>libstore</CODE> so that new storage types can be
implemented with minimum impact.




<H3><A NAME="SEC84" HREF="hurd_toc.html#TOC84">Store Arguments</A></H3>

<P>
FIXME: describe startup sequence


<P>
<DL>
<DT><U>Structure:</U> struct <B>store_parsed</B>
<DD><A NAME="IDX207"></A>
The result of parsing a store, which should be enough information to
open it, or return the arguments.
</DL>


<P>
<DL>
<DT><U>Structure:</U> struct <B>store_argp_params</B> <I>{ struct store_parsed *<VAR>result</VAR>; const char *<VAR>default_type</VAR>; const struct store_class *const *<VAR>classes</VAR>; }</I>
<DD><A NAME="IDX208"></A>
This is the structure used to pass args back and forth from
<VAR>store_argp</VAR>.  <VAR>result</VAR> is the resulting parsed result.  If
<SAMP>`--store-type'</SAMP> isn't specified, then <VAR>default_type</VAR> should be
used as the store type; zero is equivalent to <CODE>"query"</CODE>.
<VAR>classes</VAR> is set of classes used to validate store types and
argument syntax.
</DL>


<P>
<DL>
<DT><U>Variable:</U> extern struct argp <B>store_argp</B>
<DD><A NAME="IDX209"></A>
This is an argument parser that may be used for parsing a simple command
line specification for stores.  The accompanying input parameter must be
a pointer to a <CODE>struct store_argp_params</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>store_parsed_free</B> <I>(struct store_parsed *<VAR>parsed</VAR>)</I>
<DD><A NAME="IDX210"></A>
Free all resources used by <VAR>parsed</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_parsed_open</B> <I>(const struct store_parsed *<VAR>parsed</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX211"></A>
Open the store specified by <VAR>parsed</VAR>, and return it in <VAR>store</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_parsed_append_args</B> <I>(const struct store_parsed *<VAR>parsed</VAR>, char **<VAR>argz</VAR>, size_t *<VAR>argz_len</VAR>)</I>
<DD><A NAME="IDX212"></A>
Add the arguments used to create <VAR>parsed</VAR> to <VAR>argz</VAR> and
<VAR>argz_len</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_parsed_name</B> <I>(const struct store_parsed *<VAR>parsed</VAR>, char **<VAR>name</VAR>)</I>
<DD><A NAME="IDX213"></A>
Make an option string describing <VAR>parsed</VAR>, and return it in malloced
storage in <VAR>name</VAR>.
</DL>




<H3><A NAME="SEC85" HREF="hurd_toc.html#TOC85">Store Management</A></H3>

<P>
The following functions provide basic management of stores:


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_create</B> <I>(file_t <VAR>source</VAR>, int <VAR>flags</VAR>, const struct store_class *const *<VAR>classes</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX214"></A>
Return a new store in <VAR>store</VAR>, which refers to the storage
underlying <VAR>source</VAR>.  <VAR>classes</VAR> is used to select classes
specified by the provider; if zero, <VAR>store_std_classes</VAR> is used.
<VAR>flags</VAR> is set with <CODE>store_set_flags</CODE>, with the exception of
<CODE>STORE_INACTIVE</CODE>, which merely indicates that no attempt should be
made to activate an inactive store; if <CODE>STORE_INACTIVE</CODE> is not
specified, and the store returned for SOURCE is inactive, an attempt is
made to activate it (failure of which causes an error to be returned).
A reference to <VAR>source</VAR> is created (but may be destroyed with
<CODE>store_close_source</CODE>).


<P>
It is usually better to use a specific store open or create function
such as <CODE>store_open</CODE> (see section <A HREF="hurd_9.html#SEC87">Store Classes</A>), since they are
tailored to the needs of a specific store.  Generally, you should only
use <CODE>store_create</CODE> if you are defining your own store class, or you
need options that are not provided by a more specific store creation
function.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>store_close_source</B> <I>(struct store *<VAR>store</VAR>)</I>
<DD><A NAME="IDX215"></A>
If <VAR>store</VAR> was created using <CODE>store_create</CODE>, remove the
reference to the source from which it was created.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>store_free</B> <I>(struct store *<VAR>store</VAR>)</I>
<DD><A NAME="IDX216"></A>
Clean up and deallocate <VAR>store</VAR>'s underlying stores.
</DL>


<P>
<DL>
<DT><U>Structure:</U> struct <B>store_run</B> <I>{ off_t <VAR>start</VAR>, <VAR>length</VAR>; }</I>
<DD><A NAME="IDX217"></A>
A <CODE>struct store_run</CODE> represents a contiguous region in a store's
address range.  These are used to designate active portions of a store.
If <VAR>start</VAR> is -1, then the region is a <EM>hole</EM> (it is zero-filled
and doesn't correspond to any real addresses).
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_set_runs</B> <I>(struct store *<VAR>store</VAR>, const struct store_run *<VAR>runs</VAR>, size_t <VAR>num_runs</VAR>)</I>
<DD><A NAME="IDX218"></A>
Set <VAR>store</VAR>'s current runs list to (a copy of) <VAR>runs</VAR> and
<VAR>num_runs</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_set_children</B> <I>(struct store *<VAR>store</VAR>, struct store *const *<VAR>children</VAR>, size_t <VAR>num_children</VAR>)</I>
<DD><A NAME="IDX219"></A>
Set <VAR>store</VAR>'s current children to (a copy of) <VAR>children</VAR> and
<VAR>num_children</VAR> (note that just the vector <VAR>children</VAR> is copied,
not the actual children).
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_children_name</B> <I>(const struct store *<VAR>store</VAR>, char **<VAR>name</VAR>)</I>
<DD><A NAME="IDX220"></A>
Try to come up with a name for the children in <VAR>store</VAR>, combining
the names of each child in a way that could be used to parse them with
<CODE>store_open_children</CODE>.  This is done heuristically, and so may not
succeed.  If a child doesn't have a name, <CODE>EINVAL</CODE> is returned.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_set_name</B> <I>(struct store *<VAR>store</VAR>, const char *<VAR>name</VAR>)</I>
<DD><A NAME="IDX221"></A>
Sets the name associated with <VAR>store</VAR> to a copy of <VAR>name</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_set_flags</B> <I>(struct store *<VAR>store</VAR>, int <VAR>flags</VAR>)</I>
<DD><A NAME="IDX222"></A>
Add <VAR>flags</VAR> to <VAR>store</VAR>'s currently set flags.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_clear_flags</B> <I>(struct store *<VAR>store</VAR>, int <VAR>flags</VAR>)</I>
<DD><A NAME="IDX223"></A>
Remove <VAR>flags</VAR> from <VAR>store</VAR>'s currently set flags.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_set_child_flags</B> <I>(struct store *<VAR>store</VAR>, int <VAR>flags</VAR>)</I>
<DD><A NAME="IDX224"></A>
Set <VAR>flags</VAR> in all children of <VAR>store</VAR>, and if successful, add
<VAR>flags</VAR> to <VAR>store</VAR>'s flags.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_clear_child_flags</B> <I>(struct store *<VAR>store</VAR>, int <VAR>flags</VAR>)</I>
<DD><A NAME="IDX225"></A>
Clear <VAR>flags</VAR> in all children of <VAR>store</VAR>, and if successful,
remove <VAR>flags</VAR> from <VAR>store</VAR>'s flags.
</DL>


<P>
<DL>
<DT><U>Function:</U> int <B>store_is_securely_returnable</B> <I>(struct store *<VAR>store</VAR>, int <VAR>open_flags</VAR>)</I>
<DD><A NAME="IDX226"></A>
Returns true if <VAR>store</VAR> can safely be returned to a user who has
accessed it via a node using <VAR>open_flags</VAR>, without compromising
security.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_clone</B> <I>(struct store *<VAR>from</VAR>, struct store **<VAR>to</VAR>)</I>
<DD><A NAME="IDX227"></A>
Return a copy of <VAR>from</VAR> in <VAR>to</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_remap</B> <I>(struct store *<VAR>source</VAR>, const struct store_run *<VAR>runs</VAR>, size_t <VAR>num_runs</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX228"></A>
Return a store in <VAR>store</VAR> that reflects the blocks in <VAR>runs</VAR> and
<VAR>runs_len</VAR> from source; <VAR>source</VAR> is consumed, but not
<VAR>runs</VAR>.  Unlike the <CODE>store_remap_create</CODE> function, this may
simply modify <VAR>source</VAR> and return it.
</DL>




<H3><A NAME="SEC86" HREF="hurd_toc.html#TOC86">Store I/O</A></H3>

<P>
The following functions allow you to read and modify the contents of a
store:


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_map</B> <I>(const struct store *<VAR>store</VAR>, vm_prot_t <VAR>prot</VAR>, mach_port_t *<VAR>memobj</VAR>)</I>
<DD><A NAME="IDX229"></A>
Return a memory object paging on <VAR>store</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_read</B> <I>(struct store *<VAR>store</VAR>, off_t <VAR>addr</VAR>, size_t <VAR>amount</VAR>, void **<VAR>buf</VAR>, size_t *<VAR>len</VAR>)</I>
<DD><A NAME="IDX230"></A>
Read <VAR>amount</VAR> bytes from <VAR>store</VAR> at <VAR>addr</VAR> into <VAR>buf</VAR>
and <VAR>len</VAR> (which follows the usual Mach buffer-return semantics) to
<VAR>store</VAR> at <VAR>addr</VAR>.  <VAR>addr</VAR> is in <VAR>blocks</VAR> (as defined by
<CODE><VAR>store</VAR>-&#62;block_size</CODE>).  Note that <VAR>len</VAR> is in bytes.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_write</B> <I>(struct store *<VAR>store</VAR>, off_t <VAR>addr</VAR>, void *<VAR>buf</VAR>, size_t <VAR>len</VAR>, size_t *<VAR>amount</VAR>)</I>
<DD><A NAME="IDX231"></A>
Write <VAR>len</VAR> bytes from <VAR>buf</VAR> to <VAR>store</VAR> at <VAR>addr</VAR>.
Returns the amount written in <VAR>amount</VAR> (in bytes).  <VAR>addr</VAR> is in
<VAR>blocks</VAR> (as defined by <CODE><VAR>store</VAR>-&#62;block_size</CODE>).
</DL>




<H3><A NAME="SEC87" HREF="hurd_toc.html#TOC87">Store Classes</A></H3>

<P>
The store library comes with a number of standard store class
implementations:


<P>
<DL>
<DT><U>Variable:</U> extern const struct store_class *const <B>store_std_classes[]</B>
<DD><A NAME="IDX232"></A>
This is a null-terminated vector of the standard store classes
implemented by <CODE>libstore</CODE>.
</DL>


<P>
If you are building your own class vectors, the following function may
be useful:


<P>
<DL>
<DT><U>Variable:</U> error_t <B>store_concat_class_vectors</B> <I>(struct store_class **<VAR>cv1</VAR>, struct store_class **<VAR>cv2</VAR>, struct store_class ***<VAR>concat</VAR>)</I>
<DD><A NAME="IDX233"></A>
Concatenate the store class vectors in <VAR>cv1</VAR> and <VAR>cv2</VAR>, and
return a new (malloced) vector in <VAR>concat</VAR>.
</DL>




<H4><A NAME="SEC88" HREF="hurd_toc.html#TOC88"><CODE>query</CODE> store</A></H4>
<P>
<A NAME="IDX234"></A>


<P>
<DL>
<DT><U>Variable:</U> extern const struct store_class <B>store_query_class</B>
<DD><A NAME="IDX235"></A>
This store is a virtual store which queries a filesystem node, and
delegates control to an appropriate store class.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_open</B> <I>(const char *<VAR>name</VAR>, int <VAR>flags</VAR>, const struct store_class *const *<VAR>classes</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX236"></A>
Open the file <VAR>name</VAR>, and return a new store in <VAR>store</VAR>, which
refers to the storage underlying it.  <VAR>classes</VAR> is used to select
classes specified by the provider; if it is zero, then
<VAR>store_std_classes</VAR> is used.  <VAR>flags</VAR> is set with
<CODE>store_set_flags</CODE>.  A reference to the open file is created (but
may be destroyed with <CODE>store_close_source</CODE>).
</DL>




<H4><A NAME="SEC89" HREF="hurd_toc.html#TOC89"><CODE>typed_open</CODE> store</A></H4>
<P>
<A NAME="IDX237"></A>


<P>
<DL>
<DT><U>Variable:</U> extern const struct store_class <B>store_typed_open_class</B>
<DD><A NAME="IDX238"></A>
This store is special in that it doesn't correspond to any specific
store functions, rather it provides a way to interpret character strings
as specifications for other stores.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_typed_open</B> <I>(const char *<VAR>name</VAR>, int <VAR>flags</VAR>, const struct store_class *const *<VAR>classes</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX239"></A>
Open the store indicated by <VAR>name</VAR>, which should consist of a store
type name followed by a <SAMP>`:'</SAMP> and any type-specific name, returning the
new store in <VAR>store</VAR>.  <VAR>classes</VAR> is used to select classes
specified by the type name; if it is zero, <VAR>store_std_classes</VAR> is
used.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_open_children</B> <I>(const char *<VAR>name</VAR>, int <VAR>flags</VAR>, const struct store_class *const *<VAR>classes</VAR>, struct store ***<VAR>stores</VAR>, size_t *<VAR>num_stores</VAR>)</I>
<DD><A NAME="IDX240"></A>
Parse multiple store names in <VAR>name</VAR>, and open each individually,
returning all in the vector <VAR>stores</VAR>, and the number in
<VAR>num_stores</VAR>.  The syntax of <VAR>name</VAR> is a single non-alphanumeric
separator character, followed by each child store name separated by the
same separator; each child name is <SAMP>`<VAR>type</VAR>:<VAR>name</VAR>'</SAMP> notation
as parsed by <CODE>store_typed_open</CODE>.  If every child uses the same
<SAMP>`<VAR>type</VAR>:'</SAMP> prefix, then it may be factored out and put before
the child list instead (the two notations are differentiated by whether
or not the first character of <VAR>name</VAR> is alphanumeric).
</DL>




<H4><A NAME="SEC90" HREF="hurd_toc.html#TOC90"><CODE>device</CODE> store</A></H4>
<P>
<A NAME="IDX241"></A>


<P>
<A NAME="IDX242"></A>
<DL>
<DT><U>Variable:</U> extern const struct store_class <B>store_device_class</B>
<DD><A NAME="IDX243"></A>
This store is a simple wrapper for a microkernel device
driver.<A NAME="DOCF8" HREF="hurd_foot.html#FOOT8">(8)</A>
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_device_open</B> <I>(const char *<VAR>name</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX244"></A>
Open the device named <VAR>name</VAR>, and return the corresponding store in
<VAR>store</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_device_create</B> <I>(device_t <VAR>device</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX245"></A>
Return a new store in <VAR>store</VAR> referring to the microkernel device
<VAR>device</VAR>.  Consumes the <VAR>device</VAR> send right.
</DL>




<H4><A NAME="SEC91" HREF="hurd_toc.html#TOC91"><CODE>file</CODE> store</A></H4>
<P>
<A NAME="IDX246"></A>


<P>
<DL>
<DT><U>Variable:</U> extern const struct store_class <B>store_file_class</B>
<DD><A NAME="IDX247"></A>
This store reads and writes the contents of a Hurd file.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_file_open</B> <I>(const char *<VAR>name</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX248"></A>
Open the file <VAR>name</VAR>, and return the corresponding store in <VAR>store</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_file_create</B> <I>(file_t <VAR>file</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX249"></A>
Return a new store in <VAR>store</VAR> referring to the file <VAR>file</VAR>.
Unlike <CODE>store_create</CODE>, this will always use file I/O, even it would
be possible to be more direct.  This may work in more cases, for instance
if the file has holes.  Consumes the <VAR>file</VAR> send right.
</DL>




<H4><A NAME="SEC92" HREF="hurd_toc.html#TOC92"><CODE>task</CODE> store</A></H4>
<P>
<A NAME="IDX250"></A>


<P>
<DL>
<DT><U>Variable:</U> extern const struct store_class <B>store_task_class</B>
<DD><A NAME="IDX251"></A>
This store provides access to the contents of a microkernel task.
</DL>


<P>
<DL>
<DT><U>Variable:</U> error_t <B>store_task_open</B> <I>(const char *<VAR>name</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX252"></A>
Open the task <VAR>name</VAR> (<VAR>name</VAR> should be the task's pid), and
return the corresponding store in <VAR>store</VAR>.
</DL>


<P>
<DL>
<DT><U>Variable:</U> error_t <B>store_task_create</B> <I>(task_t <VAR>task</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX253"></A>
Return a new store in <VAR>store</VAR> referring to the task <VAR>task</VAR>,
consuming the <VAR>task</VAR> send right.
</DL>




<H4><A NAME="SEC93" HREF="hurd_toc.html#TOC93"><CODE>zero</CODE> store</A></H4>
<P>
<A NAME="IDX254"></A>


<P>
<DL>
<DT><U>Variable:</U> extern const struct store_class <B>store_zero_class</B>
<DD><A NAME="IDX255"></A>
Reads to this store always return zero-filled buffers, no matter what
has been written into it.  This store corresponds to the Unix
<TT>`/dev/zero'</TT> device node.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_zero_create</B> <I>(off_t <VAR>size</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX256"></A>
Return a new zero store <VAR>size</VAR> bytes long in <VAR>store</VAR>.
</DL>




<H4><A NAME="SEC94" HREF="hurd_toc.html#TOC94"><CODE>copy</CODE> store</A></H4>
<P>
<A NAME="IDX257"></A>


<P>
<DL>
<DT><U>Variable:</U> extern const struct store_class <B>store_copy_class</B>
<DD><A NAME="IDX258"></A>
This store provides a temporary copy of another store.  This is useful
if you want to provide writable data, but do not wish to modify the
underlying store.  All changes to a copy store are lost when it is
closed.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_copy_open</B> <I>(const char *<VAR>name</VAR>, int <VAR>flags</VAR>, const struct store_class *const *<VAR>classes</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX259"></A>
Open the copy store <VAR>name</VAR> (which consists of another store class
name, a <SAMP>`:'</SAMP>, and a name for the store class to open) and return the
corresponding store in <VAR>store</VAR>.  <VAR>classes</VAR> is used to select
classes specified by the type name; if it is zero,
<VAR>store_std_classes</VAR> is used.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_copy_create</B> <I>(struct store *<VAR>from</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX260"></A>
Return a new store in <VAR>store</VAR> which contains a snapshot of the
contents of the store <VAR>from</VAR>; <VAR>from</VAR> is consumed.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_buffer_create</B> <I>(void *<VAR>buf</VAR>, size_t <VAR>buf_len</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX261"></A>
Return a new store in <VAR>store</VAR> which contains the memory buffer
<VAR>buf</VAR>, of length <VAR>buf_len</VAR>.  <VAR>buf</VAR> must be allocated with
<CODE>vm_allocate</CODE>, and will be consumed.
</DL>




<H4><A NAME="SEC95" HREF="hurd_toc.html#TOC95"><CODE>gunzip</CODE> store</A></H4>
<P>
<A NAME="IDX262"></A>


<P>
<DL>
<DT><U>Variable:</U> extern const struct store_class <B>store_gunzip_class</B>
<DD><A NAME="IDX263"></A>
This store provides transparent GNU zip decompression of a substore.
Unfortunately, this store is currently read-only.
</DL>


<P>
<DL>
<DT><U>Variable:</U> error_t <B>store_gunzip_open</B> <I>(const char *<VAR>name</VAR>, int <VAR>flags</VAR>, const struct store_class *const *<VAR>classes</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX264"></A>
Open the gunzip store <VAR>name</VAR> (which consists of another store class
name, a <SAMP>`:'</SAMP>, and a name for that store class to open), and return
the corresponding store in <VAR>store</VAR>.  <VAR>classes</VAR> is used to select
classes specified by the type name; if it is zero,
<VAR>store_std_classes</VAR> is used.
</DL>


<P>
<DL>
<DT><U>Variable:</U> error_t <B>store_gunzip_create</B> <I>(struct store *<VAR>from</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX265"></A>
Return a new store in <VAR>store</VAR> which contains a snapshot of the
uncompressed contents of the store <VAR>from</VAR>; <VAR>from</VAR> is consumed.
<VAR>block_size</VAR> is the desired block size of the result.
</DL>




<H4><A NAME="SEC96" HREF="hurd_toc.html#TOC96"><CODE>concat</CODE> store</A></H4>
<P>
<A NAME="IDX266"></A>


<P>
<A NAME="IDX267"></A>
<A NAME="IDX268"></A>
<A NAME="IDX269"></A>
<A NAME="IDX270"></A>
<A NAME="IDX271"></A>
<DL>
<DT><U>Variable:</U> extern const struct store_class <B>store_concat_class</B>
<DD><A NAME="IDX272"></A>
This class provides a linear concatenation storage mode.  It creates a
new virtual store which consists of several different substores appended
to one another.


<P>
This mode is designed to increase storage capacity, so that when one
substore is filled, new data is transparently written to the next
substore.  Concatenation requires robust hardware, since a failure in
any single substore will wipe out a large section of the data.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_concat_open</B> <I>(const char *<VAR>name</VAR>, int <VAR>flags</VAR>, const struct store_class *const *<VAR>classes</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX273"></A>
Return a new store that concatenates the stores created by opening all
the individual stores described in <VAR>name</VAR>; for the syntax of
<VAR>name</VAR>, see <CODE>store_open_children</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_concat_create</B> <I>(struct store * const *<VAR>stores</VAR>, size_t <VAR>num_stores</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX274"></A>
Return a new store in <VAR>store</VAR> that concatenates all the stores in
<VAR>stores</VAR> (<VAR>num_stores</VAR> of them).  The stores in <VAR>stores</VAR> are
consumed; that is, they will be freed when this store is freed.  The
<VAR>stores</VAR> <EM>array</EM>, however, is copied, and so should be freed by
the caller.
</DL>




<H4><A NAME="SEC97" HREF="hurd_toc.html#TOC97"><CODE>ileave</CODE> store</A></H4>
<P>
<A NAME="IDX275"></A>


<P>
<A NAME="IDX276"></A>
<A NAME="IDX277"></A>
<A NAME="IDX278"></A>
<A NAME="IDX279"></A>
<A NAME="IDX280"></A>
<DL>
<DT><U>Variable:</U> extern const struct store_class <B>store_ileave_class</B>
<DD><A NAME="IDX281"></A>
This class provides a RAID-0<A NAME="DOCF9" HREF="hurd_foot.html#FOOT9">(9)</A> storage mode (also called <EM>disk striping</EM>).  It
creates a new virtual store by interleaving the contents of several
different substores.


<P>
This RAID mode is designed to increase storage performance, since I/O
will probably occur in parallel if the substores reside on different
physical devices.  Interleaving works best with evenly-yoked
substores... if the stores are different sizes, some space will be
not be used at the end of the larger stores; if the stores are different
speeds, then I/O will have to wait for the slowest store; if some stores
are not as reliable as others, failures will wipe out every <VAR>n</VAR>th
storage block, where <VAR>n</VAR> is the number of substores.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_ileave_create</B> <I>(struct store * const *<VAR>stripes</VAR>, size_t num_stripes, off_t <VAR>interleave</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX282"></A>
Return a new store in <VAR>store</VAR> that interleaves all the stores in
<VAR>stripes</VAR> (<VAR>num_stripes</VAR> of them) every <VAR>interleave</VAR> bytes;
<VAR>interleave</VAR> must be an integer multiple of each stripe's block
size.  The stores in <VAR>stripes</VAR> are consumed; that is, they will be
freed when this store is freed.  The <VAR>stripes</VAR> <EM>array</EM>,
however, is copied, and so should be freed by the caller.
</DL>




<H4><A NAME="SEC98" HREF="hurd_toc.html#TOC98"><CODE>mvol</CODE> store</A></H4>
<P>
<A NAME="IDX283"></A>


<P>
<DL>
<DT><U>Variable:</U> extern const struct store_class <B>store_mvol_class</B>
<DD><A NAME="IDX284"></A>
This store provides access to multiple volumes using a single-volume
device.  One use of this store would be to provide a store which
consists of multiple floppy disks when there is only a single disk
drive.  It works by remapping a single linear address range to multiple
address ranges, and keeping track of the currently active range.
Whenever a request maps to a range that is not active, a callback is
made in order to switch to the new range.


<P>
This class is not included in <VAR>store_std_classes</VAR>, because it
requires an application-specific callback.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_mvol_create</B> <I>(struct store *<VAR>phys</VAR>, error_t (*<VAR>swap_vols</VAR>) (struct store *<VAR>store</VAR>, size_t <VAR>new_vol</VAR>, ssize_t <VAR>old_vol</VAR>), int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX285"></A>
Return a new store in <VAR>store</VAR> that multiplexes multiple physical
volumes from <VAR>phys</VAR> as one larger virtual volume.  <VAR>swap_vols</VAR>
is a function that will be called whenever reads or writes refer to a
block which is not addressable on the currently active volume.
<VAR>phys</VAR> is consumed.
</DL>




<H4><A NAME="SEC99" HREF="hurd_toc.html#TOC99"><CODE>remap</CODE> store</A></H4>
<P>
<A NAME="IDX286"></A>


<P>
<DL>
<DT><U>Variable:</U> extern const struct store_class <B>store_remap_class</B>
<DD><A NAME="IDX287"></A>
This store translates I/O requests into different addresses on a
different store.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_remap_create</B> <I>(struct store *<VAR>source</VAR>, const struct store_run *<VAR>runs</VAR>, size_t <VAR>num_runs</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX288"></A>
Return a new store in <VAR>store</VAR> that reflects the blocks in <VAR>runs</VAR>
and <VAR>runs_len</VAR> from <VAR>source</VAR>; <VAR>source</VAR> is consumed, but
<VAR>runs</VAR> is not.  Unlike the <CODE>store_remap</CODE> function, this
function always operates by creating a new store of type <SAMP>`remap'</SAMP>
which has <VAR>source</VAR> as a child, and so may be less efficient than
<CODE>store_remap</CODE> for some types of stores.
</DL>




<H3><A NAME="SEC100" HREF="hurd_toc.html#TOC100">Store RPC Encoding</A></H3>

<P>
The store library also provides some functions which help transfer
stores between tasks via RPC:


<P>
<DL>
<DT><U>Structure:</U> struct <B>store_enc</B>
<DD><A NAME="IDX289"></A>
This structure is used to hold the various bits that make up the
representation of a store for transmission via RPC.  See
<CODE>&#60;hurd/hurd_types.h&#62;</CODE> for an explanation of the encodings for the
various storage types.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>store_enc_init</B> <I>(struct store_enc *<VAR>enc</VAR>, mach_port_t *<VAR>ports</VAR>, mach_msg_type_number_t <VAR>num_ports</VAR>, int *<VAR>ints</VAR>, mach_msg_type_number_t <VAR>num_ints</VAR>, off_t *<VAR>offsets</VAR>, mach_msg_type_number_t <VAR>num_offsets</VAR>, char *<VAR>data</VAR>, mach_msg_type_number_t <VAR>data_len</VAR>)</I>
<DD><A NAME="IDX290"></A>
Initialize <VAR>enc</VAR>.  The given vector and sizes will be used for the
encoding if they are big enough (otherwise new ones will be
automatically allocated).
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>store_enc_dealloc</B> <I>(struct store_enc *<VAR>enc</VAR>)</I>
<DD><A NAME="IDX291"></A>
Deallocate storage used by the fields in <VAR>enc</VAR> (but nothing is done
with <VAR>enc</VAR> itself).
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>store_enc_return</B> <I>(struct store_enc *<VAR>enc</VAR>, mach_port_t **<VAR>ports</VAR>, mach_msg_type_number_t *<VAR>num_ports</VAR>, int **<VAR>ints</VAR>, mach_msg_type_number_t *<VAR>num_ints</VAR>, off_t **<VAR>offsets</VAR>, mach_msg_type_number_t *<VAR>num_offsets</VAR>, char **<VAR>data</VAR>, mach_msg_type_number_t *<VAR>data_len</VAR>)</I>
<DD><A NAME="IDX292"></A>
Copy out the parameters from <VAR>enc</VAR> into the given variables suitably
for returning from a <CODE>file_get_storage_info</CODE> RPC, and deallocate
<VAR>enc</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_return</B> <I>(const struct store *<VAR>store</VAR>, mach_port_t **<VAR>ports</VAR>, mach_msg_type_number_t *<VAR>num_ports</VAR>, int **<VAR>ints</VAR>, mach_msg_type_number_t *<VAR>num_ints</VAR>, off_t **<VAR>offsets</VAR>, mach_msg_type_number_t *<VAR>num_offsets</VAR>, char **<VAR>data</VAR>, mach_msg_type_number_t *<VAR>data_len</VAR>)</I>
<DD><A NAME="IDX293"></A>
Encode <VAR>store</VAR> into the given return variables, suitably for
returning from a <CODE>file_get_storage_info</CODE> RPC.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_encode</B> <I>(const struct store *<VAR>store</VAR>, struct store_enc *<VAR>enc</VAR>)</I>
<DD><A NAME="IDX294"></A>
Encode <VAR>store</VAR> into <VAR>enc</VAR>, which should have been prepared with
<CODE>store_enc_init</CODE>, or return an error.  The contents of <VAR>enc</VAR>
may then be returned as the value of <CODE>file_get_storage_info</CODE>; if
for some reason this can't be done, <CODE>store_enc_dealloc</CODE> may be used
to deallocate the memory used by the unsent vectors.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_decode</B> <I>(struct store_enc *<VAR>enc</VAR>, const struct store_class *const *<VAR>classes</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX295"></A>
Decode <VAR>enc</VAR>, either returning a new store in <VAR>store</VAR>, or an
error.  <VAR>classes</VAR> is the mapping from Hurd storage class ids to store
classes; if it is zero, <VAR>store_std_classes</VAR> is used.  If nothing
else is to be done with <VAR>enc</VAR>, its contents may then be freed using
<CODE>store_enc_dealloc</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_allocate_child_encodings</B> <I>(const struct store *<VAR>store</VAR>, struct store_enc *<VAR>enc</VAR>)</I>
<DD><A NAME="IDX296"></A>
Calls the <CODE>allocate_encoding</CODE> method in each child store of
<VAR>store</VAR>, propagating any errors.  If any child does not have such a
method, <CODE>EOPNOTSUPP</CODE> is returned.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_encode_children</B> <I>(const struct store *<VAR>store</VAR>, struct store_enc *<VAR>enc</VAR>)</I>
<DD><A NAME="IDX297"></A>
Calls the encode method in each child store of <VAR>store</VAR>, propagating
any errors.  If any child does not have such a method, <CODE>EOPNOTSUPP</CODE>
is returned.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_decode_children</B> <I>(struct store_enc *<VAR>enc</VAR>, int <VAR>num_children</VAR>, const struct store_class *const *<VAR>classes</VAR>, struct store **<VAR>children</VAR>)</I>
<DD><A NAME="IDX298"></A>
Decodes <VAR>num_children</VAR> from <VAR>enc</VAR>, storing the results into
successive positions in <VAR>children</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_with_decoded_runs</B> <I>(struct store_enc *<VAR>enc</VAR>, size_t <VAR>num_runs</VAR>, error_t (*<VAR>fun</VAR>) (const struct store_run *<VAR>runs</VAR>, size_t <VAR>num_runs</VAR>))</I>
<DD><A NAME="IDX299"></A>
Call <VAR>fun</VAR> with the vector <VAR>runs</VAR> of length <VAR>num_runs</VAR>
extracted from <VAR>enc</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_std_leaf_allocate_encoding</B> <I>(const struct store *<VAR>store</VAR>, struct store_enc *<VAR>enc</VAR>)</I>
<DD><A NAME="IDX300"></A>
<DT><U>Function:</U> error_t <B>store_std_leaf_encode</B> <I>(const struct store *<VAR>store</VAR>, struct store_enc *<VAR>enc</VAR>)</I>
<DD><A NAME="IDX301"></A>
Standard encoding used for most data-providing (as opposed to filtering)
store classes.
</DL>


<P>
<DL>
<DT><U>Typedef:</U> typedef error_t (* <B>store_std_leaf_create_t</B> <I>)(mach_port_t <VAR>port</VAR>, int <VAR>flags</VAR>, size_t <VAR>block_size</VAR>, const struct store_run *<VAR>runs</VAR>, size_t <VAR>num_runs</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX302"></A>
Creation function used by <CODE>store_std_leaf_decode</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_std_leaf_decode</B> <I>(struct store_enc *<VAR>enc</VAR>, store_std_leaf_create_t <VAR>create</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX303"></A>
Decodes the standard leaf encoding which is common to various builtin
formats, and calls <VAR>create</VAR> to actually create the store.
</DL>


<P><HR><P>
Go to the <A HREF="hurd_1.html">first</A>, <A HREF="hurd_8.html">previous</A>, <A HREF="hurd_10.html">next</A>, <A HREF="hurd_17.html">last</A> section, <A HREF="hurd_toc.html">table of contents</A>.
</BODY>
</HTML>

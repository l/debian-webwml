#use wml::debian::template title="Debian GNU/Hurd --- Development" NOHEADER="yes"
#include "$(ENGLISHDIR)/ports/hurd/menu.inc"

<h1>
Debian GNU/Hurd</h1>
<h2>
Development of the Distribution</h2>
<h3>
Boot Disks</h3>
<p>
Currently, we do not work on native boot disks.  We are laying out
some of the necessary foundations for that, though, and sometimes port
individual necessary packages for that.  If you want to help, work on
the debian-installer project and make sure its components run on the
Hurd.

<h3>
Porting Debian Packages</h3>
<p>
If you want to help the Debian GNU/Hurd port, you should make yourself
familiar with the Debian packaging system.  Once you have done this by
reading the available documentation and visiting the <a
href="../../devel/">Developer's Corner</a> you should know how to
extract Debian source packages and build a Debian package. Here is a
crash course for the very lazy people:</p>

<h3>
Obtaining Source and Building Packages</h3>
<p>
Extracting a Debian source package requires the file
<code>package_version.dsc</code> and the files listed in it. You build the
Debian build directory with the command <code>dpkg-source -x
package_version.dsc</code></p>
<p>
Building a package is done in the now existing Debian build directory
<code>package-version</code> with the command <code>dpkg-buildpackage -B -rsudo
"-mMyName &lt;MyEmail&gt;"</code>. Instead <code>-B</code> you can use
<code>-b</code> if you also want to build the architecture independent
parts of the package. You can use <code>-rfakeroot</code> instead
<code>-rsudo</code> if you use the fakeroot package.  You can do
without the <code>-r</code> if you build as user root. You can add
<code>-uc</code> to avoid signing the package with your pgp key.</p>

<h3>
Pick One</h3>
<p>
Which package needs to be worked on?  Well, every package that is not
yet ported, but needs to be ported.  This changes constantly, so
either pick one of the missing packages at random, or watch out for
information about the autobuilding process on the debian-hurd mailing
list.

<h4>
Packages That Won't Be Ported</h4>
<p>
Some of these packages, or parts of them, might be portable later, but
currently they are considered to be unportable at least.</p>

<ul>
<li>
<code>base/update</code>, because the Hurd does not need an update
daemon (the filesystems sync themselves). To change to sync interval,
you can use <code>fsysopts</code> to adjust the <code>--sync</code>
option. You can set different sync intervals for each file system!
To do this manully, use the <a
href="hurd-doc-utils#syncfs"><code>syncfs</code> utility</a>.</li>
<li>
<code>base/makedev</code>, because the Hurd comes with its own version
of this script. The Debian source package only contains a Linux
specific version.</li>
<li>
<code>base/ld.so</code>, because the Hurd does use the linker that
ships with the GNU C library.</li>
<li>
<code>base/modconf</code> and <code>base/modutils</code>, because
modules are a concept specific to Linux.</li>
<li>
<code>base/netbase</code>, because the remaining stuff that is there
is highly specific to the Linux kernel. The Hurd uses
<code>inetutils</code> instead.</li>
<li>
<code>base/pcmcia-cs</code>, because the Hurd does not have any PCMCIA
support (and even if it had, this package is probably Linux specific).</li>
<li>
<code>base/procps</code>, because this code is specific to the Linux proc
filesystem.</li>
<li>
<code>base/ppp</code> and <code>base/pppconfig</code>, because the
Hurd does not have any PPP support (and even if it had, this package
is probably Linux specific).</li>
<li>
<code>base/setserial</code>, because it is specific to the Linux
kernel. However, with the port of Linux char drivers to GNU Mach, we
might be able to use it.</li>
</ul>

<h3>
General Porting Issues</h3>
<p>
Here is a list of common incompatibilities you may encounter when compiling
insufficient portable software on the Hurd.</p>

<ul>
<li>
<code>Bad File Descriptor</code>
<p>
If you get <code>Bad File Descriptor</code> error when trying to read
from a file (or accessing it at all), check the <code>open()</code>
invocation. The second argument is the access method. If it is a hard
coded number instead of a symbol defined in the standard header files,
the code is screwed and should be fixed to either use
<code>O_RDONLY</code>, <code>O_WRONLY</code> or
<code>O_RDWR</code>. This bug was observed in the
<code>fortunes</code> and <code>mtools</code> packages for
example.</p></li>
<li>
<code>PATH_MAX</code>
<p>
Every unconditionalized use of <code>PATH_MAX</code> is a POSIX
incompatibility.  If there is no upper limit on the length of a path,
this symbol is not defined in any header file. Instead, you need to
either use a different implementation that does not rely on the length
of a string or use <code>sysconf()</code> to query the length at
runtime. If <code>sysconf()</code> returns <code>-1</code>, you have
to use <code>realloc()</code> to allocate the needed memory
dynamically.</p></li>
<li>
<code>MAXHOSTNAMELEN</code>
<p>
see <code>PATH_MAX</code></p></li>
<li>
<code>MAXPATHLEN</code>
<p>
see <code>PATH_MAX</code></p></li>
<li>
<code>NOFILE</code>
<p>
see <code>PATH_MAX</code></p></li>
<li>
Hurd specific <code>#define</code>
<p>
If you need to include specific code for the Hurd using
<code>#if...#endif</code>, then you can use the <code>__GNU__</code>
symbol to do so. But think (at least) thrice! before doing so. In
<em>most</em> situations, this is completely unnecessary and will
create more problems than it may solve. Better ask on the mailing list
how to do it right if you can't think of a better solution.</p></li>
<li>
<code>sys_errlist[]</code> vs. <code>strerror()</code>
<p>
If a program has only support for <code>sys_errlist[]</code> you will
have to do some work to make it compile on the Hurd, which has dropped
support for it and does only provide <code>strerror()</code>. Steinar
Hamre writes about <code>strerror():</code></p>
<blockquote>
<p>
<code>strerror()</code> should be used because:
<ul>
<li>
It is the modern, POSIX way.</li>
<li>
It is localized.</li>
<li>
It handles invalid signals/numbers out of range. (better errorhandling
and not a buffer-overflow-candidate/security risk)</li></ul>
<p>
<code>strerror()</code> should always be used if it is available.
Unfortunaly there are still some <em>old</em> non-POSIX systems that
do not have <code>strerror()</code>, only
<code>sys_errlist[]</code>.</p>
<p>
Today, only supporting <code>strerror()</code> is far better than only supporting
<code>sys_errlist[]</code>. The best (from a portability viewpoint), however is
supporting both. For <code>configure.in</code>, you will need:</p>
<p>
<code>AC_CHECK_FUNCS(strerror)</code></p>
<p>
To <code>config.h.in</code>, you need to add:</p>
<p>
<code>#undef HAVE_STRERROR</code></p>
<p>
Then something like:
<pre>
        \#ifndef HAVE_STRERROR
        static char *
        private_strerror (errnum)
             int errnum;
        {
          extern char *sys_errlist[];
          extern int sys_nerr;

          if (errnum &gt; 0 &amp;&amp; errnum &lt;= sys_nerr)
            return sys_errlist[errnum];
          return "Unknown system error";
        }
        \#define strerror private_strerror
        \#endif /* HAVE_STRERROR */
</pre>
<p>
You can for example look in the latest fileutils (the above is a
simplified version of what I found there.) Patches should of course be
sent to upstream maintainers, this is very useful even for systems
with a working <code>sys_errlist[]</code>.</blockquote>
<li>
Filenames ending in a slash `/'
<p>
Those are evil if they don't exist and you want to name a directory
this way. For example, <code>mkdir foobar/</code> will <em>not</em>
work under the Hurd. This is POSIX compatible. POSIX says that the
path of a directory may have slashes appended to it. But the directory
does not exist yet, so the path does not refer to a directory, and
hence trailing slashes are not guaranteed to work. Just drop the
slashes, and you're fine.
</ul>

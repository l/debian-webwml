#use wml::debian::template title="Debian GNU/Hurd --- Development" NOHEADER="yes"
#include "$(ENGLISHDIR)/ports/hurd/menu.inc"

<h1>
Debian GNU/Hurd</h1>
<h2>
Development of the Distribution</h2>
<h3>
Boot Disks</h3>
<p>
Currently, we are investigating the various ways to boot a minimal
Hurd system and how to create boot floppies. A preliminary boot disk
is available at <code><a
href="ftp://alpha.gnu.org/gnu/hurd/contrib/marcus/">ftp://alpha.gnu.org/gnu/hurd/contrib/marcus</a></code>
in the file <code>boot-YYYYMMDD</code>. This disk contains GNU Mach,
the <code>ext2fs</code> server, the linker <code>ld.so</code>, the
bootstrap program <code>serverboot</code> and a copy of GRUB. This
disk will boot and wait for a root disk, which is not yet
available.</p>

<h3>
Porting Debian Packages</h3>
<p>
If you want to help the Debian GNU/Hurd port, you should make yourself
familiar with the Debian packaging system. Once you have done this by
reading the available documentation and visiting the <a
href="../../devel/">Developer's Corner</a> you should know how to
extract Debian source packages and build a Debian package. Here is a
crash course for the very lazy people:</p>

<h3>
Obtaining Source and Building Packages</h3>
<p>
Extracting a Debian source package requires the file
<code>package_version.dsc</code> and the files listed in it. You build the
Debian build directory with the command <code>dpkg-source -x
package_version.dsc</code></p>
<p>
Building a package is done in the now existing Debian build directory
<code>package-version</code> with the command <code>dpkg-buildpackage -B -rsudo
"-mMyName &lt;MyEmail&gt;"</code>. Instead <code>-B</code> you can use
<code>-b</code> if you also want to build the architecture independent
parts of the package. You can use <code>-rfakeroot</code> instead
<code>-rsudo</code> if you use the fakeroot package.  You can do
without the <code>-r</code> if you build as user root. You can add
<code>-uc</code> to avoid signing the package with your pgp key.</p>

<h3>
Pick One</h3>
<p>
Which package needs to be worked on? Well, the best thing I can do for
now is tell you which package you should not work on.</p>
<p>
The current list of packages that have not been ported is available by
looking at the <a href="http://hurd.sourceforge.net/turtle/">state of
the Debian hurd-i386 archive</a>.</p>
<h4>
Packages That Won't Be Ported</h4>
<p>
Some of these packages, or parts of them, might be portable later, but
currently they are considered to be unportable at least.</p>

<ul>
<li>
<code>base/update</code>, because the Hurd does not need an update
daemon (the filesystems sync themselves). To change to sync interval,
you can use <code>fsysopts</code> to adjust the <code>--sync</code>
option. You can set different sync intervals for each file system!
To do this manully, use the <a
href="hurd-doc-utils#syncfs"><code>syncfs</code> utility</a>.</li>
<li>
<code>base/makedev</code>, because the Hurd comes with its own version
of this script. The Debian source package only contains a Linux
specific version.</li>
<li>
<code>base/ld.so</code>, because the Hurd does use the linker that
ships with the GNU C library.</li>
<li>
<code>base/modconf</code> and <code>base/modutils</code>, because
modules are a concept specific to Linux.</li>
<li>
<code>base/netbase</code>, because the remaining stuff that is there
is highly specific to the Linux kernel. The Hurd uses
<code>inetutils</code> instead.</li>
<li>
<code>base/pcmcia-cs</code>, because the Hurd does not have any PCMCIA
support (and even if it had, this package is probably Linux specific).</li>
<li>
<code>base/procps</code>, because this code is specific to the Linux proc
filesystem.</li>
<li>
<code>base/ppp</code> and <code>base/pppconfig</code>, because the
Hurd does not have any PPP support (and even if it had, this package
is probably Linux specific).</li>
<li>
<code>base/setserial</code>, because it is specific to the Linux
kernel. However, with the port of Linux char drivers to GNU Mach, we
might be able to use it.</li>
</ul>

<h3>
General Porting Issues</h3>
<p>
Here is a list of common incompatibilities you may encounter when compiling
insufficient portable software on the Hurd.</p>
<p>
<ul>
<li>
<code>Bad File Descriptor</code>
<p>
If you get <code>Bad File Descriptor</code> error when trying to read
from a file (or accessing it at all), check the <code>open()</code>
invocation. The second argument is the access method. If it is a hard
coded number instead of a symbol defined in the standard header files,
the code is screwed and should be fixed to either use
<code>O_RDONLY</code>, <code>O_WRONLY</code> or
<code>O_RDWR</code>. This bug was observed in the
<code>fortunes</code> and <code>mtools</code> packages for
example.</p></li>
<li>
<code>PATH_MAX</code>
<p>
Every unconditionalized use of <code>PATH_MAX</code> is a POSIX
incompatibility.  If there is no upper limit on the length of a path,
this symbol is not defined in any header file. Instead, you need to
either use a different implementation that does not rely on the length
of a string or use <code>sysconf()</code> to query the length at
runtime. If <code>sysconf()</code> returns <code>-1</code>, you have
to use <code>realloc()</code> to allocate the needed memory
dynamically.</p></li>
<li>
<code>MAXHOSTNAMELEN</code>
<p>
see <code>PATH_MAX</code></p></li>
<li>
<code>MAXPATHLEN</code>
<p>
see <code>PATH_MAX</code></p></li>
<li>
<code>NOFILE</code>
<p>
see <code>PATH_MAX</code></p></li>
<li>
Hurd specific <code>#define</code>
<p>
If you need to include specific code for the Hurd using
<code>#if...#endif</code>, then you can use the <code>__GNU__</code>
symbol to do so. But think (at least) thrice! before doing so. In
<em>most</em> situations, this is completely unnecessary and will
create more problems than it may solve. Better ask on the mailing list
how to do it right if you can't think of a better solution.</p></li>
<li>
<code>sys_errlist[]</code> vs. <code>strerror()</code>
<p>
If a program has only support for <code>sys_errlist[]</code> you will
have to do some work to make it compile on the Hurd, which has dropped
support for it and does only provide <code>strerror()</code>. Steinar
Hamre writes about <code>strerror():</code></p>
<blockquote>
<p>
<code>strerror()</code> should be used because:
<ul>
<li>
It is the modern, POSIX way.</li>
<li>
It is localized.</li>
<li>
It handles invalid signals/numbers out of range. (better errorhandling
and not a buffer-overflow-candidate/security risk)</li></ul>
<p>
<code>strerror()</code> should always be used if it is available.
Unfortunaly there are still some <em>old</em> non-POSIX systems that
do not have <code>strerror()</code>, only
<code>sys_errlist[]</code>.</p>
<p>
Today, only supporting <code>strerror()</code> is far better than only supporting
<code>sys_errlist[]</code>. The best (from a portability viewpoint), however is
supporting both. For <code>configure.in</code>, you will need:</p>
<p>
<code>AC_CHECK_FUNCS(strerror)</code></p>
<p>
To <code>config.h.in</code>, you need to add:</p>
<p>
<code>#undef HAVE_STRERROR</code></p>
<p>
Then something like:
<pre>
        \#ifndef HAVE_STRERROR
        static char *
        private_strerror (errnum)
             int errnum;
        {
          extern char *sys_errlist[];
          extern int sys_nerr;

          if (errnum &gt; 0 &amp;&amp; errnum &lt;= sys_nerr)
            return sys_errlist[errnum];
          return "Unknown system error";
        }
        \#define strerror private_strerror
        \#endif /* HAVE_STRERROR */
</pre>
<p>
You can for example look in the latest fileutils (the above is a
simplified version of what I found there.) Patches should of course be
sent to upstream maintainers, this is very useful even for systems
with a working <code>sys_errlist[]</code>.</blockquote>
<li>
Filenames ending in a slash `/'
<p>
Those are evil if they don't exist and you want to name a directory
this way. For example, <code>mkdir foobar/</code> will <em>not</em>
work under the Hurd. This is POSIX compatible. POSIX says that the
path of a directory may have slashes appended to it. But the directory
does not exist yet, so the path does not refer to a directory, and
hence trailing slashes are not guaranteed to work. Just drop the
slashes, and you're fine.
</ul>

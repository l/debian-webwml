#use wml::debian::template title="Debian GNU/Hurd &ndash; Installazione" NOHEADER="yes"
#include "$(ENGLISHDIR)/ports/hurd/menu.inc"
#use wml::debian::translation-check translation="1.69" maintainer="Luca Monducci"

<h1>Installazione manuale di Debian GNU/Hurd</h1>

<p>Questo documento vuole fornire un insieme di istruzioni semplici e
relativamente indolori su come installare manualmente e far funzionare
Debian GNU/Hurd con il minimo sforzo. Notare che l'Installatore Debian
funziona ed è preferibile usarlo, si veda le <a href="hurd-cd">immagini
dei CD</a>.</p>

<p>È basato su <q>The Hurd Installation Guide</q> di Neal H. Walfield.
Grazie a Neal per il suo contributo.</p>

#<p>Notare che alcuni punti di questo manuale sono un po' fastidiosi perché
#richiedono molto tempo e potrebbero essere causa di problemi. Potrebbe essere
#preferibile, in particolare se si è agli inizi, l'installazione tramite le
#<a href="hurd-cd">immagini dei CD già pronte</a>. Anche se sono vecchie di
#solito funzionano e in seguito si possono prelevare gli aggiornamenti dai
#repository online.</p>

<h2>1. Introduzione</h2>

#<p>La distribuzione Debian GNU/Hurd, diversamente dalle distribuzioni di
#altri sistemi operativi, non ha un bel sistema di installazione. Prima o poi
#verrà realizzato e forse voi contribuirete al suo progetto o alla sua
#implementazione, comunque, fino ad allora l'installazione di Debian GNU/Hurd
#richiede un altro sistema operativo e in particolare un altro sistema
#Unix-like. Molti utenti hanno riportato installazioni concluse con successo
#usando varie versioni di GNU/Linux e addirittura con BSD. I requisiti minimi
#del sistema di avvio sono la capacità di: creare un filesystem ext2, estrarre
#un archivio tar e installare GNU Grub.</p>

<p>La natura di GNU è simile a qualsiasi altro sistema Unix-like: dopo il
login all'utente viene presentata una shell e il familiare VFS (filesystem
virtuale) di Unix. Nonostante GNU tenti di essere conforme a POSIX, è "Non
Unix". GNU/Hurd è basato su molti dei concetti di Unix e li estende sia
aggiungendo nuove funzionalità che correggendo le cose che sono percepite
come imperfette nel progetto originale. La differenza più grande sono i
traduttori, dei programmi in spazio utente che interagiscono con il VFS.
Questi filesystem non risiedono nel kernel e nemmeno necessitano di essere
eseguiti come root; l'unica cosa che richiedono è l'accesso al supporto
sottostante e un <code>mount point</code>. Un'altra differenza è che i
processi anziché avere l'identità di un singolo utente fissata al momento
della creazione hanno le informazioni sull'identità separate dal processo,
quindi, con i giusti permessi, si possono aggiungere o rimuovere identità.</p>

<p>Essendo parente stretto dell'ambiente Unix (e in particolar modo dello
spazio utente GNU che si trova in varianti anche molto popolari come GNU/Linux)
è imperativo sentirsi a proprio agio con GNU. L'esperienza con gli strumenti
Debian si rivela preziosa anche per la configurazione e la manutenzione di una
macchina con GNU/Hurd.</p>

<p>Questa guida si sforza di rendere il processo di installazione di GNU/Hurd
il più semplice possibile. Se si riscontrano degli errori (che sono certamente
dovuti all'autore) si prega di segnalarli insieme a qualsiasi suggerimento o
critica si voglia fare all'autore stesso; viene accettato tutto con immenso
piacere.</p>

#<h2>2. Casa di proprietà o cercarne una</h2>
#
#<p>Se non si dispone di una partizione disponibile o di un hard disk
#aggiuntivo questo può essere il passo più lungo, infatti in questo caso è necessario
#ripartizionare l'hard disk. Una possibilità è usare l'editor di partizioni
#di GNU, <a href="http://packages.debian.org/parted">Parted</a>.
#Non solo permette la modifica di base delle partizioni ma
#permette anche il ridimensionamento e lo spostamento delle partizioni.
#Il manuale è abbastanza completo e include svariati tutorial. Notare che
#esiste il tipo di partizione <code>63 GNU HURD or SysV</code>, questo tipo
#non dovrebbe essere usato altrimenti il CD di installazione non la
#riconoscerà. Usare il <code>83 Linux</code>.
#</p>
#
#<p>Hurd supporta diverse estensioni al formato del filesystem ext2fs. Le cose
#più importanti fra queste sono i traduttori passivi e un quarto gruppo di bit
#con i permessi per gli utenti sconosciuti (gli utenti senza identità, non gli
#utenti "other"). Per usare queste estensioni il proprietario della partizione
#deve essere impostato a <code>hurd</code>. <code>mke2fs</code>, a meno che non
#sia specificato diversamente sulla riga di comando, imposta come proprietario
#qualsiasi kernel sia in esecuzione. Dal momento che Hurd rispetta diligentemente
#questa impostazione si deve prestare molta attenzione dando il valore
#appropriato altrimenti Hurd si comporterà in modo impredicibile. Attenzione,
#anche se un filesystem è in possesso di un particolare kernel, altri kernel
#possono continuare a usarlo ma potrebbero non essere capaci di usare certe
#estensioni.</p>
#
#<p>Per creare un filesystem usare <code>mke2fs</code> e passare <q><var>-b
#4096 -I 128 -o hurd</var></q> per indicare l'Hurd come proprietario del
#nuovo filesystem. Per esempio, supponendo che la partizione sia
#<tt>/dev/hda1</tt>:</p>
#
#<table><tr><td>&nbsp;</td><td class=example><pre>
#\# mke2fs -b 4096 -I 128 -o hurd /dev/hda1
#</pre></td></tr></table>
#
#
#<h2>3. Boot loader</h2>
#
#<p>Il boot loader del sistema GNU è GRUB (GRand Unified Boot loader) e il suo
#scopo principale è avviare il cuore del sistema GNU (Mach e l'Hurd). Qualsiasi
#bootloader che supporti lo standard multiboot può essere usato per caricare
#Mach e l'Hurd. Al momento (noi sappiamo che) GNU GRUB è l'unico boot loader
#che supporta questo standard.</p>
#
#<p>Una parola su Grub, diversamente dai boot loader tradizionali per x86,
#come LILO, Grub è veramente molto potente. Ha una interfaccia a riga di
#comando, bootp, il supporto per terminali virtuali e una grande quantità di
#altre funzionalità. Inoltre è in grado di avviare quasi tutti i kernel, se
#non avete mai avviato una alpha o una sparc allora non potete capire cosa
#può fare Grub. Quindi, non vi preoccupate: Grub è il migliore. Vi piacerà.
#Non tornerete indietro.</p>
#
#<p>Probabilmente è consigliabile installare
#<a href="http://packages.debian.org/grub2">Grub</a> prima di installare Hurd,
#comunque è possibile eseguire l'installazione di Grub sul disco fisso anche
#in seguito.</p>
#
#
#<h2>4. Cross-installazione</h2>
#
#<p>Il passo successivo è scaricare il sistema di base. Ci sono diverse
#possibilità, se è in esecuzione un sistema Debian si può usare il pacchetto
#crosshurd altrimenti si può recuperare il tarball del sistema di base da un
#qualsiasi mirror indicato in
#<url "http://wiki.debian.org/DebianPorts/Mirrors" />.</p>
#
#<p>Il tarball è impostato per estrarre tutto il suo contenuto nella directory
#attuale. L'archivio può essere estratto solo dopo aver montato un filesystem.
#Supponendo che il filesystem sia su <tt>/dev/hda2</tt>, che il mount point sia
#<tt>/gnu</tt> e che l'archivio sia nella directory home dell'utente allora è
#necessario:</p>
#
#<table><tr><td>&nbsp;</td><td class=example><pre>
#\# mount -t ext2 /dev/hda2 /gnu
#\# cd /gnu
#\# tar --same-owner -xvjpf ~/gnu.tar.bz2
#</pre></td></tr></table>
#
#
#<h2>5. Avvio di GNU/Hurd</h2>
#
#<p>Adesso tutto è pronto per avviare GNU/Hurd per la prima volta. Notare che
#in base alla versione di Grub alcuni dettagli possono cambiare. Assicurarsi
#di disporre di GRUB1 (il vecchio 0.95 o il successivo 0.97) o GRUB2 (noto
#come 1.95 e successivi). In seguito sono forniti esempi per entrambe le versioni,
#usare quelllo corretto.</p>
#
#<p>Sono stati rilevati alcuni problemi quando si avvia con solo 128MB di
#memoria perché in questa fase la memoria di swap non è stato ancora
#configurata. Assicurarsi di avere almeno 256MB di memoria.</p>
#
#Se sul sistema è già installato GRUB, è sufficiente riavviare. Altrimenti,
#è necessario usare un dischetto per avviare Grub. Su Debian i pacchetti
#grub-disk (grub1) o grub-rescue-pc (grub2) forniscono le immagini per CD e
#dischetti. Inserire il dischetto di avvio di Grub nel nettore e reiavviare.
#Se tutto funziona verrà mostrato il menu o la riga di comando di Grub. Se
#nel menu è già presente una voce per <tt><q>GNU/Hurd</q></tt>, probabilmente
#si può usarla senza dover scrivere un sacco di roba. Per adesso, se viene
#mostrato il menu, premere <kbd>c</kbd> per avere la riga di comando.<p>
#
#<p>Per prima cosa si deve caricare GNU Mach, questo richiede la conoscenza
#del filesystem e del percorso di GNU Mach. Grub usa una nomenclatura
#leggermente diversa da Linux, per Hurd: i dischi IDE e SCSI sono entrambi
#nominati <tt><q>(hdN,M)</q></tt>. <code>N</code> è il numero del dispositivo
#(partendo da zero) fornito dal BIOS, quindi Grub non fa distinzione fra dischi
#SCSI e IDE. <code>M</code> identifica la partizione sul disco, parte da zero
#con grub1 ma parte da 1 con grub2. Se questo confonde non c'è da preoccuparsi:
#Grub fornisce molti aiuti.</p>
#
#<p>Per determinare su quale filesystem risiede un particolare file Grub
#fornisce il comando <code>find</code>. Quando questo comando viene dato
#insieme al nome di un file, Grub cerca su ogni filesystem il file specificato
#e mostra dove è stato trovato. Per esempio per cercare il kernel
#<tt>/boot/gnumach.gz</tt>:</p>
#
#<table>
#<tr><td>&nbsp;</td><td class=example><pre>
#   grub1&#62; find /boot/gnumach.gz
#   (hd0,0)
#</pre></td></tr>
#<tr><td>&nbsp;</td><td class=example><pre>
#   grub2&#62; search -f /boot/gnumach.gz
#   (hd0,1)
#</pre></td></tr>
#</table>
#
#<p>Dove indica per Grub1 che <tt><q>/boot/gnumach.gz</q></tt> è su
#<tt><q>(hd0,0)</q></tt> e per Grub2, su <tt><q>(hd0,1)</q></tt> (ricordarsi
#la differenza tra Grub1 e Grub2 nel numerare le partizioni). Per risparmiara
#un po' di scrittura, impostare la root di Grub a questo valore:</p>
#
#<table>
#<tr><td>&nbsp;</td><td class=example><pre>
#   grub1&#62; root (hd0,0)
#</pre></td></tr>
#<tr><td>&nbsp;</td><td class=example><pre>
#   grub2&#62; set root=(hd0,1)
#</pre></td></tr>
#</table>
#
#<p>Prima di caricare il kernel deve essere specificata sulla riga di comando
#almeno un'altra opzione, la partizione di root. Questa verrà usata da Hurd
#(cioè non da Grub) e quindi dovrà essere in un formato che Hurd possa
#capire.</p>
#
#<p>GNU Mach numera i dischi partendo da zero. I dispositivi IDE hanno il
#prefisso <code>hd</code> mentre i dischi SCSI hanno il prefisso
#<code>sd</code>. Come avviene con Linux i dischi sono numerati in base alla
#loro posizione sul controller. Per esempio il master su canale primario è
#<code>hd0</code> e lo slave su canale secondario è <code>hd3</code>. Le
#partizioni seguono la nomenclatura delle partizioni BSD, si aggiunge
#<code>sM</code> al nome del disco per indicare una certa partizione. Notare
#che <code>M</code> inizia a contare da uno e non da zero. Il numero della
#partizione è semplice da calcolare: con Grub2, riusare lo stesso indice,
#con Grub1, basta incrementare di uno il valore usato da Grub1.</p>
#
#<p>Dal momento che Hurd non è stato ancora configurato è necessario avviare il
#sistema in modalità singolo-utente, è sufficiente aggiungere <q><var>-s</var></q>
#alla riga di comando del kernel.</p>
#
#<p>Riassumendo, supponendo che il primo disco (cioè <tt><q>(hd0)</q></tt>) sia
#il master sul controller primario, si userà:</p>
#
#<table>
#<tr><td>&nbsp;</td><td class=example><pre>
#   grub1&#62; kernel /boot/gnumach.gz root=device:hd0s1 -s
#   [Multiboot-elf, ...]
#</pre></td></tr>
#<tr><td>&nbsp;</td><td class=example><pre>
#   grub2&#62; multiboot /boot/gnumach.gz root=device:hd0s1 -s
#</pre></td></tr>
#</table>
#
#<p>Successivamente devono essere caricati il servente per il filesystem di
#root e il servente <code>exec</code>. Questo si può fare grazie alla capacità
#di Grub di avviare i moduli. Le ${var} sono inserite da GNU Mach. Gli
#argomenti sono usati da Hurd per indicare quale tipo di informazione sarà
#fornita. Dato che la riga di comando di ext2fs è molto lunga la si può
#spezzare usando la sequenza di escape del carattere a capo nello stesso modo
#usato normalmente in Unix. Assicurarsi di non lasciare spazi dopo il
#contro-slash finale di ogni riga inoltre assicurarsi di distinguere
#<kbd>{</kbd> e <kbd>}</kbd> da <kbd>(</kbd> e <kbd>)</kbd>. Tenere in mente
#la sottile differenza tra Grub1 e Grub2: Grub2 ha bisogno che il nome del
#file sia ripetuto e tre deve essere tra virgolette. Notare che a questo
#punto l'opzione --readonbly di <code>ext2fs.static</code> non deve essere
#passata.</p>
#
#<table>
#<tr><td>&nbsp;</td><td class=example><pre>
#  grub1&#62; module /hurd/ext2fs.static \
#   --multiboot-command-line=${kernel-command-line} \
#   --host-priv-port=${host-port} \
#   --device-master-port=${device-port} \
#   --exec-server-task=${exec-task} -T typed ${root} \
#   $(task-create) $(task-resume)
#    [Multiboot-module  0x1c4000, 0x2cfe6a bytes]
#  grub1&#62; module /lib/ld.so.1 /hurd/exec $(exec-task=task-create)
#    [Multiboot-module  0x494000, 0x27afe bytes]
#</pre></td></tr>
#<tr><td>&nbsp;</td><td class=example><pre>
#  grub2&#62; module /hurd/ext2fs.static ext2fs \
#   --multiboot-command-line='${kernel-command-line}' \
#   --host-priv-port='${host-port}' \
#   --device-master-port='${device-port}' \
#   --exec-server-task='${exec-task}' -T typed '${root}' \
#   '$(task-create)' '$(task-resume)'
#  grub2&#62; module /lib/ld.so.1 exec /hurd/exec '$(exec-task=task-create)'
#</pre></td></tr>
#</table>
#
#<p>In alternativa è possibile inserire queste righe nel file di configurazione
#<tt><q>menu.lst</q></tt> (Grub1) o <tt><q>grub.cfg</q></tt> (Grub2) nella
#partizione e caricarle dal prompt di grub usando
#<tt><q>configfile /percorso/a/menu.lst</q></tt> (Grub1) o
#<tt><q>configfile /percorso/a/grub.cfg</q></tt> (Grub2). Ovviamente è possibile
#anche installare grub in qualche MBR e avviare da lì.</p>
#
#<p>Adesso GNU/Hurd può essere avviato con:</p>
#
#<table><tr><td>&nbsp;</td><td class=example><pre>
#grub&#62; boot
#</pre></td></tr></table>
#
#<p>Se GNU/Hurd non si avvia potrebbe essere colpa di IRQ condivisi: GNU Mach
#non li gestisce molto bene. Si può verificare questa situazione guardando,
#per esempio, il file <tt>/proc/interrupts</tt> sotto GNU/Linux. Inoltre, dato
#che GNU Mach non supporta i moduli del kernel molti dei driver sono compilati
#nel kernel, se nel sistema sono presenti delle vecchie periferiche queste
#potrebbero creare dei problemi infatti un dispositivo potrebbe rispondere in
#modo non corretto a un segnale rivolto a un dispositivo completamente
#indipendente e quindi causare un crash. Di solito compilare un nuovo kernel
#con solo i driver dei dispositivi necessari risolve questo genere di problemi,
#GNU Mach è facilmente cross-compilabile. Se si usa Debian si installi il
#pacchetto <tt><q>mig</q></tt> e il compilatore <tt><q>gcc</q></tt>.</p>
#
#<p>Se questo non è di aiuto si chieda sull'appropriata lista di
#messaggi.</p>
#
#
#<h2>6. Installazione nativa</h2>
#
#<p>Una volta che si dispone del prompt della shell e ogni volta che Hurd è
#in modalità singolo-utente è necessario impostare il tipo di terminale:</p>
#
#<table><tr><td>&nbsp;</td><td class=example><pre>
#\# export TERM=mach
#</pre></td></tr></table>
#
#<p>Avviso: <kbd>CONTROL-C</kbd> e famiglia non funzionano nella modalità
#singolo-utente.</p>
#
#<p>Adesso è possibile eseguire lo script <code>native-install</code>. Questo
#configurerà i pacchetti e imposterà molti importanti traduttori:</p>
#
#<table><tr><td>&nbsp;</td><td class=example><pre>
#\# ./native-install
#</pre></td></tr></table>
#
#<p>La fine prematura dello script indica che è possibile riavviare ed entrare
#in modalità multi-utente. Fatto questo, Hurd è pronto!</p>
#
#
#<h2>7. Configurazione</h2>
#
#
#<h3>7.1 La rete</h3>
#
#<p>Come prima cosa assicurarsi che la propria scheda di rete sia
#riconosciuta da GNU Mach:</p>
#
#<table><tr><td>&nbsp;</td><td class=example><pre>
#\# devprobe eth0
# eth0
#</pre></td></tr></table>
#
#<p>Se <code>devprobe eth0</code> non restituisce <code>eth0</code>, il
#kernel non ha rilevato la scheda di rete ed è necessario provare con
#un'altra scheda. Per esempio, la scheda e1000 di qemu non è supportata,
#invece la pcnet dovrebbe funzionare con: <code>-net nic,model=pcnet
#-net user</code>.</p>
#
#<p>Per configurare la rete è necessario configurare prima il traduttore
#pfinet. Questo lo si fa con il comando <code>settrans</code> che collega
#un tradutore a un certo nodo del filesystem e quando i programmi accedono
#al nodo, per esempio inviando un RPC, il sistema operativo avvia in modo
#trasparente il servente per gestire la richiesta.</p>
#
#<table><tr><td>&nbsp;</td><td class=example><pre>
#\# settrans -fgap /servers/socket/2 /hurd/pfinet -i eth0 \
#   -a a.b.c.d -g e.f.g.h -m i.j.k.l
#</pre></td></tr></table>
#
#<p>In questo esempio a <code>settrans</code> sono state passate diverse
#opzioni. Le prime due <q><var>fg</var></q> forzano tutti i traduttori esistenti
#a disattivarsi. Le due successive <q><var>ap</var></q> creano un traduttore sia
#attivo che passivo, rendendo attivo un traduttore si possono immediatamente
#vedere i messaggi di errore su <tt>stderr</tt>. Le opzioni seguenti salvano
#il traduttore e gli argomenti nel nodo e quindi può essere riavviato in modo
#trasparente in seguito (cioè rendono le impostazioni persistenti ai riavvii
#del sistema). Le opzioni sono seguite dal nodo a cui deve essere collegato
#il traduttore, infine c'è il programma (cioè il traduttore) da eseguire e
#tutti gli argomenti da passargli. L'opzione <q><var>-i</var></q> è l'interfaccia
#su cui <code>pfinet</code> si metterà in ascolto, <q><var>-a</var></q> è
#l'indirizzo IP, <q><var>-g</var></q> è il gateway e <q><var>-m</var></q> è la maschera
#di rete.</p>
#
#<p>Assicurarsi di aggiungere i name server nel file
#<tt>/etc/resolv.conf</tt>:</p>
#
#<table><tr><td>&nbsp;</td><td class=example><pre>
#nameserver 192.168.1.1
#</pre></td></tr></table>
#
#<p>Testare la configurazione con <code>ping -c2 gateway</code>, l'opzione
#<samp>-c</samp> è importantre per limitare il numero di ping, infatti
#<kbd>CONTROL-C</KBD> non funziona in modalità singolo-utente.</p>
#
#<p>DHCP ancora non funziona con Hurd. Questo è dovuto alle limitazioni di
#pfinet: è basato sul codice TCP/IP di Linux ed è incapace di ascoltare su
#<tt>0.0.0.0</tt>.</p>
#
#<p>Aiuto su <code>settrans</code> può essere ottenuto passando l'opzione
#<samp>--help</samp>. L'aiuto su uno specifico traduttore può essere ottenuto
#invocandolo dalla riga di comando con lo stesso argomento, per esempio:</p>
#
#<table><tr><td>&nbsp;</td><td class=example><pre>
#\# /hurd/pfinet --help
#</pre></td></tr></table>
#
#<p>Come in questo caso può essere generato molto output, si tenga
#in considerazione l'uso di una pipe con un impaginatore come
#<code>less</code>.</p>
#
#
#<h3>7.2 Ulteriori filesystem</h3>
#
#<p>Il passo successivo è modificare <tt>/etc/fstab</tt> per aggiungere altri
#filesystem e lo spazio di swap. È <em>molto importante</em> usare lo
#spazio di swap, l'Hurd risulterà di un ordine di grandezza più stabile. Notare
#che l'Hurd può condividere in modo trasparente una partizione di swap con
#Linux ma sarà anche lieto di condividere qualsiasi altro dispositivo comprese
#partizioni grezze come la partizione con la home. Normalmente <code>nano</code>
#è l'unico editor installato con la distribuzione di base.</p>
#
#<p>Questo è un esempio del file <tt>/etc/fstab</tt>:</p>
#
#<table><tr><td>&nbsp;</td><td class=example><pre>
#\# &#60;file system&#62; &#60;mount point&#62;   &#60;type&#62;  &#60;options&#62;  &#60;dump&#62;  &#60;pass&#62;
#/dev/hd0s1      /               ext2    rw         0       1
#/dev/hd0s2      /home           ext2    rw         0       2
#/dev/hd0s3      none            swap    sw         0       0
#</pre></td></tr></table>
#
#<p>Ricordarsi di creare tutti i device con il comando <code>MAKEDEV</code>:</p>
#
#<table><tr><td>&nbsp;</td><td class=example><pre>
#\# cd /dev
#\# ./MAKEDEV hd0s1 hd0s2 hd0s3
#</pre></td></tr></table>
#
#<p>Per montare un filesystem nfs viene usato il traduttore
#<code>/hurd/nfs</code>. Quando è eseguito da un utente non privilegiato il
#traduttore si connette al server utilizzando una porta superiore alla 1023.
#Normalmente GNU/Linux non permette questo comportamento, per far accettare
#a GNU/Linux le connessioni da porte non riservate si deve aggiungere
#l'opzione <samp>insicure</samp> nella riga export. Segue un esempio di
#<tt>/etc/exports</tt> in cui si suppone che l'indirizzo IP del client sia
#<tt>192.168.1.2</tt>:</p>
#
#<table><tr><td>&nbsp;</td><td class=example><pre>
#/home  192.168.1.2(rw,insecure)
#</pre></td></tr></table>
#
#<p>Per montarlo sul sistema GNU supponendo che l'indirizzo IP del server nfs
#sia <tt>192.168.1.1</tt> usare:</p>
#
#<table><tr><td>&nbsp;</td><td class=example><pre>
#\# settrans -cgap /mount/point /hurd/nfs 192.168.1.1:/home
#</pre></td></tr></table>
#
#
#<h3>7.3 Riavvio</h3>
#
#<p>Infine riavviare in modalità multiutente, cioè nello stesso modo usato
#per la modalità singolo-utente ma tralasciando l'opzione <samp>-s</samp>
#quando si carica il kernel. Per i dettagli vedere la sezione 5. Avvio di
#GNU/Hurd.</p>
#
#<p>Buon divertimento!</p>
#

<h2>8. Ritocchi finali</h2>

#<h3>8.1 Il menu di Grub</h3>
#
#<p>Dover caricare il kernel a mano può essere molto tedioso. Modificare
#<tt><q>/boot/grub/menu.lst</q></tt> con Grub1 o <tt><q>/boot/grub/grub.cfg</q></tt>
#con Grub2 e adattarlo alle proprie esigenze, l'avvio del sistema diventerà
#molto più veloce e molto più semplice.</p>
#
#
#<h3>8.2 Aggiunta di device</h3>
#
#<p>Normalmente solo pochi device sono creati nella directory <tt>/dev</tt>.
#Usare lo script <code>MAKEDEV</code> per creare i device node di cui si
#necessita.</p>
#

<h3>8.3 Installazione di altri pacchetti</h3>

<p>Esistono diversi modi per aggiungere dei pacchetti, scaricarli e usare
<code>dpkg -i</code> funziona ma è molto scomodo. Il modo più semplice è
usare <code>apt-get</code>. Aggiungere una delle prossime righe da
<url "http://wiki.debian.org/DebianPorts/Mirrors" /> di unreleased a
<tt><q>/etc/apt/sources.list</q></tt>:</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
deb http://ftp.debian-ports.org/debian unreleased main
</pre></td></tr></table>

<p><url "http://ftp.debian-ports.org/" /> e i suoi mirror contengono dei pacchetti
modificati o delle patch che ancora non sono stati integrati nella versione
originale o in Debian.</p>

<p>E da unstable su uno dei mirror Debian (si veda
<url "http://www.debian.org/mirror/list"/> per l'elenco completo) che contiene
l'architettura hurd:</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
deb http://ftp.de.debian.org/debian unstable main
</pre></td></tr></table>

<p><url "http://ftp.debian-ports.org/" /> e i mirror contengono dei pacchetti
modificati o delle patch che ancora non sono stati integrati nella verisone
originale o in debian. Per usare un mirror locale Debian vedere
<url "http://www.debian.org/distrib/ftplist" />.</p>

<p>Se GNU Mach non riconosce la scheda di rete o si usa un modem, l'unico
modo per aggiornare i pacchetti è scaricarli e poi trasferirli nel sistema
GNU. Il modo più semplice per fare queste operazioni è usare apt fuori-linea.
Vedere <tt>/usr/share/doc/apt-doc/offline.text.gz</tt> per le istruzioni
dettagliate.</p>


<h3>8.4 La console Hurd</h3>

<p>Oltre alla console Mach già vista durante l'installazione, GNU/Hurd ha
una potente console in spazio-utente che fornisce terminali virtuali.
Attualmente è necessario avviare manualmente la console Hurd con il seguente
comando:</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
\# console -d vga -d pc_mouse --repeat=mouse -d pc_kbd --repeat=kbd -d generic_speaker -c /dev/vcs
</pre></td></tr></table>

<p>Nella console Hurd si può passare da iun terminale virtuale a un altro
con <kbd>ALT+F1</kbd>, <kbd>ALT+F2</kbd> e così via.
<kbd>ALT+CTRL+BACKSPACE</kbd> chiude la console Hurd causando il ripristino
della console Mach da dove si può riaprire la console Hurd con il comando
precedente.</p>


<h3>8.5 X.Org</h3>

<p>È stato fatto il port di X.Org, tutte le schede video supportate
che non richiedono un modulo del kernel o drm dovrebbero funzionare.</p>

<p>È necessario essere nella console Hurd e ripetere l'installazione
come indicato nella Sezione 8.4.</p>

<p>Sono necessari parecchi pacchetti per X. <code>x-window-core</code>,
<code>rxvt</code> e <code>twm</code>, <code>fvwm</code> o <code>wmaker</code>
sono un buon inizio.</p>

<p>X.Org funziona senza alcun file di configurazione. In alcuni casi potrebbe
essere necessario usa il driver vesa.</p>

<p>Infine, eseguire <code>startx</code>.</p>

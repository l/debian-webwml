#use wml::debian::template title="Debian GNU/Hurd &ndash; Installazione" NOHEADER="yes"
#include "$(ENGLISHDIR)/ports/hurd/menu.inc"
#use wml::debian::translation-check translation="1.40" maintainer="Luca Monducci"

<h1>Installazione di Debian GNU/Hurd</h1>

<p>Questo documento vuole fornire un insieme di istruzioni semplici e
relativamente indolori su come installare e far funzionare Debian GNU/Hurd
con il minimo sforzo.</p>

<p>&Egrave; basato sulla <a href="http://web.walfield.org/pub/people/neal/papers/hurd-installation-guide/english/hurd-install-guide.html">\
Guida all'installazione di Hurd</a> di Neal H. Walfield. Grazie a Neal per
il suo contributo.</p>

<p>Notare che alcuni punti di questo manuale sono un po' fastidiosi perché
richiedono molto tempo e potrebbero essere causa di problemi. Potrebbe essere
preferibile, in particolare se si è agli inizi, l'installazione tramite le
<a href="hurd-cd">immagini dei CD già pronte</a>. Anche se sono vecchie di
solito funzionano e in seguito si possono prelevare gli aggiornamenti dai
repository online.</p>

<h2>1. Introduzione</h2>

<p>La distribuzione Debian GNU/Hurd, diversamente dalle distribuzioni di
altri sistemi operativi, non ha un bel sistema di installazione. Prima o poi
verrà realizzato e forse voi contribuirete al suo progetto o alla sua
implementazione, comunque, fino ad allora l'installazione di Debian GNU/Hurd
richiede un altro sistema operativo e in particolare un altro sistema
Unix-like. Molti utenti hanno riportato installazioni concluse con successo
usando varie versioni di GNU/Linux e addirittura con BDS. I requisiti minimi
del sistema di avvio sono la capacità di: creare un filesystem ext2, estrarre
un archivio tar e installare GNU Grub.</p>

<p>La natura di GNU è simile a qualsiasi altro sistema Unix-like: dopo il
login all'utente viene presentata una shell e il familiare VFS (filesystem
virtuale) di Unix. Nonostante GNU tenti di essere conforme a POSIX, è "Non
Unix". GNU/Hurd è basato su molti dei concetti di Unix e li estende sia
aggiungendo nuove funzionalità che correggendo le cose che sono percepite
come imperfette nel progetto originale. La differenza più grande sono i
traduttori, dei programmi in spazio utente che interagiscono con il VFS.
Questi filesystem non risiedono nel kernel e nemmeno necessitano di essere
eseguiti come root; l'unica cosa che richiedono è l'accesso al supporto
sottostante e un <code>mount point</code>. Un'altra differenza è che i
processi anziché avere l'identità di un singolo utente fissata al momento
della creazione, hanno le informazioni sull'identità separate dal processo,
quindi, con i giusti permessi, si possono aggiungere o rimuovere identità.</p>

<p>Essendo parente stretto dell'ambiente Unix (e in particolar modo dello
spazio utente GNU che si trova in varianti anche molto popolari come GNU/Linux)
è imperativo sentirsi a proprio agio con GNU. L'esperienza con gli strumenti
Debian si rivela preziosa anche per la configurazione e la manutenzione di una
macchina con GNU/Hurd.</p>

<p>Questa guida si sforza di rendere il processo di installazione di GNU/Hurd
il più semplice possibile. Se si riscontrano degli errori (che sono certamente
dovuti all'autore) si prega di segnalarli insieme a qualsiasi suggerimento o
critica si voglia fare all'autore stesso; viene accettato tutto con immenso
piacere.</p>

<h2>2. Casa di proprietà o cercarne una</h2>

<p>Se non si dispone di una partizione disponibile o di un hard disk
aggiuntivo questo può essere il passo più lungo, infatti in questo caso è necessario
ripartizionare l'hard disk. Una possibilità è usare l'editor di partizioni
di GNU, Parted. Non solo permette la modifica di base delle partizioni ma
permette anche il ridimensionamento e lo spostamento delle partizioni.
&Egrave; possibile trovarlo su <url "http://www.gnu.org/software/parted" />.
Il manuale è abbastanza completo e include svariati tutorial.</p>

<p>Hurd supporta diverse estensioni al formato del filesystem ext2fs. Le cose
più importanti fra queste sono i traduttori passivi e un quarto gruppo di bit
con i permessi per gli utenti sconosciuti (gli utenti senza identità, non gli
utenti "other"). Per usare queste estensioni il proprietario della partizione
deve essere impostato a <code>hurd</code>. <code>mke2fs</code>, a meno che non
sia specificato diversamente sulla riga di comando, imposta come proprietario
qualsiasi kernel sia in esecuzione. Dal momento che Hurd rispetta diligentemente
questa impostazione si deve prestare molta attenzione dando il valore
appropriato altrimenti Hurd si comporterà in modo impredicibile. Attenzione,
anche se un filesystem è in possesso di un particolare kernel, altri kernel
possono continuare a usarlo ma potrebbero non essere capaci di usare certe
estensioni.</p>

<p>Per creare un filesystem usare <code>mke2fs</code> e passare <samp>-b 4096
-o hurd</samp> per indicare l'Hurd come proprietario del nuovo filesystem. Per
esempio, supponendo che la partizione sia <tt>/dev/hda2</tt>:

<table><tr><td>&nbsp;</td><td class=example><pre>
\# mke2fs -o hurd /dev/hda2
</pre></td></tr></table>


<h2>3. Boot loader</h2>

<p>Il boot loader del sistema GNU è GRUB (GRand Unified Boot loader) e il suo
scopo principale è avviare il cuore del sistema GNU (Mach e l'Hurd). Qualsiasi
bootloader che supporti lo standard multiboot può essere usato per caricare
Mach e l'Hurd. Al momento (noi sappiamo che) GNU GRUB è l'unico boot loader
che supporta questo standard.</p>

<p>Una parola su Grub, diversamente dai boot loader tradizionali per x86,
come LILO, Grub è veramente molto potente. Ha una interfaccia a riga di
comando, bootp, il supporto per terminali virtuali e una grande quantità di
altre funzionalità. Inoltre è in grado di avviare molti altri kernel, se
non avete mai avviato una alpha o una sparc allora non potete capire cosa
può fare Grub. Quindi, non vi preoccupate: Grub è il migliore. Vi piacerà.
Non tornerete indietro.</p>

<p>Per procurarsi Grub si visiti <url "http://www.gnu.org/software/grub/" />.
Sono disponibili il tarball con i sorgenti e l'immagine di un floppy. Se si
sceglie di scaricare il tarball usare i normali <code>configure</code>,
<code>make</code> e <code>make install</code>. &Egrave; incluso un manuale
magnificamente completo sul funzionamento di Hurd, leggetelo. Se, d'altra
parte, si sceglie di scaricare l'immagine del floppy è sufficiente scriverla
su un dischetto per avere Grub funzionante, per esempio:</p>

<table><tr><td>&nbsp;</td><td class=example><pre># dd if=grub-boot-image of=/dev/fd0
</pre></td></tr></table>

<p>&Egrave; possibile installare Grub sul disco fisso successivamente.</p>


<h2>4. Cross-installazione</h2>

<p>Il passo successivo è scaricare il sistema di base. Ci sono diverse
possibilità, se è in esecuzione un sistema Debian si può usare il pacchetto
crosshurd altrimenti si può recuperare il tarball del sistema di base da
<url "http://ftp.gnuab.org/pub/debian/base/"> in Spagna,
<url "http://www.superunprivileged.org/debian/base/"> in Canada e
<url "http://ftp.easynet.be/ftp/gnuab/debian/base/"> in Belgium.
</p>

<p>Il tarball è impostato per estrarre tutto il suo contenuto nella directory
attuale. L'archivio può essere estratto solo dopo aver montato un filesystem.
Supponendo che il filesystem sia su <tt>/dev/hda2</tt>, che il mount point sia
<tt>/gnu</tt> e che l'archivio sia nella directory home dell'utente allora è
necessario:</p>

<table><tr><td>&nbsp;</td><td class=example><pre># mount -t ext2 /dev/hda2 /gnu
\# cd /gnu
\# tar --same-owner -xvjpf ~/gnu.tar.bz2
</pre></td></tr></table>


<h2>5. Avvio di GNU/Hurd</h2>

<p>Adesso tutto è pronto per avviare GNU/Hurd per la prima volta. Dopo aver
verificato che il dischetto di avvio con Grub sia inserito nel drive riavviare
il sistema. Se tutto va bene verrà mostrato il menu o la riga di comando di
Grub. Se si presenta il menu premere <kbd>c</kbd> per passare alla riga di
comando.</p>

<p>Per prima cosa si deve caricare GNU Mach, questo richiede la conoscenza
del filesystem e del percorso di GNU Mach. Grub usa una nomenclatura
leggermente diversa sia da Linux che da Hurd: i dischi IDE e SCSI sono
entrambi nominati <tt>(hdN,M)</tt>. <code>N</code> è il numero del dispositivo
(partendo da zero) fornito dal BIOS, quindi Grub non fa distinzione fra dischi
SCSI e IDE. <code>M</code> identifica la partizione sul disco (anche questo
partendo da zero). Se questo confonde non c'è da preoccuparsi: Grub fornisce
molti aiuti.</p>

<p>Per determinare su quale filesystem risiede un particolare file Grub
fornisce il comando <code>find</code>. Quando questo comando viene dato
insieme al nome di un file, Grub cerca su ogni filesystem il file specificato
e mostra dove è stato trovato. Per esempio per cercare il kernel
<tt>/boot/gnumach.gz</tt>:</p>

<table><tr><td>&nbsp;</td><td class=example><pre>grub&#62; find /boot/gnumach.gz
   (hd0,0)
</pre></td></tr></table>

<p>In questo esempio Grub indica che <tt>/boot/gnumach.gz</tt> è su
<tt>(hd0,0)</tt>.</p>

<p>Prima di caricare il kernel deve essere specificata sulla riga di comando
almeno un'altra opzione, la partizione di root. Questa verrà usata da Hurd
(cioè non da Grub) e quindi dovrà essere in un formato che Hurd possa
capire.</p>

<p>GNU Mach numera i dischi partendo da zero. I dispositivi IDE hanno il
prefisso <code>hd</code> mentre i dischi SCSI hanno il prefisso
<code>sd</code>. Come avviene con Linux i dischi sono numerati in base alla
loro posizione sul controller. Per esempio il master su canale primario è
<code>hd0</code> e lo slave su canale secondario è <code>hd3</code>. Le
partizioni seguono la nomenclatura delle partizioni BSD, si aggiunge
<code>sM</code> al nome del disco per indicare una certa partizione. Notare
che <code>M</code> inizia a contare da uno e non da zero. Il numero della
partizione è semplice da calcolare: basta incrementare il valore usato da
Grub di uno.</p>

<p>Dal momento che Hurd non è stato ancora configurato è necessario avviare il
sistema in modalità singolo-utente, è sufficiente aggiungere <samp>-s</samp>
alla riga di comando del kernel.</p>

<p>Supponendo che il primo disco (cioè <tt>(hd0)</tt>) sia il master sul
controller secondario, si userà:</p>

<table><tr><td>&nbsp;</td><td class=example><pre>grub&#62; kernel (hd0,0)/boot/gnumach.gz root=device:hd2s1 -s
   [Multiboot-elf, ...]
</pre></td></tr></table>

<p>Successivamente devono essere caricati il servente per il filesystem di
root e il servente <code>exec</code>. Questo si può fare grazie alla capacità
di Grub di avviare i moduli. Le ${var} sono inserite da GNU Mach. Gli
argomenti sono usati da Hurd per indicare quale tipo di informazione sarà fornita.
Dato che la riga di comando di ext2fs è molto lunga la si può spezzare
usando la sequenza di escape del carattere a capo nello stesso modo usato
normalmente in Unix. Assicurarsi di non lasciare spazi dopo lo slash finale
di ogni riga inoltre assicurarsi di distinguere <kbd>{</kbd> e <kbd>}</kbd>
da <kbd>(</kbd> e <kbd>)</kbd>.</p>

<table><tr><td>&nbsp;</td><td class=example><pre>grub&#62; module (hd0,0)/hurd/ext2fs.static \
   --multiboot-command-line=${kernel-command-line} \
   --host-priv-port=${host-port} \
   --device-master-port=${device-port} \
   --exec-server-task=${exec-task} -T typed ${root} \
   $(task-create) $(task-resume)
    [Multiboot-module  0x1c4000, 0x2cfe6a bytes]
  grub&#62; module (hd0,0)/lib/ld.so.1 /hurd/exec $(exec-task=task-create)
    [Multiboot-module  0x494000, 0x27afe bytes]
</pre></td></tr></table>

<p>Una volta che Hurd è in esecuzione, il procedimento può essere automatizzato
inserendo gli appropriati comandi nel file di configurzione di Grub
<tt>/boot/grub/menu.lst</tt>.</p>

<p>Adesso GNU/Hurd può essere avviato con:</p>

<table><tr><td>&nbsp;</td><td class=example><pre>grub&#62; boot
</pre></td></tr></table>

<p>Se GNU/Hurd non si avvia potrebbe essere colpa di IRQ condivisi: GNU Mach
non li gestisce molto bene. Si può verificare questa situazione guardando,
per esempio, il file <tt>/proc/interrupts</tt> sotto GNU/Linux. Inoltre, dato
che GNU Mach non supporta i moduli del kernel molti dei driver sono compilati
nel kernel, se nel sistema sono presenti delle vecchie periferiche queste
potrebbero creare dei problemi infatti un dispositivo potrebbe rispondere in
modo non corretto a un segnale rivolto a un dispositivo completamente
indipendente e quindi causare un crash. Di solito compilare un nuovo kernel
con solo i driver dei dispositivi necessari risolve questo genere di problemi,
GNU Mach è facilmente cross-compilabile. Se si usa Debian si installi il
pacchetto <tt>gcc-i386-gnu</tt>.</p>

<p>Se questo non è di aiuto si consulti i riferimenti elencati alla fine di
questo documento e come ultima risorsa si chieda sull'appropriata lista di
messaggi.</p>


<h2>6. Installazione nativa</h2>

<p>Una volta che si dispone del prompt della shell e ogni volta che Hurd è
in modalità singolo-utente è necessario impostare il tipo di terminale:</p>

<table><tr><td>&nbsp;</td><td class=example><pre># export TERM=mach
</pre></td></tr></table>

<p>Avviso: <kbd>CONTROL-C</kbd> e famiglia non funzionano nella modalità
singolo-utente.</p>

<p>Adesso è possibile eseguire lo script <code>native-install</code>. Questo
configurerà i pacchetti e imposterà molti importanti traduttori:</p>

<table><tr><td>&nbsp;</td><td class=example><pre># ./native-install
</pre></td></tr></table>

<p>La fine premetura dello script indica che è necessario eseguirlo una
seconda volta. Seguite le sue istruzioni e riavviate usando il comando
<code>reboot</code>. Si entri nuovamente in modalità singolo-utente e si
esegua di nuovo <code>./native-install</code>.</p>


<h2>7. Configurazione</h2>


<h3>7.1 La rete</h3>

<p>Per configurare la rete è necessario configurare prima il traduttore
pfinet. Questo lo si fa con il comando <code>settrans</code> che collega
un tradutore a un certo nodo del filesystem e quando i programmi accedono
al nodo, per esempio inviando un RPC, il sistema operativo avvia in modo
trasparente il servente per gestire la richiesta.</p>

<table><tr><td>&nbsp;</td><td class=example><pre># settrans -fgap /servers/socket/2 /hurd/pfinet -i eth0 \
   -a a.b.c.d -g e.f.g.h -m i.j.k.l
</pre></td></tr></table>

<p>In questo esempio a <code>settrans</code> sono state passate diverse
opzioni. Le prime due <samp>fg</samp> forzano tutti i traduttori esistenti
a disattivarsi. Le due successive <samp>ap</samp> creano un traduttore sia
attivo che passivo, rendendo attivo un traduttore si possono immediatamente
vedere i messaggi di errore su <tt>stderr</tt>. Le opzioni seguenti salvano
il traduttore e gli argomenti nel nodo e quindi può essere riavviato in modo
trasparente in seguito (cioè rendono le impostazioni persistenti ai riavvii
del sistema). Le opzioni sono seguite dal nodo a cui deve essere collegato
il traduttore, infine c'è il programma (cioè il traduttore) da eseguire e
tutti gli argomenti da passargli. L'opzione <samp>-i</samp> è l'interfaccia
su cui <code>pfinet</code> si metterà in ascolto, <samp>-a</samp> è
l'indirizzo IP, <samp>-g</samp> è il gateway e <samp>-m</samp> è la maschera
di rete.</p>

<p>Assicurarsi di aggiungere i name server nel file
<tt>/etc/resolv.conf</tt>:</p>

<table><tr><td>&nbsp;</td><td class=example><pre>nameserver 192.168.1.1
</pre></td></tr></table>

<p>Testare la configurazione con <code>ping -c2 gateway</code>, l'opzione
<samp>-c</samp> è importantre per limitare il numero di ping, infatti
<kbd>CONTROL-C</KBD> non funziona in modalità singolo-utente.</p>

<p>DHCP ancora non funziona con Hurd. Questo è dovuto alle limitazioni di
pfinet: è basato sul codice TCP/IP di Linux ed è incapace di ascoltare su
<tt>0.0.0.0</tt>.</p>

<p>Aiuto su <code>settrans</code> può essere ottenuto passando l'opzione
<samp>--help</samp>. L'aiuto su uno specifico traduttore può essere ottenuto
invocandolo dalla riga di comando con lo stesso argomento, per esempio:</p>

<table><tr><td>&nbsp;</td><td class=example><pre># /hurd/pfinet --help
</pre></td></tr></table>

<p>Come in questo caso può essere generato molto output, si tenga
in considerazione l'uso di una pipe con un impaginatore come
<code>less</code>.</p>


<h3>7.2 Ulteriori filesystem</h3>

<p>Il passo successivo è modificare <tt>/etc/fstab</tt> per aggiungere altri
filesystem e lo spazio di swap. &Egrave; <em>molto importante</em> usare lo
spazio di swap, l'Hurd risulterà di un ordine di grandezza più stabile. Notare
che l'Hurd può condividere in modo trasparente una partizione di swap con
Linux ma sarà anche lieto di condividere qualsiasi altro dispositivo comprese
partizioni grezze come la partizione con la home. Normalmente <code>nano</code>
è l'unico editor installato con la distribuzione di base.</p>

<p>Questo è un esempio del file <tt>/etc/fstab</tt>:</p>

<table><tr><td>&nbsp;</td><td class=example><pre># &#60;file system&#62; &#60;mount point&#62;   &#60;type&#62;  &#60;options&#62;  &#60;dump&#62;  &#60;pass&#62;
/dev/hd2s1      /               ext2    rw         0       1
/dev/hd2s2      /home           ext2    rw         0       2
/dev/hd2s3      none            swap    sw         0       0
</pre></td></tr></table>

<p>Ricordarsi di creare tutti i device con il comando <code>MAKEDEV</code>:</p>

<table><tr><td>&nbsp;</td><td class=example><pre># cd /dev
\# ./MAKEDEV hd2s1 hd2s2 hd2s3
</pre></td></tr></table>

<p>Per montare un filesystem nfs viene usato il traduttore
<code>/hurd/nfs</code>. Quando è eseguito da un utente non privilegiato il
traduttore si connette al server utilizzando una porta superiore alla 1023.
Normalmente GNU/Linux non permette questo comportamento, per far accettare
a GNU/Linux le connessioni da porte non riservate si deve aggiungere
l'opzione <samp>insicure</samp> nella riga export. Segue un esempio di
<tt>/etc/exports</tt> in cui si suppone che l'indirizzo IP del client sia
<tt>192.168.1.2</tt>:</p>

<table><tr><td>&nbsp;</td><td class=example><pre>/home  192.168.1.2(rw,insecure)
</pre></td></tr></table>

<p>Per montarlo sul sistema GNU supponendo che l'indirizzo IP del server nfs
sia <tt>192.168.1.1</tt> usare:</p>

<table><tr><td>&nbsp;</td><td class=example><pre># settrans -cgap /mount/point /hurd/nfs 192.168.1.1:/home
</pre></td></tr></table>


<h3>7.3 Riavvio</h3>

<p>Infine riavviare in modalità multiutente, cioè nello stesso modo usato
per la modalità singolo-utente ma tralasciando l'opzione <samp>-s</samp>
quando si carica il kernel. Per i dettagli vedere la sezione 5. Avvio di
GNU/Hurd.</p>

<p>Buon divertimento!</p>


<h2>8. Ritocchi finali</h2>

<h3>8.1 Il menu di Grub</h3>

<p>Dover caricare il kernel a mano può essere molto tedioso. Modificare
<tt>/boot/grub/menu.lst</tt> e adattarlo alle proprie esigenze, l'avvio
del sistema diventerà molto più veloce e molto più semplice.</p>


<h3>8.2 Aggiunta di device</h3>

<p>Normalmente solo pochi device sono creati nella directory <tt>/dev</tt>.
Usare lo script <code>MAKEDEV</code> per creare i device node di cui si
necessita.</p>


<h3>8.3 Installazione di altri pacchetti</h3>

<p>Esistono diversi modi per aggiungere dei pacchetti, scaricarli e usare
<code>dpkg -i</code> funziona ma è molto scomodo. Il modo più semplice è
usare <code>apt-get</code>. Aggiungere una delle prossime righe da unreleased
a <tt>/etc/apt/sources.list</tt>:</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
deb http://ftp.gnuab.org/debian unreleased main
deb http://www.superunprivileged.org/debian unreleased main
deb http://ftp.easynet.be/ftp/gnuab/debian unrelease main
</pre></td></tr></table>

<p>E per unstable una Debian:</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
deb http://ftp.debian.org/debian unstable main
</pre></td></tr></table>

<p><url "http://ftp.gnuab.org/" /> e i mirror contengono dei pacchetti
modificati o delle patch che ancora non sono stati integrati nella verisone
originale o in Debian. Per usare un mirror locale Debian vedere
<url "http://www.debian.org/distrib/ftplist" />.</p>

<p>Se GNU Mach non riconosce la scheda di rete o si usa un modem, l'unico
modo per aggiornare i pacchetti è scaricarli e poi trasferirli nel sistema
GNU. Il modo più semplice per fare queste operazioni è usare apt fuori-linea.
Vedere <tt>/usr/share/doc/apt-doc/offline.text.gz</tt> per le istruzioni
dettagliate.</p>


<h3>8.4 La console Hurd</h3>

<p>Oltre alla console Mach già vista durante l'installazione, GNU Hurd ha
una potente console in spazio-utente che fornisce terminali virtuali.
Attualmente è necessario avviare manualmente la console Hurd con il seguente
comando:</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
\# console -d vga -d pc_mouse --repeat=mouse -d pc_kbd --repeat=kbd -d generic_speaker -c /dev/vcs
</pre></td></tr></table>

<p>Nella console Hurd si può passare da iun terminale virtuale a un altro
con <kbd>ALT+F1</kbd>, <kbd>ALT+F2</kbd> e così via.
<kbd>ALT+CTRL+BACKSPACE</kbd> chiude la console Hurd causando il ripristino
della console Mach da dove si può riaprire la console Hurd con il comando
precedente.</p>


<h3>8.5 XFree86</h3>

<p>&Egrave; stato fatto il port di XFree86, tutte le schede video supportate
che non richiedono un modulo del kernel dovrebbero funzionare.</p>

<p>&Egrave; necessario essere nella console Hurd e ripetere l'installazione
come indicato nella Sezione 8.4. Poiché XFree86 ha <code>/dev/kbd</code>
come device per la tastiera cablato nel codice è necessario creare un link
simbolico:</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
\# cd /dev
\# ln -s cons/kbd kbd
\# ln -s cons/mouse mouse
</pre></td></tr></table>

<p>Sono necessari parecchi pacchetti per X. <code>x-window-core</code>,
<code>rxvt</code> e <code>twm</code>, <code>fvwm</code> o <code>wmaker</code>
sono un buon inizio.</p>

<p>Si può usare debconf per configurare XFree86, comunque non è pronto per
Hurd e il file di configurazione deve essere ritoccato. Dopo la configurazione,
modificare la sezione pointer che deve diventare:</p>

<table><tr><td>&nbsp;</td><td class=example><pre>Section "Pointer"
  Protocol "osmouse"
  Device "/dev/mouse"
EndSection
</pre></td></tr></table>

<p><samp>Emulate3Buttons</samp> e <samp>ZAxisMapping</samp> devono essere
entrambi disattivati.</p>

<p>GNU/Hurd non usa ld.so.conf. Dato che <tt>/X11R6/lib</tt> non fa parte
del path predefinito di ricerca delle librerie, è necessario aggiungere a
<tt>/etc/profile</tt> o ai <tt>.profile</tt> di ogni utente:</p>

<table><tr><td>&nbsp;</td><td class=example><pre>export LD_LIBRARY_PATH=/X11R6/lib:$LD_LIBRARY_PATH
</pre></td></tr></table>

<p>Infine, eseguire <code>startx</code>.</p>

<p>Ci sono diverse cose da tenere in mente. <code>xterm</code> non funziona
correttamente quando è SETGID (perché ignora LD_LIBRARY_PATH e non riesce a
caricare le giuste librerie condivise) provare <code>rxvt</code>. Ancora non
è stato fatto il port di <code>update-menu</code> quindi mancano i menu
Debian. Sebbene esista l'implementazione di <code>pthreads</code> non è stato
fatto il port di tutti i pacchetti pthread: non pensate che GNOME o KDE
funzionino senza.</p>

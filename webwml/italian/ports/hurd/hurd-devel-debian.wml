#use wml::debian::template title="Debian GNU/Hurd -- Sviluppo" NOHEADER="yes"
#include "$(ENGLISHDIR)/ports/hurd/menu.inc"
#use wml::debian::translation-check translation="1.28" maintainer="Luca Monducci"

<h1>Debian GNU/Hurd</h1>

<h2>Sviluppo della distribuzione</h2>

<h3>Dischi di avvio</h3>

<p>In questo momento non si sta lavorando su dischi per l'avvio nativo,
comunque si stanno posando le loro fondamenta il che, qualche volta, comporta
il port di singoli pacchetti. Se si vuole contribuire, si aiuti il progetto
debian-installer e assicurarsi che i suoi componenti funzionino con Hurd.</p>

<h3>Port dei pacchetti Debian</h3>

<p>Se si desidera contribuire al port Debian GNU/Hurd è necessario aver
confidenza con il sistema di pacchettizzazione Debian. Una volta fatto questo
leggendo la documentazione disponibile e visitando <a href="../../devel/">\
l'angolo degli sviluppatori</a> si dovrebbe essere in grado estrarre i
pacchetti sorgente Debian e creare un pacchetto binario Debian. Per le persone
più pigre è disponibile un corso rapido:</p>

<h3>Recuperare i sorgenti e creare i pacchetti</h3>

<p>L'estrazione di un pacchetto sorgente Debian richiede il file
<code>pacchetto_versione.dsc</code> e i file che sono elncati al suo
interno. La directory di compilazione Debian viene creata con il comando
<code>dpkg-source -x pacchetto_versione.dsc</code>.</p>

<p>La costruzione del pacchetto avviene nella directory di compilazione
Debian <code>pacchetto-versione</code> appena creata con tramite il comando
<code>dpkg-buildpackage -B -rsudo "-mMyName &lt;MyEmail&gt;"</code>. Al
posto di <code>-B</code> si può usare <code>-b</code> per compilare le
parti indipendenti dall'architettura del pacchetto. &Egrave; possibile
usare <code>-rfakeroot</code> al posto di <code>-rsudo</code> per usare
il pacchetto fakeroot. Si può tralasciare <code>-r</code> se si compila
da utente root. Infine è possibile aggiungere <code>-uc</code> per evitare di
firmare il pacchetto con la chiave GPG.</p>

<h3>Scegliere un pacchetto</h3>

<p>Quale pacchetto richiede del lavoro? Ogni pacchetto che ancora non è
stato portato e che deve essere portato. Questi cambiano continuamente
quindi o si prende un pacchetto a caso oppure si controllano attentamente le
informazioni del processo autobuilder sulla lista di messaggi debian-hurd.</p>

<h4>Pacchetto che non devono essere portati</h4>

<p>Alcuni di questi pacchetti, o delle loro parti, potrebbero essere
portabili in futuro ma almeno per ora sono considerati non-portabili.</p>

<ul>
    <li>
	<code>base/update</code>, perché Hurd non necessita di un demone di
	aggiornamento (i filesystem si sincronizzano da soli). Per modificare
	l'intervallo di sincronizzazione si può usare <code>fsysopts</code>
	e regolare l'opzione <code>--sync</code>. Si possono impostare valori
	diversi dell'intervallo di sincronizzazione per ogni filesystem! Per
	farlo manualmente si usi l'utilità
	<a href="hurd-doc-utils#syncfs"><code>syncfs</code></a>.</li>

    <li>
	<code>base/makedev</code>, perché Hurd dispone della propria versione
	di questo script. Il pacchetto sorgente Debian contiene solo la
	versione specifica per Linux.</li>

    <li>
	<code>base/ld.so</code>, perché Hurd non usa il linker fornito insieme
	alla libreria C GNU.</li>

    <li>
	<code>base/modconf</code> e <code>base/modutils</code>, perché i
	moduli sono un concetto specifico di Linux.</li>

    <li>
	<code>base/netbase</code>, perché le parti fornite da questo pacchetto
	non disponibili sono altamente specifiche del kernel Linux. Al suo
	posto Hurd usa <code>inetutils</code>.</li>

    <li>
	<code>base/pcmcia-cs</code>, perché Hurd non ha nessun tipo supporto
	per PCMCIA (e se lo avrà probabilmente questo pacchetto risulterà
	specifico di Linux).</li>

    <li>
	<code>base/procps</code>, perché il codice è specifico per il
	filesystem proc di Linux.</li>

    <li>
	<code>base/ppp</code> e <code>base/pppconfig</code>, perché Hurd non ha
	nussun supporto per PPP (e se lo avrà probabilmente questo pacchetto
	risulterà specifico di Linux).</li>

    <li>
	<code>base/setserial</code>, perché è specifico per il kernel Linux.
	Comunque con il port dei driver a caratteri di Linux su GNU Mach saremo
	in grado di usarlo.</li>
</ul>

<h3>Problemi generali del port</h3>

<p>Questo è un elenco delle incompatibilità più comuni che possono incontrare
quando si compila del software non sufficientemente portabile su Hurd.</p>

<ul>
    <li>
	<code>Bad File Descriptor</code>

	<p>Se si ottiene l'errore <code>Bad File Descriptor</code> quando si
	tenta di leggere da un file (o quando si tenta di accedervi) si
	controlli la chiamata a <code>open()</code>. Il secondo argomento è il
	metodo di accesso, se questo è un numero fisso e non uno dei simboli
	definiti nei file header standard il codice non è perfetto e deve
	essere corretto in modo che usi <code>O_RDONLY</code>,
	<code>O_WRONLY</code> o <code>O_RDWR</code>. Per esempio questo
	problema è stato riscontrato nei pacchetti <code>fortunes</code> e
	<code>mtools</code>.</p></li>

    <li>
	<code>PATH_MAX</code>

	<p>Ogni uso incondizionato di <code>PATH_MAX</code> è incompatibile
	con POSIX. Se non ci sono limiti superiori alla lunghezza di un
	percorso questo simbolo non è definito in nessun file header, nel caso
	opposto si può usare una implementazione che non si fida della
	lunghezza della stringa oppure usare <code>sysconf()</code> per
	interrogare la lunghezza durante l'esecuzione; se
	<code>sysconf()</code> restituisce <code>-1</code> si deve usare
	<code>realloc()</code> per allocare dinamicamente la memoria.</p></li>

    <li>
	<code>MAXHOSTNAMELEN</code>

	<p>vedere <code>PATH_MAX</code></p></li>

    <li>
	<code>MAXPATHLEN</code>

	<p>vedere <code>PATH_MAX</code></p></li>

    <li>
	<code>NOFILE</code>

	<p>vedere <code>PATH_MAX</code></p></li>

    <li>
	<code>#define</code> specifiche di Hurd

	<p>Se è necessario includere del codice specifico per Hurd tramite
	<code>#if...#endif</code>, allora si può fare usando
	<code>__GNU__</code>, però pensateci almeno tre volte prima di farlo.
	In <em>molte</em> situazioni questo non è assolutamente necessario e
	crea molti più problemi di quanti ne può risolvere. &Egrave; meglio
	chiedere cosa fare sulla lista di messaggi se non si riesce a trovare
	una soluzione migliore.</p></li>

    <li>
	<code>sys_errlist[]</code> vs. <code>strerror()</code>

	<p>Se un programma ha solo il supporto per <code>sys_errlist[]</code>
	allora è necessario fare un po' di lavoro per riuscire a compilarlo
	con Hurd che non lo supporta e fornisce solo <code>strerror()</code>.
	Steinar Hamre ha scritto riguardo a <code>strerror()</code>:</p>

	<blockquote>
	<p><code>strerror()</code> dovrebbe essere usato perché:</p>

	<ul>
	    <li>&Egrave; il modo previsto in POSIX.</li>
	    <li>&Egrave; localizzato.</li>
	    <li>Gestisce segnali non validi e valori fuori dai limiti (miglior
		gestione degli errori, nessuna possibilità di buffer overflow
		e nessun rischio di sicurezza).</li>
	</ul>

	<p><code>strerror()</code> dovrebbe essere usato sempre se è
	disponibile. Sfortunatamente esistono ancora dei <em>vecchi</em>
	sistemi non-POSIX che non hanno <code>strerror()</code>, ma hanno
	solo <code>sys_errlist[]</code>.</p>

	<p>Oggi, il supporto del solo <code>strerror()</code> è molto meglio
	del solo supporto di <code>sys_errlist[]</code>. La cosa migliore (dal
	punto di vista del port) è il supporto di entrambi. In
	<code>configure.in</code> si deve:</p>

	<p><code>AC_CHECK_FUNCS(strerror)</code></p>

	<p>In <code>config.h.in</code>, si deve aggiungere:</p>

	<p><code>#undef HAVE_STRERROR</code></p>

	<p>E successivamente qualcosa di simile a:

<pre>
        \#ifndef HAVE_STRERROR
        static char *
        private_strerror (errnum)
             int errnum;
        {
          extern char *sys_errlist[];
          extern int sys_nerr;

          if (errnum &gt; 0 &amp;&amp; errnum &lt;= sys_nerr)
            return sys_errlist[errnum];
          return "Unknown system error";
        }
        \#define strerror private_strerror
        \#endif /* HAVE_STRERROR */
</pre>

	<p>Come esempio si può guardare le ultime fileutils (il codice
	precedente è una versione semplificata di ciò che contengono).
	Ovviamente le patch dovono essere inviate ai manutentori originali,
	Questo è molto utile anche per i sistemi che funzionano con
	<code>sys_errlist[]</code>.</p>
	</blockquote></li>

    <li>
	Nomi di file che finiscono con uno slash "/"

	<p>Questi sono una disgrazia se si vuole nominare una directory non
	esistente usando questa sintassi. Per esempio, <code>mkdir
	foobar/</code> <em>non</em> funziona sotto Hurd ma è conforme a POSIX.
	POSIX permette che il percorso di una directory termini con degli
	slash, poiché la directory ancora non esiste il percorso non indica
	una directory e quindi non è garantito il funzionamento degli slash
	finali. Eliminate gli slash e tutto andrà benissimo.</p></li>
</ul>

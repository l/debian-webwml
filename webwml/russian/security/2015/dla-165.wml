#use wml::debian::translation-check translation="1.2" maintainer="Lev Lamberov"
<define-tag description>обновление безопасности LTS</define-tag>
<define-tag moreinfo>
<p>В eglibc, версии библиотеки GNU C для Debian, было обнаружено несколько
уязвимостей.</p>

<ul>

<li>#553206,
<a href="https://security-tracker.debian.org/tracker/CVE-2015-1472">CVE-2015-1472</a>,
<a href="https://security-tracker.debian.org/tracker/CVE-2015-1473">CVE-2015-1473</a>

    <p>Семейство функций scanf неправильно ограничивает выделение
    стека, что позволяет злоумышленникам в зависимости от контекста вызывать
    отказ в обслуживании (аварийная остановка) или потенциально выполнять произвольный код.</p>

<li><a href="https://security-tracker.debian.org/tracker/CVE-2012-3405">CVE-2012-3405</a>

    <p>Семейство функций printf неправильно вычисляет длину
    буфера, что позволяет злоумышленникам в зависимости от контекста обходить
    механизм защиты форматной строки FORTIFY_SOURCE и вызывать
    отказ в обслуживании.</p></li>

<li><a href="https://security-tracker.debian.org/tracker/CVE-2012-3406">CVE-2012-3406</a>

    <p>Семейство функций printf неправильно ограничивает выделение
    стека, что позволяет злоумышленникам в зависимости от контекста обходить
    механизм защиты форматной строки FORTIFY_SOURCE и вызывать
    отказ в обслуживании (аварийная остановка) или потенциально выполнять произвольный код с помощью
    специально сформированной форматной строки.</p></li>

<li><a href="https://security-tracker.debian.org/tracker/CVE-2012-3480">CVE-2012-3480</a>

    <p>Многочисленные переполнения целых чисел в strtod, strtof, strtold,
    strtod_l и других связанных функциях позволяют локальным пользователям вызывать
    отказ в обслуживании (аварийная остановка приложения) и потенциально выполнять
    произвольный код с помощью длинных строк, вызывающих переполнение
    буфера.</p></li>

<li><a href="https://security-tracker.debian.org/tracker/CVE-2012-4412">CVE-2012-4412</a>

    <p>Переполнение целых чисел в функциях strcoll и wcscoll позволяют
    злоумышленникам в зависимости от контекста вызывать отказ в обслуживании (аварийная остановка)
    или потенциально выполнять произвольный код с помощью длинных строк, вызывающих
    переполнение динамической памяти.</p></li>

<li><a href="https://security-tracker.debian.org/tracker/CVE-2012-4424">CVE-2012-4424</a>

    <p>Переполнение буфера в функциях strcoll и wcscoll
    позволяет злоумышленникам в зависимости от контекста вызывать отказ в обслуживании
    (аварийная остановка) или потенциально выполнять произвольный код с помощью длинных строк,
    вызывающих ошибку malloc и использование функции alloca.</p></li>

<li><a href="https://security-tracker.debian.org/tracker/CVE-2013-0242">CVE-2013-0242</a>

    <p>Переполнение буфера в функции extend_buffers в коде сравнения
    для регулярных выражений позволяет злоумышленникам в зависимости от контекста вызывать
    отказ в обслуживании (повреждение содержимого памяти и аварийная остановка) с помощью специально
    сформированных многобайтовых символов.</p></li>

<li><a href="https://security-tracker.debian.org/tracker/CVE-2013-1914">CVE-2013-1914</a>,
    <a href="https://security-tracker.debian.org/tracker/CVE-2013-4458">CVE-2013-4458</a>

    <p>Переполнение буфера в функции getaddrinfo позволяет
    удалённым злоумышленникам вызывать отказ в обслуживании (аварийная остановка) с помощью
    имени узла или IP адреса, которые при их обработке кодом для преобразования домена
    приводят к порождению большого числа результатов преобразования.</p></li>

<li><a href="https://security-tracker.debian.org/tracker/CVE-2013-4237">CVE-2013-4237</a>

    <p>readdir_r позволяет злоумышленникам в зависимости от контекста вызывать отказ в
    обслуживании (запись за пределами выделенного буфера памяти и аварийная остановка) или потенциально выполнять
    произвольный код с помощью специально подготовленного образа NTFS или службы CIFS.</p></li>

<li><a href="https://security-tracker.debian.org/tracker/CVE-2013-4332">CVE-2013-4332</a>

    <p>Многочисленные переполнения целых чисел в malloc/malloc.c позволяют
    злоумышленникам в зависимости от контекста вызывать отказ в обслуживании (повреждение
    содержимого динамической памяти) с помощью большого значения, передаваемого функциям pvalloc,
    valloc, posix_memalign, memalign или aligned_alloc.</p></li>

<li><a href="https://security-tracker.debian.org/tracker/CVE-2013-4357">CVE-2013-4357</a>

    <p>Функции getaliasbyname, getaliasbyname_r, getaddrinfo, getservbyname,
    getservbyname_r, getservbyport, getservbyport_r и glob
    неправильно ограничивают выделение стека, что позволяет
    злоумышленникам в зависимости от контекста вызывать отказ в обслуживании (аварийная остановка)
    или потенциально выполнять произвольный код.</p></li>

<li><a href="https://security-tracker.debian.org/tracker/CVE-2013-4788">CVE-2013-4788</a>

    <p>Если библиотека GNU C статически скомпонована в выполняемый файл,
    то реализация PTR_MANGLE не выполняет инициализацию случайного значения
    для защитника указателей, поэтому различные механизмы повышения уровня защищённости
    оказываются неэффективными.</p></li>

<li><a href="https://security-tracker.debian.org/tracker/CVE-2013-7423">CVE-2013-7423</a>

    <p>Функция send_dg в resolv/res_send.c неправильно повторно использует
    файловые дескрипторы, что позволяет удалённым злоумышленника отсылать
    DNS-запросы в неожиданные места с помощью большого числа запросов, приводящих
    к вызову функции getaddrinfo.</p></li>

<li><a href="https://security-tracker.debian.org/tracker/CVE-2013-7424">CVE-2013-7424</a>

    <p>Функция getaddrinfo может попытаться освободить некорректный указатель
    при обработке IDN (интернационализированных имён доменов), что позволяет
    удалённым злоумышленникам вызывать отказ в обслуживании (аварийная остановка) или потенциально
    выполнять произвольный код.</p></li>

<li><a href="https://security-tracker.debian.org/tracker/CVE-2014-4043">CVE-2014-4043</a>

    <p>Функция posix_spawn_file_actions_addopen не выполняет копирование аргумента
    пути в соответствии со спецификацией POSIX, что
    позволяет злоумышленникам в зависимости от контекста вызывать использование
    указателей после освобождения памяти.</p></li>

</ul>

<p>В предыдущем стабильном выпуске (squeeze) эти проблемы были исправлены
в версии 2.11.3-4+deb6u5.</p>

<p>В стабильном выпуске (wheezy) эти проблемы были исправлены в
версии 2.13-38+deb7u8 или более ранних.</p>
</define-tag>

# do not modify the following line
#include "$(ENGLISHDIR)/security/2015/dla-165.data"
# $Id$

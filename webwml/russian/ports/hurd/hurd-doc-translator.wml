#use wml::debian::template title="Debian GNU/Hurd — Документация" NOHEADER="yes"
#include "$(ENGLISHDIR)/ports/hurd/menu.inc"
#use wml::debian::translation-check translation="1.13" maintainer="Lev Lamberov"

<h1>Debian GNU/Hurd</h1>
<h2>Трансляторы</h2>
<ul>
<li><a href="#concept" name="TOC_concept">Концепция</a></li>
<li><a href="#examples" name="TOC_examples">Примеры</a></li>
<li><a href="#actpas" name="TOC_actpas">Пассивные трансляторы, активные трансляторы</a></li>
<li><a href="#manage" name="TOC_manage">Управление трансляторами</a></li>
</ul>

<h3><a href="#TOC_concept" name="concept">Концепция</a></h3>
<p>
До того, как мы обратимся к трансляторам, рассмотрим обычные
файловые системы. Файловая система представляет собой хранилище иерархичного дерева каталогов
и файлов. Вы получаете доступ к каталогам и файлам с помощью специальной символьной строки,
пути. Более того, имеются символьные ссылки, которые указывают на один файл в
из нескольких мест в дереве, существуют жёсткие ссылки, с помощью которых можно дать одному и тому же
файлу несколько имён. Имеются специальные файлы устройств для взаимодействия с
драйверами устройств из ядра, также имеются точки монтирования,
которые используются для того, что включать в себя другие хранилища дерева каталогов. Ещё существуют такие
непонятные объекты как FIFO.</p>
<p>
Несмотря на то, что все эти объекты очень отличаются друг от друга, они обладают некоторыми общими
свойствами; например, у всех этих объектов имеется владелец и группа,
которые с ними ассоциированы, также с ними ассоциированы права (права доступа). Эта информация записана в
инодах (inodes). Это ещё одно общее свойство: всякий объект имеет ровно
одну иноду, ассоциированную с ним (жёсткие ссылки являются, в некотором смысле, специальным случаем, поскольку они
разделяют одну и ту же иноду). Иногда инода содержит в себе
дополнительную информацию. Например, инода может содержать цель символьной
ссылки.</p>
<p>
Тем не менее, эти общие свойства зачастую не используются в
реализациях, несмотря на то, что для них имеются общие интерфейсы. Доступ ко всем
инодам может быть получен через стандартные вызовы POSIX; например,
<code>read()</code> и <code>write()</code>. Например, чтобы добавить новый
тип объекта (например, новый тип ссылки) к общему монолитному ядру unix,
вам потребовалось бы изменить код каждой файловой системы
по отдельности.</p>
<p>
В Hurd всё по-другому. Несмотря на то, что в Hurd специальный
сервер файловой системы может использовать специальные свойства стандартных типов объектов,
таких как ссылки (например, в файловой системе ext2 с «быстрыми ссылками»), он имеет
общий интерфейс для добавления возможностей без изменения существующего кода.</p>
<p>
Трюк состоит в том, чтобы поместить программу между фактическим содержанием
файла и пользователем, обращающимся к этому файлу. Такая программа называется
транслятором, так как она способна обрабатывать входящие запросы разными
способами. Другими словами, транслятор является сервером Hurd, который предоставляет
базовый интерфейс файловой системы.</p>
<p>
Трансляторы обладают очень интересными свойствами. С точки зрения ядра,
они являются обычными пользовательскими процессами. Это означает, что трансляторы могут быть запущены
пользователем. Вам не нужны права суперпользователя для установки или изменения
транслятора, вам нужны лишь права доступа к иноде, к
которой прикреплён транслятор. Многим трансляторам для работы не требуется фактическое существование
файла, они могут предоставлять информацию самостоятельно. Вот почему
информация о трансляторах хранится в иноде.</p>
<p>
Трансляторы ответственны за выполнение всех операций файловой системы, в которых
участвует инода, к которой они прикреплены. Поскольку они не ограничены обычным
набором объектов (файл устройств, ссылка и т.д.), они могут вернуть всё, что
разработчик посчитает необходимым. Можно было бы представить себе транслятор, который
ведёт себя как каталог, когда к нему обращаются с помощью команд <code>cd</code> или
<code>ls</code>, и в то же самое время ведёт себя как файл, когда к нему обращаются с помощью
команды <code>cat</code>.</p>

<h3><a href="#TOC_examples" name="examples">Примеры</a></h3>
<h4>Точки монтирования</h4>
<p>
Точка монтирования может рассматриваться как инода, к которой прикреплён специальный
транслятор. Его целью является транслирование операций файловой системы, производимых над
точкой монтирования, в операции файловой системы на другом хранилище, допустим, на другом
разделе.</p>
<p>
В действительности, именно так реализованы файловые системы в Hurd. Файловая
система является транслятором. Этот транслятор принимает хранилище в качестве своего аргумента
и может прозрачно выполнять все операции файловой системы.</p>

<h4>Файлы устройств</h4>
<p>
Существует множество различных файлов устройств, в системах с монолитным ядром
все они предоставляются самим ядром. В Hurd все файлы
устройств предоставляются трансляторами. Один транслятор может предоставить поддержку для
множества схожих файлов устройств, например для разделов жёсткого диска. Таким образом,
количество необходимых трансляторов довольно мало. Тем не менее, заметьте, что
для доступа к каждому отдельному файлу устройств запускается отдельная задача транслятора.
Поскольку Hurd является действительно многозадачной системой, это не требует больших накладных расходов.</p>
<p>
Когда во взаимодействии участвует оборудование, транслятор обычно начинает взаимодействовать с
ядром, чтобы получить данные от устройства. Тем не менее, если доступ к устройству не
требуется, то нет необходимости и обращаться к ядру. Например,
<code>/dev/zero</code> не требует доступа к оборудованию и может, следовательно,
быть целиком реализовано в пространстве пользователя.</p>

<h4>Символьные ссылки</h4>
<p>
Символьная ссылка может рассматриваться как транслятор. Обращение к символьной ссылке
запустит транслятор, который передаст запрос
файловой системе, содержащей файл, на который указывает эта ссылка.</p>
<p>
Тем не менее, в целях обеспечения лучшей производительности, файловые системы, имеющие встроенную поддержку
символьных ссылок, могут использовать эту свою возможность и по-другому реализовывать
символьные ссылки, внутри себя. Таким образом, обращение к символьной ссылке не будет
приводить к запуску нового процесса транслятора. Тем не менее, для пользователя, это всё ещё
будет выглядеть так, как будто используется пассивный транслятор (см. ниже объяснение того, что такое
пассивный транслятор).</p>
<p>
Поскольку Hurd поставляется с транслятором символьных ссылок, любой сервер файловой системы,
предоставляющий поддержку трансляторов, автоматически имеет поддержку символьных ссылок (а также
твёрдых ссылок (firmlinks), файлов устройств и т.д.)! Это означает, что вы можете очень быстро
получить работающую файловую систему, потом позже добавить встроенную поддержку символьных ссылок
и других возможностей.</p>

<h3><a href="#TOC_actpas" name="actpas">Пассивные трансляторы, активные трансляторы</a></h3>
<p>
Существует два типа трансляторов — пассивные и активные. Они очень сильно
различаются, не путайте их, но они очень тесно
связаны друг с другом.</p>

<h4>Активные трансляторы</h4>
<p>
Активный транслятор &mdash; это работающий процесс транслятора, как это уже было указано выше.
Вы можете установить или удалить активный транслятор, используя
команду <code>settrans -a</code>. Параметр
<code>-a</code> требуется для того, чтобы сообщить
<code>settrans</code>, что вы хотите изменить активный транслятор.</p>
<p>
Команда <code>settrans</code> принимает три вида аргументов. Во-первых, вы
можете установить параметры для самой команды <code>settrans</code>, например
ключ <code>-a</code> для того, чтобы изменить активный транслятор. Далее, вы можете установить иноду, которую
хотите изменить. Помните, что транслятор всегда ассоциируется с
инодой в иерархии каталогов. Вы можете изменить только одну иноду за раз.
Если вы не укажите каких-либо дополнительных аргументов, <code>settrans</code> попытается
удалить существующий транслятор. Насколько сильно она пытается сделать это, зависит от указания параметра
форсирования (если транслятор используется каким-либо процессом, и если вы не укажите параметр
форсирования, то получите сообщение об ошибке, гласящие, что «устройство или ресурс занят»).</p>
<p>
Но если вы укажите дополнительные аргументы, это будет интерпретировано как командная
строка для запуска транслятора. Это означает, что следующим аргументом является имя исполняемого файла
транслятора. Следующие затем аргументы являются параметрами транслятора,
а не команды <code>settrans</code>.</p>
<p>
Например, чтобы смонтировать раздел ext2fs, вы можете выполнить
<code>settrans -a -c /mnt /hurd/ext2fs /dev/hd2s5</code>. Параметр
<code>-c</code> создаст для вас точку монтирования, если она ещё
не существует. Она, кстати, не обязательно должна быть каталогом. Чтобы отмонтировать
раздел, вы можете попытаться выполнить <code>settrans -a /mnt</code>.</p>

<h4>Пассивные трансляторы</h4>
<p>
Пассивный транслятор устанавливается и изменяется с помощью того же синтаксиса как и активный
транслятор (но без ключа <code>-a</code>), поэтому всё, что было сказано выше,
справедливо и для пассивных трансляторов. Тем не менее, существует и отличие: пассивные
трансляторы не запускаются сразу же.</p>
<p>
Это имеет смысл, поскольку это именно то, чего вы обычно хотите. Вы не хотите, чтобы
раздел монтировался до тех пор, пока вы не обратитесь к файлам на этом разделе. Вы
не хотите подключать сеть до тех пор, пока не происходит обмен данными и
так далее.</p>
<p>
Вместо этого, когда происходит первое обращение к пассивному транслятору, он
автоматически считывается из иноды и запускается как активный транслятор над этой инодой;
при этом используется командная строка, которая была сохранена в этой иноде. Это
схоже с тем, как работает служба автоматического монтирования в Linux. Тем не менее, это не какой-то
дополнительный бонус, который вам нужно устанавливать вручную, а встроенная часть
системы. Поэтому установка пассивного транслятора откладывает запуск задачи
этого транслятора до того момента, когда последняя будет вам действительно нужна. Кстати, если активный транслятор умрёт по каким-то
причинам, в следующий раз когда произойдет обращение к этой иноде, этот транслятор будет
перезапущен.</p>
<p>
Также имеется ещё дополнительное отличие: активные трансляторы могут умереть или потеряться. Как
только процесс активного транслятора будет убит (например, потому, что вы
перезагружаете машину), он будет потерян навсегда. Пассивные же трансляторы не выгружаются
и остаются в иноде в ходе перезагрузки, пока вы не измените их с помощью команды
<code>settrans</code> или не удалите иноды, к которым они прикреплены.
Это означает, что вам не нужно иметь специальный файл настроек для ваших
точек монтирования.</p>
<p>
И ещё одно: даже если у вас имеется установленный пассивный транслятор, вы всё ещё
можете установить другой активный транслятор. Пассивный транслятор запускается
автоматически только, если во время обращения к иноде не существовало запущенного транслятора.</p>

<h3><a href="#TOC_manage" name="manage">Управление трансляторами</a></h3>
<p>
Как уже было указано выше, вы можете использовать
<code>settrans</code>
для установки и изменения пассивных и активных трансляторов. Имеется много различных параметров,
с помощью которых можно изменять поведение команды <code>settrans</code> в случае, если что-то
пойдёт не так, а также для определения её действий. Ниже приведены некоторые примеры обычного использования этой команды:</p>
<ul><li><code>settrans -c /mnt /hurd/ext2fs /dev/hd2s5</code> монтирует
раздел, транслятор сохранится после перезагрузки.</li>
<li><code>settrans -a /mnt /hurd/ext2fs ~/dummy.fs</code> монтирует
файловую системы в файл данных, транслятор исчезнет, если умрёт.</li>
<li><code>settrans -fg /nfs-data</code> заставляет транслятор исчезнуть.</li>
</ul>
<p>
Вы можете использовать <a href="hurd-doc-utils#showtrans">команду <code>showtrans</code></a>,
чтобы проверить, прикреплён ли к иноде транслятор. Правда, эта команда покажет вам лишь
пассивный транслятор.</p>
<p>
Вы можете изменить параметры активного транслятора (для файловой системы) с
помощью <code>fsysopts</code>, не перезапуская этот транслятор. Это очень
удобно. Например, вы можете выполнить то, что называется «перемонтирование
раздела в режим только для чтения» под Linux, просто выполнив <code>fsysopts
/mntpoint --readonly</code>. Работающий активный транслятор
изменит своё поведение в соответствии с вашим запросом, если это возможно.
Выполнение <code>fsysopts /mntpoint</code> без параметра покажет вам текущие
настройки.</p>

<h4>Примеры</h4>
<p>
Я рекомендую вам начать с чтения команды <code>/bin/mount</code>,
она представляет собой небольшой сценарий. Поскольку установка транслятора файловой системы
похожа на монтирование разделов, так вы легко сможете понять всю концепцию.
Создайте образ файловой системы с помощью <code>dd if=/dev/zero of=dummy.fs bs=1024k
count=8; mke2fs dummy.fs</code> и «смонтируйте» её с помощью <code>settrans -c dummy
/hurd/ext2fs `pwd`/dummy.fs</code>. Заметьте, что транслятор не будет запущен,
не будет запущен и новый процесс <code>ext2fs</code> (проверьте это с помощью <code>ps
Aux</code>). Проверьте, что всё верно, используя <code>showtrans</code>.</p>
<p>
Теперь введите <code>ls dummy</code>, вы заметите небольшую задержку, которая
возникает при запуске транслятора. После этого задержек при обращении к
dummy не будет. Под Linux можно было бы сказать, что вы автоматически смонтировали
блочную файловую систему. Проверьте с помощью <code>ps Aux</code>, что появился процесс <code>ext2fs
dummy</code>, и что он работает. Теперь поместите какие-нибудь файлы в новый
каталог. Попробуйте изменить параметры файловой системы, переведя её в режим только для чтения с помощью <code>fsysopts</code>.
Заметьте, после этого попытки записи будут неудачны. Попробуйте убить активный транслятор
с помощью <code>settrans -g</code>.</p>
<p>
Теперь вы должны кое-что понимать о том, что происходит. Запомните, что
это был лишь <em>один</em> специальный сервер, сервер Hurd ext2fs.
В каталоге <code>hurd</code> существует огромное количество других серверов. Некоторые из них
предназначены для файловых систем. Некоторые требуются для таких возможностей файловых систем как ссылки.
Некоторые требуются для файлов устройств. Некоторые полезны для работы сети. Представьте
себе «монтирование» сервера FTP с помощью <code>settrans</code> и загрузку файлов с него
при помощи обычной команды <code>cp</code>. Или редактирование вашего веб-сайта
с помощью <code>emacs /ftp/homepage.my.server.org/index.html</code>!</p>

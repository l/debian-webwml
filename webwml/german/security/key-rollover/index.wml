#use wml::debian::template title="Schlüsselaustausch"
#use wml::debian::translation-check translation="1.17" maxdelta="1"

<p>
In der <a href="$(HOME)/security/2008/dsa-1571">Debian-Sicherheitsankündigung 1571</a>,
deckte das Debian-Sicherheitsteam eine Verwundbarkeit im Paket OpenSSL auf, die viele
kryptografische Schlüssel, die für Authentifizierung (z.B. mittels SSH)
oder Signierung (z.B. Web-Server-Zertifikate) verwendet werden, potenziell
anfällig macht.
</p>

<p>
Diese Seite dokumentiert, wie die Schlüssel für Pakete, deren Schlüssel durch
die OpenSSL-Verwundbarkeit betroffen sind, ausgetauscht werden können.
</p>

<ul>
<li><b><a href="#openssh">OpenSSH</a></b>

<li><a href="#ftpd-ssl">ftpd-ssl</a>
<li><a href="#gforge">gforge</a>
<li><a href="#kerberos">MIT Kerberos (krb5)</a>
<li><a href="#openswan">OpenSWAN / StrongSWAN</a>
<li><a href="#openvpn">OpenVPN</a>
<li><a href="#puppet">puppet</a>
<li><a href="#ssl-cert">ssl-cert</a>
<li><a href="#telnetd-ssl">telnetd-ssl</a>
<li><a href="#xrdp">xrdp</a>
</ul>

<p>
Other software uses cryptographic keys, but is 
<a href="notvuln">not vulnerable</a> as OpenSSL is not used to generate
or exchange its keys.
</p>

<ul>
<li><a href="notvuln#ckermit">ckermit</a>
<li><a href="notvuln#gnupg">GnuPG</a>
<li><a href="notvuln#iceweasel">Iceweasel</a>
<li><a href="notvuln#mysql">MySQL</a>
</ul>

<p>
Für Anleitungen zum Schlüsselaustausch für andere Software wird auf die
von Benutzern zusammengetragenen Informationen unter
<url http://wiki.debian.org/SSLkeys> verwiesen.
</p>

<h1><a name="openssh">OpenSSH</a></h1>

<p>
Ein Paket wurde als <a href="$(HOME)/security/2008/dsa-1576">DSA-1576</a>
herausgegeben, das die Schlüsseltransformation vereinfacht.
</p>

<p>1. Installieren Sie die Sicherheitsaktualisierungen aus DSA-1576</p>

   <p>Sobald die Aktualisierung eingespielt wurde, werden schwache
   Benutzerschlüssel, wenn möglich, automatisch zurückgewiesen (diese können
   aber nicht in allen Fällen erkannt werden). Falls Sie solche Schlüssel
   für die Benutzerauthentifizierung verwenden, werden sie ab sofort nicht
   mehr funktionieren und müssen ersetzt werden (siehe Schritt 3).</p>

   <p>OpenSSH-Rechner-Schlüssel können automatisch neu erzeugt werden, wenn
      die OpenSSH-Sicherheitsaktualisierung eingespielt wurde. Die
      Aktualisierung wird nach Bestätigung fragen, bevor dieser Schritt
      durchgeführt wird.</p>

<p>2. Aktualisierung der OpenSSH-Dateien <tt>known_hosts</tt></p>

   <p>Die Neuerzeugung der Rechnerschlüssel wird eine Warnung ausgeben, wenn
      auf das System mit SSH zugegriffen wird, bis der Rechnerschlüssel in
      der Datei known_hosts auf dem Klient aktualisiert wurde. Die Warnung
      wird wie folgt aussehen:</p>

<pre>
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that the RSA host key has just been changed.
</pre>

Auf Deutsch lautet diese Meldung in etwa wie folgt:

<pre>
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ WARNING: IDENTIFIZIERUNG DES ENTFERNTES RECHNERS HAT SICH GEÄNDERT @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
ES IST MÖGLICH, DASS JEMAND ETWAS BÖSES TUT!
Jemand könnte Sie zurzeit abhören (man-in-the-middle-(Mann in der Mitte)-Angriff)!
Es ist auch möglich, dass der RSA-Rechnerschlüssel vor kurzem geändert wurde.
</pre>

   <p>In diesem Fall wurde der Rechnerschlüssel einfach geändert und Sie
      sollten die entsprechende Datei <tt>known_hosts</tt>, wie in der
      Meldung beschrieben, aktualisieren.
   
   Es wird empfohlen, dass Sie einen vertrauenswürdigen Kanal zum Austausch
   des Server-Schlüssels verwenden. Er befindet sich in der Datei
   <tt>/etc/ssh/ssh_host_rsa_key.pub</tt> auf dem Server;
   sein Fingerabdruck kann mit dem folgenden Kommando gedruckt werden:</p>

      <p><code>ssh-keygen -l -f /etc/ssh/ssh_host_rsa_key.pub</code></p>

   <p>Zusätzlich zu benutzerspezifischen <tt>known_hosts</tt>-Dateien, kann
      eine systemweite Datei <tt>/etc/ssh/known_hosts</tt> existieren. Diese
      Datei wird sowohl vom ssh-Klient als auch von sshd für die
      <tt>hosts.equiv</tt>-Funktionalität verwendet. Diese Datei muss auch
      aktualisiert werden.</p>

<p>3. Überprüfen aller OpenSSH-Benutzerschlüssel</p>

   <p>Der sicherste Weg ist es, alle OpenSSH-Benutzerschlüssel neu zu
      erzeugen, es sei denn, es kann mit ausreichender Bestimmtheit
      sichergestellt werden, dass der Schlüssel auf einem nicht betroffenen
      System erstellt wurde.</p>

   <p>Um zu testen, ob Ihr Schlüssel betroffen ist, können Sie
      <tt>ssh-vulnkey</tt> starten, was in der Sicherheitsaktualisierung enthalten ist.
      Standardmäßig wird <tt>ssh-vulnkey</tt> den Standardort für Benutzerschlüssel
      (<tt>~/.ssh/id_rsa</tt>, <tt>~/.ssh/id_dsa</tt> und <tt>~/.ssh/identity</tt>), Ihre Datei
      <tt>authorized_keys</tt> (<tt>~/.ssh/authorized_keys</tt> und
      <tt>~/.ssh/authorized_keys2</tt>) und die Rechnerschlüssel des Systems
      (<tt>/etc/ssh/ssh_host_dsa_key</tt> und <tt>/etc/ssh/ssh_host_rsa_key</tt>) überprüfen.</p>

   <p>Sie können alle Ihre eigenen Schlüssel wie folgt testen, unter der
      Voraussetzung, dass sie sich an den Standardorten (<tt>~/.ssh/id_rsa</tt>,
      <tt>~/.ssh/id_dsa</tt> oder <tt>~/.ssh/identity</tt>) befinden:</p>

     <p><code>ssh-vulnkey</code></p>

   <p>Um alle Schlüssel auf Ihrem System zu überprüfen:</p>

     <p><code>sudo ssh-vulnkey -a</code></p>

   <p>Um einen Schlüssel an einem nicht standardmäßigem Ort zu testen:</p>

     <p><code>ssh-vulnkey <var>/Pfad/zum/Schlüssel</var></code></p>

   <p>Falls <tt>ssh-vulnkey</tt> die Meldung <q>Unknown (no blacklist information)</q>
      ausgibt, hat es keine Informationen darüber, ob der Schlüssel betroffen ist.
      Im Zweifelsfall sollte der Schlüssel zerstört und ein neuer erzeugt
      werden.
   </p>

<p>4. Neuerzeugen beliebiger betroffener Benutzerschlüssel</p>

   <p>Für die Benutzerauthentifizierung verwendete OpenSSH-Schlüssel müssen
   manuell neu erzeugt werden, inklusive derjenigen, die nach der
   Erzeugung auf ein anderes System übertragen wurden.</p>

   <p>Neue Schlüssel können mit <tt>ssh-keygen</tt> erzeugt werden, z.B.:</p>

   <pre>
   $ ssh-keygen
   Generating public/private rsa key pair.
   Enter file in which to save the key (/home/user/.ssh/id_rsa):
   Enter passphrase (empty for no passphrase):
   Enter same passphrase again:
   Your identification has been saved in /home/user/.ssh/id_rsa.
   Your public key has been saved in /home/user/.ssh/id_rsa.pub.
   The key fingerprint is:
   00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00 user@host
   </pre>

<p>5. Aktualisierung der <tt>authorized_keys</tt>-Dateien (falls nötig)</p>

   <p>Sobald die Benutzerschlüssel neu erzeugt wurden, müssen die relevanten
      öffentlichen Schlüssel in <tt>authorized_keys</tt>-Dateien (und eventuell
      <tt>authorized_keys2</tt>-Dateien) auf entfernten Systemen übertragen
      werden. Stellen Sie sicher, dass die betroffenen Schlüssel gelöscht werden.</p>

<h1><a name="ftpd-ssl">ftpd-ssl</a></h1>

<pre>
rm -f /etc/ftpd-ssl/ftpd.pem /etc/ssl/certs/ftpd.pem
dpkg-reconfigure ftpd-ssl
</pre>

<p>
this covers the default setup. if the local admin has setup further
ssl infrastructure beyond that, these keys will need to be regenerated
as well.
</p>

<h1><a name="gforge">gforge</a></h1>

<p>
The gforge-web-apache2 package in sid and lenny sets up the website
with a dummy certificate if no existing certificate is found. Users are then
encouraged to replace it with a "real" one. The dummy certificate in
question is the Snake Oil one, so it should already be known as a weak
one (even without the SSL bug), but some users may accept
it without a second thought. 
</p>

<h1><a name="kerberos">MIT Kerberos (krb5)</a></h1>

<p>
No part of MIT Kerberos in Debian 4.0 ("Etch") uses OpenSSL, and so Kerberos
in Debian 4.0 is not affected at all.
</p>

<p>
In Lenny the separate binary package krb5-pkinit uses OpenSSL.
<ul>
<li>
MIT Kerberos itself does not generate long-term key pairs even when the
PKINIT plugin is used, so any vulnerable long-term key pairs would have
been generated outside of the MIT Kerberos software itself.  The PKINIT
plugin only references existing key pairs and isn't responsible for key
management.
</li>
<li>
All of the random session key generation inside the PKINIT plugin is
done using the regular MIT Kerberos random key functions, <em>not</em> the
OpenSSL random number generator, and hence sessions created via PKINIT
are not subject to this vulnerability.
</li>
</ul>
</p>

<p>
MIT Kerberos itself is not in affected.  However, long-term key pairs used
with PKINIT may be affected if generated on an affected Debian system, but
such generation is external to MIT Kerberos.
</p>

<h1><a name="openswan">OpenSWAN / StrongSWAN</a></h1>

<pre>
rm /etc/ipsec.d/private/`hostname`Key.pem /etc/ipsec.d/certs/`hostname`Cert.pem
dpkg-reconfigure (open|strong)swan
/etc/init.d/ipsec restart
</pre>

<p>
Vorsicht: Neustarten des Dienstes ipsec beendet alle aktuell offenen
IPSec-Verbindungen. Diese müssen eventuell vom anderen Ende neu gestartet werden.
</p>

<h1><a name="openvpn">OpenVPN</a></h1>

<p>
Backup your secret key files. While key names are arbitrary, they can
be detected by running
<pre>grep secret /etc/openvpn/*.conf</pre>
</p>

<p>
Recreate them using
<pre>openvpn --genkey --secret SECRET_FILENAME</pre>
</p>

<p>
Then copy the shared secret keys to the remote hosts and restart the VPN
on each host with
<pre>/etc/init.d/openvpn force-reload</pre>
</p>

<h1><a name="puppet">puppet</a></h1>

<p>
There are two methods to handle puppet certificates, one is via capistrano,
the second is manually.
</p>

<p>
Regenerating Puppet SSL Certificates using capistrano is detailed here:
<a href="http://reductivelabs.com/trac/puppet/wiki/RegenerateSSL">http://reductivelabs.com/trac/puppet/wiki/RegenerateSSL</a>
</p>

<p>
The manual steps are as follows:
</p>

<ol>
<li>You need to wipe and regenerate your CA info:
<pre>
/etc/init.d/puppetmaster stop
rm $vardir/ssl/*
/etc/init.d/puppetmaster start
</pre>
<p>
However, if you are running mongrel, instead of starting puppetmaster from
the init script, you will need to first stop the front-end web listener
(apache, nginx, etc.) and then do the following:
</p>
<pre>
puppetmasterd --daemonize ; sleep 30 ; pkill -f 'ruby /usr/sbin/puppetmasterd'
</pre>
<p>
The above is necessary because for some reason when running with mongrel,
puppetmaster will not regenerate its CA.
</p>
</li>
<li>Wipe all the client certs
<pre>
/etc/init.d/puppet stop
rm $vardir/ssl/*
</pre> 
</li>
<li>Have each client request a new cert:
<pre>
puppetd --onetime --debug --ignorecache --no-daemonize
</pre> 
</li>
<li>Once all the requests have rolled in, you can sign them all at once:
<pre>
puppetca --sign --all
</pre> 
</li>
<li>Start up your puppet clients:
<pre>
/etc/init.d/puppet start
</pre>
</li>
</ol>

<p>
You could also enable autosign temporarily, if you are comfortable with that.
</p>

<h1><a name="ssl-cert">ssl-cert</a></h1>

<p>
The snakeoil certificate /etc/ssl/certs/ssl-cert-snakeoil.pem can be
recreated with:
</p>

<pre>make-ssl-cert generate-default-snakeoil --force-overwrite</pre>

<h1><a name="telnetd-ssl">telnetd-ssl</a></h1>

<pre>
rm -f /etc/telnetd-ssl/telnetd.pem /etc/ssl/certs/telnetd.pem
dpkg-reconfigure telnetd-ssl
</pre>

<p>
This covers the default setup. If the local admin has setup further
SSL infrastructure beyond that, these keys will need to be regenerated
as well.
</p>

<h1><a name="xrdp">xrdp</a></h1>

<p>
xrdp uses generated keys. Most clients do not check those keys by
default, therefore changing them is painless. You just have to:
</p>

<pre>
rm /etc/xrdp/rsakeys.ini
/etc/init.d/xrdp restart
</pre>

<p>
xrdp is not in stable.
</p>

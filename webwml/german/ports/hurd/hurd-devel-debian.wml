#use wml::debian::template title="Debian GNU/Hurd &ndash; Entwicklung" NOHEADER="yes"
#include "$(ENGLISHDIR)/ports/hurd/menu.inc"
#use wml::debian::translation-check translation="1.31"
# $Id$
# Translator: Frank Lichtenheld <frank@lichtenheld.de> 2003-03-08

<h1>Debian GNU/Hurd</h1>

<h2>Entwicklung der Distribution</h2>

<h3>Installationssystem</h3>
<p>Aktuell arbeiten wir nicht an einem nativen
Installationssystem. Wir versuchen allerdings die Basis dafür zu
schaffen und portieren manchmal dafür wichtige Pakete. Wenn Sie uns
helfen wollen, arbeiten sie am debian-installer-Projekt mit und
stellen Sie sicher, dass die Komponenten auf dem Hurd laufen.</p>

<h3>Debian-Pakete portieren</h3>
<p>Wenn Sie dem Debian GNU/Hurd Port helfen wollen, sollten Sie sich
mit dem Debian-Paketsystem vertraut machen. Wenn Sie dies getan haben,
durch Lesen der verfügbaren Dokumentation und Besuchen der 
<a href="$(HOME)/devel/">Entwickler-Ecke</a>, sollten Sie gelernt haben,
wie man Debian-Quellcodepakete auspackt und wie man Debian-Pakete
erstellt. Nachfolgend finden sie einen Crashkurs für die ganz faulen
Leute:</p>

<h3>Quellcode bekommen und Pakete erstellen.</h3>
<p>Um ein Debian-Quellcodepaket auszupacken, benötigt man die Datei
<code>paketname_version.dsc</code> und die in ihr aufgelisteten
Dateien. Sie erstellen das Debian-Paketverzeichnis mit dem Programm
<code>dpkg-source -x paketname_version.dsc</code></p>

<p>Um ein Paket zu erstellen, wechseln Sie in das
Debian-Paketverzeichnis <code>paketname_version</code> und führen Sie
den Befehl <code>dpkg-buildpackage -B -rsudo "-mMeinName
&lt;Meine-E-Mail&gt;"</code> aus. Anstelle von <code>-B</code> können
Sie auch <code>-b</code> benutzen, um auch die architekturunabhängigen
Teile des Pakets zu erstellen. Sie können <code>-rfakeroot</code>
statt <code>-rsudo</code> benutzen, wenn Sie das fakeroot-Paket
installiert haben. Oder Sie können das <code>-r</code> weglassen, wenn
Sie den Befehl als Benutzer root ausführen. Sie können auch
<code>-uc</code> hinzufügen, wenn Sie das Paket nicht mit ihrem
PGP-Schlüssel signieren wollen.</p>

<h3>Eins auswählen</h3>
<p>An welchem Paket sollte gearbeitet werden? An jedem, das noch nicht
portiert wurde aber portiert werden muss. Das ändert sich ständig,
also können Sie sich entweder eines der nicht portierten Pakete
zufällig heraussuchen oder auf der debian-hurd Mailingliste nach
Informationen über den autobuilding-Prozess Ausschau halten.</p>

<h4>Pakete, die nicht portiert werden.</h4>
<p>Manche dieser Pakete oder Teile von ihnen könnten später doch
portabel sein, aber im Moment werden sie als nicht portabel
angesehen.</p>

<ul>
      <li><code>base/update</code>, weil der Hurd keinen update Daemon
	braucht (Die Dateisysteme synchronisieren sich selbst). Wollen
	Sie das Synchronisationsintervall ändern, können sie
	<code>fsysopts</code> verwenden, um die <code>--sync</code>
	Option zu einzustellen. Sie können für jedes Dateisystem ein
	anderes Synchronisationsintervall einstellen. Um dies manuell
	zu tun, benutzen Sie das <a href="hurd-doc-utils#syncfs">\
	  <code>syncfs</code>-Hilfsprogramm</a>.</li> 

      <li><code>base/makedev</code>, weil der Hurd eine eigene Version
	dieses Skripts mitbringt. Das Debian-Quellcodepaket enthält
	nur eine linuxspezifische Version.</li>

      <li><code>base/ld.so</code>, weil der Hurd den Linker benutzt,
	der bei der GNU C Bibliothek mitgeliefert wird.</li>
      
      <li><code>base/modconf</code> und <code>base/modutils</code>,
	weil Module ein linuxspezifisches Konzept sind.</li>

      <li><code>base/netbase</code>, weil der dort übrig gebliebene
	Kram sehr spezifisch für den Linux-Kernel ist. Der Hurd benutzt
	stattdessen <code>inetutils</code>.</li>

      <li><code>base/pcmcia-cs</code>, weil der Hurd keine
	PCMCIA-Unterstützung hat (und wenn er sie hätte, wäre das
	Paket wahrscheinlich trotzdem linuxspezifisch).</li>

      <li><code>base/procps</code>, weil der Code speziell für das
	Linux proc-Dateisystem ist.</li>

      <li><code>base/ppp</code> und <code>base/pppconfig</code>, weil
	der Hurd keine PPP-Unterstützung hat (und wenn er sie hätte,
	wäre das Paket wahrscheinlich trotzdem linuxspezifisch).</li>

      <li><code>base/setserial</code>, weil es speziell für den
	Linux-Kernel ist. Das Paket könnte dennoch nutzbar sein, wenn
	die Linuxtreiber für zeichenorientierte Geräte für den GNU
	Mach portiert werden.</li>
</ul>

<h3>Allgemeine Portierungsprobleme</h3>
<p>Nachfolgend finden sie eine Liste mit verbreiteten
Kompatibilitätsproblemen, auf die Sie stoßen könnten, wenn Sie
schlecht portable Software auf dem Hurd kompilieren.</p>

<ul>
      <li><code>Ungültiger Dateideskriptor</code> (<code>Bad File
	  Descriptor</code>)
	<p>Wenn beim Versuch, aus einer Datei zu lesen (oder sonstwie
	  auf sie zuzugreifen) ein <code>Bad File Descriptor</code>
	  Fehler auftritt, sollten sie den <code>open()</code>-Aufruf
	  überprüfen. Das zweite Argument ist die Zugriffsmethode. Wenn
	  es eine feste Nummer anstatt eines in den
	  Standard-Headerdateien definierten Symbols ist, dann ist der
	  Code nicht portabel und sollte durch Benutzung eines der drei Symbole
	  <code>O_RDONLY</code>, <code>O_WRONLY</code> oder
	  <code>O_RDWR</code> gefixt werden. Dieser Fehler trat zum
	  Beispiel in den Paketen <code>fortunes</code> und
	  <code>mtools</code> auf.</p></li>
      
      <li><code>PATH_MAX</code>
	<p>Jede unbedingte Benutzung von <code>PATH_MAX</code> ist eine
	  POSIX-Inkompatibilität. Wenn es kein oberes Limit für die Länge
	  eines Pfades gibt wird dieses Symbol in keiner Headerdatei
	  definiert. Stattdessen sollten Sie eine andere Implementierung
	  benutzen, die nicht auf die Länge eines Strings angewiesen ist
	  oder <code>sysconf()</code> benutzen, um die Länge zur Laufzeit
	  zu ermitteln. Wenn <code>sysconf()</code> <code>-1</code>
	  zurückgibt, müssen Sie <code>realloc()</code> benutzen, um den
	  benötigten Speicher dynamisch zu allozieren.</p></li>

      <li><code>MAXHOSTNAMELEN</code>
	<p>siehe <code>PATH_MAX</code></p></li>
      <li><code>MAXPATHLEN</code>
	<p>siehe <code>PATH_MAX</code></p></li>
      <li><code>NOFILE</code>
	<p>siehe <code>PATH_MAX</code></p></li>
      
      <li>hurdspezifisches <code>#define</code>
	<p>Wenn Sie speziellen Code für den Hurd mit Hilfe von
	  <code>#if...#endif</code> einfügen müssen, können Sie das
	  <code>__GNU__</code>-Symbol dafür benutzen. Aber denken Sie
	  mindestens dreimal nach, bevor Sie das tun. In den
	  <em>meisten</em> Situationen ist dies komplett unnötig und
	  schafft mehr Probleme als es löst. Fragen Sie besser auf der
	  Mailingliste nach einer besseren Lösung, wenn Ihnen keine
	  einfällt.</p></li>

      <li><code>sys_errlist[]</code> vs. <code>strerror()</code>
	<p>Wenn ein Programm nur <code>sys_errlist[]</code>
	unterstützt, müssen Sie ein wenig Arbeit leisten, um es auf dem
	Hurd zum Kompilieren zu bringen, da dieser nur noch
	<code>strerror()</code> unterstützt. Steinar Hamre schreibt
	über <code>strerror()</code>:</p>

	<blockquote class="documentquote">
	  <p><code>strerror()</code> sollte benutzt werden weil:
	  <ul>
	    <li>Es der moderne, POSIX-Weg ist.</li>
	    <li>Es lokalisiert ist.</li>
	    <li>Es ungültige Signale/Nummern außerhalb des
	    erlaubten Bereichs verarbeitet. (Bessere Fehlerbehandlung und kein
	    Pufferüberlauf-Kandidat/Sicherheitsrisiko)</li>
	  </ul> 
	  <p>Wenn verfügbar, sollte immer <code>strerror()</code> benutzt
	    werden. Leider gibt es immer noch einige <em>alte</em>
	    nicht-POSIX-Systeme, die kein <code>strerror()</code> haben,
	    nur <code>sys_errlist[]</code>.</p>
	  <p>Heute ist es wesentlich besser, nur
	    <code>strerror()</code> zu unterstützen anstatt nur
	    <code>sys_errlist[]</code>. Am besten (aus dem Blickwinkel
	    der Portabilität) ist, beide zu unterstützen. Für
	    <code>configure.in</code> brauchen Sie:</p>
	  <p><code>AC_CHECK_FUNCS(strerror)</code></p>
	  <p>In <code>config.h.in</code> müssen sie hinzufügen:</p>
	  <p><code>#undef HAVE_STRERROR</code></p>
	  <p>Und etwas wie:
	  <pre>
        \#ifndef HAVE_STRERROR
        static char *
        private_strerror (errnum)
             int errnum;
        {
          extern char *sys_errlist[];
          extern int sys_nerr;

          if (errnum &gt; 0 &amp;&amp; errnum &lt;= sys_nerr)
            return sys_errlist[errnum];
          return "Unknown system error";
        }
        \#define strerror private_strerror
        \#endif /* HAVE_STRERROR */
	  </pre>

	  <p>Sie können zum Beispiel in die neueste Version der
	    fileutils schauen (das obige ist eine vereinfachte Version
	    dessen, was ich dort gefunden habe.) Patches sollten
	    natürlich an den ursprünglichen Betreuer weitergeleitet
	    werden, das obige ist auch auf Systemen mit einem
	    funktionierenden <code>sys_errlist[]</code>
	    nützlich.</p>
	</blockquote></li>

      <li>Dateinamen, die in einem Slash <q>/</q> enden. 
	<p>Solche Dateinamen sind böse, wenn sie nicht
	  existieren und Sie ein Verzeichnis so nennen
	  wollen. <code>mkdir foobar/</code> wird beim Hurd
	  <em>nicht</em> funktionieren. Das ist
	  POSIX-kompatibel. POSIX sagt, dass der Pfad eines
	  Verzeichnisses am Ende angefügte Slashes haben darf. Aber
	  das Verzeichnis existiert noch nicht, deshalb verweist
	  der Pfad nicht auf ein Verzeichnis und so müssen abschließende
	  Slashes nicht funktionieren. Entfernen Sie einfach die
	  Slashes und alles ist ok.</p></li>
</ul>

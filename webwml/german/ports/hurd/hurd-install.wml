#use wml::debian::template title="Debian GNU/Hurd &ndash; Installation" NOHEADER="yes"
#include "$(ENGLISHDIR)/ports/hurd/menu.inc"
#use wml::debian::translation-check translation="1.107"
# $Id$
# Translator: Helge Kreutzmann <debian@helgefjell.de>  2005-07-17
# Updated: Holger Wansing <linux@wansing-online.de>, 2011, 2012.

<h1>Debian GNU/Hurd-Konfiguration</h1>
<p>
Dieses Dokument hat zum Ziel, einfache und relativ schmerzlose
Instruktionen zu vermitteln, wie man Debian GNU/Hurd 
mit minimalem Aufwand konfiguriert.
</p>

<p>Es basiert auf Neal H. Walfields <q>Hurd Installations-Anleitung</q>.
   Vielen Dank an Neal für seinen Beitrag.
</p>

<h2>Überblick</h2>

<p>
GNU ist von der Art ähnlich zu jedem Unix-artigen System: nach dem Einloggen
werden dem Benutzer eine Shell und das vertraute Unix VFS (virtuelles Dateisystem)
präsentiert. Obwohl GNU versucht, POSIX zu befolgen, ist es <q>Nicht Unix</q>.
GNU/Hurd baut auf vielen der Unix-Konzepte auf und erweitert diese, um entweder
neue Funktionalität zu ergänzen oder um zu korrigieren, was als Schwachstelle im
ursprünglichen Design angesehen wird. Der am ehesten feststellbare Unterschied
sind die Übersetzer, User-Space-Programme, die mit dem VFS interagieren. Diese
Dateisysteme leben weder im Kernel noch müssen sie als root laufen; sie müssen
nur auf die Hintergrundspeicherung und den <code>Einbindungspunkt</code> zugreifen.
Ein anderer Unterschied ist der, dass Prozesse anstelle einer einzelnen
Benutzeridentität, die bei der Erzeugung festgelegt ist, über Identitätsmarken
verfügen, die vom Prozess abgekoppelt sind, d.h. sie können mit den 
erforderlichen Rechten von einer Autorität ergänzt oder zerstört werden.
</p>

<p>
Es ist zwingend erforderlich, mit der Unix-Umgebung (und speziell
den GNU-Benutzerprogrammen, wie sie in beliebten Varianten wie beispielsweise
GNU/Linux gefunden werden können) vertraut zu sein, um sich in GNU wohlzufühlen. 
Erfahrung mit den Debian-Werkzeugen erweist sich auch als unschätzbar zur
Konfiguration und Wartung einer GNU/Hurd-Kiste.
</p>

<p>
Diese Anleitung bemüht sich, die Installation von GNU/Hurd zu einem so
schmerzlosen Prozess wie möglich zu machen. Falls Fehler vorliegen, sind
dies fast sicher Fehler des Autoren. Bitte berichten Sie diese an ihn, zusammen
mit anderen Vorschlägen und Kritik; sie werden alle dankend entgegengenommen.
</p>


#<h2>2. Grundstück oder ein Zuhause finden</h2>
#
#<p>
#Falls Sie keine verfügbare Partition oder extra Festplatte haben, kann dies
#der längste Schritt sein. In diesem Fall müssen Sie Ihre Festplatte neu
#partitionieren. Eine Möglichkeit ist es, GNUs Partitions-Editor,
#<a href="http://packages.debian.org/parted">Parted</a>, zu
#verwenden. Er bietet nicht nur grundlegende Partitionseditierung, sondern auch
#Partitionsgrößenveränderungs- und -verschiebe-Funktionalität. Das Handbuch ist
#recht vollständig und enthält mehrere Anleitungskurse. Beachten Sie, dass es
#  auch den Partitionstyp <code>63 GNU HURD or SysV</code> gibt, er sollte nicht
#  verwandt werden, da ansonsten die Installations-CD sie nicht finden wird. 
#  Verwenden Sie einfach <code>83 Linux</code>.
#</p>
#
#<p>
#Der Hurd unterstützt mehrere Erweiterungen des ext2fs-Dateisystem-Formats. 
#Zuallererst sind darunter die passiven Übersetzer und ein vierter Satz an 
#Rechte-Bits für unbekannte Benutzer (Benutzer ohne eine Identität &ndash; nicht
#der <q>other</q>-Benutzer). Um diese Erweiterungen zu benutzen, muss der Eigentümer
#der Partition auf <code>hurd</code> gesetzt werden. <code>mke2fs</code> setzt
#den Eigentümer auf den aktuell laufenden Kernel, wenn dies nicht explizit auf
#der Befehlszeile aufgehoben wird. Da der Hurd diese Einstellung fleißig 
#respektieren wird, muss darauf geachtet werden, diese zutreffend zu setzen, oder
#der Hurd wird auf subtile Art versagen. Beachten Sie, dass selbst ein 
#Dateisystem, das einem bestimmten Kernel gehört, noch von anderen benutzt
#werden kann; Sie können u.U. nur einige Erweiterungen nicht benutzen.
#</p>
#
#<p>
#Um ein Dateisystem zu erzeugen, benutzen Sie <code>mke2fs</code> und übergeben
#Sie <q><var>-b 4096 -I 128 -o hurd</var></q>, um dem Hurd anzuzeigen, dass er der neue
#Eigentümer des Dateisystems ist. Wenn beispielsweise Ihre Partition 
#<tt><q>/dev/hda1</q></tt> ist:
#</p>
#
#<table><tr><td>&nbsp;</td><td class=example><pre>
# \# mke2fs -b 4096 -I 128 -o hurd /dev/hda1
#</pre></td></tr></table>
#
#
#<h2>3. Das Boot-Lade-Programm</h2>
#
#<p>
#Das Boot-Lade-Programm des GNU-Systems ist Grub, der <q>GRand Unified Boot 
#loader</q>, und es ist seine Hauptaufgabe, den Kern des GNU-Systems (Mach und
#den Hurd) zu booten. Allerdings kann jedes Boot-Lade-Programm, das den
#Multiboot-Standard unterstützt, dazu verwendet werden, Mach und den Hurd zu
#laden. Momentan (soweit uns das bewusst ist) ist der GNU Grub das einzige 
#Boot-Lade-Programm, das so einen Standard unterstützt.
#</p>
#
#<p>
#Ein Wort über Grub. Anders als traditionelle Boot-Lade-Programme auf x86, wie
#LILO, ist Grub sehr mächtig. Es hat eine Kommandozeilenschnittstelle, bootp,
#dummy-Terminal-Unterstützung und eine Fülle an anderen Funktionen. Zusätzlich
#kann er fast jeden Kernel booten. Falls Sie jemals eine Alpha oder Sparc
#gebootet haben, werden Sie verstehen, was Grub machen kann. Daher seien Sie nicht
#verängstigt: Grub ist besser. Sie werden ihn mögen. Sie werden nicht 
#zurückkehren.
#</p>
#
#<p>
#Es ist wahrscheinlich besser, dass Sie 
#<a href="http://packages.debian.org/grub2">Grub</a> vor der Installation von
#Hurd installieren. Sie können es aber auch zu jedem späteren Zeitpunkt auf Ihre Festplatte installieren.
#</p>
#
#
#<h2>4. Cross-Installation</h2>
#
#<p>
#Der nächste Schritt ist das Erhalten des Basis-Systems. Es gibt mehrere 
#Alternativen, falls Sie ein Debian-System verwenden, können Sie das Paket
#<q>crosshurd</q> verwenden. Andernfalls können Sie ein aktualisiertes
#Basissystem-Tar-Archiv von einem beliebigen unter
#<url "http://wiki.debian.org/DebianPorts/Mirrors" />
#aufgeführten Spiegel holen.
#</p>
#
#<p>
#Das Tar-Archiv ist so aufgesetzt, dass alles in das aktuelle Verzeichnis
#extrahiert wird. Nachdem das Dateisystem eingehängt ist, kann das Archiv
#extrahiert werden. Ist das Dateisystem beispielsweise auf <tt><q>/dev/hda2</q></tt>,
#der Einhängepunkt <tt><q>/gnu</q></tt> und das Archiv im aktuellen Home-Verzeichnis
#des Benutzers, dann wird das Folgende benötigt:
#</p>
#
#<table><tr><td>&nbsp;</td><td class=example><pre>
# \# mount -t ext2 /dev/hda2 /gnu
# \# cd /gnu
# \# tar --same-owner -xvjpf ~/gnu.tar.bz2
#</pre></td></tr></table>
#
#
#<h2>5. GNU/Hurd booten</h2>
#
#<p>
#  Alles ist nun in Bereitschaft, um GNU/Hurd zum ersten Mal zu booten. Beachten
#  Sie, dass abhängig von der Version von GRUB sich kleine Details unterscheiden
#  werden. Bitte stellen Sie sicher, ob Sie GRUB1 (auch <q>legacy</q> oder
#  0.95 oder neuer bis 0.97) oder GRUB2 (auch 1.95 oder neuer) haben. Die 
#  folgenden Beispiele berücksichtigen beide Versionen, wählen Sie die richtige
#  aus. 
#</p>
#<p>
#  Beachten Sie bitte weiterhin, dass einige Fehler gemeldet wurden, wenn mit nur
#  128 MB gebootet wird, da zu diesem Zeitpunkt noch kein Swap eingerichtet ist.
#  Stellen Sie sicher, dass mindestens 256 MB Arbeitsspeicher zur Verfügung stehen.
#</p>
#<p>
#  Falls auf Ihrem System bereits GRUB installiert ist, starten Sie das 
#  System einfach neu. Andernfalls müssen Sie ein Grub-Boot-Medium benutzen. 
#  Unter Debian stellen die Pakete grub-disk (grub1) bzw. grub-rescue-pc (grub2)
#  CD- und Disketten-Images bereit. Stellen Sie sicher, dass das Grub-Boot-Medium
#  im Laufwerk ist und starten Sie das System neu. Falls alles klappt, wird
#  entweder ein Grub-Menü oder eine Befehlszeile angezeigt. Falls im Menü ein
#  <tt><q>GNU/Hurd</q></tt>-Eintrag vorliegt, können Sie es wahrscheinlich 
#  benutzen, um viele Tipparbeit zu sparen. Erstmal drücken Sie <kbd>c</kbd>,
#  falls Ihnen das Menü angezeigt wird, um auf die Befehlszeile zu wechseln.
#</p>
#
#<p>
#Zuerst muss der GNU Mach geladen werden. Dies benötigt das Wissen über das
#Dateisystem und den Pfad zu GNU Mach. Grub benutzt eine Partitions-Nomenklatur,
#die sich ein bisschen von Linux und dem Hurd unterscheidet: sowohl IDE als auch
#SCSI-Laufwerke werden <tt><q>(hdN,M)</q></tt> benannt. <code>N</code> ist die
#Laufwerksnummer (mit Null beginnend) wie sie vom BIOS durchnummeriert wird.
#Das bedeutet, Grub unterscheidet nicht zwischen IDE- und SCSI-Platten. 
#<code>M</code> identifiziert die Partition auf dem Laufwerk. Bei Grub1 ist dies
#  auch ein bei Null beginnender Index, bei Grub2 beginnt er mit 1.
#  Falls dies verwirrend klingt, entspannen Sie sich: Der
#Grub ist auch hilfsbereit.
#</p>
#
#<p>
#Um zu bestimmen, auf welchem Dateisystem eine bestimmte Datei liegt, bietet
#Grub den <code>find</code>-Befehl. Wenn dieser Befehl zusammen mit einem 
#Dateinamen geäußert wird, sucht Grub auf jedem Dateisystem nach der 
#spezifizierten Datei und gibt aus, wo sie gefunden wurde. Um zum Beispiel nach
#dem Kernel <tt><q>/boot/gnumach.gz</q></tt> zu suchen:
#</p>
#
#<table><tr><td>&nbsp;</td><td class=example><pre>  
#   grub1&#62; find /boot/gnumach.gz
#   (hd0,0)
#</pre></td></tr>
#<tr><td>&nbsp;</td><td class=example><pre>
#   grub2&#62; search -f /boot/gnumach.gz
#   (hd0,1)
#</pre></td></tr>
#</table>
#
#<p>
#Hier gibt Grub1 an, dass <tt><q>/boot/gnumach.gz</q></tt> auf 
#  <tt><q>(hd0,0)</q></tt> ist und Grub2, dass es auf <tt><q>(hd0,1)</q></tt>
#  ist (denken Sie an die Unterschiede in der Partitionsnummerierung zwischen
#  Grub1 und Grub2). Um Ihnen Tipparbeit zu sparen, setzen Sie Grubs Wert für 
#  root auf diesen Wert:
#</p>
#
#<table>
#<tr><td>&nbsp;</td><td class=example><pre>
#   grub1&#62; root (hd0,0)
#</pre></td></tr>
#<tr><td>&nbsp;</td><td class=example><pre>
#   grub2&#62; set root=(hd0,1)
#</pre></td></tr>
#</table>
#
#<p>
#Vor dem Laden des Kernels muss mindestens eine Option, die Wurzel-Partition, auf
#der Befehlszeile spezifiziert werden. Dies wird vom Hurd selber (d.h. nicht von
#Grub) verwendet. Als solche muss sie so bezeichnet sein, dass der Hurd sie
#verstehen kann.
#</p>
#
#<p>
#GNU Mach nummeriert Platten beginnend bei Null. IDE-Laufwerke haben das Präfix
#<code>hd</code> während SCSI-Platten das Präfix <code>sd</code> haben. Wie bei
#Linux werden die Laufwerke entsprechend Ihrer Position am Kontroller nummeriert.
#Zum Beispiel ist der primäre Master <code>hd0</code> und der sekundäre Slave
#<code>hd3</code>. Partitionen benutzen die BSD-<q>Slice</q>-Namenskonvention und
#hängen <code>sM</code> an den Laufwerksnamen an, um eine bestimmte Partition
#anzuzeigen. Die Slice-Zahl ist einfach zu berechnen: falls Sie Grub2 einsetzen,
#  verwenden Sie den gleichen Index, im Falle von Grub1 erhöhen Sie einfach die
#von Grub verwendete Zahl um eins.
#</p>
#
#<p>
#Da der Hurd noch nicht konfiguriert wurde, muss er im Einzelbenutzermodus
#gestartet werden. Hierzu reicht die Ergänzung von <q><var>-s</var></q> auf der
#Kernel-Befehlszeile.
#</p>
#
#<p>
#  In Summe hätten wir unter der Annahme, dass das erste Laufwerk (d.h. 
#  <tt><q>(hd0)</q></tt>) der Master auf dem sekundären Kontroller ist:
#</p>
#
#<table>
#<tr><td>&nbsp;</td><td class=example><pre>
#   grub1&#62; kernel /boot/gnumach.gz root=device:hd0s1 -s
#   [Multiboot-elf, ...]
#</pre></td></tr>
#<tr><td>&nbsp;</td><td class=example><pre>
#   grub2&#62; multiboot /boot/gnumach.gz root=device:hd0s1 -s
#</pre></td></tr>
#</table>
#
#<p>
#Als nächstes muss der Wurzeldateisystem-Server und der <code>exec</code>-Server
#geladen werden. Dies geschieht mittels Grubs Boot-Modul Lademöglichkeit. Die
#${var} werden von GNU Mach eingefüllt. Die Argumente werden vom Hurd verwendet
#um anzugeben, was für eine Art von Information bereitgestellt wird. Da die 
#ext2fs-Befehlszeile sehr lang ist, kann Sie durch Schützen des 
#Zeilenumbruchzeichens in normaler Unix-Manier umgebrochen werden. Stellen Sie
#sicher, dass nach dem umgedrehten Schrägstrich am Zeilenende kein Leerzeichen folgt. Stellen
#Sie auch sicher, <kbd>{</kbd> und <kbd>}</kbd> von <kbd>(</kbd> und <kbd>)</kbd>
#zu unterscheiden. Beachten Sie die subtilen Unterschiede zwischen Grub1 und
#  Grub2: Bei Grub2 muss der Dateiname wiederholt und Anführungszeichen verwandt
#  werden. Beachten Sie, dass in dieser Stufe die Option <q>--readonly</q> von
#  <code>ext2fs.static</code> nicht übergeben werden darf.
#</p>
#
#<table><tr><td>&nbsp;</td><td class=example><pre>  
#  grub1&#62; module /hurd/ext2fs.static \
#   --multiboot-command-line=${kernel-command-line} \
#   --host-priv-port=${host-port} \
#   --device-master-port=${device-port} \
#   --exec-server-task=${exec-task} -T typed ${root} \
#   $(task-create) $(task-resume)
#    [Multiboot-module  0x1c4000, 0x2cfe6a bytes]
#  grub1&#62; module /lib/ld.so.1 /hurd/exec $(exec-task=task-create)
#    [Multiboot-module  0x494000, 0x27afe bytes]
#</pre></td></tr>
#<tr><td>&nbsp;</td><td class=example><pre>
#  grub2&#62; module /hurd/ext2fs.static ext2fs \
#   --multiboot-command-line='${kernel-command-line}' \
#   --host-priv-port='${host-port}' \
#   --device-master-port='${device-port}' \
#   --exec-server-task='${exec-task}' -T typed '${root}' \
#   '$(task-create)' '$(task-resume)'
#  grub2&#62; module /lib/ld.so.1 exec /hurd/exec '$(exec-task=task-create)'
#</pre></td></tr>
#</table>
#
#<p>
#  Als Alternative können Sie diese Befehle auch in die Konfigurationsdatei 
#  <tt><q>menu.lst</q></tt> (Grub1) oder <tt><q>grub.cfg</q></tt> (Grub2) eintragen
#  und dann mittels <tt><q>configfile /pfad/zu/menu.lst</q></tt> (Grub1) oder 
#  <tt><q>configfile /pfad/zu/grub.cfg</q></tt> (Grub2) von der
#  grub-Eingabeaufforderung aktivieren. Sie können natürlich grub auch einfach in den 
#  <acronym lang="en" title="Master Boot Record">MBR</acronym> installieren und dann daraufhin verweisen.
#</p>
#
#<p>
#GNU/Hurd kann nun gebootet werden:
#</p>
#
#<table><tr><td>&nbsp;</td><td class=example><pre>
#grub&#62; boot
#</pre></td></tr></table>
#
#<p>
#Falls der GNU/Hurd nicht bootet, könnte dies an geteilten IRQs liegen: GNU Mach
#arbeitet nicht gut mit diesen. Sie können Ihre Situation bestätigen, indem Sie
#beispielsweise in die <tt><q>/proc/interrupts</q></tt>-Datei unter Linux schauen. 
#Da der GNU Mach auch keine ladbaren Kernelmodule unterstützt, sind viele Treiber
#in den Standardkernel einkompiliert. Falls es alte Peripherie gibt, kann dies ein
#Problem sein: Ein Gerät könnte auf eine Sondierung für ein komplett anderes
#Gerät ohne Bezug reagieren und dadurch einen Absturz hervorrufen. Das Bauen
#eines neuen Kernels mit nur den benötigten Gerätetreibern löst normalerweise
#dieses Problem. GNU Mach kann einfach cross-kompiliert werden. Falls Sie Debian
#betreiben, versuchen Sie das <tt><q>mig</q></tt>-Paket zu installieren und der
#normale <tt><q>gcc</q></tt> sollte es erledigen.
#</p>
#
#<p>
#Falls dies nicht hilft fragen Sie auf der angemessenen Mailingliste.
#</p>
#
#
#<h2>6. Native Installation</h2>
#
#<p>
#Sobald Ihnen eine Shell-Eingabeaufforderung präsentiert wird, und immer wenn
#der Hurd im Einzelbenutzermodus ist, ist es notwendig, den Terminaltyp 
#einzustellen:
#</p>
#
#<table><tr><td>&nbsp;</td><td class=example><pre>
#\# export TERM=mach
#</pre></td></tr></table>
#
#<p>
#Seien Sie gewarnt, dass <kbd>CONTROL-C</kbd> und Freunde im Einzelbenutzermodus
#nicht funktionieren.
#</p>
#
#<p>
#Wir können nun das <code>native-install</code>-Skript laufen lassen. Dies wird
#die Pakete konfigurieren und mehrere wichtige Übersetzer einrichten:
#</p>
#
#<table><tr><td>&nbsp;</td><td class=example><pre>
#\# ./native-install
#</pre></td></tr></table>
#
#<p>
#Bevor sich das Skript beendet, wird es angeben, dass es ein zweites Mal laufen
#muss. Folgen Sie den Anweisungen und rebooten Sie mittels des
#<code>reboot</code>-Befehls. Gehen Sie wieder in den Einzelbenutzermodus und 
#lassen Sie <code>./native-install</code> laufen.
#</p>
#
#

<h2>Installation</h2>

<p>
Sie können einfach den Debian-Installer verwenden, siehe die
<a href="hurd-cd">vorbereiteten CD-Images</a>.
Dann sind die folgenden Schritte nötig für eine korrekte Konfiguration.
</p>

<h2>Konfiguration</h2>


<h3>Das Netzwerk</h3>

<p>
Der Debian-typische Weg wird derzeit nicht unterstützt:
<tt>/etc/network/interfaces</tt> wird ignoriert, <tt>ifup</tt> und
<tt>ifdown</tt> funktionieren nicht. Bis auf Weiteres wird lediglich der
<q>Hurdische</q> Weg unterstützt.
</p>

<p>
  Stellen Sie zuerst sicher, dass Ihre Netzwerkkarte von GNU Mach erkannt wird:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
 \# devprobe eth0
 eth0
</pre></td></tr></table>

<p>
  Falls <code>devprobe eth0</code> nicht <code>eth0</code> ausgibt, hat der
  Kernel Ihre Netzwerkkarte nicht erkannt und Sie müssen eine andere
  ausprobieren. Beispielsweise wird die Karte e1000 von Qemu nicht
  unterstützt, die rtl8139 sollte aber funktionieren:
  <code>-net nic,model=rtl8139 -net user</code>
</p>

<p>
Beginnend mit Version 20120520-1 enthält das hurd-Paket DDE-Treiber, die
verwendet werden können, um aktuellere Geräte zu unterstützen (die Treiber
stammen aus Linux 2.6.32). Übersetzer dafür wurden bereits für Sie eingerichtet;
alles was Sie tun müssen ist, im Rest dieses Dokuments <code>eth0</code> (den
Mach-Treibernamen) durch <code>/dev/eth0</code> (den DDE-Treiberpfad) zu ersetzen.
</p>

<p>
Es ist möglich zu versuchen, den DDE-Treiber zu verwenden, auch wenn GNU Mach
einen Treiber enthält: das Hinzufügen von <code>nonetdev</code> auf der
gnumach-Kommandozeile wird den GNU Mach-Treiber deaktivieren, und der
DDE-Treiber wird mit seiner Arbeit beginnen.
</p>

<p>
Falls das Netzwerk nicht zu funktionieren scheint, verwenden Sie Folgendes,
um Debugging-Informationen vom DDE-Treiber zu erhalten:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
 \# settrans -fgap /dev/netdde /hurd/netdde
</pre></td></tr></table>

<p>
und beenden Sie dann alle devnode- und pfinet-Prozesse, um diese mit dem
neueren netdde neu starten zu lassen. Wenn es immer noch nicht funktioniert,
schicken Sie uns bitte die Ausgabe des obigen settrans-Befehls für netdde
sowie die Ausgabe von <code>lspci</code> und <code>lspci -n</code> .
</p>

<p>
Um das Netz zu konfigurieren, muss der pfinet-Übersetzer konfiguriert werden.
Dies kann durch die Verwendung von <code>dhclient</code> aus dem
<code>isc-dhcp-client</code>-Paket geschehen, allerdings wurde dessen Start
noch nicht automatisiert. Manuell kann dies auch mittels
<code>inetutils-ifconfig</code> aus dem <code>inetutils-tools</code>-Paket
erledigt werden. Oder zu guter Letzt (und dauerhaft abgespeichert) ebenfalls über den
<code>settrans</code>-Befehl, um einen
Übersetzer an einen gegebenen Dateisystemknoten anzubinden. Wenn Programme
auf den Knoten, beispielsweise durch Senden eines RPC, zugreifen, wird das
Betriebssystem transparent den Server starten, um die Anfrage zu bearbeiten.
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
 \# settrans -fgap /servers/socket/2 /hurd/pfinet -i eth0 \
   -a a.b.c.d -g e.f.g.h -m i.j.k.l
</pre></td></tr></table>

<p>
Hier werden <code>settrans</code> mehrere Optionen übergeben. Die ersten zwei,
<q><var>fg</var></q>, erzwingen, dass existierende Übersetzer verschwinden. Die
nächsten zwei, <q><var>ap</var></q>, erzeugen sowohl aktive als auch passive
Übersetzer. Indem wir aktive Übersetzer erzeugen, sehen wir sofort jede 
Fehlermeldung auf <tt><q>stderr</q></tt>. Der Letztere speichert den Übersetzer und
die Befehle im Knoten, so dass er später transparent neu gestartet werden kann (d.h.
die Einstellungen bleiben persistent über Neustarts hinweg erhalten). Hinter den
Optionen folgen der Knoten, an den der Übersetzer angebunden werden soll, dann
das zu startende Programm (d.h. der Übersetzer) und schließlich jedes Argument,
das Sie ihm übergeben. Die <q><var>-i</var></q>-Option ist die Schnittstelle, auf
der <code>pfinet</code> auf Verbindungen warten wird, <q><var>-a</var></q> ist
die IP-Adresse,
<q><var>-g</var></q> ist das Gateway und <q><var>-m</var></q> ist die Netzmaske.
</p>

<p>
Stellen Sie sicher, dass Sie Nameserver zu Ihrer 
<tt><q>/etc/resolv.conf</q></tt>-Datei hinzufügen:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
  nameserver 192.168.1.1
</pre></td></tr></table>

<p>
Um diese Konfiguration zu testen: <code>ping -c2 gateway</code>. Das
<q><var>-c</var></q> ist wichtig, um die Anzahl der Pings zu begrenzen; erinnern
Sie sich, dass <kbd>CONTROL-C</kbd> im Einzelbenutzermodus nicht funktioniert.
</p>

<p>
Hilfe über <code>settrans</code> können Sie durch Übergabe der 
<q><var>--help</var></q>-Option erhalten. Hilfe über einen speziellen
Übersetzer erhalten Sie, indem er von der Befehlszeile mit dem gleichen
Argument aufgerufen wird, z.B.:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
\# /hurd/pfinet --help
</pre></td></tr></table>

<p>
Da dies viel Ausgabe erzeugen kann, sollten Sie überlegen, diese durch ein
seitenbasiertes Anzeigeprogramm wie <code>less</code> zu leiten.
</p>

<p>
Um auch IPv6-Unterstützung zu konfigurieren, muss die gleiche Konfiguration
für <tt>/servers/socket/2</tt> und <tt>/servers/socket/26</tt> derart
durchgeführt werden, dass sie sich gegenseitig referenzieren (damit nur
einer wirklich gestartet wird) und an beide Knoten gebunden sind:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
 \# settrans -fgap /servers/socket/2 /hurd/pfinet -6 /servers/socket/26 -i eth0 \
   -a a.b.c.d -g e.f.g.h -m i.j.k.l
 \# settrans -fgap /servers/socket/26 /hurd/pfinet -4 /servers/socket/2 -i eth0 \
   -a a.b.c.d -g e.f.g.h -m i.j.k.l
</pre></td></tr></table>

<p>
Der pfinet-Server aktiviert IPv6-Autokonfiguration als Standardeinstellung. Der
aktuelle Status kann mit <tt>fsysopts /servers/socket/26</tt> abgefragt werden.
Adressen können auch von Hand festgelegt werden, indem z.B.
<tt>-A 2001:123:123::42/64 -G 2001:123:123::1</tt> verwendet wird.
</p>

<p>
Die Konfiguration von pfinet kann auch live verändert werden (ohne Abspeicherung
auf Festplatte), indem <tt>fsysopts</tt> verwendet wird:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
 \# fsysopts /servers/socket/2
 /hurd/pfinet --interface=eth0 --address=10.3.0.1 --netmask=255.255.0.0 --gateway=10.3.0.128
 \# fsysopts /server/socket/2 -a 10.3.0.2 -m 255.255.0.0 -g 10.3.0.128
</pre></td></tr></table>

<h3>Tastaturbelegung</h3>

<p>
Die Belegung der Tastatur kann über das standardmäßige
<code>keyboard-configuration</code>-Paket konfiguriert werden. Stellen Sie sicher,
dass dies installiert ist und führen Sie <code>dpkg-reconfigure
keyboard-configuration</code> aus. Der Effekt wird nicht unmittelbar sichtbar
sein, da die Konsole neu gestartet werden muss, um die geänderten Parameter
in Betracht zu ziehen. Ein Systemneustart zum Beispiel sollte dies erledigen.
</p>

<h3>Andere Dateisysteme</h3>

<p>
Als nächstes editieren Sie <tt><q>/etc/fstab</q></tt>, um weitere Dateisysteme sowie
Auslagerungsspeicher (<q>swap space</q>) hinzuzufügen. Es ist <em>sehr wichtig</em>,
dass ein Auslagerungsspeicher verwendet wird; der Hurd wird um eine Größenordnung
stabiler sein. Beachten Sie, dass sich der Hurd transparent eine 
Auslagerungspartition mit Linux teilen kann, aber auch fröhlich in jedes Gerät auslagern kann,
das eine rohe Partitionstabelle enthält, wie beispielsweise Ihre Home-Partition.
Standardmäßig sind <code>nano</code> und <code>vi</code>
die einzigen Editoren, die in der
Basisdistribution installiert werden.
</p>

<p>
Hier ist eine <tt><q>/etc/fstab</q></tt>-Datei als Beispiel:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
\# &#60;file system&#62; &#60;mount point&#62;   &#60;type&#62;  &#60;options&#62;  &#60;dump&#62;  &#60;pass&#62;
/dev/hd0s1      /               ext2    rw         0       1
/dev/hd0s2      /home           ext2    rw         0       2
/dev/hd0s3      none            swap    sw         0       0
</pre></td></tr></table>

<p>
Falls irgendeine <code>/dev</code>-Gerätedatei fehlt, denken Sie daran, sie mit dem
<code>MAKEDEV</code>-Befehl anzulegen:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
 \# cd /dev
 \# ./MAKEDEV hd0s1 hd0s2 hd0s3
</pre></td></tr></table>

<p>
Sie können auch ein Dateisystem von Hand einbinden, indem Sie <code>settrans</code>
aufrufen:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
 \# settrans /mnt /hurd/ext2fs /dev/hd0s5
</pre></td></tr></table>

<p>
Die Idee hinter diesem Kommando ist, dass Sie auf dem <code>/mnt</code>-Knoten
den <code>/hurd/ext2fs /dev/hd0s5</code>-Übersetzer setzen. <code>/hurd/ext2fs</code>
wird ausgeführt und beginnt, <code>/dev/hd0s5</code> zu lesen/zu schreiben und dessen
Inhalt in <code>/mnt</code> anzuzeigen. Mehr Informationen finden Sie in der
<a href="hurd-doc-translator">Dokumentation über Übersetzer</a>.
</p>

<p>
Um ein NFS-Dateisystem einzubinden, wird der <code>/hurd/nfs</code>-Übersetzer
verwendet. Falls er nicht als root läuft, wird er sich am Server mit einer 
Port-Nummer oberhalb von 1023 anmelden. Standardmäßig wird GNU/Linux dies
ablehnen. Um GNU/Linux mitzuteilen, Verbindungen aus nicht-reservierten Ports
zu akzeptieren, ergänzen Sie die <q><var>insecure</var></q>-Option zu der 
export-Zeile. Hier ist eine <tt><q>/etc/exports</q></tt>-Datei als Beispiel, die 
annimmt, dass die IP-Adresse des Clients <tt><q>192.168.1.2</q></tt> ist:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
  /home  192.168.1.2(rw,insecure)
</pre></td></tr></table>

<p>
Um dies von einer GNU-Kiste einzubinden und unter der Annahme, dass die 
IP-Adresse des NFS-Servers <tt><q>192.168.1.1</q></tt> ist:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
\# settrans -cgap /mount/point /hurd/nfs 192.168.1.1:/home
</pre></td></tr></table>

<h2>Spaß haben mit Debian GNU/Hurd</h2>

<p>
Nun, welche tollen Sachen können wir jetzt mit dem Hurd machen?
</p>

<h3>Disk-Images einbinden</h3>

<p>
Auf den Inhalt eines CD-Images zuzugreifen ist mit Standard-Unix-Systemen ein
wenig mühsam, wenn Sie nicht root sind. Unter GNU/Hurd läuft dies auf Folgendes
hinaus:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
settrans ~/mnt /hurd/iso9660fs CD_image.iso
</pre></td></tr></table>

<p>
Und es ist total sicher: der <code>iso9660fs</code>-Übersetzer läuft unter
Ihrer Identität, nicht als root. Sie können sogar Ihren eigenen Übersetzer für
jede Art von Dateisystem programmieren. Ja, dies ist wie FUSE. Aber ohne den
ganzen Behelf.
</p>

<h3>Transparentes FTP</h3>

<p>
Folgender Befehl setzt ein transparentes <code>ftp</code>-Verzeichnis auf:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
settrans -c /ftp: /hurd/hostmux /hurd/ftpfs /
</pre></td></tr></table>

<p>
Wechseln Sie nun mit <code>cd</code> z.B. nach <code>/ftp://ftp.gnu.org/</code>
und führen Sie dort <code>ls</code> aus.
Ja, Sie können von Ihrem Home-Verzeichnis aus einfach
<code>tar xf ftp://ftp.gnu.org/pub/gnu/gcc/gcc-4.6.0/gcc-4.6.0.tar.bz2</code>
ausführen!
</p>

<h3>Sub-Hurd</h3>

<p>
Ein <a href="http://www.gnu.org/software/hurd/hurd/subhurd.html">Sub-Hurd</a>
ist ein vollständiges Untersystem, auf den ersten Blick Virtualisierungs-Containern
sehr ähnlich. Außer dass man nicht root sein muss, um eines laufen zu lassen.
</p>

<h3>gdb ext2fs, pfinet, ...</h3>

<p>
Ja, Sie können gdb z.B. auf die ext2fs-Implementation laufen lassen oder auf den
<code>pfinet</code> TCP/IP-Stack usw.
</p>

<h3>Und vieles mehr!</h3>

<p>
Zu weiteren Dingen, die noch in Arbeit sind, gehören 
<code>mboxfs</code>, <code>tarfs</code>, <code>xmlfs</code>, <code>gopherfs</code> ...
</p>

#<h3>7.3 Neustart</h3>
#
#<p>
#Schließlich rebooten Sie in den Mehrbenutzermodus, d.h. auf die gleiche Art, wie
#der Einzelbenutzermodus hochgebracht wurde ohne die <q><var>-s</var></q>-Option
#beim Laden des Kernels. Für Details lesen Sie den Abschnitt 5 <q>GNU/Hurd booten</q>.
#</p>
#
#<p>
#Lustiges Hacken!
#</p>


<h2>Abschließende Worte</h2>

<p>
Das folgende sind lediglich einige, während der Installation notierte kurze
Hinweise, stellen Sie sicher, dass Sie auch Dokumentation für das installierte
System lesen: die <a href=hurd-doc>Debian GNU/Hurd-Dokumentation</a>, aber auch die
<a href=http://hurd.gnu.org/>Original-Website des GNU/Hurd-Projekts</a>.
</p>

#<h3>8.1 Das Grub-Menü</h3>
#
#<p>
#Immer den Kernel von Hand zu laden kann sehr ermüdend werden. Editieren Sie
#  <tt><q>/boot/grub/menu.lst</q></tt> für Grub1 bzw. 
#  <tt><q>/boot/grub/grub.cfg</q></tt> für Grub2 und passen Sie sie entsprechend
#  an; das Booten
#wird viel schneller und leichter werden.
#</p>
#
#
#<h3>8.2 Geräte ergänzen</h3>
#
#<p>
#Standardmäßig sind nur einige Geräte im <tt><q>/dev</q></tt>-Verzeichnis angelegt.
#Benutzen Sie das <code>MAKEDEV</code>-Skript, um jedes benötigte Gerät anzulegen.
#</p>


<h3>Weitere Pakete installieren</h3>
<p>
Es gibt mehrere Wege, um Pakete zu ergänzen. Herunterladen und 
<code>dpkg -i</code> verwenden funktioniert, ist aber sehr unbequem. Die einfachste Methode
ist die Verwendung von <code>apt-get</code>. Editieren Sie
<tt><q>/etc/apt/sources.list</q></tt> und ergänzen Sie einen der folgenden
unreleased-Einträge für
<url "http://www.debian-ports.org/mirrors">, installieren Sie dann das Paket
<code>debian-ports-archive-keyring</code>:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
deb http://ftp.debian-ports.org/debian unreleased main
</pre></td></tr></table>

<p>
  <url "http://ftp.debian-ports.org/" /> und seine Spiegel enthalten Pakete, die
  Korrekturen oder Patches enthalten, die noch nicht von den Originalautoren
  oder Debian integriert wurden.
</p>

<p>
  Und den Unstable-Eintrag von einem der Debian-Spiegel (schauen Sie auf
  <url "http://www.debian.org/mirror/list" /> für die komplette Liste), der diese
  Architektur bedient (falls apt <q>bad archive mirror</q> meldet, versuchen
  Sie einen anderen Spiegel):
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
deb http://ftp.fr.debian.org/debian unstable main
</pre></td></tr></table>

<p>
Falls GNU Mach Ihre Netzwerk-Karte nicht erkennt oder Sie ein Modem verwenden,
ist der einzige Weg, ein Upgrade durchzuführen, das Herunterladen der Pakete und
die Übertragung in das GNU System. Der einfachste Weg hierzu ist die Verwendung
von apt off-line. Lesen Sie <tt><q>/usr/share/doc/apt-doc/offline.text.gz</q></tt> 
für detaillierte Instruktionen.
</p>


<h3>Die Hurd-Konsole</h3>

<p>
Neben der Mach-Konsole, der Sie während der Installation begegnen, weist der
GNU/Hurd eine mächtige Konsole mit virtuellen Terminals im Userspace auf.
Sie sollte automatisch beim Booten gestartet werden, ansonsten können
Sie sie manuell mit dem folgenden Befehl starten:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
 \# console -d vga -d pc_mouse --repeat=mouse -d pc_kbd --repeat=kbd -d generic_speaker -c /dev/vcs
</pre></td></tr></table>

<p>
Das automatische Starten der Konsole wird in <tt>/etc/default/hurd-console</tt>
aktiviert.
</p>

<p>
Innerhalb der Hurd-Konsole können Sie zwischen virtuellen Terminals via
<kbd>ALT+F1</kbd>, <kbd>ALT+F2</kbd> und so weiter wechseln.
<kbd>ALT+CTRL+BACKSPACE</kbd> hängt die Hurd-Konsole ab und bringt Sie zurück 
zur Mach-Konsole, von der aus Sie sich wieder mit dem obigen Befehl 
zurückverbinden können.
</p>


<h3>X.Org</h3>

<p>
X.Org ist portiert worden und alle Grafikkarten, die es unterstützt und die
kein Kernelmodul oder DRM erfordern, sollten funktionieren.
</p>

<p>
  Die Hurd-Konsole muss bereits laufen und die Repeater müssen eingerichtet
  sein, wie dies in dem vorherigen Abschnitt beschrieben ist.
</p>

<p>
Sie müssen <tt>dpkg-reconfigure x11-common</tt> ausführen, um jedem Benutzer
zu ermöglichen, Xorg zu starten, da der X-Wrapper nichts von den Hurd- und Mach-Konsolen
weiß.
</p>

<p>
Sie müssen auch die Datei <tt>/etc/X11/xorg.conf</tt> mit folgendem Inhalt
erstellen, um das Tastenkürzel Strg-Alt-Zurück (Ctrl-Alt-Backspace) zu aktivieren:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
Section "InputDevice"
   Identifier "Generic Keyboard"
   Driver "kbd"
   Option "XkbOptions" "terminate:ctrl_alt_bksp"
EndSection
</pre></td></tr></table>

<p>

Sie werden mehrere X-Pakete benötigen. <code>xorg</code>, 
<code>rxvt</code> und ein Window-Manager wie 
<code>twm</code>, <code>fvwm</code>, <code>wmaker</code>, <code>icewm</code>,
<code>openbox</code>, ... sind ein guter Anfang.
</p>

<p>
  X.Org sollte sofort ohne eine Konfigurationsdatei funktionieren. Allerdings
  könnte in manchen Fällen die Verwendung des VESA-Treibers notwendig sein.
</p>

<p>
Schließlich geben Sie <code>startx</code> ein.
</p>

<h3>Letzte Worte</h3>

<p>
Das SysV rc-System wird noch nicht verwendet. Um Ihr System herunterzufahren,
benutzen Sie einfach <code>halt</code> oder <code>reboot</code>.
</p>

#use wml::debian::template title="Debian GNU/Hurd &dash; Installation" NOHEADER="yes"
#include "$(ENGLISHDIR)/ports/hurd/menu.inc"
#use wml::debian::translation-check translation="1.50"
# $Id$
# Translator: Helge Kreutzmann <debian@helgefjell.de>  2005-07-17


<h1>Debian GNU/Hurd-Installation</h1>
<p>
Dieses Dokument hat als Ziel, einen einfachen und relativ schmerzlosen Satz an
Instruktionen zu vermitteln, wie man mit einem minimalen Aufwand Debian GNU/Hurd
zum Laufen bekommt.
</p>

<p>Es basiert auf Neal H. Walfields <q>Hurd Installations-Anleitung</q>.
   Vielen Dank an Neal für seinen Beitrag.
</p>

<p>
Beachten Sie, dass einige Punkte in diesem Handbuch ein bisschen unbequem sind,
da sie eine lange Zeit in Anspruch nehmen und Probleme verursachen können. Sie könnten
die Installation über die <a href="hurd-cd">vorbereiteten CD-Images</a>
bevorzugen, insbesondere wenn Sie ein Anfänger sind. Selbst wenn sie veraltet
sind, funktionieren sie in der Regel. Sie können Aktualisierungen immer noch
aus den Online-Depots erhalten.
</p>

<h2>1. Überblick</h2>

<p>
Die Debian GNU/Hurd-Distribution hat, anders als Distributionen anderer
Betriebssysteme, kein nettes Installationsprogramm. Eines Tages mag es dies
haben, und Sie werden beim Design und der Implementation helfen; bis zu diesem
Tag wird die Installation von Debian GNU/Hurd ein anderes Betriebssystem,
speziell ein Unix-artiges System, benötigen. Die Benutzer haben erfolgreiche
Installationen über verschiedene Arten von GNU/Linux sowie BSDs gemeldet. Die
minimalen Anforderungen an das ur-ladende Betriebssystem sind die Fähigkeiten:
ein ext2-Dateisystem zu erzeugen; ein Tar-Archiv darauf zu extrahieren und
GNU Grub zu installieren.
</p>

<p>
GNU ist von der Art ähnlich zu jedem Unix-artigen System: nach dem Einloggen
werden dem Benutzer eine Shell und das vertraute Unix VFS (virtuelle Dateisystem)
präsentiert. Obwohl GNU versucht, POSIX zu befolgen, ist es <q>Nicht Unix</q>.
GNU/Hurd baut auf vielen der Unix-Konzepte auf und erweitert diese, um entweder
neue Funktionalität zu ergänzen oder um zu korrigieren, was als Schwachstelle im
ursprünglichen Design angesehen wird. Der am ehesten bemerkbare Unterschied
sind die Übersetzer, User-Space-Programme, die mit dem VFS interagieren. Diese
Dateisysteme leben weder im Kernel noch müssen sie als root laufen; sie müssen
nur auf die Hintergrundspeicherung und den <code>Einhängepunkt</code> zugreifen.
Ein anderer Unterschied ist der, dass Prozesse anstelle einer einzelnen
Benutzeridentität, die bei der Erzeugung festgelegt ist, über Identitätsmarken
verfügen, die vom Prozess abgekoppelt sind, d.h. sie können mit den 
erforderlichen Rechten von einer Autorität ergänzt oder zerstört werden.
</p>

<p>
Es ist zwingend erforderlich, vertraut mit der Unix-Umgebung (und speziell
den GNU-Benutzerprogrammen, wie sie in beliebten Varianten wie beispielsweise
GNU/Linux gefunden werden können) zu sein, um sich in GNU wohlzufühlen. 
Erfahrung mit den Debian-Werkzeugen erweist sich auch als unschätzbar zur
Konfiguration und Wartung einer GNU/Hurd-Kiste.
</p>

<p>
Diese Anleitung bemüht sich, die Installation von GNU/Hurd einen so
schmerzlosen Prozess wie möglich zu machen. Falls Fehler vorliegen, sind
sie fast sicher Fehler des Autoren. Bitte berichten Sie diese an ihn, zusammen
mit anderen Vorschlägen und Kritik; sie werden alle dankend entgegengenommen.
</p>


<h2>2. Grundstück oder ein Zuhause finden</h2>

<p>
Falls Sie keine verfügbare Partition oder extra Festplatte haben, kann dies
der längste Schritt sein. In diesem Fall müssen Sie Ihre Festplatte neu
partitionieren. Eine Möglichkeit ist es, GNUs Partitions-Editor, Parted, zu
verwenden. Er bietet nicht nur grundlegende Partitionseditierung, sondern auch
Partitionsgrößenveränderungs- und -verschiebe-Funktionalität. Er kann unter
<url "http://www.gnu.org/software/parted" /> gefunden werden. Das Handbuch ist
recht vollständig und enthält mehrere Anleitungskurse.
</p>

<p>
Der Hurd unterstützt mehrere Erweiterungen des ext2fs-Dateisystem-Formats. 
Zuallererst sind darunter die passiven Übersetzer und ein vierter Satz an 
Rechte-Bits für unbekannte Benutzer (Benutzer ohne eine Identität &ndash; nicht
der <q>other</q>-Benutzer). Um diese Erweiterungen zu benutzen, muss der Eigentümer
der Partition auf <code>hurd</code> gesetzt werden. <code>mke2fs</code> setzt
den Eigentümer auf den aktuell laufenden Kernel, wenn dies nicht explizit auf
der Befehlszeile aufgehoben wird. Da der Hurd diese Einstellung fleißig 
respektieren wird, muss darauf geachtet werden, diese zutreffend zu setzen, oder
der Hurd wird auf subtile Art versagen. Beachten Sie, dass selbst ein 
Dateisystem, das einem bestimmten Kernel gehört, noch von anderen benutzt
werden kann; Sie können u.U. nur einige Erweiterungen nicht benutzen.
</p>

<p>
Um ein Dateisystem zu erzeugen, benutzen Sie <code>mke2fs</code> und übergeben
Sie <samp><q>-b 4096 -o hurd</q></samp>, um dem Hurd anzuzeigen, dass er der neue
Eigentümer des Dateisystems ist. Wenn beispielsweise Ihre Partition 
<tt><q>/dev/hda2</q></tt> ist:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
 \# mke2fs -b 4096 -o hurd /dev/hda2
</pre></td></tr></table>


<h2>3. Das Boot-Lade-Programm</h2>

<p>
Das Boot-Lade-Programm des GNU-Systems ist Grub, der <q>GRand Unified Boot 
loader</q>, und es ist seine Hauptaufgabe, den Kern des GNU-Systems (Mach und
den Hurd) zu booten. Allerdings kann jedes Boot-Lade-Programm, das den
Multiboot-Standard unterstützt, dazu verwendet werden, Mach und den Hurd zu
laden. Momentan (soweit uns das bewusst ist) ist der GNU Grub das einzige 
Boot-Lade-Programm, das so einen Standard unterstützt.
</p>

<p>
Ein Wort über Grub. Anders als traditionelle Boot-Lade-Programme auf x86, wie
LILO, ist Grub sehr mächtig. Es hat eine Kommandozeilenschnittstelle, bootp,
dummy-Terminal-Unterstützung und eine Fülle an anderen Funktionen. Zusätzlich
kann er fast jeden Kernel booten. Falls Sie jemals eine Alpha oder Sparc
gebootet haben, werden Sie verstehen, was Grub machen kann. Daher seien Sie nicht
verängstigt: Grub ist besser. Sie werden ihn mögen. Sie werden nicht 
zurückkehren.
</p>

<p>
Um Grub zu finden, besuchen Sie <url "http://www.gnu.org/software/grub/" />. Hier
ist ein Quell-Tar-Archiv und ein Disketten-Image. Wenn Sie sich entscheiden,
das Tar-Archiv herunterzuladen, führen Sie ein normales <code>configure</code>, 
<code>make</code> und <code>make install</code> aus. Es ist ein wundervoll 
komplettes Handbuch über die Funktionsweise des Grub enthalten. Lesen Sie es.
Falls Sie sich andererseits entschließen, das Disketten-Image herunterzuladen,
reicht es, dieses auf eine Diskette zu kopieren, um einen funktionierenden Grub zu
erhalten, beispielsweise:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
\# dd if=grub-boot-image of=/dev/fd0
</pre></td></tr></table>

<p>
Sie können Grub immer noch später auf Ihrer Festplatte installieren.
</p>


<h2>4. Cross-Installation</h2>

<p>
Der nächste Schritt ist das Erhalten des Basis-Systems. Es gibt mehrere 
Alternativen, falls Sie ein Debian-System verwenden, können Sie das Paket
<q>crosshurd</q> verwenden. Andernfalls können Sie ein aktualisiertes
Basissystem-Tar-Archiv von <url "http://ftp.gnuab.org/pub/debian/base/" /> in
Spanien, <url "http://www.superunprivileged.org/debian/base/" /> in Kanada oder
<url "http://ftp.easynet.be/ftp/gnuab/debian/base/" /> in Belgien holen.
</p>

<p>
Das Tar-Archiv ist so aufgesetzt, dass alles in das aktuelle Verzeichnis
extrahiert wird. Nachdem das Dateisystem eingehängt ist, kann das Archiv
extrahiert werden. Ist das Dateisystem beispielsweise auf <tt><q>/dev/hda2</q></tt>,
der Einhängepunkt <tt><q>/gnu</q></tt> und das Archiv im aktuellen Home-Verzeichnis
des Benutzers, dann wird das Folgende benötigt:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
 \# mount -t ext2 /dev/hda2 /gnu
 \# cd /gnu
 \# tar --same-owner -xvjpf ~/gnu.tar.bz2
</pre></td></tr></table>


<h2>5. GNU/Hurd booten</h2>

<p>
Alles ist nun in Bereitschaft, um GNU/Hurd zum ersten Mal zu booten. Nach der
Überprüfung, dass die Grub-Boot-Diskette im Laufwerk liegt, rebooten Sie. Falls
alles gut abläuft, wird entweder ein Grub-Menü oder eine Kommandozeile 
angezeigt. Falls ein Menü angezeigt wird, drücken Sie <kbd>c</kbd>, um zur
Kommandozeile zu gelangen.
</p>

<p>
Zuerst muss der GNU Mach geladen werden. Dies benötigt das Wissen über das
Dateisystem und den Pfad zu GNU Mach. Grub benutzt eine Partitions-Nomenklatur,
die sich ein bisschen von Linux und dem Hurd unterscheidet: sowohl IDE als auch
SCSI-Laufwerke werden <tt><q>(hdN,M)</q></tt> benannt. <code>N</code> ist die
Laufwerksnummer (mit Null beginnend) wie sie vom BIOS durchnummeriert wird.
Das bedeutet, Grub unterscheidet nicht zwischen IDE- und SCSI-Platten. 
<code>M</code> identifiziert die Partition auf dem Laufwerk. Es ist auch ein bei
Null beginnender Index. Falls dies verwirrend klingt, entspannen Sie sich: Der
Grub ist auch hilfsbereit.
</p>

<p>
Um zu bestimmen, auf welchem Dateisystem eine bestimmte Datei liegt, bietet
Grub den <code>find</code>-Befehl. Wenn dieser Befehl zusammen mit einem 
Dateinamen geäußert wird, sucht Grub auf jedem Dateisystem nach der 
spezifizierten Datei und gibt aus, wo sie gefunden wurde. Um zum Beispiel nach
dem Kernel <tt><q>/boot/gnumach.gz</q></tt> zu suchen:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>  
   grub&#62; find /boot/gnumach.gz
   (hd0,0)
</pre></td></tr></table>

<p>
Hier gibt Grub an, dass <tt><q>/boot/gnumach.gz</q></tt> auf <tt><q>(hd0,0)</q></tt> ist.
</p>

<p>
Vor dem Laden des Kernels muss mindestens eine Option, die Wurzel-Partition, auf
der Befehlszeile spezifiziert werden. Dies wird vom Hurd selber (d.h. nicht von
Grub) verwendet. Als solche muss sie so bezeichnet sein, dass der Hurd sie
verstehen kann.
</p>

<p>
GNU Mach nummeriert Platten beginnend bei Null. IDE-Laufwerke haben das Präfix
<code>hd</code> während SCSI-Platten das Präfix <code>sd</code> haben. Wie bei
Linux werden die Laufwerke entsprechend Ihrer Position am Kontroller nummeriert.
Zum Beispiel ist der primäre Master <code>hd0</code> und der sekundäre Slave
<code>hd3</code>. Partitionen benutzen die BSD-<q>Slice</q>-Namenskonvention und
hängen <code>sM</code> an den Laufwerksnamen an, um eine bestimmte Partition
anzuzeigen. Die Slice-Zahl ist einfach zu berechnen: erhöhen Sie einfach die
von Grub verwendete Zahl um eins.
</p>

<p>
Da der Hurd noch nicht konfiguriert wurde, muss er im Einzelbenutzermodus
gestartet werden. Hierzu reicht die Ergänzung von <samp><q>-s</q></samp> auf der
Kernel-Befehlszeile.
</p>

<p>
Unter der Annahme, dass das erste Laufwerk (d.h. <tt><q>(hd0)</q></tt>) der Master
auf dem sekundären Kontroller ist, hätten wir:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>  
   grub&#62; kernel (hd0,0)/boot/gnumach.gz root=device:hd2s1 -s
   [Multiboot-elf, ...]
</pre></td></tr></table>

<p>
Als nächstes muss der Wurzeldateisystem-Server und der <code>exec</code>-Server
geladen werden. Dies geschieht mittels Grubs Boot-Modul Lademöglichkeit. Die
${var} werden von GNU Mach eingefüllt. Die Argumente werden vom Hurd verwendet
um anzugeben, was für eine Art von Information bereitgestellt wird. Da die 
ext2fs-Befehlszeile sehr lang ist, kann Sie durch Schützen des 
Zeilenumbruchzeichens in normaler Unix-Manier umgebrochen werden. Stellen Sie
sicher, dass nach dem umgedrehten Schrägstrich am Zeilenende kein Leerzeichen folgt. Stellen
Sie auch sicher, <kbd>{</kbd> und <kbd>}</kbd> von <kbd>(</kbd> und <kbd>)</kbd>
zu unterscheiden.
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>  
  grub&#62; module (hd0,0)/hurd/ext2fs.static \
   --multiboot-command-line=${kernel-command-line} \
   --host-priv-port=${host-port} \
   --device-master-port=${device-port} \
   --exec-server-task=${exec-task} -T typed ${root} \
   $(task-create) $(task-resume)
    [Multiboot-module  0x1c4000, 0x2cfe6a bytes]
  grub&#62; module (hd0,0)/lib/ld.so.1 /hurd/exec $(exec-task=task-create)
    [Multiboot-module  0x494000, 0x27afe bytes]
</pre></td></tr></table>

<p>
Sobald der Hurd läuft, kann dieser Prozess automatisiert werden, indem die 
passenden Befehle zu Grubs <tt><q>/boot/grub/menu.lst</q></tt>-Konfigurationsdatei
hinzugefügt werden.
</p>

<p>
GNU/Hurd kann nun gebootet werden:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
grub&#62; boot
</pre></td></tr></table>

<p>
Falls der GNU/Hurd nicht bootet, könnte dies an geteilten IRQs liegen: GNU Mach
arbeitet nicht gut mit diesen. Sie können Ihre Situation bestätigen, indem Sie
beispielsweise in die <tt><q>/proc/interrupts</q></tt>-Datei unter Linux schauen. 
Da der GNU Mach auch keine ladbaren Kernelmodule unterstützt, sind viele Treiber
in den Standardkernel einkompiliert. Falls es alte Peripherie gibt, kann dies ein
Problem sein: Ein Gerät könnte auf eine Sondierung für ein komplett anderes
Gerät ohne Bezug reagieren und dadurch einen Absturz hervorrufen. Das Bauen
eines neuen Kernels mit nur den benötigten Gerätetreibern löst normalerweise
dieses Problem. GNU Mach kann einfach cross-kompiliert werden. Falls Sie Debian
betreiben, versuchen Sie das <tt><q>gcc-i386-gnu</q></tt>-Paket zu installieren.
</p>

<p>
Falls dies nicht hilft fragen Sie auf der angemessenen Mailing-Liste.
</p>


<h2>6. Native Installation</h2>

<p>
Sobald Ihnen eine Shell-Eingabeaufforderung präsentiert wird, und immer wenn
der Hurd im Einzelbenutzermodus ist, ist es notwendig, den Terminaltyp 
einzustellen:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
\# export TERM=mach
</pre></td></tr></table>

<p>
Seien Sie gewarnt, dass <kbd>CONTROL-C</kbd> und Freunde im Einzelbenutzermodus
nicht funktionieren.
</p>

<p>
Wir können nun das <code>native-install</code>-Skript laufen lassen. Dies wird
die Pakete konfigurieren und mehrere wichtige Übersetzer einrichten:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
\# ./native-install
</pre></td></tr></table>

<p>
Bevor sich das Skript beendet, wird es angeben, dass es ein zweites Mal laufen
muss. Folgen Sie den Anweisungen und rebooten Sie mittels des
<code>reboot</code>-Befehls. Gehen Sie wieder in den Einzelbenutzermodus und 
lassen Sie <code>./native-install</code> laufen.
</p>


<h2>7. Konfiguration</h2>


<h3>7.1 Das Netz</h3>

<p>
Um das Netz zu konfigurieren muss der pfinet-Übersetzer konfiguriert werden. 
Dies geschieht über den <code>settrans</code>-Befehl, der einen Übersetzer an
einen gegebenen Dateisystemknoten einhängt. Falls Programme auf den Knoten,
beispielsweise durch Senden eines RPC, zugreifen, wird das Betriebssystem
transparent den Server starten, um die Anfrage zu bearbeiten.
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
\# settrans -fgap /servers/socket/2 /hurd/pfinet -i eth0 \
   -a a.b.c.d -g e.f.g.h -m i.j.k.l
</pre></td></tr></table>

<p>
Hier werden <code>settrans</code> mehrere Optionen übergeben. Die ersten zwei,
<samp><q>fg</q></samp>, erzwingen, dass existierende Übersetzer verschwinden. Die
nächsten zwei, <samp><q>ap</q></samp>, erzeugen sowohl aktive als auch passive
Übersetzer. Indem wir aktive Übersetzer erzeugen, sehen wir sofort jede 
Fehlermeldung auf <tt><q>stderr</q></tt>. Der letztere speichert den Übersetzer und
die Befehle im Knoten, so dass er transparent neu gestartet werden kann (d.h.
die Einstellungen bleiben persistent über Neustarts hinweg erhalten). Die
Optionen werden vom Knoten, an den der Übersetzer angehängt werden soll, dann
dem zu startenden Programm (d.h. dem Übersetzer) und jedem Argument, das Sie
ihm übergeben, gefolgt. Die <samp><q>-i</q></samp>-Option ist die Schnittstelle, auf
der <code>pfinet</code> horchen wird, <samp><q>-a</q></samp> ist die IP-Adresse,
<samp><q>-g</q></samp> ist das Gateway und <samp><q>-m</q></samp> ist die Netzmaske.
</p>

<p>
Stellen Sie sicher, dass Sie Name-Server zu Ihrer 
<tt><q>/etc/resolv.conf</q></tt>-Datei hinzufügen:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
  nameserver 192.168.1.1
</pre></td></tr></table>

<p>
Um diese Konfiguration zu testen: <code>ping -c2 gateway</code>. Das
<samp><q>-c</q></samp> ist wichtig, um die Anzahl der pings zu begrenzen; erinnern
Sie sich, dass <kbd>CONTROL-C</kbd> im Einzelbenutzermodus nicht funktioniert.
</p>

<p>
DHCP funktioniert noch nicht im Hurd. Dies ist in Beschränkungen von pfinet
begründet: es basiert auf Linux TCP/IP-Code und kann nicht auf 
<tt><q>0.0.0.0</q></tt> lauschen.
</p>

<p>
Hilfe über <code>settrans</code> kann durch Übergabe der 
<samp><q>--help</q></samp>-Option erhalten werden. Hilfe über einen speziellen
Übersetzer kann erhalten werden, indem er von der Befehlszeile mit dem gleichen
Argument aufgerufen wird, z.B.:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
\# /hurd/pfinet --help
</pre></td></tr></table>

<p>
Da es viel an Ausgabe geben kann, überlegen Sie, diese durch ein
seitenbasiertes Anzeige-Programm wie <code>less</code> zu leiten.
</p>


<h3>7.2 Andere Dateisysteme</h3>

<p>
Als nächstes editieren Sie <tt><q>/etc/fstab</q></tt>, um weitere Dateisysteme sowie
Auslagerungs-Bereich (<q>swap space</q>) hinzuzufügen. Es ist <em>sehr wichtig</em>,
dass ein Auslagerungsbereich verwendet wird; der Hurd wird um eine Größenordnung
stabiler sein. Beachten Sie, dass sich der Hurd transparent eine 
Auslagerungspartition mit Linux teilen kann, aber in jedes Gerät auslagern kann,
darunter in rohe Partitionen wie beispielsweise Ihre Home-Partition. 
Standardmäßig ist <code>nano</code> der einzige Editor, der in der
Basisdistribution installiert ist.
</p>

<p>
Hier ist eine <tt><q>/etc/fstab</q></tt>-Datei als Beispiel:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
\# &#60;file system&#62; &#60;mount point&#62;   &#60;type&#62;  &#60;options&#62;  &#60;dump&#62;  &#60;pass&#62;
/dev/hd2s1      /               ext2    rw         0       1
/dev/hd2s2      /home           ext2    rw         0       2
/dev/hd2s3      none            swap    sw         0       0
</pre></td></tr></table>

<p>
Denken Sie daran, jedes Gerät mit dem <code>MAKEDEV</code>-Befehl anzulegen:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
 \# cd /dev
 \# ./MAKEDEV hd2s1 hd2s2 hd2s3
</pre></td></tr></table>

<p>
Um ein NFS-Dateisystem einzuhängen, wird der <code>/hurd/nfs</code>-Übersetzer
verwendet. Falls er nicht als root läuft, wird er sich am Server mit einer 
Port-Nummer oberhalb von 1023 anmelden. Standardmäßig wird GNU/Linux dies
ablehnen. Um GNU/Linux mitzuteilen, Verbindungen aus nicht-reservierten Ports
zu akzeptieren, ergänzen Sie die <samp><q>insecure</q></samp>-Option zu der 
export-Zeile. Hier ist eine <tt><q>/etc/exports</q></tt>-Datei als Beispiel, die 
annimmt, dass die IP-Adresse des Clients <tt><q>192.168.1.2</q></tt> ist:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
  /home  192.168.1.2(rw,insecure)
</pre></td></tr></table>

<p>
Um dies von einer GNU-Kiste einzuhängen und unter der Annahme, dass die 
IP-Adresse des NFS-Servers <tt><q>192.168.1.1</q></tt> ist:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
\# settrans -cgap /mount/point /hurd/nfs 192.168.1.1:/home
</pre></td></tr></table>


<h3>7.3 Neustart</h3>

<p>
Schließlich rebooten Sie in den Mehrbenutzermodus, d.h. auf die gleiche Art, wie
der Einzelbenutzermodus hochgebracht wurde ohne die <samp><q>-s</q></samp>-Option
beim Laden des Kernels. Für Details lesen Sie den Abschnitt 5 <q>GNU/Hurd booten</q>.
</p>

<p>
Lustiges Hacken!
</p>


<h2>8. Abschließende Worte</h2>


<h3>8.1 Das Grub-Menü</h3>

<p>
Immer den Kernel von Hand zu laden kann sehr ermüdend werden. Editieren Sie
<tt><q>/boot/grub/menu.lst</q></tt> und passen Sie sie entsprechend an; das Booten
wird viel schneller und leichter werden.
</p>


<h3>8.2 Geräte ergänzen</h3>

<p>
Standardmäßig sind nur einige Geräte im <tt><q>/dev</q></tt>-Verzeichnis angelegt.
Benutzen Sie das <code>MAKEDEV</code>-Skript, um jedes benötigte Gerät anzulegen.
</p>


<h3>8.3 Weitere Pakete installieren</h3>
<p>
Es gibt mehrere Wege, um Pakete zu ergänzen. Herunterladen und 
<code>dpkg -i</code> funktioniert, ist aber sehr unbequem. Die einfachste Methode
ist die Verwendung von <code>apt-get</code>. Editieren Sie
<tt><q>/etc/apt/sources.list</q></tt> und ergänzen Sie einen der folgenden
unveröffentlichten Einträge:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
deb http://ftp.gnuab.org/debian unreleased main
deb http://www.superunprivileged.org/debian unreleased main
deb http://ftp.easynet.be/ftp/gnuab/debian unrelease main
</pre></td></tr></table>

<p>
  <url "http://ftp.gnuab.org/" /> und seine Spiegel enthalten Pakete, die
  Korrekturen oder Patches enthalten, die noch nicht von den Originalautoren
  oder Debian integriert wurden.
</p>

<p>
  Und den Unstable-Eintrag von einem der Debian-Spiegel (schauen Sie auf
  <url "http://www.debian.org/mirror/list" /> für die komplette Liste), der diese
  Architektur bedient:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
deb http://ftp.de.debian.org/debian unstable main
</pre></td></tr></table>

<p>
Falls GNU Mach Ihre Netzwerk-Karte nicht erkennt oder Sie ein Modem verwenden,
ist der einzige Weg, ein Upgrade durchzuführen, das Herunterladen der Pakete und
die Übertragung in das GNU System. Der einfachste Weg hierzu ist die Verwendung
von apt off-line. Lesen Sie <tt><q>/usr/share/doc/apt-doc/offline.text.gz</q></tt> 
für detaillierte Instruktionen.
</p>


<h3>8.4 Die Hurd-Konsole</h3>

<p>
Neben der Mach-Konsole, der Sie während der Installation begegnen, weist der
GNU/Hurd eine mächtige Konsole mit virtuellen Terminals im Userspace auf.
Derzeit müssen Sie die Konsole manuell mit dem folgenden Befehl starten:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
 \# console -d vga -d pc_mouse --repeat=mouse -d pc_kbd --repeat=kbd -d generic_speaker -c /dev/vcs
</pre></td></tr></table>

<p>
Innerhalb der Hurd-Konsole können Sie zwischen virtuellen Terminals via
<kbd>ALT+F1</kbd>, <kbd>ALT+F2</kbd> und so weiter wechseln.
<kbd>ALT+CTRL+BACKSPACE</kbd> hängt die Hurd-Konsole ab und bringt Sie zurück 
zur Mach-Konsole, von der aus Sie sich wieder mit dem obigen Befehl 
zurückverbinden können.
</p>


<h3>8.5 X.Org</h3>

<p>
X.Org ist portiert worden und alle Grafikkarten, die es unterstützt und die
kein Kernelmodul erfordern, sollten funktionieren.
</p>

<p>
Sie müssen in der Hurd-Konsole sein und Repeater aufgesetzt haben, wie dies
in dem obigen Abschnitt 8.4 gezeigt ist. Da X.Org <code>/dev/kbd</code> als
Gerät für Ihre Tastatur hartkodiert hat, müssen Sie einen Symlink erstellen:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
 \# cd /dev
 \# ln -s cons/kbd kbd
 \# ln -s cons/mouse mouse
</pre></td></tr></table>

<p>
Sie werden mehrere X-Pakete benötigen. <code>x-window-system-core</code>, 
<code>rxvt</code> und <code>twm</code>, <code>fvwm</code> oder
<code>wmaker</code> sind ein guter Anfang.
</p>

<p>
Debconf kann zur Konfiguration von X.Org verwendet werden, allerdings hat er
keine Hurd-Kenntnisse und die Konfigurationsdatei muss angepasst werden. Nach
der Konfiguration ändern Sie den <q>Pointer</q>-Abschnitt in folgende Form:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
Section "Pointer"
  Protocol "osmouse"
  Device "/dev/mouse"
EndSection
</pre></td></tr></table>

<p>
<samp><q>Emulate3Buttons</q></samp> und <samp><q>ZAxisMapping</q></samp> müssen beide
deaktiviert sein.
</p>

<p>
Schließlich geben Sie <code>startx</code> ein.
</p>

<p>
Es gibt mehrere Warnungen, derer Sie sich bewusst sein müssen. 
<code>update-menu</code> ist noch nicht
portiert worden. Daher gibt es keine schönen Debian-Menüs. Obwohl eine
<code>pthreads</code>-Implementation existiert, sind noch nicht alle 
pthread-Pakete portiert: erwarten Sie nicht, dass Gnome und KDE funktionieren.
</p>


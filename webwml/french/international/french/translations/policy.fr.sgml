<!doctype debiandoc system [
<!-- include version information so we don't have to hard code it
     within the document -->
<!--entity % versiondata SYSTEM "version.ent"> &versiondata; -->
]>
<debiandoc>
<!--/policy.sgml /1.65 -->
  <!--
  Debian GNU/Linux Policy Manual.
  Copyright (C)1996,1997,1998 Ian Jackson and Christian Schwarz;
  released under the terms of the GNU
  General Public License, version 2 or (at your option) any later.
  Initial version 1996, Ian Jackson, ijackson@gnu.ai.mit.edu
  Revised November 27, 1996, David A. Morris, bweaver@debian.org 
  New sections March 15, 1997, Christian Schwarz, schwarz@debian.org
  Reworked/Restructured April-July 1997, Christian Schwarz, schwarz@debian.org
  Maintainer since 1997, Christian Schwarz, schwarz@debian.org
  Christoph Lameter contributed the "Web Standard"
  The debian-policy mailing list has taken responsibility for the
  contents of this document since September 1998, with the package
  maintainers responsible for packaging administrivia only.
  -->
  
  <book>
    <titlepag>
      <title>La Charte Debian </title>
      <author>
	<name>Ian Jackson </name>
	<email>ijackson@gnu.ai.mit.edu</email>
      </author>
      <author>
	<name>Christian Schwarz</name> 
	<email>schwarz@debian.org</email>
      </author>
      <author>
	<name>révision : David A. Morris</name> 
	<email>bweaver@debian.org</email>
      </author>
      <author>
	<name>La liste de diffusion « Debian Policy&nbsp;»</name>
	<email>debian-policy@lists.debian.org</email>
      </author>
      <version>version 3.5.6.0  cvs 1.65 08/2001</version>

      <abstract>
	Ce manuel est la charte de la distribution Debian
GNU-Linux. Sont abordés la structure et le contenu d'une archive Debian,
certaines questions sur la conception du système d'exploitation,
ainsi que les exigences techniques que chaque paquet doit satisfaire afin
d'être inclus dans la distribution. Le paquet «&nbsp;debian-policy&nbsp;» 
quant à lui est maintenu par un groupe de responsables sans pouvoirs 
rédactionnels, dont voici la liste actuelle :
	<enumlist>
	  <item>
	  <p>Julian Gilbey <email>jdg@debian.org</email></p>
          </item>
         <item>
          <p>Manoj Srivastava <email>srivasta@debian.org</email></p>
	  </item>
	</enumlist>
      </abstract>


      <copyright>
	<copyrightsummary>
	  Copyright &copy;1996,1997,1998 Ian Jackson
	  and Christian Schwarz.
	</copyrightsummary>
	<p>
	  Ce manuel est un logiciel libre ; il peut être redistribué 
et/ou modifié selon les termes de la licence publique générale du projet GNU
(GNU GPL), telle que publiée par la «&nbsp;Free Software Foundation&nbsp;»  
(version 2 ou toute version supérieure).
	</p>

	<p>
	  Il est distribué dans l'espoir qu'il sera utile, mais <em>sans aucune
garantie</em> ; sans même la garantie implicite d'une possible valeur 
marchande ou d'une adéquation à un besoin particulier. 
Consultez la licence publique générale du projet GNU pour plus de détails.
	</p>

	<p>
Une copie de la licence publique générale est disponible à
<tt>/usr/share/common-licenses/GPL</tt> dans la distribution Debian GNU-Linux
ou sur la « Toile »&nbsp;: 
<url id="http://www.gnu.org/copyleft/gpl.html" name=" La licence publique générale du projet GNU">.
Vous pouvez également l'obtenir en écrivant à la
Free Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.
	</p>
      </copyright>
    </titlepag>

    <toc detail="sect">
    
    <chapt id="1">
      <heading>À propos de ce manuel</heading>
      <sect>
	<heading>Les objectifs de ce manuel</heading>
	<p>
	  Ce manuel est la charte de la distribution 
Debian GNU-Linux. Sont abordés la structure et le contenu d'une archive 
Debian, certaines questions sur la conception du système d'exploitation,
ainsi que les exigences techniques que chaque paquet doit satisfaire afin
d'être inclus dans la distribution.
	  </p>
	
<p>
Ce manuel décrit aussi la politique debian en ce qui concerne la création 
des paquets. Ce n'est pas un cours sur la construction des paquets et il ne
décrit pas complètement le comportement du système de gestion des paquets. 
Il essaye plutôt de définir la seule interface que doivent maîtriser les 
développeurs 
<footnote><p>
D'une manière informelle, l'intégration de «&nbsp;matériel&nbsp;» se fait 
selon les critères suivants :
<taglist compact="compact">
<tag>Interfaces standards</tag>
<item> <p>
Le «&nbsp;matériel&nbsp;» présenté est une interface au système de gestion de 
paquets dont l'utilisation est obligatoire ; un nombre significatif de paquets
l'utilise et elle ne sera pas modifiée sans une étude sérieuse. Les
responsables de paquet peuvent donc compter sur la stabilité de cette 
interface et les auteurs du système de gestion des paquets doivent assurer
la compatibilité avec les définitions de ces interfaces. (Le format des 
fichiers «&nbsp;control&nbsp;» et «&nbsp;changelog&nbsp;» en est un exemple.)
</p>
               </item>
               <tag>Convention choisie</tag>
               <item>
                 <p>
Quand on a besoin, pour des raisons d'inter-opérabilité, de faire un choix
parmi un certain nombre de possibilités techniquement valides. Le numéro
de version est un exemple.
</p></item></taglist>
Veuillez noter que ces critères ne s'excluent pas mutuellement ; une convention
choisie devient souvent une interface standard.
	    </p>
	  </footnote>.
<p>
Les notes de ce manuel ne font pas partie de la Charte
et sont purement instructives.</p>
<p>
Les mots <em>must</em>, <em>should</em>, <em>may</em> et les adjectifs
<em>required</em>, <em>recommended</em> et <em>optional</em> servent à
distinguer la signification des diverses directives contenues dans cette
charte. La distribution Debian ne considérera généralement pas comme
acceptables les paquets qui ne se conforment pas aux directives dénotées par
<em>must</em> (ou <em>required</em>)<footnote><p>
En français, nous employons le verbe «&nbsp;devoir&nbsp;» et ses déclinaisons.
</footnote>. Une non conformité à une directive
dénotée par <em>should</em> (ou <em>recommended</em>) sera en général
considérée comme un bogue, mais cela n'empêchera pas nécessairement la
distribution du paquet.<footnote><p>
En français, nous employons le futur de l'indicatif et jamais le verbe
«&nbsp;devoir&nbsp;».</footnote>.
Les directives dénotées par <em>may</em> (ou <em>optional</em>) sont 
véritablement facultatives et sont laissées à l'appréciation du responsable 
de paquet.
</p>
<p>
Ce classement est en gros équivalent à celui des bogues : <em>serious</em>
(pour les violations des directives <em>must</em> ou <em>required</em>),
<em>minor</em>, <em>normal</em> ou <em>important</em> (pour les violations 
des directives <em>should</em> ou <em>recommended</em>) et <em>wishlist</em> 
(pour les éléments <em>optional</em>)<footnote><p>Comparez avec la RFC 2119.
Remarquez cependant que ces mots sont employés différemment dans ce
document.</p></footnote>.
</p>

	<p>
	  La plupart des informations de ce manuel seront également utiles
pour la création de paquets qu'on doit distribuer d'une autre façon
ou qui sont destinés à un usage local.
	</p>
      </sect>
      <sect>
	
<heading>Nouvelles versions de ce document</heading>
	<p>
	  La version actuelle de ce document est toujours accessible depuis
	  le serveur FTP de Debian <ftpsite>ftp.debian.org</ftpsite> comme
	  <ftppath>/debian/doc/package-developer/policy.txt.gz</ftppath> (dans
ce répertoire se trouvent d'autres formats : <tt>policy.html.tar.gz</tt>,
<tt>policy.pdf.gz</tt> et <tt>policy.ps.gz</tt>)
ou sur la 
<url id="http://www.debian.org/doc/debian-policy/" name="Debian Policy Manual"> page web</p>

	<p>
	 Ce manuel est aussi distribué avec le paquet <tt>debian-policy</tt>.
	</p>

<p>
Le paquet <tt>debian-policy</tt> contient aussi le fichier 
<tt>upgrading-checklist.txt</tt> qui note les changements entre les versions 
de ce document
</p>
      </sect>
      <sect>
	<heading>Avis et critiques</heading>

	<p>
	  Le système Debian GNU-Linux est en constante évolution et ce
manuel aussi.
	</p>
	<p>
	Bien que les auteurs de ce document aient veillé à ne pas introduire
de coquilles et autres erreurs, il en reste toujours.
Si vous découvrez des erreurs dans cette version du manuel ou si
vous voulez faire part de vos commentaires, suggestions ou
critiques, veuillez envoyer un courrier électronique sur la liste de diffusion
«&nbsp;Debian Policy&nbsp;», <email>debian-policy@lists.debian.org</email>,
ou un rapport de bogue concernant le paquet <tt>debian-policy</tt>.
	</p>
</sect>
<sect>
<heading>À propos de la traduction</heading>
<p>
Depuis la version 3.5.0.0, la charte Debian regroupe le 
<em>Debian Policy Manual</em> et des éléments tirés du 
<em>Debian Packaging Manual</em>.</p>
<p>
Serge Stinckwich et David Rocher ont initié la traduction du 
<em>Debian Policy Manual</em> et ils furent rejoints par Christophe Le Bars, 
Benjamin Drieu, Laurent Pelecq, Christophe Mertz, Olivier Ripoll, 
Georges Mariano, Hugues Marilleau, Michel Court et les relecteurs de la liste 
de diffusion <em>debian-l10n-french</em>, 
<email>debian-l10n-french@lists.debian.org</email>.</p>
<p>
David Curé et Christian Jacolot ont traduit les passages 
du <em>Debian Packaging Manual</em> intégrés dans la charte.</p>
<p>
Si vous voulez faire part de vos commentaires, suggestions ou critiques,
vous pouvez envoyer un courrier à Philippe Batailler <email>
pbatailler@teaser.fr</email>.
</p>
	      </sect>
    </chapt>
    <chapt id="2">
      <heading>L'archive Debian</heading>
      <p>
	Le système Debian GNU-Linux est maintenu et distribué sous la forme
d'un ensemble de <em>paquets</em>. Très nombreux (plus de 6000), ces paquets
sont répartis en plusieurs <em>sections</em> et on leur donne des
<em>priorités</em> afin de simplifier leur traitement.
      </p>
      <p>
	Le projet Debian s'efforce de construire un système
d'exploitation libre, mais tous les paquets que nous voulons rendre
accessibles ne sont pas <em>libres</em> selon notre définition
(voir plus loin les Directives Debian pour le logiciel libre) ou ne peuvent
pas être importés ou exportés sans restrictions. L'archive a donc été
séparée suivant les sections <em>main</em>, <em>non-free</em>,
<em>contrib</em>, <em>non-US/main</em>, <em>non-US/non-free</em> et 
<em>non-US/contrib</em>. Ces sections sont détaillées plus bas.
      <p>
	Les sections <em>main</em> et <em>non-US/main</em> constituent 
ensemble la <em>distribution Debian GNU-Linux</em>.
      <p>
	Les paquets des autres sections ne sont pas considérés comme faisant
partie de la distribution Debian, bien que nous soutenions leur utilisation
à travers notre infrastructure (comme notre système
de suivi des bogues et nos listes de diffusion). La <em>Charte Debian</em> 
s'applique aussi à ces paquets.
</p>

      <sect id="pkgcopyright">
	<heading>Le copyright des paquets et les sections</heading>
	<p>
	  Les objectifs de cette section doivent nous permettre de :

	  <list compact="compact">
	    <item>
<p> mettre à disposition le plus grand nombre possible de 
logiciels ;</p>
	    </item>
	    <item>
	  <p>encourager chacun à écrire des logiciels libres ;</p>
	    </item>
	    <item>
		<p>faciliter la production des cédéroms
 de notre système sans craindre de violation de licences, ou de restrictions
 d'importation/exportation ou de toutes autres lois.
		</p>
	    </item>
	  </list>
	</p>
      <sect1>
	<heading>Les directives Debian pour le logiciel libre</heading>
	<p>
	  Les directives Debian pour le logiciel libre (DFSG : 
«&nbsp;Debian Free Software Guidelines&nbsp;») suivantes constituent notre 
définition du logiciel «&nbsp;libre&nbsp;».
	  <taglist>
	    <tag>Redistribution autorisée
	    </tag>
	    <item>
	      <p>
		La licence d'un composant Debian ne doit pas empêcher quiconque
 de vendre ou de donner ce logiciel en tant qu'élément d'une distribution
 logicielle qui regroupe des programmes de différentes sources. La licence
 ne doit pas demander le paiement de droits ou de redevances
 pour une telle vente.
	      </p>
	    </item>
	    <tag>Code source
	    </tag>
	    <item>
	      <p>
		Le programme doit inclure son code source et doit permettre sa
 distribution en tant que code source et comme forme compilée.
	      </p>
	    </item>
	    <tag>Travaux dérivés
	    </tag>
	    <item>
	      <p>
		La licence doit autoriser les modifications et les travaux 
dérivés. Elle doit autoriser leur distribution selon les termes mêmes de
la licence du logiciel original.
	      </p>
	    </item>
	    <tag>Intégrité du code source de l'auteur
	    </tag>
	    <item>
	      <p>
		La distribution d'un code source modifié peut être limitée
par la licence <em>seulement</em> si des fichiers «&nbsp;patch&nbsp;», joints 
avec le code source, permettent de modifier le programme au moment de sa 
compilation. La licence doit explicitement permettre la redistribution de 
logiciels construits à partir de code source modifié. La licence peut exiger 
que les travaux dérivés portent un nom différent ou un numéro de version 
différent du logiciel initial. (C'est un  compromis. Le projet Debian 
encourage tous les auteurs à ne pas limiter les modifications de fichier, 
source ou binaire.)
	      </p>
	    </item>
	    <tag>Non-discrimination envers des personnes ou groupes 
de personnes
	    </tag>
	    <item>
	      <p>
		La licence ne doit faire aucune discrimination à l'encontre 
d'une personne ou d'un groupe de personnes.
	      </p>
	    </item>
	    <tag>Non-discrimination envers des champs d'activités
	    </tag>
	    <item>
	      <p>
		La licence ne doit pas empêcher l'usage du programme dans un
 champ spécifique d'activité. Par exemple, elle ne doit pas empêcher 
 l'utilisation du programme dans le cadre d'une activité commerciale ou
 pour faire de la recherche génétique.
	      </p>
	    </item>
	    <tag>Distribution de licence
	    </tag>
	    <item>
	      <p>
		Les droits attachés au programme doivent s'appliquer à tous 
ceux à qui le logiciel est redistribué sans que ceux-ci aient besoin 
d'une licence supplémentaire.
	      </p>
	    </item>
	    <tag>La licence ne doit pas être spécifique à Debian
	    </tag>
	    <item>
	      <p>
		Les droits attachés à un programme ne doivent pas être liés
à l'appartenance de ce programme à un système Debian. Si ce programme
est extrait de Debian et est utilisé ou distribué sans Debian mais
dans les termes de la licence du programme, toutes les parties à
qui ce programme a été redistribué doivent avoir les mêmes droits
que ceux qui sont accordés avec le système Debian.
	      </p>
	    </item>
	    <tag>La licence ne doit pas contaminer d'autres logiciels
	    </tag>
	    <item>
	      <p>
		La licence ne doit pas apporter des restrictions à d'autres 
logiciels distribués avec le logiciel en question. Par exemple, la licence ne
doit pas exiger que tous les autres programmes distribués sur le même
support soient des logiciels libres.
	      </p>
	    </item>
	    <tag>Exemples de licence
	    </tag>
	    <item>
	      <p>
		Les licences «&nbsp;GPL&nbsp;», «&nbsp;BSD&nbsp;» et 
«&nbsp;Artistic&nbsp;» sont des exemples de licence que nous considérons 
comme <em>libres</em>.
	      </p>
	    </item>
	  </taglist>
	</p>
      </sect1>
      <sect1>
	<heading>La section «&nbsp;main&nbsp;»</heading>
	<p>
	  Tous les paquets dans <em>main</em> et dans <em>non-US/main</em> 
doivent se conformer aux <em>DFSG</em>
(«&nbsp;Debian Free Software Guidelines&nbsp;» -- Les directives Debian pour 
le logiciel libre).
	</p>

	<p>
	  De plus, les paquets dans <em>main</em>
	  <list compact="compact">
	    <item>
	      <p>
ne doivent pas demander un paquet extérieur à <em>main</em> pour leur 
compilation ou leur exécution (ainsi les paquets ne doivent pas déclarer de 
relation «&nbsp;Depends&nbsp;», «&nbsp;Recommends&nbsp;» ou 
«&nbsp;Build-Depends&nbsp;» avec un paquet qui n'est pas contenu dans 
<em>main</em>),
	      </p>
	    </item>
	    <item>
	      <p>
		ne doivent pas être tellement bogués que nous refusions de les 
soutenir, 
	      </p>
	    </item>
	    <item>
	      <p>
		et doivent se conformer à toutes les règles énoncées 
dans ce manuel.
	      </p>
	    </item>
	  </list>
	</p>
<p>
De la même manière, les paquets dans <em>non-US/main</em>
<list compact="compact">

<item>
<p>
ne doivent pas demander un paquet extérieur à <em>main</em> ou à 
<em>non-US/main</em> pour leur compilation ou exécution,
		</p>
	      </item>
<item>
<p>
ne doivent pas être tellement bogués que nous refusions de les soutenir,
              </p>
            </item>
            <item>
              <p>
<item>
              <p>
doivent se conformer à toutes les règles énoncées dans ce manuel.
              </p>
            </item>
          </list>
        </p>
	</sect1>

      <sect1>
	<heading>La section «&nbsp;contrib&nbsp;»</heading>
	<p>
	 Tous les paquets dans <em>contrib</em> et <em>non-US/contrib</em> 
doivent se conformer aux «&nbsp;DFSG&nbsp;».
	</p>

	<p>
De plus, les paquets dans <em>contrib</em> et <em>non-US/contrib</em>
	  <list compact="compact">
	    <item>
	      <p>
ne doivent pas être tellement bogués que nous refusions de les soutenir, 
		</p>
	      </item>
<item>
<p>
et doivent se conformer à toutes les règles énoncées dans ce manuel.
		</p>
	      </item>
	    </list>
</p>
<p>
De plus, les paquets dans <em>contrib</em> ne doivent pas exiger, pour leur
compilation ou pour leur exécution, de paquet appartenant à une section
<em>non-US</em>.
	  </p>
<p>		
Voici des exemples de paquets qu'on peut mettre dans <em>contrib</em> ou 
<em>non-US/contrib</em> :
<list compact="compact">
<item><p>
des paquets libres qui demandent pour leur compilation ou 
leur exécution des paquets appartenant aux sections <em>contrib</em>, 
<em>non-free</em> ou des paquets qui ne sont pas contenus dans notre archive ;
	      </p>
	    </item>
	    <item>
	      <p>
des paquets «&nbsp;wrapper&nbsp;», et des accessoires libres pour des 
programmes non libres.
	      </p>
	    </item>
	  </list>
	</p>
      </sect1>
      <sect1>
	<heading>La section «&nbsp;non-free&nbsp;»</heading>
	<p>
On doit placer dans les sections <em>non-free</em> et <em>non-US/non-free</em>
les paquets qui ne se conforment pas aux «&nbsp;DFSG&nbsp;», ou bien les 
paquets dont la distribution est rendue problématique par des brevets ou des 
questions légales.
	  </p>
<p>
De plus les paquets dans <em>non-free</em> et <em>non-US/non-free</em> 
<list compact="compact">
<item>
<p>
ne doivent pas être tellement bogués que nous refusions de les soutenir, 
		</p>
	      </item>
<item>
<p>
et doivent se conformer, autant qu'il leur est possible, à toutes les règles 
énoncées dans ce manuel<footnote><p>
Il se peut que certains paquets ne puissent pas respecter telle règle ; p.ex.,
les sources ne sont pas disponibles. Ces situations seront examinés au cas par
cas.</p>
		  </footnote>.</p>
	      </item>
	    </list>
</p>
     </sect1>

      <sect1>
	<heading>Les sections  «&nbsp;non-US&nbsp;»</heading>
	<p>
	  Certains programmes qui contiennent du code source utilisant
la cryptographie doivent être déposés sur le serveur <em>non-US</em> à cause 
des limitations US à l'exportation. De tels programmes doivent être
distribués dans les sections <em>non-US</em> appropriées : 
<em>non-US/main</em>, <em>non-US/contrib</em> ou <em>non-US/non-free</em>.
</p>
	<p>
	  Ceci ne s'applique qu'aux paquets qui contiennent du code source
utilisant la cryptographie. Un paquet qui contient un programme interfacé
avec un programme de cryptographie ou lié dynamiquement à une bibliothèque
de cryptographie ne sera pas distribué par le serveur <em>non-us</em>
s'il peut fonctionner sans le programme ou la bibliothèque cryptographique.
	</p>
      </sect1>
      <sect1>
	<heading>Considérations supplémentaires sur le copyright</heading>
	<p>
Tous les paquets doivent être accompagnés d'une copie <em>verbatim</em>
de leur copyright et de leur licence dans le fichier
	  <tt>/usr/share/doc/<var>paquet</var>/copyright</tt> 
(voir <ref id="copyrightfile"> pour des précisions).</p>
	<p>
	  Nous nous réservons le droit d'empêcher l'inclusion de fichiers 
dans nos archives si
	  <list compact="compact">
	    <item>
	      <p>
		 leur utilisation ou leur distribution violent une loi ;
	      </p>
	    </item>
	    <item>
	      <p>
	leur utilisation ou leur distribution créent un conflit éthique ;
		      </p>
	    </item>
	    <item>
	      <p>
		nous sommes obligés de signer une licence pour les utiliser ;
	      </p>
	    </item>
	    <item>
	      <p>
		leur distribution entre en conflit avec des politiques 
du projet Debian.
	      </p>
	    </item>
	  </list>
	</p>

	<p>
	  Les programmes dont les auteurs encouragent l'utilisateur à faire des
dons conviennent très bien à la section <em>main</em>, sauf si les auteurs
affirment que ne pas faire de don est immoral, non-éthique, illégal 
ou quelque chose de similaire ; dans ce cas, ces programmes 
doivent être placés dans la section <em>non-free</em>.
</p>

	<p>
	  Les paquets dont les notices de copyright (ou des problèmes de 
brevet) ne permettent pas la redistribution, même sous forme binaire, 
et pour lesquels aucune permission spéciale n'a été obtenue, ne doivent pas 
être placés sur le site FTP de Debian et ses miroirs.</p>

	<p>
On notera que dans la loi internationale du copyright (ceci s'applique aussi
aux États-Unis), <em>aucune</em> distribution ou modification d'un travail 
n'est autorisée sans une mention explicite. C'est pourquoi un programme sans
notice de copyright <em>est</em> protégé et vous ne pouvez rien en faire
sans risquer d'être poursuivi. De même, un programme avec une notice
de copyright qui n'énoncerait pas explicitement ce qui est permis
interdit tout.
</p>

	<p>
Beaucoup d'auteurs de soi-disant logiciels libres ignorent les problèmes
posés aux utilisateurs par des copyrights restrictifs (ou l'absence
de notice de copyright). Il est souvent intéressant de contacter
diplomatiquement de tels auteurs pour leur demander de modifier les
termes de leur licence. Cependant cela peut être politiquement difficile
et vous devriez au préalable demander conseil sur la liste
de diffusion <tt>debian-legal</tt>, comme il est expliqué plus bas.
</p>

	<p>
En cas de doute à propos d'un copyright, envoyez un courrier électronique à
<email>debian-legal@lists.debian.org</email>. Soyez prêt à nous donner
le copyright complet. Les logiciels couverts par la «&nbsp;GPL&nbsp;», les 
logiciels du domaine public et les copyrights de type «&nbsp;BSD&nbsp;» sont 
sûrs ; méfiez-vous d'expressions comme «&nbsp;utilisation commerciale 
interdite&nbsp;» et «&nbsp;distribution limitée&nbsp;».
</p>
      </sect1>
      <sect1>
	<heading>Les sous-sections</heading>

	<p>
Les paquets des sections (<em>main</em>, <em>contrib</em> et <em>non-free</em>
sont regroupés en <em>sous-sections</em> pour simplifier leur traitement.
</p>

	<p>
	  La section et la sous-section seront spécifiées dans le champ de 
contrôle <tt>Section</tt> de chaque paquet. Toutefois, le responsable de
l'archive Debian peut changer ce choix afin d'assurer la cohérence de la 
distribution Debian. le champ <tt>Section</tt> sera de la forme :
<list compact="compact">
<item>
<p>
<em>sous-section</em> si le paquet appartient à la section <em>main</em>,
</p>
	      </item>
<item>
<p>
<em>section/sous-section</em> si le paquet appartient à la section 
<em>contrib</em> ou à la section <em>non-free</em>, et
		</p>
	      </item>
<item>
<p>
<tt>non-US</tt>, <tt>non-US/contrib</tt> ou <tt>non-US/non-free</tt> si le
paquet appartient, respectivement, aux sections <em>non-US/main</em>, 
<em>non-US/contrib</em> et <em>non-US/non-free</em>.
               </p>
             </item>
           </list>
         </p>

	<p>
Les responsables de l'archive Debian donne la liste des sous-sections
autorisées :
<em>admin</em>, <em>base</em>, <em>comm</em>,
            <em>contrib</em>, <em>devel</em>, <em>doc</em>,
            <em>editors</em>, <em>electronics</em>, <em>games</em>,
            <em>graphics</em>, <em>hamradio</em>,
            <em>interpreters</em>, <em>libs</em>, <em>mail</em>,
            <em>math</em>, <em>misc</em>, <em>net</em>, <em>news</em>,
            <em>non-US</em>, <em>non-free</em>, <em>oldlibs</em>,
            <em>otherosfs</em>, <em>science</em>, <em>shells</em>,
            <em>sound</em>, <em>tex</em>, <em>text</em>,
            <em>utils</em>, <em>web</em>, <em>x11</em>.
	  </p>
	      </sect1>
      <sect>
	<heading>Les priorités</heading>
	  
	<p>
	  Chaque paquet aura une <em>priorité</em> spécifiée dans son
<em>fichier de contrôle</em>. Cette information, utilisée par l'outil
de gestion des paquets Debian, permet de séparer les paquets prioritaires
de ceux qui le sont moins.
</p>
	<p>
	  Le système Debian de gestion de paquet, <prgn>dpkg</prgn>, comprend
les <em>niveaux de priorités</em> suivants :

	  <taglist>
	    <tag><tt>required</tt></tag>
	    <item>
	      <p>
Ce sont les paquets nécessaires au bon fonctionnement du système. Vous ne 
devez pas les enlever sous peine de rendre votre système complètement 
inutilisable ; vous ne pourrez probablement même plus utiliser 
<prgn>dpkg</prgn> pour remettre les choses en place. Les systèmes composés 
uniquement de paquets <tt>required</tt> sont probablement inutilisables, 
mais ils disposent des fonctionnalités suffisantes pour permettre à 
l'administrateur système de <em>booter</em> et d'installer d'autres logiciels.
 </p>
	    </item>
	    <tag><tt>important</tt></tag>
	    <item>
	      <p>
Ces paquets incluent ceux que l'on s'attend à trouver  sur un système de type 
Unix. Si l'on pense qu'un expert Unix, détectant l'absence d'un programme 
s'exclamera : «&nbsp;Qu'arrive-t-il à la terre ? où est passé le programme 
<prgn>foo</prgn> ?&nbsp;», alors celui-ci doit être dans <tt>important</tt>
<footnote>
<p>
C'est un critère fort, car nous cherchons à produire, entre autres choses, un 
Unix libre.</p>	</footnote>. Les autres paquets sans
lesquels le système ne fonctionne pas bien ou est inutilisable
doivent avoir cette priorité. Cela <em>n'inclut pas</em>
«&nbsp;Emacs&nbsp;» ou «&nbsp;X11&nbsp;» ou «&nbsp;TeX&nbsp;» ou tout autre 
grosse application. Les paquets <tt>important</tt> constituent simplement un 
ensemble minimal d'outils nécessaires et communément attendus.
 </p>
	    </item>
	    <tag><tt>standard</tt></tag>
	    <item>
	      <p>		
Ces paquets fournissent un système en mode caractère, relativement
petit mais pas trop limité. Ils seront installés par défaut si
l'utilisateur ne sélectionne rien d'autre. Ce niveau laisse de côté
beaucoup de grosses applications. 
</p>
	    </item>
	    <tag><tt>optional</tt></tag>
	    <item>
	      <p>		
(En un sens, ce qui n'est pas obligatoire est facultatif, mais
ici «&nbsp;optional&nbsp;» ne doit pas être compris ainsi.) Ce sont tous les
logiciels qu'on pourrait raisonnablement vouloir installer quand on ne les
connaît pas et qu'on a pas d'exigences particulières. Cela constitue un 
système nettement plus gros et contient «&nbsp;X11&nbsp;», la distribution 
complète de «&nbsp;TeX&nbsp;» et de nombreuses applications. Notez qu'il ne
doit pas y avoir de conflit entre les paquets optionnels.
</p>
	    </item>
	    <tag><tt>extra</tt></tag>
	    <item>
	      <p>
Sont regroupés là les paquets qui sont en conflit avec d'autres
paquets dont les priorités sont «&nbsp;required&nbsp;», «&nbsp;important&nbsp;», «&nbsp;standard&nbsp;»
ou «&nbsp;optional&nbsp;», ou bien les paquets utiles uniquement
si vous savez déjà ce qu'ils font, ou bien les paquets qui ont des
exigences spécifiques.	
	      </p>
	    </item>
	  </taglist></p>
	  
	<p>
	Les paquets ne doivent pas dépendre de paquets dont les priorités 
sont de valeur inférieure (hors dépendances pour la construction).
Pour cela, on pourra ajuster les priorités d'un ou de plusieurs paquets.
	</p>
      </sect>
	  
      <sect>
	<heading>Les paquets binaires</heading>
	  
	<p>
La distribution Debian GNU-Linux est fondée sur le système Debian de gestion de
paquets, appelé <prgn>dpkg</prgn>. Par conséquent, tous les
paquets de la distribution Debian doivent être fournis au format de
fichier <tt>.deb</tt>.
</p>
	
	<sect1>
	  <heading>Le nom d'un paquet</heading>
	    
	  <p>
Chaque paquet doit avoir un nom unique dans l'archive Debian.
</p>
	    
	  <p>
Un nom de paquet ne doit comporter que des lettres minuscules (<tt>a-z</tt>),
des chiffres (<tt>0-9</tt>), les signes plus (<tt>+</tt>), moins (<tt>-</tt>) 
ou point (<tt>.</tt>). Il doit
contenir au moins deux caractères, dont l'un est une lettre.
</p>
	    
	  <p>
Le nom d'un paquet fait partie du nom du fichier <tt>.deb</tt> et est
inclus dans le <em>fichier de contrôle</em> du paquet.
	  </p>
	</sect1>
	        
	<sect1>
	  <heading>Le responsable d'un paquet</heading>
	    
	  <p>
	    Chaque paquet doit avoir un responsable Debian (quelqu'un ou 
un groupe de personnes, qu'on peut joindre à une adresse électronique, telle
que, par exemple, une liste de diffusion). Le responsable assure que la 
licence du logiciel du paquet suit les règles des distributions auxquelles 
il appartient.
</p>
	  <p>
Le responsable doit être indiqué dans le champ <tt>Maintainer</tt> avec son 
nom correct et une adresse électronique valide. Quand une personne s'occupe 
de plusieurs paquets, elle essaiera d'éviter d'avoir différents noms ou 
adresses dans les champs <tt>Maintainer</tt> des différents paquets.
</p>
	    
	  <p>
Quand la personne en charge d'un paquet quitte le projet Debian,
c'est le groupe Debian QA <email>packages@qa.debian.org</email>
qui reprend la maintenance du paquet jusqu'à ce qu'un volontaire 
se propose pour cette tâche.
Ces paquets sont appelés <em>paquets orphelins</em>
<footnote>
              <p>
La façon élégante de le faire  peut être trouvée dans le 
« Debian Developer's Reference », [trad. franç. : Manuel de référence du 
développeur Debian : &lt;http://www.fdn.fr/~ahulin/&gt;], soit dans le paquet 
<tt>developers-reference</tt>, soit 
sur le serveur FTP Debian <ftpsite>ftp.debian.org</ftpsite> :
<ftppath>/debian/doc/package-developer/developers-reference.txt.gz</ftppath>
ou sur la
<url id="http://www.debian.org/doc/packaging-manuals/developers-reference/"
                name="Debian Developer's Reference"> page web.
              </p>
            </footnote>.


</p>
	</sect1>
	    
	    
	<sect1>
	  <heading>La description d'un paquet</heading>
	    
	  <p>
Chaque paquet Debian doit avoir une description complète enregistrée
dans les champs <em>ad hoc</em> de son <em>fichier de contrôle</em>.
</p>
<p>
La description apportera les informations dont a besoin un 
administrateur-système pour décider d'installer le paquet. La description ne 
reprendra pas simplement la documentation du programme. Les instructions de 
configuration ou d'utilisation du paquet ne doivent pas en faire partie (c'est
le rôle des scripts d'installation, des pages de man, des fichiers infos, 
etc.), non plus que les notices de copyright et autres écrits administratifs 
(c'est le rôle des fichiers de copyright).
</p>
	</sect1>
	    
	    
	<sect1>
	  <heading>Les dépendances</heading>
	    
	  <p>
Chaque paquet doit indiquer ses relations de dépendance avec les
paquets dont il a besoin pour fonctionner correctement.
</p>
	  <p>
Par exemple, une relation de dépendance doit être déclarée pour toute 
bibliothèque partagée qui est demandée par un exécutable 
dynamiquement lié d'un paquet.
</p>
	    
	  <p>
Il n'est pas nécessaire d'indiquer les dépendances d'un paquet envers
des paquets étiquetés <tt>Essential</tt> (voir ci-dessous), et on ne doit 
pas le faire, à moins que ce ne soit une dépendance pour une version
précise de tel paquet. 
</p>
	  <p>
Dans certains cas, l'installation d'un paquet exige l'installation 
<em>et</em> la configuration préalables d'un autre paquet. Il faut alors 
déclarer une relation <tt>Pre-Depends</tt> pour ce paquet.</p>
	    
	  <p>
Vous ne déclarerez pas une relation <tt>Pre-Depends</tt>
pour un paquet avant qu'une discussion dans la liste de diffusion 
<tt>debian-devel</tt> n'ait abouti à un consensus sur le sujet.
</p>
</sect1>
	    
	    
	<sect1>
	  <heading>Les paquets virtuels</heading>
	    
	  <p>
Parfois il y a des paquets qui font plus ou moins la même chose.
Dans ce cas, il est utile de définir un <em>paquet virtuel</em> dont
le nom décrit la fonction de ces paquets. (Les paquets virtuels existent
de manière logique et non physique ; c'est pour cela qu'ils sont appelés
<em>virtuels</em>.) Les paquets assurant cette fonction viendront 
<em>remplir</em> ce paquet virtuel. Ainsi, tout autre paquet qui a besoin 
de cette fonction pourra simplement dépendre du paquet virtuel, sans
avoir à énumérer tous les paquets possibles.
</p>
	    
	  <p>
Tous les paquets utiliseront les noms de paquets virtuels
quand il conviendra de le faire ; ils s'arrangeront pour en créer de
nouveaux quand ce sera nécessaire. On n'utilisera que les paquets 
virtuels qui ont été acceptés et qui apparaissent dans la liste des noms de 
paquets virtuels 
(sauf de manière privée, pour un ensemble local de paquets corrélés).
</p>
	    
	  <p>
La plus récente version de la liste officielle des paquets virtuels se trouve 
sur <ftpsite>ftp.debian.org</ftpsite> dans
<ftppath>/debian/doc/package-developer/virtual-package-names-list.txt</ftppath>
ou sur votre miroir local. Elle est aussi dans le paquet
<tt>debian-policy</tt>. La procédure de mise à jour de la liste est
décrite au début du fichier.
</p>
</sect1>
	    
	<sect1>
	  <heading>Les paquets dans «&nbsp;base&nbsp;»</heading>
	    
	  <p>
Les paquets inclus dans la section <tt>base</tt> ont une fonction
particulière. Ils forment le sous-ensemble minimal du système Debian
GNU-Linux qui est installé, avant tout autre chose, sur un nouveau système.
Ainsi, seulement un tout petit nombre de paquets peut aller dans
la section <tt>base</tt> afin de minimiser la quantité d'espace disque
nécessaire à une installation.
</p>	    
	  <p>
La plupart de ces paquets auront le niveau de priorité
<tt>required</tt> ou au moins <tt>important</tt> et beaucoup d'entre eux
seront étiquetés <tt>essential</tt> (voir ci-dessous).
</p>
	    
	  <p>
Vous ne devez placer aucun paquet dans la section <tt>base</tt> avant
qu'une discussion dans la liste de diffusion <tt>debian-devel</tt>
n'ait abouti à un consensus sur le sujet.
</p>
</sect1>
	    
	<sect1>
	  <heading>les paquets «&nbsp;essential&nbsp;»</heading>
	    
	  <p>
Certains paquets sont marqués <tt>essential</tt>. (Ils ont
<tt>Essential: yes</tt> dans leur champ de contrôle.)
Cet indicateur est utilisé pour les paquets qui sont <em>indispensables</em> à
un système.
</p>
	    
	  <p>
Comme ces paquets ne peuvent pas être facilement supprimés
(il faut ajouter une option de <em>forçage</em> de <prgn>dpkg</prgn>)
l'indicateur <tt>essential</tt> ne doit être utilisé que si
c'est absolument nécessaire.
Un paquet comprenant une bibliothèque partagée ne doit pas être étiqueté
<em>essential</em> ; les dépendances empêchent sa suppression
prématurée, or il doit être possible de la supprimer quand elle est
périmée.
</p>
<p>
Comme <prgn>dpkg</prgn> n'empêche pas la mise à jour de paquets alors qu'un 
paquet <em>essential</em> est non configuré, tous les paquets 
<em>essential</em> doivent fournir l'essentiel de leurs fonctions même s'ils
ne sont pas configurés. Quand un paquet ne peut pas satisfaire à cette
exigence, il ne doit pas être étiqueté <em>essential</em> ; et tous les paquets
qui en dépendent doivent, comme il est de règle, expliciter leurs dépendances.
</p>
	    
	  <p>
Vous ne devez pas étiqueter un paquet comme <tt>essential</tt> avant qu'une
discussion dans la liste de diffusion <tt>debian-devel</tt>
n'ait abouti à un consensus sur le sujet.
</p>
</sect1>
	    
	    
	<sect1 id="maintscripts">
	  <heading>Les scripts du responsable de paquet</heading>
	    
	  <p>
Les scripts d'installation d'un paquet éviteront d'afficher des
messages que l'utilisateur n'a pas besoin de voir et s'appuieront
sur <prgn>dpkg</prgn> pour sauver de l'ennui un utilisateur qui
installe de nombreux paquets. Cela signifie entre autres choses qu'il faut
utiliser l'option <tt>--quiet</tt> de <prgn>install-info</prgn>.
</p>
	    
	  <p>
Les scripts d'installation doivent détecter toute erreur qui se produit et
doivent arrêter immédiatement l'installation en cours.
</p>
	    
	  <p>
On remarquera que la section <ref id="scripts">, s'applique généralement
aussi aux scripts des responsables de paquet.
</p>

<p>
On n'utilisera pas <prgn>dpkg-divert</prgn> sur un fichier appartenant à 
un autre paquet sans consulter au préalable le responsable du paquet en 
question.
</p>

<p>
Tous les paquets qui donnent une valeur au nom «&nbsp;partagé&nbsp;» d'une 
commande (en général, c'est un nom de fichier), utiliseront en général
<prgn>update-alternatives</prgn>, de manière à rendre possible leur
installation simultanée. Quand on n'emploie pas 
<prgn>update-alternatives</prgn>, chaque paquet doit utiliser 
<tt>Conflicts</tt> pour s'assurer que les autres paquets ne sont pas
installés. (On peut spécifier dans ce cas un conflit avec quelques
versions antérieures d'un paquet qui n'utilisait pas
<prgn>update-alternatives</prgn> ; c'est une exception à la règle
habituelle qui demande d'éviter les conflits de version.)
</p>

<sect2>
<heading>Poser des questions avec les scripts du responsable</heading>

<p>
Les scripts du responsable de paquet peuvent interroger l'utilisateur quand
c'est nécessaire. On peut interroger «&nbsp;à la main&nbsp;» ou bien par
l'intermédiaire d'un programme, tel que <prgn>debconf</prgn>, qui se
conforme aux règles Debian de gestion de la configuration, version 2 ou
supérieure. Ces règles se trouvent dans le fichier 
<tt>debconf_specification</tt> du paquet <package>debian-policy</package>. 
On peut aussi trouver ce fichier sur le site FTP 
<ftpsite>ftp.debian.org</ftpsite> dans 
<ftppath>/debian/doc/package-developer/debconf_specification.txt.gz</ftppath>
ou sur un miroir local<footnote>
<p>
4% des paquets Debian 
[Voir <url id="http://kitenet.net/programs/debconf/stats/" name="Debconf stats">] utilisent
<package>debconf</package> pour interroger l'utilisateur au moment de 
l'installation ; ce nombre augmente régulièrement. Les avantages de debconf 
sont expliqués rapidement sur
<url id="http://kitenet.net/doc/debconf-doc/introduction.html" name="Debconf introduction"> : configuration
préalable (en particulier), installation non-interactive, élimination des
questions redondantes, cohérence de l'interface utilisateur, etc.
		</p>
<p>
Le nombre croissant de paquet utilisant <package>debconf</package>, 
l'existence d'une implémentation naissante d'un second système Debian de 
gestion de la configuration (<package>cdebconf</package>) et la stabilisation 
des protocoles utilisés nous invitent finalement à les mentionner dans la
charte.
		</p>
	      </footnote>.
	    </p>

<p>
Les paquets qui utilisent les règles Debian de gestion de la configuration
peuvent contenir un script supplémentaire <prgn>config</prgn> et un fichier
<tt>templates</tt> dans leur archive de contrôle. Le script
<prgn>config</prgn> peut être lancé avant le script <prgn>preinst</prgn> et
avant que le paquet soit dépaqueté ou bien avant que ses dépendances et
pré-dépendances soient satisfaites : il doit donc fonctionner en utilisant
seulement les outils présents dans les paquets <em>Essential</em> <footnote>
<p>
<package>Debconf</package> ou tout autre outil qui met en oeuvre les règles 
Debian de gestion de la configuration est aussi installé, et toutes les 
dépendances concernant des versions sont satisfaites avant le commencement de 
la configuration préalable.
		</p>
	      </footnote>.
	    </p>
	    
<p>
Les paquets essaieront de minimiser le nombre de questions
posées et s'assureront que chaque question ne sera posée qu'une
seule fois. Cela signifie que les paquets doivent
essayer d'utiliser les fichiers de configuration partagés (comme
<tt>/etc/papersize</tt> ou <tt>/etc/news/server</tt>) et les variables
partagées de <package>debconf</package>,
plutôt que de redemander, chacun, la même information.
</p>
	  
	  <p>
Quand un paquet doit donner une information importante à l'utilisateur
(comme : «&nbsp;ne pas exécuter directement ce programme, vous devez d'abord
modifier les fichiers de configuration suivants sinon votre système
émettra des messages mal formatés&nbsp;»), il affichera ce message
dans le script <prgn>config</prgn> ou dans le script <prgn>postinst</prgn>).
Il demandera ensuite à l'utilisateur de taper sur la touche
«&nbsp;retour-chariot&nbsp;» quand il a pris connaissance du message. Les 
messages de copyright et les instructions d'utilisation ne sont pas considérés
comme des messages vitaux. Ils doivent apparaître respectivement
dans <tt>/usr/share/doc/<var>package</var>/copyright</tt> et dans la
documentation en ligne, où tous les utilisateurs peuvent les consulter.
</p>
	    
	  <p>
Presque toujours, seuls les scripts <prgn>config</prgn> et 
<prgn>postinst</prgn> poseront les questions nécessaires ; Quand on utilise
le script <prgn>postinst</prgn>, il doit empêcher, par une condition 
quelconque, qu'elles soient posées en cas d'échec de l'installation d'un 
paquet ou s'il est appelé avec <tt>abort-upgrade</tt>, <tt>abort-remove</tt> ou
<tt>abort-deconfigure</tt>.</p>

	</sect1>
      </sect>
      
<sect>
	<heading>Les paquets sources</heading>
	  
      <sect1 id="standardsversion">
	  <heading>La conformité aux manuels Debian</heading>

 <p>
On indiquera la version la plus récente de la <em>Charte Debian</em> à 
laquelle s'est conformé le paquet lors de sa plus récente mise à jour. Cela 
se précise dans le champ
de contrôle <tt>Standards-Version</tt> du paquet source. La version actuelle
est la version 3.5.6.0.
</p>
	  <p>
On peut utiliser cette valeur pour remplir automatiquement des rapports de 
bogue quand le paquet est vraiment trop vieux.
</p>
	    
	  <p>
Le numéro de version est composé de quatre parties : un numéro de version 
majeur et un mineur, un niveau de patch majeur et un mineur. Quand les normes
changent, exigeant des modifications dans tous les paquets, le numéro
majeur est changé. Les changements significatifs, exigeant des évolutions
dans de nombreux paquets, sont signalés par un changement du numéro mineur.
Le niveau majeur de patch sera modifié pour tout changement
limité de la signification des standards. Le niveau de
patch mineur sera changé pour toute amélioration légère (typographique, ou
autres...) qui ne modifie pas le sens de ce document, ou pour des changements 
qui n'affectent pas le contenu des paquets.
</p>
	  <p>
Seuls les trois premiers chiffres de la version sont significatifs pour le 
champ <em>Standards-Version</em>, et on peut choisir
de donner soit les trois chiffres, soit la formule complète
	    <footnote>
	      <p>
Par le passé, on devait donner la formule complète à quatre chiffres,
par exemple : «&nbsp;2.3.0.0&nbsp;». Mais comme un changement de niveau de 
«&nbsp;patch&nbsp;»
n'introduit pas une nouvelle norme, on a trouvé préférable d'assouplir la 
règle et de ne demander qu'une formule à trois chiffres, dans ce cas : 
«&nbsp;2.3.0&nbsp;». (On peut toujours
utiliser la formule complète si l'on veut.)
	      </p>
	    </footnote>.
	  </p>
	    
	  <p>
Vous consulterez régulièrement, et notamment si votre paquet est obsolète,
la plus récente version de la <em>Charte Debian</em>, et vous mettrez à jour 
votre paquet si nécessaire.
Lorsque le paquet est conforme à la nouvelle norme,
vous mettrez à jour le champ <tt>Standards-Version</tt>
du paquet source et vous le diffuserez
<footnote><p>
Consultez le fichier <tt>upgrading-checklist</tt> pour connaître les
changements entre différentes versions de ce document.</p>
	  </footnote>.
</p>
</sect1>
	    
         <sect1>
           <heading>Les relations entre paquets</heading>
 
           <p>
Les paquets source préciseront les paquets binaires qui doivent être 
installés et ceux qui ne doivent pas l'être, pour que leur construction 
réussisse.
Si l'on doit, par exemple, compiler un paquet avec tel compilateur particulier,
une dépendance de compilation sera déclarée envers ce paquet.
           </p>
 
           <p>
Pour un très petit nombre de paquets, ceux dont on a toujours besoin pour 
compiler, lier et insérer dans un paquet debian un programme classique écrit 
en C ou C++ comme «&nbsp;Hello world!&nbsp;», il n'est pas nécessaire de 
déclarer explicitement des relations de dépendance. Ces paquets, sur lesquels
on peut trouver des renseignements dans la liste 
<tt>/usr/share/doc/build-essential/list</tt> (contenue dans le
paquet <tt>build-essential</tt>), sont marqués <em>build-essential</em>
<footnote>
<p>
Le raisonnement : 
<list compact="compact">
<item>
<p>
On peut ainsi maintenir une liste distincte de la Charte (une liste nécessite 
moins de contrôle que la Charte) ;
		    </p>
		  </item>
<item>
<p>
Un paquet distinct permet l'installation des paquets 
«&nbsp;build-essential&nbsp;» sur une machine, et permet aussi que d'autres 
paquets tels que les paquets «&nbsp;task&nbsp;» installent les paquets 
«&nbsp;build-essential&nbsp;» à travers une relation de dépendance ;
		    </p>
		  </item>
<item>
<p>
Un paquet distinct permet de séparer les rapports de bogues concernant la 
liste du processus de gestion de la charte dans le «&nbsp;BTS&nbsp;»
(système de suivi des bogues).
		    </p>
		  </item>
		</list></p>
	    </footnote>.
</p>
 
           <p>
La liste des dépendances de compilation ne contiendra que les paquets
explicitement nécessaires à la compilation. Les paquets simplement demandés
parce qu'un paquet de cette liste dépend d'eux ne doivent pas être déclarés
<footnote><p>
La raison en est que les relations de dépendance changent et vous ne 
déclarerez que les paquets et <em>seulement ceux-là</em> dont <em>vous</em> 
avez besoin. Ce dont les autres ont besoin est leur affaire. Si par exemple
vous utilisez la bibliothèque <tt>libimlib</tt>, vous aurez besoin d'une
dépendance de construction pour le paquet <package>libimlib2-dev</package> ;
mais vous n'avez pas besoin de dépendance pour les paquets <tt>libjpeg*</tt>,
même si <tt>libimlib2-dev</tt> dépend de ces paquets : l'installation de
<package>libimlib2-dev</package> s'assurera que toutes les dépendances
nécessaires à son exécution sont satisfaites.</p>
	    </footnote>.
           </p>
 
           <p>
Quand les relations de dépendance de compilation sont indiquées, on doit
pouvoir compiler un paquet et produire un binaire opérationnel sur un
système où les paquets <tt>essential</tt> et <tt>build-essential</tt> sont 
installés ainsi que ceux nécessaires pour que les relations de dépendance de 
compilation soient satisfaites (y compris les implicites). Cela signifie en 
particulier que, dans les relations de 
dépendance de compilation, on doit traiter rigoureusement les questions de
version de manière à éviter les paquets mal ou stupidement configurés quand
les relations de dépendances sont correctement satisfaites.
</p>
 
	<sect1>
	  <heading>Les modifications dans les «&nbsp;sources&nbsp;» originaux</heading>
	    
	  <p>
Si vous modifiez le code source d'une manière qui n'est pas liée au système
Debian, vous enverrez 
ces changements aux auteurs, dans la forme qu'ils préféreront, de manière à
ce qu'ils puissent être intégrés dans la version originale.
</p>
	    
	  <p>
Si vous avez besoin de configurer le paquet de façon différente sous 
Debian et sous Linux et si les sources originaux ne proposent pas de manière
de le faire, veuillez ajouter ces moyens de configuration.
C'est par exemple un nouveau test d'<prgn>autoconf</prgn> ou un
<tt>#define</tt>. Envoyez ensuite le «&nbsp;patch&nbsp;» aux auteurs,
en choisissant comme valeur par défaut la configuration qu'ils
avaient choisie.  Vous pouvez facilement remplacer la valeur par défaut
dans votre <tt>debian/rules</tt> ou dans tout autre endroit approprié.
</p>
	  <p>
Vous vérifierez que l'outil <prgn>configure</prgn>
détecte la bonne déclaration d'architecture (reportez
vous à la section <ref id="arch-spec"> pour plus de détails).
</p>
	  <p>
Si vous avez besoin de modifier un <prgn>Makefile</prgn> qui utilise
des scripts <prgn>configure</prgn> de style «&nbsp;GNU&nbsp;», vous modifierez
les fichiers <tt>.in</tt>, plutôt que directement le
<prgn>Makefile</prgn>. Cela permet à l'utilisateur de reconfigurer
le paquet si nécessaire. Vous <em>ne devez pas</em>
configurer le paquet et modifier le <prgn>Makefile</prgn> produit !
Cela rend impossible la reconfiguration ultérieure du paquet par
un autre utilisateur.
</p>
</sect1>
	    
	<sect1>
	  <heading>Comment documenter vos modifications ? </heading>
	    
	  <p>
Vous documenterez vos modifications et vos mises à jour des sources du paquet
dans le fichier <em>ad hoc</em> <tt>debian/changelog</tt>. (Plutôt que
de «&nbsp;réécrire l'histoire&nbsp;» en modifiant les vieilles entrées,
il vaut mieux corriger les erreurs en créant une 
nouvelle entrée dans le «&nbsp;changelog&nbsp;».)
</p>
	    
	  <p>
Dans les paquets définitifs, vous devez utiliser, 
pour <tt>debian/changelog</tt>, un format supporté par la version la plus 
récente de <prgn>dpkg</prgn>
<footnote><p>
Si vous souhaitez utiliser un autre format, vous pouvez le faire tant que
vous fournissez un outil d'analyse (parser) dans votre paquet source. Cet
outil doit avoir une API compatible avec celle attendue par 
<prgn>dpkg-genchanges</prgn> et par <prgn>dpkg-gencontrol</prgn>. Quand ce
nouveau format recueille un intérêt partagé, vous contacterez le 
responsable de <package>dpkg</package> afin qu'il ajoute le script analyseur 
de votre format dans le paquet <prgn>dpkg</prgn>. (Vous accepterez ainsi que 
l'analyseur et sa page de manuel soient distribués sous la licence 
«&nbsp;GNU GPL&nbsp;», comme l'est le reste du paquet <prgn>dpkg</prgn>.)
	      </p>
	    </footnote>.
</p>
</sect1>
	    
	<sect1>
	  <heading>La détection des erreurs dans les makefiles</heading>
	    
	  <p>
Quand <prgn>make</prgn> appelle une commande dans un
makefile (incluant les makefiles originaux de votre
paquet et <tt>debian/rules</tt>), cela se fait par
<tt>sh</tt>. Or <tt>sh</tt> traite mal les erreurs :
si vous incluez un mini-script shell en tant que
commande dans votre makefile, vous constaterez que si
vous n'avez pas de mécanisme de détection d'erreur, <prgn>make</prgn> 
continuera aveuglément malgré les problèmes rencontrés.
</p>
	    
	  <p>
Chaque fois que vous mettez plus d'une commande shell (cela
inclut l'utilisation d'une boucle) dans une commande
du makefile, vous devez vous assurer que les erreurs
sont détectées. Pour de simples commandes composées comme changer de 
répertoire et exécuter un programme,
il est suffisant d'utiliser «&nbsp;<tt>&amp;&amp;</tt>&nbsp;» à la place
du point-virgule.
Pour des commandes plus complexes incluant la plupart des boucles et 
des instructions conditionnelles, vous ajouterez la commande <tt>set -e</tt> 
au début de chacun de ces mini-scripts shell que sont les commandes d'un 
makefile.
</p>
</sect1>
	<sect1>
	  <heading>Les constructions obsolètes et les bibliothèques</heading>
	    
	  <p>
Le fichier d'«&nbsp;include&nbsp;» <tt>&lt;varargs.h&gt;</tt> est fourni 
pour les utilisateurs qui compilent des logiciels très anciens ; la 
bibliothèque <tt>libtermcap</tt> est fournie pour l'exécution de programmes 
qui ont été liés avec elle (soit de vieux programmes, soit des programmes comme
Netscape disponibles uniquement sous forme binaire).
</p>
	  <p>
Les paquets Debian utiliseront plutôt <tt>&lt;stdarg.h&gt;</tt> et 
<tt>ncurses</tt>.
</p>
</sect1>
</sect>
</chapt>

<chapt id="3"><heading>Les fichiers de contrôle et leurs
champs</heading>
<p>
Beaucoup d'outils du système de gestion des paquets manipulent les données de
la même façon : ces <em>données de contrôle</em> sont stockées dans des 
<em>fichiers de contrôle</em>.
Les paquets source et binaire possèdent des fichiers de contrôle ; et
les fichiers <tt>.changes</tt> qui contrôlent l'installation des
fichiers sur le serveur (upload), les bases de données internes à 
<tt>dpkg</tt> sont aussi des fichiers de contrôle.
<sect id="controlsyntax"><heading>La syntaxe des fichiers de contrôle</heading>
<p>
Un fichier consiste en un ou plusieurs paragraphes comportant des champs. Ces
paragraphes sont séparés par des lignes blanches. Certains fichiers de
contrôle n'autorisent qu'un seul paragraphe ; d'autres en autorisent 
plusieurs, et dans ce cas, chaque paragraphe fait souvent référence à un 
paquet différent. (Dans les paquets sources, par exemple, le premier 
paragraphe se réfère au paquet source et les paragraphes suivants aux paquets 
binaires créés à partir de ce source.)</p>
<p>
Chaque paragraphe est une série de champs contenant des données ; chaque champ
est constitué d'un nom, suivi par deux-points et la valeur associée. Il se
termine à la fin de la ligne. Les espaces horizontaux (espaces et
tabulations) peuvent apparaître immédiatement avant la valeur et après, mais 
là, ils sont ignorés ; par convention, il y a un espace après les deux-points.
Voici un exemple de champ :
<example compact="compact">
Package: libc6
         </example>
Le nom du champ est <tt>Package</tt> et la valeur est <tt>libc6</tt>.
</p>
<p>
Certaines valeurs de champ peuvent déborder sur plusieurs lignes ; dans ce cas
chaque nouvelle ligne <em>doit</em> commencer par un espace ou une tabulation.
Tous les espaces ou tabulations restants en fin de ligne sont ignorés.
	</p>      
<p>
Sauf indications contraires, une seule ligne de données est
autorisée et les espaces ne sont pas significatifs dans le corps du
champ. Les espaces ne doivent jamais apparaître dans les noms (de
paquets, d'architectures, de fichiers, etc), dans les numéros de version
ou entre les éléments de relations de version à plusieurs caractères.
	</p>
<p>
Les noms de champs sont indépendants de la casse ; en général, ceux-ci sont
écrits en commençant par une majuscule puis en mélangeant majuscules et
minuscules comme dans les exemples plus bas.
</p>
<p>
Les lignes vides ou les lignes contenant seulement des espaces ou des
tabulations ne sont pas autorisées à l'intérieur des valeurs de champ ou
entre les champs - ce qui signifierait un nouveau paragraphe.
	</p>
      </sect>
<sect><heading>La liste des champs</heading>
<p>
Cette liste n'est pas supposée être complète. La plupart des champs sont 
étudiés ailleurs dans ce texte.
	</p>
<p>
<sect1 id="Package"><heading><tt>Package</tt>
          </heading>

<p>
Le nom du paquet binaire. Les noms de paquet sont constitués de
caractères alphanumériques et des caractères <tt>+</tt>, <tt>-</tt>, <tt>.</tt>
(plus, moins, point).
	  </p>

	  <p>	    
Ils doivent contenir au moins deux caractères, commencer par un caractère
alphanumérique et ne pas contenir que des chiffres. Il est fortement 
recommandé de les écrire en minuscules
à moins que le paquet que l'on construit ou auquel on se réfère (par exemple,
dans d'autres champs) n'utilise déjà des majuscules.
</p>
	</sect1>
	
	<sect1 id="f-Version"><heading><tt>Version</tt></heading>

	  <p>	    
Ce champ donne le numéro de version des paquets source ou binaire - voir
<ref id="4">.
	  </p>

	</sect1>

	<sect1><heading><tt>Standards-Version</tt>
	  </heading>

	  <p>	    
Ce champ donne la plus récente version des normes (la charte Debian et les
textes associés) à laquelle se conforme le paquet. Il est mis à jour
manuellement quand on modifie le paquet source pour le rendre conforme
à des normes plus récentes ; on peut parfois se servir de ce champ pour
signaler qu'un paquet a besoin d'entretien. Son format est décrit plus bas ;
Voyez <ref id="standardsversion">.
  </p>

	</sect1>
	
	
	<sect1 id="Distribution"><heading><tt>Distribution</tt>
	  </heading>

	  <p>	    
Dans un fichier <tt>.changes</> ou affiché par l'analyse d'un changelog,
ce champ contient les noms (séparés par des espaces) des distributions dans 
lesquelles cette version du paquet sera installée. Les noms de 
distribution sont déterminés par les responsables de l'archive
	    <footnote>
Actuellement, les noms des distributions sont les suivants :
		<taglist compact="compact">
		  <tag><em>stable</em></tag>
		  <item>
		    <p> 
C'est l'édition d'une version à jour de Debian GNU-Linux.
Une fois que la distribution est <em>stable</em>, seule la
correction d'erreurs majeures ou d'erreurs concernant la sécurité est 
autorisée. Quand cette distribution est modifiée, son numéro d'édition est 
incrémenté (par exemple : 1.2r1 devient 1.2r2 puis 1.2r3 etc.).
		    </p>
		  </item>
<tag><em>unstable</em></tag>
                  <item>
                    <p>
Cette valeur de distribution fait référence au côté
<em>développement</em> de l'arbre Debian des distributions. Les nouveaux
paquets, de nouvelles sources pour les paquets et la correction d'erreur
vont dans le répertoire <em>unstable</>. C'est prendre des risques que
d'utiliser cette distribution.
                    </p>
                  </item>
		  
		  <tag><em>testing</em></tag>
<item>
<p>
Cette valeur de distribution fait référence au côté <em>test</em> de l'arbre 
Debian des distributions. Les paquets qui la composent proviennent de la
distribution <em>unstable</em> où ils sont restés un court moment de manière
à s'assurer qu'ils n'ont pas de défauts graves. Les paquets de cette
distribution sont moins défectueux que ceux de la distribution 
<em>unstable</em> mais comportent des risques. On ne peut pas installer des
paquets dans <em>testing</em>.</p>
		  </item>

		  <tag><em>frozen</em></tag>
		  <item>
		    <p>
De temps en temps, la distribution <em>testing</em> entre dans un état 
dit de «&nbsp;gel du code&nbsp;» qui anticipe la version <em>stable</>. 
Pendant cette période de test, seules les corrections d'erreurs existantes ou 
nouvellement découvertes sont autorisées. Le détail précis de cette étape est
déterminé par le responsable de l'édition («&nbsp;Release Manager&nbsp;»).
		    </p>
		  </item>
		  
		  <tag><em>experimental</em></tag>
	  <item>
	    <p>
Les paquets qui possèdent cette valeur de distribution sont considérés par
leur responsable comme représentant un grand risque. Souvent, ce sont des
paquets en béta-test ou en cours de développement, provenant de sources
variées que les responsables veulent faire tester, mais ce ne sont pas des 
paquets qui peuvent être inclus dans d'autres répertoires de l'arbre Debian 
des distributions. À utiliser à ses risques et périls.
		    </p>
		  </item>
		</taglist>

<p>
On listera <em>toutes</em> les distributions dans lesquelles le paquet sera
installé. 
	      </p>
	    </footnote>.
	  </p>
	</sect1>
	      </sect>
    </chapt>
<chapt id="4"><heading>La numérotation des versions</heading>

<p>
Chaque paquet possède un numéro de version enregistré dans le champ 
<tt>Version</> de son fichier de contrôle.
</p>
<p>
Le système de gestion des paquets impose un ordre aux numéros de version : 
il peut ainsi connaître quel type de mise à niveau est en cours et les
applications qui lui servent d'interface peuvent dire si un paquet disponible 
est plus récent que celui installé sur le système. La partie la plus 
significative (du moins en ce qui concerne la comparaison) du format des 
numéros de version se trouve au début.
      </p>
<p>

Le format des numéros de version est le suivant :
&lsqb;<var>epoch</var><tt>:</tt>&rsqb;<var>version_originelle</var>&lsqb;<tt>-</tt><var>debian_revision</var>&rsqb;
      </p>
<p>
Les trois composants sont :

<taglist>

<tag><var>epoch</var></tag>
<item>
<p>
C'est simplement un entier non signé (souvent petit). Il peut être
omis et dans ce cas il est égal à 0. S'il est omis, le champ
<var>version_originelle</var> ne peut pas contenir un «&nbsp;:&nbsp;».
</p>
<p>
Il sert à permettre les erreurs dans les numéros des vieilles 
versions d'un paquet, et aussi à abandonner les précédentes structures de 
numérotation concernant les versions d'un paquet.
</p>
	  </item>

<tag><var>version_originelle</var></tag>
<item>
<p>
C'est la partie principale du champ. En général, on utilise le numéro de la 
version originelle («&nbsp;upstream&nbsp») du paquet à partir duquel le 
fichier <tt>.deb</> a été crée (s'il est utilisable). Le plus souvent, ce 
champ est dans le même format que celui spécifié par le ou les auteurs 
originels ; cependant, il peut devoir être reformaté pour s'adapter au format 
et aux méthodes de comparaison du système de gestion des paquets.
	    </p>
<p>
Les méthodes de comparaison du système de gestion des paquets en ce qui
concerne la partie <var>version_originelle</var> sont décrites  ci-dessous. 
Cette partie est obligatoire.
	    </p>
<p>
La partie <var>version_originelle</var> ne peut contenir que des
caractères alphanumériques <footnote><p>Les caractères alphanumériques sont :
<tt>A-Za-z0-9</tt></p>
	      </footnote>et les caractères <tt>.</tt>, <tt>+</tt>,
<tt>-</tt> et <tt>:</tt> (point, plus, trait d'union et deux-points) ; elle 
commencera par un chiffre. S'il n'y a pas de partie <var>révision_debian</var>
alors le trait d'union «&nbsp;-&nbsp;» n'est pas autorisé. S'il n'y a pas de
partie <var>epoch</var> alors les «&nbsp;:&nbsp;» ne sont pas autorisés.
	    </p>
	  </item>

<tag> <var>révision_debian</var></tag>
<item>
<p>
Cette partie du champ indique le numéro de version du paquet Debian basé sur
la version originelle. Il ne peut contenir que des caractères alphanumériques
et les caractères <tt>+</tt> et <tt>.</tt> (plus et point) ; les méthodes de 
comparaison sont les mêmes que pour la partie <var>version_originelle</var>.
	  </p>
<p>
Cette partie est facultative. Si elle manque, la partie
<var>version_originelle</var> ne peut contenir de trait d'union.  
On utilise cette partie quand un morceau de code a été écrit spécialement pour
obtenir un paquet Debian. Il n'y a qu'une seule <em>débianisation</em> de
ce paquet et aucune indication de révision n'est nécessaire.
</p>

<p>
Par convention, la partie <var>révision_debian</var> est remis à 1 à chaque
fois que la partie <var>version_originelle</var> est incrémentée.
</p>

<p>
Le système de gestion de paquet sépare les parties 
<var>version_originelle</var> et <var>révision_debian</var> au dernier trait 
d'union de la chaîne. Dans une comparaison, l'absence de la partie
<em>révision_debian</> est détectée plus tôt que sa présence (néanmoins 
la partie <var>révision_debian</var> est la partie la
moins significative du numéro de version).
</p>
	  </item>
</taglist>

Le système de gestion des paquets compare les parties 
<var>version_originelle</var> et <var>révision_debian</var> en utilisant le 
même algorithme.
      </p>

<p>
Les chaînes sont comparées de gauche à droite.
      </p>

<p>
Pour chaque chaîne, une partie initiale composée uniquement de
lettres est déterminée. Ces deux parties (l'une peut être vide) sont comparées
lexicalement. Si une différence est trouvée, elle est retournée. La
comparaison lexicale est une comparaison qui utilise des valeurs ASCII 
modifiées de manière à ce que toutes les lettres soient classées avant les 
chiffres et les caractères de ponctuation.
      </p>

<p>
Ensuite, pour ce qui reste de cette chaîne, une partie initiale composée
uniquement de chiffres est déterminée. Les valeurs numériques de ces deux
parties sont comparées, la différence est retournée comme résultat de la
comparaison. Dans ce but, une chaîne vide (qui peut seulement
apparaître à la fin de l'une ou des deux chaînes que l'on compare)
compte pour zéro.
      </p>

<p>
Ces deux phases sont répétées (comparaison et suppression des caractères et 
des chiffres se trouvant au début des chaînes) jusqu'à ce qu'une différence 
soit trouvée ou que les deux chaînes soient terminées.
      </p>

<p>
Le but de la partie <var>epoch</var> est de permettre des erreurs dans la
numérotation de version et de s'arranger avec les situations où la
numérotation de version change. Il <em>ne sert pas</em> à corriger les
numéros de version contenant des chaînes de caractères que le système de
gestion des paquets ne peut pas interpréter (tel que <tt>ALPHA</tt> ou 
<tt>pre-</tt>) ou une numérotation bâtarde (l'auteur de ce manuel a 
entendu parler d'un paquet dont les versions allaient ainsi : <tt>1.1.1.2</>, 
<tt>1.3</>, <tt>1</>, <tt>2.1</>, <tt>2.2</>, <tt>2</> et ainsi de suite).
      </p>

<p>
Quand la numérotation d'un paquet pose problème, elle sera convertie en un 
format utilisable dans le champ <tt>Version</tt>.
      </p>

   <sect>
<heading>La numérotation des versions fondée sur des dates</heading>

<p>
En règle générale, les paquets Debian utiliseront les mêmes numéros de 
version que les sources.</p>

<p>
Cependant, la numérotation des sources est parfois fondée sur une date (par
exemple, un instantané d'une version de développement) ; le système de 
gestion des paquets ne peut pas manipuler cette numérotation sans les
<em>epochs</em>. Et <prgn>Dpkg</prgn> par exemple considère que
«&nbsp;96May01&nbsp;» est plus grand que «&nbsp;96Dec24&nbsp;».</p>

<p>
Pour éviter l'utilisation d'<em>epochs</em> à chaque nouvelle version source,
on emploiera dans de tels cas le format suivant : «&nbsp;19960501&nbsp;», «&nbsp;19961224&nbsp;».
Le responsable de paquet décidera d'embêter ou non le responsable des
sources avec une demande de modification de la numérotation de ses versions. 
	</p>

<p>
Il faut noter que d'autres formats fondés sur les dates et qui sont 
correctement analysés par le système de gestion des paquets <em> ne doivent
pas</em> être modifiés.
	</p>

<p>
Les paquets «&nbsp;Debian pure souche&nbsp;» (c.-à-d. écrits spécialement pour debian) 
dont les numéros de version comprennent des dates utiliseront toujours le
format suivant : «&nbsp;AAAAMMJJ&nbsp;».
	</p>
      </sect>
    </chapt>

<chapt id="5"><heading>Considérations sur la construction de paquet</heading>
<sect id="timestamps"><heading>Timbres à date</heading>

<p>
Les responsables de paquets préserveront, autant que possible, 
les dates de modification des fichiers sources d'un paquet<footnote>
<p>
Le raisonnement est que la connaissance de l'âge d'un fichier apporte 
certaines informations ; par exemple, on peut reconnaître l'ancienneté de telle
documentation en regardant la date de modification. Et donc il serait bon de 
préserver les dates de modifications des fichiers sources.</p>
	  </footnote>.
</p>
      </sect>
<sect id="debianrules"><heading><tt>debian/rules</tt> - Le principal script
          de construction</heading>

<p>
Ce fichier doit être un <em>makefile</em> exécutable et doit contenir des 
règles permettant la compilation du paquet et la construction de paquet(s)
binaire(s) à partir des sources.
	</p>

<p>
Il doit commencer par la ligne <tt>#!/usr/bin/make -f</tt>,
afin de pouvoir être appelé directement sans passer par <prgn>make</prgn>.
	</p>

<p>
Puisqu'un script <tt>debian/rules</tt> interactif ne peut pas compiler un
paquet automatiquement et empêche une reproduction de ce paquet binaire par 
d'autres personnes, toutes les <em>cibles exigées</em> DOIVENT être
non-interactives. Au minimum, les cibles exigées sont celles qu'appelle
<prgn>dpkg-buildpackage</prgn>, à savoir, <em>clean</em>, <em>binary</em>,
<em>binary-arch</em>, <em>binary-indep</em>, et <em>build</em>. Il s'ensuit 
qu'une cible dont dépendent ces cibles, doit être aussi non interactive.
	</p>
<p>
Les cibles nécessaires et les cibles facultatives sont :

<taglist>
<tag><tt>build</tt>, <tt>build-arch</tt> (facultative), <tt>build-indep</tt>
(facultative)</tag>
<item>
<p>
La cible <tt>build</tt> procèdera à la configuration non interactive et à la
compilation du paquet. Quand un paquet
possède une routine interactive de configuration préalable à la construction, 
soit le paquet source débianisé doit être construit après cette opération 
(afin qu'il puisse être construit sans ré-exécuter cette configuration), soit
la routine de configuration doit devenir non interactive. (Cette dernière façon
est préférable quand la routine détecte des caractéristiques propres à
l'architecture.)
	      </p>

<p>
Pour certains paquets, notamment ceux où la même arborescence source est 
compilée différemment pour obtenir des paquets binaires différents, la cible 
<tt>build</> n'a aucun sens. Pour ces paquets, il suffit de prévoir deux 
cibles ou plus (<tt>build-a</tt>, <tt>build-b</tt>, ...) pour chaque manière 
de construire le paquet et une cible <tt>build</tt> qui ne produit rien. La 
cible <tt>binary</tt> s'occupera de construire le paquet pour chaque cas 
possible et de créer le paquet binaire correspondant à chacun d'eux.
	      </p>

<p>
La cible <tt>build</tt> ne doit pas effectuer d'actions qui exigent les 
privilèges de root.
	      </p>

<p>
La cible <tt>build</tt> peut avoir besoin d'exécuter d'abord la 
cible <tt>clean</tt>. Voir ci-dessous.
	      </p>

<p>
Quand un paquet possède une routine de configuration qui prend du temps, ou 
quand le <em>makefile</em> est pauvrement conçu, ou quand <tt>build</tt> 
a d'abord besoin d'exécuter <tt>clean</tt>, il est alors intéressant 
d'exécuter <tt>touch build</tt> quand le processus de construction est 
terminé. On s'assure ainsi que si <tt>debian/rules build</tt> est lancé à
nouveau, il ne reconstruira pas le programme complet
<footnote><p>
Une autre façon de faire est que <tt>build</tt> dépende de 
<prgn>build-stamp</prgn> sans rien faire d'autre, et que 
<prgn>build-stamp</prgn> fasse le travail et se termine par 
<tt>touch build-stamp</tt>. C'est particulièrement utile si la routine
crée un fichier ou un répertoire appelé <tt>build</tt> ; <tt>build</tt>
doit alors être déclaré comme une cible <tt>.PHONY</tt>. Consultez la
documentation de <prgn>make</prgn> pour des renseignements sur les cibles
«&nbsp;phony&nbsp;»</p>
		</footnote>.
	      </p>

	    </item>
<tag><tt>binary</tt>, <tt>binary-arch</tt>, <tt>binary-indep</tt></tag>
<item>
<p>
La cible <tt>binary</tt> doit être tout ce qui est nécessaire à 
l'utilisateur pour construire le(s) paquet(s) binaire(s). Toutes ces cibles 
doivent
être non-interactives. Cette cible a deux parties : <prgn>binary-arch</prgn>
construit les paquets binaires qui sont spécifiques à une 
architecture particulière, et <tt>binary-indep</tt> construit les 
paquets qui ne le sont pas.
	      </p>

<p>
<tt>binary</tt> peut être (et c'est communément le cas) une cible sans 
commande, qui dépend simplement de <tt>binary-arch</tt> et de 
<tt>binary-indep</tt>.
	      </p>

<p>
Les deux cibles <tt>binary-*</tt> dépendront soit de la cible 
<tt>build</tt>, soit de l'une des cibles <tt>build-arch</tt> ou 
<tt>build-indep</tt> si elles sont proposées, afin que le paquet soit
construit s'il ne l'a pas déjà été. Les paquets binaires pertinents seront 
ensuite créés en  utilisant <prgn>dpkg-gencontrol</prgn> pour créer leurs 
fichiers de contrôle et <prgn>dpkg-deb</prgn> pour construire les binaires et 
les placer dans le répertoire parent du répertoire le plus élevé.
	      </p>

<p>
Les cibles <tt>binary-arch</tt> et <tt>binary-indep</tt> 
<em>doivent</em> exister.
Si l'une des deux cibles <tt>binary-*</tt> n'a rien à faire (ce sera 
toujours le cas si le source crée un seul paquet binaire, qu'il soit 
dépendant de l'architecture ou pas), elle doit tout de même exister,
et doit toujours se dérouler correctement.
	      </p>

<p>
La cible <tt>binary</tt> doit être invoquée avec les privilèges de root
<footnote><p>
le paquet <prgn>fakeroot</prgn> permet souvent de construire correctement
un paquet tout en n'étant pas root.</p>
		</footnote>.
	      </p>
	    </item>
<tag><tt>clean</tt></tag>
            <item>

<p>
Cette cible doit nettoyer les effets obtenus par les cibles
<tt>build</tt> et <tt>binary</tt>, mais elle doit laisser les 
fichiers de sortie créés par la cible <tt>binary</tt> dans le répertoire 
parent. Cette cible ne doit pas être interactive.
	      </p>

<p>
Si un fichier <tt>build</tt> est créé par <prgn>touch</prgn> à la fin
de la cible <tt>build</tt>, comme suggéré ci-dessus, c'est la première 
chose qui sera effacée par la cible <tt>clean</tt> ; ainsi 
<tt>build</tt>, exécuté de nouveau après un nettoyage (<tt>clean</tt>)
interrompu, ne pensera pas que tout est déjà fait.
	      </p>

<p>
La cible <tt>clean</tt> peut avoir besoin d'être invoquée par root, si 
<tt>binary</tt> a été invoqué depuis le dernier <tt>clean</tt>, ou 
si <tt>build</tt> a été invoqué par root (étant donné que 
<tt>build</tt> peut créer des répertoires par exemple).
	      </p>
	    </item>
<tag><tt>get-orig-source</tt> (facultatif)</tag>
<item>
<p>
Cette cible va chercher la plus récente version du paquet original dans un 
site d'archive autorisé (par FTP ou WWW, par exemple), s'occupe des 
arrangements nécessaires pour le mettre sous la forme d'un fichier tar (une 
archive source) décrite ci-dessus, et le laisse dans le répertoire en cours.
	      </p>
<p>
Cette cible peut être invoquée dans n'importe quel répertoire et s'occupera
de supprimer tous ses fichiers temporaires. 
	      </p>
<p>
Elle est facultative mais la proposer, quand c'est possible, est une bonne 
idée.
	      </p>
	    </item>
	  </taglist>
<p>
Les cibles <tt>build</tt>, <tt>binary</tt> et <tt>clean</tt> 
doivent être invoquées avec comme répertoire actuel, le répertoire de plus
haut niveau du paquet.
	</p>
<p>
Des cibles supplémentaires peuvent exister dans <tt>debian/rules</tt>, soit
comme des interfaces publiées ou non documentées soit pour l'utilisation 
interne du paquet.
	</p>
<p>
Ce sont les variables de <prgn>make</prgn> à travers 
<prgn>dpkg-architecture</prgn> qui déterminent l'architecture <em>sur</em> 
laquelle et <em>pour</em> laquelle on construit. On peut obtenir, aussi bien
pour la machine sur laquelle on construit que pour la machine pour laquelle
on construit, la chaîne indiquant l'architecture Debian et la chaîne
indiquant l'architecture à la façon <em>GNU</em>. Voici une liste de
variables acceptées par <prgn>make</prgn> :
<list compact="compact">
            <item>
              <p><tt>DEB_*_ARCH</tt> (L'architecture Debian)</p>
</item>
            <item>
              <p><tt>DEB_*_GNU_TYPE</tt> (L'architecture indiquée à la
                façon <em>GNU</em>)</p>
            </item>
            <item>
              <p><tt>DEB_*_GNU_CPU</tt> (La partie CPU de 
<tt>DEB_*_GNU_TYPE)</tt></p>
            </item>
            <item>
<p><tt>DEB_*_GNU_SYSTEM</tt> (La partie système de <tt>DEB_*_GNU_TYPE)</tt></p>
          </list>
        </p>
<p>
où «&nbsp;*&nbsp;» représente <tt>BUILD</tt> pour une indication de la 
machine <em>sur</em>
laquelle on construit, ou bien <tt>HOST</tt> pour une indication de la machine
<em>pour</em> laquelle on construit.
	</p>
<p>
On peut assurer une compatibilité ascendante dans le fichier <em>rules</em>
en fixant par défaut les bonnes variables à des valeurs adéquates ;
veuillez consulter la documentation de <prgn>dpkg-architecture</prgn>
pour des précisions.
	</p>
<p>
Il est important de comprendre que la chaîne <tt>DEB_*_ARCH</tt> détermine
seulement l'architecture Debian sur ou pour laquelle on construit. On
ne l'utilisera pas pour avoir des renseignements sur le CPU ou le
Système ; les variables GNU sont là pour ça.
	</p>
      </sect>
    <sect id="dpkgchangelog"><heading><tt>debian/changelog</tt>
        </heading>

<p>
Ce fichier enregistre les modifications apportées aux éléments Debian
d'un paquet<footnote>Bien que rien n'empêche un auteur qui est aussi le 
responsable Debian d'utiliser ce fichier pour tous les changements, il faudra 
modifier son nom si les responsables Debian et les auteurs deviennent 
différents. Mais dans ce cas, il vaudrait mieux considérer le paquet comme
n'étant pas un paquet «&nbsp;pure souche&nbsp;» Debian.
</footnote>.
	</p>

<p>

Son format spécial permet aux outils de construction de paquets
de découvrir quelle version du paquet est en train de se construire
et de trouver des informations spécifiques à cette version.
	</p>

<p>

Le format ressemble à une suite d'entrées :

<example compact="compact">
<var>paquet</var> (<var>version</var>) <var>distribution(s)</var>; 
urgency=<var>urgency</var>
<comment>
<p>[ ligne(s) vide(s) facultative(s), enlevée(s)]</p>
	    </comment>
  * <var>détails des modifications</var>
    <var>plus de détails</var>
<comment>
<p>[ligne(s) vide(s), apparaissant dans la sortie de dpkg-parsechangelog]</p>
	    </comment>
  * <var>encore plus de détails</var>
<comment>
<p>[ligne(s) vide(s) facultative(s), enlevée(s)]</p>
	    </comment>
 -- <var>nom du responsable </var> &lt;<var>adresse électronique</var>&gt;
<var>[deux espaces]</var>  <var>date</var>
</example>
	</p>

<p>
Les entrées <var>paquet</var> et <var>version</var> représentent le nom du 
paquet source et le numéro de version.
	</p>

<p>
L'entrée <var>distribution(s)</var> liste les distributions dans lesquelles 
cette version sera installée. Elle est copiée dans le champ 
<tt>Distributions</> du fichier <tt>.changes</tt>.
Voyez <ref id="Distribution">.
	</p>

<p>
<var>urgency</var> est la valeur pour le champ <tt>Urgency</tt>
du fichier <tt>.changes</> pour le chargement.
Une <var>urgency</var> ne peut pas contenir de virgules ; les virgules sont 
utilisées pour séparer les couples 
<tt><var>mot-clé</var>=<var>valeur</var></tt> dans le format du fichier
d'enregistrement de <tt>dpkg</> (bien qu'il n'y ait pour
l'instant qu'un seul <var>mot-clé</var> utile : <tt>urgency</>)<footnote><p>
les valeurs habituelles pour <tt>urgency</> sont : <tt>low</tt>, 
<tt>medium</tt>, <tt>high</tt> et <tt>emergency</tt>. Elles influent sur la
rapidité avec laquelle on envisagera l'installation du paquet dans la 
distribution <tt>testing</tt> et elles donnent une indication de l'importance
des corrections contenues dans cette mise à jour.</p>
	  </footnote>.
	</p>

<p>
L'énoncé des modifications peut n'être qu'une suite de lignes 
commençant par au moins deux espaces, mais par convention, on commence
une modification par une étoile «&nbsp;*&nbsp;» suivie d'un espace ; les 
lignes de continuation sont indentées pour les amener en face du texte de la 
ligne précédente. On peut séparer si l'on veut les groupes de modifications
par des lignes vides.
	</p>

<p>
Si par cette mise à jour sont corrigés des bogues enregistrés par le système 
de suivi de bogues (BTS), ils seront automatiquement fermés par l'installation
de ce paquet dans l'archive Debian et une chaîne 
<tt>closes: Bug#<var>nnnnn</var></tt> sera insérée dans les notes de
modifications<footnote>
<p>
Pour être précis, cette chaîne doit correspondre à l'expression rationnelle
Perl suivante :
              <example>
/closes:\s*(?:bug)?\#?\s?\d+(?:,\s*(?:bug)?\#?\s?\d+)*/i
              </example>

<p>
Alors tous les numéros de bogues listés seront fermés par le script de
maintenance de l'archive (<prgn>katie</prgn>), ou, dans le cas d'une mise à
jour par un suppléant du responsable (Non-maintainer-upload), seront
marqués comme corrigés.</p>
	  </footnote>.
<p>
Le nom de responsable et son adresse électronique utilisés dans le 
<em>changelog</em> seront ceux de la personne installant <em>cette</em>
version. Ils <em>ne sont pas</em> nécessairement ceux du responsable habituel
du paquet. Ces informations seront copiées dans le champ <tt>Changed-By</tt>
du fichier <tt>.changes</tt>, et plus tard, utilisées pour envoyer un 
accusé de réception quand le chargement aura été installé.
<p>

La date doit être dans le format RFC 822
<footnote>produite par le programme <prgn/822-date/.</footnote>;
elle doit inclure le nom du fuseau horaire (timezone) spécifié
sous forme de chiffre, et en option le nom du fuseau ou son abréviation entre
parenthèses.

<p>
La première ligne de «&nbsp;titre&nbsp;» avec le nom du paquet commencera
sur la marge de gauche, la ligne de «&nbsp;fin&nbsp;» avec les renseignements sur
le responsable et la date, doit être précédée par exactement
un espace. Les éléments responsable et date doivent être
séparés exactement par deux espaces.
	</p>

<p>
<sect1><heading>Comment définir des formats alternatifs pour le fichier
<tt>changelog</>
<p>

Il est possible d'utiliser un format différent de celui proposé,
en fournissant un analyseur pour le format qu'on veut utiliser.
	  </p>
<p>
Un analyseur de changelog ne doit pas être interactif.
	  </p>
	</sect1>
      </sect>
<sect id="srcsubstvars"><heading><tt>debian/substvars</tt>
          et le remplacement de variables</heading>

<p>
Quand <prgn/dpkg-gencontrol/, <prgn/dpkg-genchanges/ et
<prgn/dpkg-source/ créent des fichiers de contrôle, ils procèdent au 
remplacement des variables qu'ils doivent écrire dans ces fichiers. Les
substitutions de variable sont de la forme 
<tt>${<var>variable-nom</var>}</tt>.
Le fichier facultatif <tt>debian/substvars</tt> contient les remplacements de 
variable à utiliser. On peut aussi fixer directement les variables dans le 
fichier <tt>debian/rules</> en utilisant l'option <tt>-V</> des commandes 
d'empaquetage des sources ; certaines variables prédéfinies sont disponibles.
	</p>

<p>
Le fichier <tt>debian/substvars</tt> est habituellement créé et modifié 
dynamiquement par les cibles de <tt>debian/rules</tt>, et dans ce cas, il 
doit être supprimé par la cible <tt>clean</tt>.
	</p>

<p>
Voyez <manref name="dpkg-source" section="1"> pour plus de détails sur les
remplacements de variables source, et sur le format de
<tt>debian/substvars</tt>.
	</p>
      </sect>

<sect id="debianfiles"><heading><tt>debian/files</tt></heading>

<p>
Ce fichier n'est pas un fichier permanent de l'arborescence source ; il est
utilisé pendant la construction des paquets pour enregistrer quels
fichiers sont en train d'être créés. <prgn>dpkg-genchanges</prgn>
l'utilise quand il crée un fichier <tt>.changes</tt>.
	</p>
<p>
Ce fichier ne doit pas exister dans le paquet source qu'on propose, et il 
doit être supprimé par la règle <tt>clean</> (ainsi que n'importe quel fichier 
temporaire ou de sauvegarde tel que <tt>files.new</tt>
<footnote><tt>files.new</> est utilisé
temporairement par <prgn>dpkg-gencontrol</prgn> et
<prgn>dpkg-distaddfile</prgn> ; ils écrivent une nouvelle version
de <tt>files</> avant de le renommer, pour éviter de laisser
une copie corrompue, si une erreur se produit.</footnote>).
Il peut aussi être sage, pour garantir un nouveau départ, de l'enlever ou
de le vider au début de la cible <tt>binary</tt>.
	</p>

<p>
Quand <prgn>dpkg-gencontrol</prgn> est exécuté pour un paquet binaire, il
ajoute une entrée dans le fichier <tt>debian/files</tt> pour le fichier 
<tt>.deb</tt> qui sera créé quand <tt>dpkg-deb --build</tt> sera
exécuté pour ce paquet binaire. Ainsi pour la plupart des paquets, il n'y a 
rien d'autre à faire que de supprimer ce fichier dans la cible 
<tt>clean</tt>.
	</p>

<p>
Quand une installation de paquet inclut des fichiers autres que ceux du paquet
source ou des paquets binaires dont les fichiers de contrôle ont été créés par
<prgn>dpkg-gencontrol</prgn>, ces fichiers seront placés dans le
répertoire parent du répertoire racine du paquet et 
<prgn>dpkg-distaddfile</prgn> sera appelé pour ajouter ces fichiers à la liste
<tt>debian/files</tt>.
	</p>
      </sect>

<sect id="restrictions"><heading>Restrictions sur les objets dans les paquets source</heading>

<p>
Un paquet source ne peut pas contenir des liens «&nbsp;en dur&nbsp;»<footnote>
<p>On ne les détecte pas encore pendant la phase de construction du paquet
source, mais seulement pendant la phase d'extraction.</p>
	  </footnote><footnote>
<p>
À l'avenir, les liens «&nbsp;en dur&nbsp;» pourraient être autorisés d'une manière ou
d'une autre, mais cela demandera beaucoup de travail.
	    </p>
	  </footnote>,
des fichiers spéciaux pour les <em>device</em>, des <em>sockets</em> ou des fichiers
<em>setuid</em> ou <em>setgid</em><footnote>
<p>
Les répertoires <em>setgid</em> sont autorisés.
	    </p>
	  </footnote>.
	</p>
      </sect>
<sect id="descriptions"><heading>La description des paquets - le champ
          <tt>Description</tt></heading>
<p>
La description d'un programme est faite pour permettre à l'utilisateur qui
n'a jamais entendu parler de ce programme auparavant de savoir s'il veut
l'installer. Elle donnera des informations sur les conflits et
dépendances significatives entre ce paquet et les autres, afin que
l'utilisateur sache pourquoi ces conflits et dépendances ont été
déclarés.
	</p>

<sect1><heading>Remarques sur la rédaction des descriptions</heading>

<p>
La ligne de résumé sera brève -- moins de 80 caractères.
	  </p>

<p>
Ne mettez pas le nom du paquet dans la ligne de résumé. Le logiciel
sait déjà l'afficher, et ce n'est pas nécessaire de l'indiquer. N'oubliez pas
que dans beaucoup de cas, l'utilisateur ne peut lire que la ligne de résumé : 
il faut donc la rendre aussi instructive que possible.
	  </p>

<p>
N'essayez pas de poursuivre la ligne du résumé dans la description étendue. 
Cela ne fonctionnera pas correctement quand la description complète est 
affichée et cela n'aura aucun sens quand  seul le résumé (la ligne de
résumé) est disponible.
	  </p>
<p>
La description étendue décrira ce que fait le paquet, et comment il
se relie au reste du système (en termes, par exemple, de sous-systèmes,
de partie de ...).
	  </p>
<p>
Le champ description doit être compréhensible pour tout le monde, y compris
ceux qui n'ont aucune idée sur ce que fait le paquet<footnote>
<p>
Le commentaire, qui est fourni par un programme dans ses fichiers
d'annonces et/ou fichiers <tt>README</tt>, est rarement approprié pour une
utilisation dans une description. Il est habituellement conçu pour les
gens qui connaissent déjà le paquet...
	      </p>
	    </footnote>.
	  </p>

<p>
Mettez les informations importantes d'abord, à la fois dans le résumé et 
dans la description étendue. Quelques fois, seule la première partie du
résumé ou de la description sera affichée. En principe on peut supposer qu'il 
y a une manière de voir l'ensemble de la description étendue.
	  </p>

<p>
Quand on le souhaite, on peut inclure des informations sur les dépendances 
ou sur d'autres choses dans la description étendue.
	  </p>

<p>
N'utilisez pas le caractère de tabulation, son effet est imprévisible.
	  </p>
	</sect1>
      </sect>
    </chapt>

<chapt id="6"><heading>Les scripts du responsable de paquet
        et la procédure d'installation</heading>
<sect><heading>Introduction aux scripts du responsable de paquet</heading>

<p>
Il est possible de fournir des scripts qui seront exécutés
par le système de gestion de paquet lors d'une installation, d'une mise à 
jour ou d'une suppression du paquet.
	</p>

<p>
Ces scripts sont les fichiers <prgn>preinst</prgn>, <prgn>postinst</prgn>, 
<prgn>prerm</prgn> et <prgn>postrm</prgn> contenus dans le répertoire de 
contrôle du paquet. Ils doivent être des fichiers exécutables corrects ; 
quand ce sont des scripts (ce qui est recommandé), ils doivent commencer par 
la convention habituelle : <tt>#!</tt>. Ils seront lisibles et exécutables 
par tout le monde mais ils ne pourront pas être modifiés.
	</p> 

<p>
Le système de gestion de paquet teste le code de sortie de ces scripts. Il 
est important que ce code soit différent de zéro quand il y a une erreur ;
le système de gestion de paquet peut alors s'interrompre. Pour les
scripts shell, cela signifie qu'on doit <em>presque toujours</em>
utiliser <tt>set -e</tt> (et c'est généralement vrai pour tout script shell).
Bien sûr, il est aussi important que ce code ne soit pas différent de zéro 
quand tout s'est bien passé.
	</p>

<p>

Il est nécessaire pour les procédures de gestion des erreurs que les
scripts soient idempotents ;  c.-à-d., le même script doit pouvoir être
appelé plusieurs fois dans la même situation sans provoquer de
problèmes. Si le premier appel échoue, ou s'arrête au milieu du chemin
pour une raison ou une autre, le second appel fera, s'il y en a, les choses
qui n'ont pas été faites la première fois et se terminera normalement.
	</p>

<p>
Quand un paquet est mis à jour, une combinaison des scripts du vieux et
du nouveau paquet est appelée durant la procédure de mise à jour. Il faut 
faire attention quand les scripts se compliquent et il faut vérifier leurs 
arguments.
	</p>

<p>
D'une manière générale, le script <prgn>preinst</prgn> est appelé avant 
d'installer (une version particulière d') un paquet, et le script 
<prgn>postinst</prgn> après ; le script <prgn>prerm</prgn> avant d'effacer 
(une version d') un paquet et <prgn>postrm</prgn> après.
	</p>

<p>
Normalement on ne doit pas préfixer le chemin des programmes appelés par les 
scripts. Avant le début de l'installation, le système de
gestion de paquet vérifie que les programmes <prgn>ldconfig</prgn>, 
<prgn>start-stop-daemon</prgn>, <prgn>install-info</prgn> et 
<prgn>update-rc.d</prgn> peuvent être trouvés via la
variable d'environnement <tt>PATH</tt>. Ces programmes, et n'importe quel
autre programme qu'on s'attend à trouver dans le <tt>PATH</>, seront
donc appelés sans nom de chemin absolu.
Les scripts du responsable ne doivent pas non plus réinitialiser la variable
<tt>PATH</tt>, bien qu'ils puissent choisir de la modifier en ajoutant
au début ou à la fin un répertoire spécifique à un paquet.
Ces considérations s'appliquent vraiment à tous les scripts shell.
	</p>
      </sect>

<sect>
        <heading>L'idempotence des scripts du responsable</heading>
<p>
Il est nécessaire pour les procédures de gestion des erreurs que les
scripts soient idempotents. Cela signifie qu'un script, appelé à nouveau
après une exécution réussie, n'explose pas et ne fait pas de dégâts ; il
s'assure simplement que chaque chose est à sa place. Si le premier appel 
échoue, ou s'arrête au milieu du chemin pour une raison ou une autre, le 
second appel fera, s'il y en a, les choses qui n'ont pas été faites la 
première fois et se terminera normalement si tout est correct <footnote><p>
Qu'une erreur arrive -- l'utilisateur interrompt <prgn>dpkg</prgn> ou bien 
quelque chose d'imprévu se passe -- il ne faut pas laisser un paquet 
défectueux à l'utilisateur quand <prgn>dpkg</prgn> essaye de refaire l'action.
	    </p>
	  </footnote>.
	</p>
      </sect>
<sect>
        <heading>Les terminaux de contrôle et les scripts du responsable</heading>

<p>
Les scripts du responsable sont assurés de s'exécuter avec un terminal de 
contrôle et de pouvoir interagir avec l'utilisateur. Quand ils ont besoin de
demander un mot de passe, d'intervenir en plein écran... c'est à partir de et
vers <tt>/dev/tty</tt> qu'ils le feront, puisque <prgn>dpkg</prgn> redirige
à un moment ou un autre les sorties et entrées standards des scripts de 
manière à enregistrer le processus d'installation. De même les scripts Perl, 
ces scripts pouvant rediriger leur sortie standard dans un tube à des fins 
d'enregistrement, utiliseront un mode de sortie sans buffer
en déclarant <tt>$|=1</tt> de manière à ce que la sortie soit affichée
immédiatement plutôt que d'être mise dans un buffer.
	</p>
<p>
Chaque script retournera un code de sortie égal à zéro en cas de succès et
un code différent de zéro en cas d'échec.
	</p>
      </sect>

<sect id="mscriptsinstact"><heading>Résumé des façons d'appeler les scripts du 
responsable</heading>
<p>

<list compact="compact">
<item> 
<p><var>preinst-du-nouveau-paquet</var> <tt>install</tt></p>
	    </item>
<item> 
<p><var>preinst-du-nouveau-paquet</var> <tt>install</tt> <var>vieille-version</var>
	      </p>
	    </item>
<item> 
<var>preinst-du-nouveau-paquet</var> <tt>upgrade</tt> <var>vieille-version</var></p>
	    </item>
<item> <var>preinst-de-l'ancien-paquet</var> <tt>abort-upgrade</tt> 
<var>nouvelle-version</var></p>
	    </item>
</list>

<list compact="compact">
<item> 
<p><var>postinst</var> <tt>configure</tt> <var>version-la-plus-récemment-configurée</var></p>
	    </item>
<item> <var>postinst-de-l'ancien-paquet</var> <tt>abort-upgrade</tt> 
<var>nouvelle-version</var></p>
	    </item>
<item> <var>postinst-du-paquet-conflictuel</var> <tt>abort-remove in-favour</tt>
<var>paquet nouvelle-version</var></p>
	    </item>
<item> <var>postinst-du-paquet-déconfiguré</var> <tt>abort-deconfigure in-favour</tt>
<var>paquet-dont-installation-a-échoué version</var> <tt>removing</tt> 
<var>paquet-conflictuel</var> <var>version</var></p>
	    </item>
	  </list>
<p>
<list compact="compact">
<item>
<p> <var>prerm</var> <tt>remove</tt></p>
	    </item>
<item>
<p> <var>prerm-de-l'ancien-paquet</var> <tt>upgrade</tt> <var>nouvelle-version</var></p>
	    </item>
<item>
<var>prerm-du-nouveau-paquet</var> <tt>failed-upgrade</tt> <var>nouvelle-version</var>
</p>
	    </item>
<item> 
<p><var>prerm-du-paquet-conflictuel</var> <tt>remove</tt><tt>in-favour</tt> 
<var>paquet</var> <var>nouvelle-version</var></p>
	    </item>
<item>
<p><var>postrm-du-paquet-déconfiguré</> <tt>deconfigure in-favour</tt>
<var>paquet-installé version</var> <tt>removing</tt> 
<var>paquet-conflictuel version</var></p>
	    </item>
</list>

<list compact="compact">
<item>
<p><var>postrm</var> <tt>remove</tt></p>
	    </item>
<item>
<p><var>postrm</var> <tt>purge</tt></p>
	    </item>

<item>
<p><var>postrm-de-l'ancien-paquet</var> <tt>upgrade</tt> <var>nouvelle-version</var></p>
	    </item>
<item>
<p><var>postrm-du-nouveau-paquet</var> <tt>failed-upgrade</tt> <var>vieille-version</var>
	      </p>
	    </item>
<item>
<p> <var>postrm-du-nouveau-paquet</var> <tt>abort-install</tt></p>
	    </item>
<item>
<p><var>postrm-du-nouveau-paquet</var> <tt>abort-install</tt> <var>vieille-version</var>
	      </p>
	    </item>
<item>
<p><var>postrm-du-nouveau-paquet</var> <tt>abort-upgrade</tt> <var>vieille-version</var>
	      </p>
	    </item>
<item>
<p><var>postrm-du-paquet-disparu</var> <tt>disappear</tt> <var>remplaçant</var> 
<var>version-du-remplaçant</var></p>
	    </item>
</list>
	</p>

<sect id="unpackphase">Précisions sur la phase de dépaquetage lors d'une
installation ou d'une mise à jour
<p>

La procédure d'installation ou de mise à jour -- remplacement, 
effacement --  (c'est à dire quand on exécute <tt>dpkg --unpack</tt>, ou bien 
l'étape <em>unpack</em> de <tt>dpkg --install</tt>) est la suivante. Dans 
chaque cas, si une erreur majeure se produit (à moins d'être listée 
ci-dessous), les actions sont généralement «&nbsp;rembobinées&nbsp;» -- ce 
qui signifie que les scripts du responsable sont 
exécutés dans l'ordre inverse avec des arguments différents. Ce sont les 
appels «&nbsp;correction d'erreur&nbsp;» listés ci-dessous.

<enumlist>
<item>
<p>
     <enumlist>
     <item>
<p>
Si une version du paquet est déjà installée, appel
	   <example compact="compact">
<var>prerm-de-l'ancien-paquet</var> upgrade <var>nouvelle-version</var>
	   </example>

     <item>Quand le script se termine avec un code de sortie
différent de zéro, <prgn>dpkg</prgn> essaye :
	   <example compact="compact">
<var>prerm-du-nouveau-paquet</var> failed-upgrade <var>vieille-version</var>
	   </example>
	  Correction d'erreur, dans les deux cas ci-dessus :
	   <example compact="compact">
<var>postinst-de l'ancien-paquet</var> abort-upgrade <var>nouvelle-version</var>
	   </example>
</p>
		  </item>
     </enumlist>
</p>
	    </item>

<item>
<p>
Si un paquet conflictuel est enlevé en même temps :
     <enumlist>
   
     <item>
<p>
Quand un paquet dépend de ce paquet conflictuel et si l'option
 <tt>--auto-deconfigure</> est spécifiée, appel pour chaque paquet :
	<example compact="compact">
<var>prerm-du-paquet-déconfiguré</var> deconfigure in-favour
<var>paquet-à-installer</var> <var>version</var>
removing <var>paquet-conflictuel</var> <var>version</var>
        </example>

	Correction d'erreurs :
	<example compact="compact">
<var>postinst-du- paquet-déconfiguré</var> abort-deconfigure in-favour
<var>paquet-dont-l'installation-a-échouée</var> <var>version</var>
removing <var>paquet-conflictuel</var> <var>version</var>
        </example>
	Les paquets déconfigurés sont indiqués comme nécessitant une
configuration, afin que si l'option <tt>--install</> est utilisée, ils 
soient, si possible, de nouveau configurés.
		    </p>

		  </item>
<item>
<p>
Pour préparer l'effacement du paquet conflictuel, appel :
	<example compact="compact">
<var>prerm-du-paquet-conflictuel</var> remove in-favour
 <var>paquet</var> <var>nouvelle-version</var>
        </example>
	Correction d'erreurs :
	<example compact="compact">
<var>postinst-du-paquet-conflictuel</var> abort-remove in-favour
 <var>paquet</var> <var>nouvelle-version</var>
        </example>
		    </p>
		  </item>
		</enumlist>
	      </p>
	    </item>

<item>
     <p>
<enumlist>
     <item>
<p>
Si le paquet est mis à jour, appel :
	<example compact="compact">
<var>preinst-du-nouveau-paquet</var> upgrade <var>vieille-version</var>
        </example>
		    </p>
		  </item>
<item>
Autrement si le paquet a des fichiers de configuration d'une
          version précédemment installée (c'est à dire, il ne reste
	  plus du paquet que les fichiers de configuration) :
	<example compact="compact">
<var>preinst-du-nouveau-paquet</var> install <var>vieille-version</var>
	</example>
		    </p>
     <item>
<p>
Autrement (c'est à dire, le paquet a été complètement
effacé) :
	<example compact="compact">
<var>preinst-du-nouveau-paquet</var> install
	</example>

	Les corrections d'erreurs, respectivement :
	<example compact="compact">
<var>postrm-du-nouveau-paquet</var> abort-upgrade <var>vieille-version</var>
<var>postrm-du-nouveau-paquet</var> abort-install <var>vieille-version</var>
<var>postrm-du-nouveau-paquet</var> abort-install
	</example>
		    </p>
		  </item>
		</enumlist>
	      </p>
	    </item>
<item>
Les fichiers du nouveau paquet sont dépaquetés, remplacant ceux qui
peuvent déjà être sur le système, par exemple, les fichiers appartenant à la
vieille version du même paquet ou ceux d'un autre paquet. Les sauvegardes des
vieux fichiers sont laissées, et si quelque chose se passe mal, le système de 
gestion des paquets, dans sa partie «&nbsp;correction d'erreurs&nbsp;» 
essayera de les remettre en place.
	      </p>
<p>
C'est une erreur pour un paquet de contenir des fichiers qui sont sur le
système dans un autre paquet, à moins que <tt>Replaces</> soit utilisé
(voir <ref id="replaces">). </p>
<!-- Pour l'instant l'option <tt>force-overwrite</tt> -->
<!--est disponible, la dégradant en un avertissement, mais cela ne sera 
peut-être pas toujours le cas.-->
<p>
C'est une erreur plus grave pour un paquet de contenir un simple
fichier ou autre chose qu'un répertoire quand un autre paquet veut un
répertoire (à moins que <tt>Replaces</tt> ne soit utilisé).
Cette erreur peut être évitée si c'est l'effet recherché, en utilisant
<tt>--force-overwrite-dir</>, mais ce n'est pas à conseiller.
	      </p>
<p>
Les paquets qui remplacent mutuellement leurs fichiers ont une démarche qui,
bien que déterministe, est difficile à comprendre pour
un administrateur système. Cela peut aisément conduire à des programmes 
annoncés comme «&nbsp;absent&nbsp;» quand, par exemple, un paquet remplacant 
tel fichier d'un autre paquet est installé puis effacé<footnote>Une 
partie du problème vient certainement d'une erreur de <tt>dpkg</>.</footnote>.
	      </p>
<p>
Un répertoire ne sera jamais remplacé par un lien symbolique vers un
répertoire et vice versa ; à la place, l'état existant (lien symbolique
ou non) est conservé et <tt>dpkg</tt> suivra les liens s'il y en a.
	      </p>
	    </item>

<item>
<p>   <enumlist>
   <item>
Si le paquet est mis à jour, appel :
	<example compact="compact">
<var>postrm-de l'ancien-paquet</var> upgrade <var>nouvelle-version</var>
	</example></p>
		  </item>

   <item>
<p>Si cela échoue, <prgn>dpkg</prgn> essaye :
	<example compact="compact">
<var>postrm-du-nouveau-paquet</var> failed-upgrade <var>vieille-version</var>
	</example>
	Les corrections d'erreur, dans les deux cas :
	<example compact="compact">
<var>preinst-de-l'ancien-paquet</var> abort-upgrade <var>nouvelle-version</var>
	</example>
		    </p>
		  </item>
		</enumlist>
<p>
	C'est le point de non-retour - Quand <prgn>dpkg</prgn> atteint ce 
point, il ne revient pas en arrière si une erreur se produit. Le paquet
reste dans un très mauvais état et demande une réinstallation réussie 
pour remettre tout en place ; cela arrive quand <prgn>dpkg</prgn> 
commence à faire des choses irréversibles.
	      </p>
	    </item>
	
<item>
Tous les fichiers de la version précédente du paquet qui ne sont pas dans la
nouvelle sont effacés.
	      </p>
	    </item>
<item>
La nouvelle liste de fichiers remplace la précédente.
	      </p>
	    </item>

<item>
Les nouveaux scripts du responsable remplacent les anciens.
	      </p>
	    </item>

<item>
Les paquets dont tous les fichiers ont été remplacés pendant
l'installation, et qui ne sont pas nécessaires pour les dépendances,
sont considérés comme effacés. Pour ces paquets :
	<enumlist>
	<item>
<p>
<prgn>dpkg</prgn> appelle:
	      <example compact="compact">
<var>postrm-du-paquet-effacé</var> disappear 
<var>remplaçant</var> <var>version-du-remplaçant</var>
	      </example>
		    </p>
		  </item>

	<item>
<p>Les scripts du responsable de paquet sont effacés.
		    </p>
		  </item>

	<item>
Le paquet est inscrit dans la base de données des statuts
comme étant dans un état correct, à savoir non installé (ses 
<em>conffiles</em> sont ignorés et non pas supprimés par <prgn>dpkg</prgn>).
Il faut remarquer que <prgn>dpkg</prgn> n'appelle pas le script prerm du paquet
effacé, car il ne sait pas à l'avance que le paquet va disparaître.
		    </p>
		  </item>
	</enumlist>
	      </p>
	    </item>
<item>
<p>
Les fichiers du paquet à installer qui sont aussi répertoriés par d'autres 
paquets sont enlevés des listes de ces paquets (ce qui
lobotomisera la liste de fichiers du paquet «&nbsp;conflictuel&nbsp;», s'il y en a
un).
	      </p>
	    </item>

<item>
<p>
Les fichiers de sauvegarde faits pendant la phase précédente d'installation
sont effacés.
	      </p>
	    </item>

<item>
Le statut du nouveau paquet est correct et enregistré comme
«&nbsp;dépaqueté&nbsp;».</p> 
<p>
C'est un autre point de non-retour - si l'effacement d'un
paquet conflictuel échoue, on ne «&nbsp;rembobine&nbsp;» pas le reste de
l'installation ; le paquet conflictuel est laissé dans un état 
«&nbsp;enlevé à moitié&nbsp;».
	      </p>
	    </item>

<item>
Au cas où existe un paquet conflictuel, on procède aux actions
d'effacement (décrites ci-dessus), en commençant par l'effacement des
fichiers du paquet conflictuel (les fichiers qui sont aussi dans le
paquet installé ont déjà été effacés de la liste des fichiers du paquet
conflictuel et ne sont pas enlevés maintenant).
	      </p>
	    </item>
          </enumlist>
	</p>
      </sect>
<sect id="configdetails"><heading>Précisions sur la configuration</heading>

<p>
Quand on configure un paquet (avec <tt>dpkg --install</tt>, ou avec 
<tt>--configure</tt>), on met à jour d'abord les <tt>conffiles</tt> et
ensuite on appelle :
<example compact="compact">
<var>postinst</var> configure <var>version-la-plus-récemment-configurée</var>
</example>
	</p>
<p>
On n'essaye pas de «&nbsp;rembobiner&nbsp;» après une erreur pendant la
configuration.
	</p>
<p>
S'il n'existe pas de «&nbsp;version-la-plus-récemment-configurée&nbsp;», <tt>dpkg</tt> 
passe un argument nul ; les vieilles versions de <tt>dpkg</tt> peuvent passer
dans ce cas <tt>&lt;unknow&gt;</tt> (avec les signes supérieur et inférieur). 
Et les plus vieilles versions ne passent pas de second argument du tout, 
quelques soient les circonstances.
	</p>
      </sect>

<sect id="removedetails"><heading>Précisions sur la phase de suppression sans 
et/ou avec suppression des fichiers de configuration</heading>

<p>
<enumlist>

<item>
<p>
<example compact="compact">
<var>prerm</var> remove
		</example>
	      </p>
	    </item>
<item> 
Les fichiers du paquet sont effacés (sauf les <tt>conffiles</tt>).
	      </p>
	    </item>

<item>
<p>
<example compact="compact">
<var>postrm</var> remove
		</example>
	      </p>
	    </item>

<item> 
<p>Tous les scripts du responsable sont effacés sauf <prgn>postrm</prgn>.
	      </p>
<p>
Si on n'efface pas le paquet, la procédure s'arrête là. Il faut remarquer que
les paquets qui n'ont pas de <prgn>postrm</prgn> ni de <tt>conffiles</tt> sont 
automatiquement purgés pendant l'effacement, comme il n'y pas de différence, 
sauf pour le statut de <prgn>dpkg</prgn>.
	      </p>
	    </item>


<item>
Les <tt>conffiles</tt> et les fichiers de sauvegarde (<tt>~</tt>-fichier,
<tt>#*#</tt>fichiers, <tt>%</tt>-fichiers, <tt>.dpkg-{old, new, tmp}</tt>, 
etc.) sont effacés.
	      </p>
	    </item>

<item>
<example compact="compact">
<var>postrm</var> purge
		</example>
	      </p>
	    </item>

<item>
La liste des fichiers du paquet est effacée.
	      </p>
	    </item>
</enumlist>

Aucune tentative n'est faite pour «&nbsp;rembobiner&nbsp;» après une erreur durant la
phase de suppression.</p>
      </sect>
    </chapt>

<chapt id="7"><heading>Comment déclarer des relations entre les paquets ?</heading>

<p>
Les paquets peuvent déclarer dans leur fichier <em>control</em> qu'ils ont
certaines relations avec d'autres paquets - par exemple, qu'ils ne
peuvent pas être installés en même temps que tel paquet,
et/ou qu'ils dépendent de la présence de tel autre, ou bien qu'ils doivent
remplacer les fichiers de certains s'ils sont présents.
      </p>
<p>
On se sert pour cela des champs du fichier <em>control</em> :
<tt>Depends</tt>, <tt>Pre-Depends</tt>,<tt>Recommends</tt>, <tt>Sugggests</tt>
, <tt>Enhances</tt>, <tt>Conflicts</tt>, <tt>Provides</tt> et 
<tt>Replaces</tt>.
      </p>
    
<p>
Les paquets sources peuvent déclarer des relations avec des paquets
binaires : par exemple, ils ont besoin que tel paquet soit présent ou
absent au moment de leur construction.
      </p>
<p>
On se sert pour cela des champs du fichier <em>control</em> :
<tt>Build-Depends</tt>, <tt>Build-Depends-Indep</tt>, 
<tt>Build-Conflicts</tt> et <tt>Build-Conflicts-Indep</tt>.
      </p>

<sect id="depsyntax">La syntaxe des champs de relation</heading>

<p>
Ces champs ont tous la même syntaxe. Ce sont des listes de
noms de paquets séparés par des virgules.
	</p>

<p>
Dans les champs <tt>Depends</tt>, <tt>Recommends</tt>, <tt>Suggests</tt>, 
<tt>Pre-Depends</tt>, <tt>Build-Depends</tt> et <tt>Build-Depends-Indep</tt> 
(les champs qui déclarent les dépendances d'un paquet envers d'autres 
paquets), ces noms peuvent aussi être des listes de noms de paquets 
alternatifs, séparés par des symboles barre verticale «&nbsp;|&nbsp;» 
(symbole du tube de communication). Si c'est le cas, quand l'un des paquets
alternatifs est installé, on considère que cette partie de la dépendance
est satisfaite.
	</p>

<p>
Tous les champs sauf le champ <tt>Provides</tt> peuvent restreindre leur
application à des versions particulières de chaque paquet nommé. Ces versions
sont indiquées entre parenthèses après chaque nom de paquet ; les
parenthèses contiendront une des relations de la liste ci-dessous,
suivie par un numéro de version, dans le format décrit dans
<ref id="4">.
	</p>

<p>
Les relations autorisées sont : <tt>&lt;&lt;</tt>, <tt>&lt;=</tt>,
<tt>=</tt>, <tt>&gt;=</tt> et <tt>&gt;&gt;</tt>pour
strictement avant, avant ou égal, égal, après ou égal, strictement
après, respectivement. Les formes déconseillées <tt>&lt;</tt> et 
<tt>&gt;</tt> ont été utilisées pour signifier avant/après ou égal, plutôt 
que strictement avant/après, ainsi elles ne doivent pas apparaître dans les 
nouveaux paquets (bien que <prgn>dpkg</prgn> les accepte encore).
	</p>

<p>
Les espaces peuvent apparaître n'importe où dans la spécification de
version sujette aux règles énoncées dans <ref id="controlsyntax">, et doivent 
apparaître là où c'est nécessaire pour supprimer toute ambiguïté ; autrement 
ils ne sont pas significatifs. Pour la cohérence et dans le cas de futures 
modifications de <prgn>dpkg</prgn>, il est recommandé de mettre un seul 
espace après une relation de version et avant un numéro de version ; il est 
aussi convenu de mettre un espace après chaque virgule, de chaque côté d'une 
barre verticale, et avant chaque parenthèse ouvrante.
	</p>

<p>
Par exemple, une liste de dépendances peut apparaître ainsi :
<example compact="compact">
Package: mutt
Version: 1.3.17-1
Depends: libc6 (>= 2.2.1), exim | mail-transport-agent
</example>
	</p>

<p>
On peut limiter à un ensemble d'architectures tous les champs qui précisent 
des relations pour la compilation 
(<tt>Build-Depends</tt>, <tt>Build-Depends-Indep</tt>, <tt>Build-Conflicts</tt>
et<tt>Build-Conflicts-Indep</tt>). On se sert de crochets après chaque nom
de paquet et l'indication facultative de la version. Les crochets enferment
une liste d'architectures acceptées par Debian, séparées par un espace. Un
point d'exclamation peut être ajouté à chaque nom. (On ne peut pas ajouter un
point d'exclamation à certains noms et pas à d'autres.) Quand l'architecture de
la machine hôte n'est pas présente dans la liste et qu'il n'y a pas de
point d'exclamation, ou bien quand elle est dans la liste et préfixée par un 
point d'exclamation, le paquet et l'indication de la version associée sont
complètement ignorés pour ce qui concerne la définition du système de
relation.
	</p>
<p>
Par exemple :
<example compact="compact">
Source: glibc
Build-Depends-Indep: texinfo
Build-Depends: kernel-headers-2.2.10 [!hurd-i386],
hurd-dev [hurd-i386], gnumach-dev [hurd-i386]
          </example>
        </p>
<p>
Il faut remarquer que les champs concernant les relations entre paquets
binaires tel que <tt>Depends</tt> apparaissent dans l'une des sections du
fichier de contrôle du paquet binaire, alors que les champs concernant
les relations pour la construction tel que <tt>Build-Depends</tt> apparaissent
dans la première section du fichier de contrôle du paquet source.
	</p>
      </sect>

<sect>
        <heading>Les dépendances pour les paquets binaires - <tt>Depends</tt>,
          <tt>Recommends</tt>, <tt>Suggests</tt>, <tt>Enhances</tt>,
 <tt>Pre-Depends</tt>
        </heading>

<p>
Ces cinq champs sont utilisés pour déclarer une relation de dépendance d'un
paquet envers un autre paquet. Ils apparaissent dans le fichier 
<em>control</em> du paquet dépendant (binaire), sauf le champ 
<tt>Enhances</tt> qui apparaît dans le fichier de contrôle du paquet 
recommandé.
	</p>

<p>
Un champ <tt>Depends</tt> prend effet <em>seulement</em> lors de la 
configuration du paquet. Il n'empêche pas qu'un paquet soit sur le système 
dans un état «&nbsp;non configuré&nbsp;» et ses dépendances non 
satisfaites&nbsp;; 
il est aussi possible de remplacer un paquet correctement installé et dont 
les dépendances sont satisfaites par une version différente dont les 
dépendances ne sont pas et ne peuvent pas être satisfaites ; quand c'est le 
cas, le paquet dépendant est laissé «&nbsp;non configuré&nbsp;» (étant donnée 
que les tentatives pour le configurer donnent des erreurs) et il ne 
fonctionne pas correctement. On peut utiliser si nécessaire un champ
<tt>Pre-Depends</tt> qui a un effet limité même si le paquet est dans la 
phase de dépaquetage, comme c'est expliqué plus bas. (Les trois autres
champs, <tt>Recommends</tt>, <tt>Suggests</tt> et <tt>Enhances</tt>, ne
sont utilisés que par les différentes interfaces de <prgn>dpkg</prgn>,
telle que <prgn>dselect</prgn>.) 
	</p>

<p>
Pour cette raison, lors d'une installation, les paquets sont généralement
tous installés d'abord et tous configurés ensuite ; cela permet que les
dernières versions des paquets ayant des dépendances sur les dernières
versions d'autres paquets voient leurs dépendances satisfaites.
	</p>

<p>
Ainsi le champ <tt>Depends</tt> autorise les responsables de paquet à imposer 
un ordre sur la manière de configurer les paquets.
	</p>


<p>
Voici la signification des cinq champs de dépendance :
<taglist>
<tag><tt>Depends</tt></tag>
<item>
<p>
Ce champ déclare une dépendance absolue. Il n'est pas possible de configurer
un paquet tant que tous les paquets listés dans ce champ n'ont pas été
correctement configurés.
	    </p>
<p>
Le champ <tt>Depends</> sera utilisé quand le paquet dépendant a besoin,
pour fonctionner d'une manière intéressante, de tel paquet.
	    </p>
<p>
Le champ <tt>Depends</tt> sera aussi utilisé quand les scripts
<prgn>postinst</prgn>, <prgn>prerm</prgn> ou <prgn>postrm</prgn> demandent
que tel paquet soit présent pour qu'ils puissent fonctionner. Cependant,
il faut noter que le script <prgn>postrm</prgn> ne peut pas compter sur
la présence de paquets « non-essential » pendant la phase de <tt>purge</tt>.
</item>

<tag><tt>Recommends</tt></tag>
<item>
ce champ déclare une dépendance forte, mais pas absolue.
<p>
Le champ <tt>Recommends</tt> listera les paquets qu'on trouve habituellement 
avec ce paquet dans toute installation standard.
	    </p>
	  </item>

<tag><tt>Suggests</tt></tag>
<item>
<p>
On se sert de ce champ pour déclarer qu'un paquet serait plus utile avec
un ou plusieurs autres paquets. On indique au système de gestion de
paquet et à l'utilisateur que les paquets listés sont liés au paquet et
qu'ils peuvent peut-être augmenter son utilité, mais qu'une installation 
sans ces paquets est parfaitement concevable.
	    </p>
	  </item>

<tag><tt>Enhances</tt></tag>
<item>
<p>
Ce champ ressemble au champ <tt>Suggests</tt> mais il marche en sens inverse. 
On s'en sert pour déclarer qu'un paquet améliore l'efficacité de tel
autre paquet.
	      </p>
	    </item>
<tag><tt>Pre-Depends</tt></tag>
<item>
Ce champ ressemble au champ <tt>Depends</tt>, sauf qu'il force aussi
<prgn>dpkg</prgn> à terminer l'installation des paquets qu'il liste avant 
même de démarrer l'installation du paquet qui déclare ces pré-dépendances.
	    </p>

<p>
Quand un paquet déclarant une relation de pré-dépendance est sur le point 
d'être <em>dépaqueté</em>, cette relation peut être satisfaite si le paquet
exigé par la pré-dépendance est, soit pleinement configuré, <em>soit même</em>
s'il est seulement dépaqueté ou « à demi configuré », pourvu qu'il ait été 
déjà correctement configuré au moins une fois (et pas effacé ou partiellement 
effacé depuis). Dans ce cas, les deux versions,
celle précédemment configurée et celle actuellement dépaquetée ou dans un état
«&nbsp;à moitié configuré&nbsp;», doivent satisfaire à toute clause de version
contenue dans le champ <tt>Pre-Depends</tt>.
</p>

<p>
Quand le paquet déclarant une relation de <tt>Pre-Dépendance</tt> est 
configuré, cette relation sera considérée comme une relation <tt>Depends</tt>
normale ; c'est-à-dire, elle sera considérée comme satisfaite seulement si le 
paquet dépendant a bien été configuré.
	    </p>

<p>
Le champ <tt>Pre-Depends</tt> sera utilisé parcimonieusement et de préférence
seulement pour les paquets dont une mise à jour ou une installation
prématurée entraverait la capacité du système à continuer les mises à jour
en cours.
	    </p>
<p>
Des relations <tt>Pre-Depends</tt> sont aussi exigées quand un script
<prgn>preinst</prgn> dépend du paquet <prgn>named</prgn>. Il vaut mieux
éviter cette situation.
	  </item>
	</taglist>
	</p>

<p>
Pour choisir un niveau de dépendance, on mesurera l'importance du paquet
demandé pour les fonctionnalités du paquet qui déclare la dépendance. Certains
paquets sont composés d'éléments plus ou moins importants. Un tel paquet
listera dans le champ <tt>Depends</tt> le ou les paquets qui sont nécessaires 
aux éléments les plus importants. Les autres éléments peuvent
être mentionnés comme des Suggestions ou des Recommandations, selon
l'importance relative de ces éléments.
	</p>

<sect id="conflicts"><heading>Mettre en conflit des paquets binaires --
          le champ <tt>Conflicts</tt>
        </heading>
<p>
Quand un paquet déclare un conflit avec un autre, en utilisant le champ
<tt>Conflicts</tt>, <prgn>dpkg</prgn> refuse
de les installer en même temps sur le système.
	</p>
<p>
Si l'on veut installer l'un de ces paquets, l'autre doit d'abord être supprimé 
-- si le paquet en cours d'installation est marqué comme remplaçant
(voir <ref id="replaces">) le paquet sur le système, ou si celui-ci est 
marqué comme «&nbsp;désélectionné&nbsp;», ou bien si les deux paquets sont 
marqués <tt>Essential</tt>, alors <prgn>dpkg</prgn> enlève automatiquement le 
paquet qui crée le conflit, ou bien arrête l'installation du nouveau paquet 
par une erreur. Ce mécanisme est spéciquement conçu pour provoquer une
erreur quand le paquet installé est marqué <tt>Essential</tt> et que le 
nouveau paquet ne l'est pas.
	</p>

<p>
Un paquet ne provoque pas de conflit simplement parce que ses fichiers de
configuration sont toujours installés ; il doit être au moins dans l'état 
«&nbsp;à moitié installé&nbsp;».
	</p>

<p>
Une exception spéciale est faite pour les paquets qui déclarent un conflit
avec leur propre nom de paquet, ou avec le paquet virtuel qu'ils
fournissent (voir ci-dessous) : cela n'empêche pas leur installation,
et cela autorise un paquet à déclarer un conflit avec les paquets qui 
peuvent le remplacer. On utilise ce dispositif quand on veut 
que le paquet en question soit le seul paquet à fournir une fonctionnalité
particulière.
	</p>

<p>
Une entrée <tt>Conflicts</> ne devrait presque jamais avoir une clause de
version indiquant une relation «&nbsp;avant&nbsp;». Cela empêcherait <prgn>dpkg</prgn> 
de mettre à jour ou d'installer le paquet qui déclare un tel conflit jusqu'à 
ce que la mise à jour ou l'effacement du paquet en conflit ait été terminé.
	</p>
      </sect>

<sect id="virtual"><heading>Les paquets virtuels -- le champ <tt>Provides</tt></heading>

<p>
Aussi bien que des noms de paquets réels (concrets), les champs de
relation <tt>Depends</tt>, <tt>Recommends</tt>, <tt>Suggests</tt>,
<tt>Enhances</tt>, <tt>Pre-Depends</tt>, <tt>Conflicts</tt>, 
<tt>Build-Depends</tt>,<tt>Build-Depends-Indep</tt>, <tt>Build-Conflicts</tt> 
et <tt>Build-Conflicts-Indep</tt> 
peuvent mentionner des noms de «&nbsp;paquets virtuels&nbsp;».
	</p>

<p>
Un paquet «&nbsp;virtuel&nbsp;» est un paquet qui apparaît dans le champ
<tt>Provides</tt> du fichier «&nbsp;control&nbsp;» d'un autre paquet. L'effet 
est le même que si le ou les paquets qui fournissent un paquet virtuel 
particulier avaient été listés par leur nom partout où le nom du paquet virtuel
apparaît.
	</p>

<p>
Quand un paquet réel et un paquet virtuel ont le même nom, la
dépendance peut être satisfaite (ou le conflit provoqué) soit par le
paquet réel soit par n'importe quel paquet fournissant le paquet virtuel et 
qui indique cette dépendance.
Par exemple, en supposant que nous ayons :
<example compact="compact">
Package: foo
Depends: bar
</example>
Et que quelqu'un d'autre sorte un paquet <tt>bar</tt> amélioré (p.ex. une
variante non-US), il peut dire :
<example compact="compact">
Package: bar-plus
Provides: bar
</example>

et le paquet <tt>bar-plus</tt> satisfera aussi la dépendance pour le
paquet <tt>foo</tt>.
	</p>

<p>
Quand un numéro de version est attaché à une dépendance ou à un conflit,
seuls les paquets réels seront examinés pour savoir si la relation est
satisfaite (ou, pour un conflit, l'interdiction violée) - on supposera
qu'un paquet réel qui fournit un paquet virtuel n'a pas la «&nbsp;bonne&nbsp;»
version. Ainsi, un champ <tt>Provides</tt> ne peut pas contenir de numéros
de version, et le numéro de version du paquet concret qui fournit un
paquet virtuel particulier n'est pas examiné quand on considère une
dépendance envers ou un conflit avec le nom du paquet virtuel.
	</p>

<p>
Il est probable que la possibilité d'indiquer un numéro de version pour 
chaque paquet virtuel sera ajoutée dans une version prochaine de 
<prgn>dpkg</prgn>. Cette caractéristique n'est pas encore présente et il vaut
mieux s'en servir très peu souvent.
	</p>

<p>
Quand on  veut spécifier quel paquet d'un ensemble de paquets réels
sera celui qui satisfait par défaut une dépendance particulière envers
un paquet virtuel, on listera le paquet réel alternatif
avant le paquet virtuel.
	</p>

<p>

<sect id="replaces"><heading>le champ <tt>Replaces</tt> -- remplacer les fichiers et les paquets</heading>

<p>
 Le champ <tt>Replaces</tt> du fichier «&nbsp;control&nbsp;» a deux buts 
différents qui entrent en jeu dans des situations différentes.
	</p>

<sect1><heading>Remplacer les fichiers appartenant à d'autres paquets</heading>

<p>
Tout d'abord, comme mentionné auparavant, qu'un paquet possède des fichiers 
qui sont sur le système mais dans un autre paquet est généralement une erreur.
	  </p>

<p>
Cependant, si le paquet, qui veut faire un remplacement, déclare, dans le champ
<tt>Replaces</tt>, qu'il remplace le paquet
qui contient le fichier à remplacer, <prgn>dpkg</prgn> procède au
remplacement du fichier de l'ancien paquet par le nouveau. Ce fichier ne
sera plus listé comme faisant partie de l'ancien paquet.
	  </p>

<p>
Quand un paquet est ainsi complètement remplacé, de sorte que
<prgn>dpkg</prgn> ne sait pas quels fichiers il contient encore, on 
considère qu'il a «&nbsp;disparu&nbsp;». Sur le système, il est marqué comme 
«&nbsp;non sélectionné&nbsp;» (sélectionné pour l'effacement) et «&nbsp;non installé&nbsp;». 
Tous les renseignements contenus dans les <tt>conffiles</tt> sont ignorés, vu
que le paquet remplaçant les aura repris. Le script <prgn>postrm</prgn> du 
paquet est exécuté avec un argument particulier pour permettre au paquet de 
faire le nettoyage final nécessaire.
Voir <ref id="mscriptsinstact">.
	  </p>

<p>
Quand un paquet installé, disons <tt>foo</tt>, déclare qu'il remplace le 
paquet <tt>bar</tt>, et que d'autre part on essaye d'installer <tt>bar</tt>,
<prgn>dpkg</prgn> laissera de côté les fichiers de <tt>bar</tt> qui 
auraient remplacés ceux déjà présent de <tt>foo</tt>. De cette façon, on peut 
installer sans problème une version plus ancienne d'un paquet.
	  </p>

<p>
Avec cette utilisation du champ <tt>Replaces</tt>, et quand on l'examine,
on ne prend pas en compte les paquets virtuels -- les paquets déclarants
qu'ils sont remplacés doivent être mentionnés par leurs noms réels.
</p>

<p>
De plus, cet usage de <tt>Replaces</> prend seulement effet quand deux 
paquets sont -- au moins partiellement -- en même temps sur le système, et 
cela peut seulement se produire s'ils ne sont pas en conflit, ou si le 
conflit a été annulé.
	  </p>
	</sect1>

<sect1><heading>Le remplacement total d'un paquet ; forcer sa suppression</heading>

<p>
Et deuxièmement, le champ <tt>Replaces</tt> permet au système de gestion des
paquets de savoir quel paquet enlever quand il y a un conflit - voir
<ref id="conflicts">. Cet usage prend seulement effet quand deux paquets sont 
réellement en conflit, afin que les deux usages de ce champ n'interfèrent pas 
l'un avec l'autre.
	  </p>

<p>
Dans ce cas, le paquet déclaré comme étant remplacé peut être un paquet
virtuel ; c'est ainsi que les agents de transport du courrier (MTA) pourront
avoir les champs suivants dans leur fichier de contrôle&nbsp;:
           <example compact="compact">
Provides: mail-transport-agent
Conflicts: mail-transport-agent
Replaces: mail-transport-agent
           </example>
On s'assure ainsi qu'un seul MTA peut être installé à la fois.
	</sect1>
      </sect>

<sect><heading>Les relations entre les paquets binaires et les paquets sources
-- les champs <tt>Build-Depends</tt>, <tt>Build-Depends-Indep</tt>,
          <tt>Build-Conflicts</tt>, <tt>Build-Conflicts-Indep</tt>
        </heading>

<p>
Un paquet source peut déclarer une dépendance (ou un conflit) envers un 
paquet binaire, indiquant les paquets dont la présence sur le système est
nécessaire pour construire les binaires à partir du paquet source. On se sert 
des champs <tt>Build-Depends</tt>,
<tt>Build-Depends-Indep</tt>, <tt>Build-Conflicts</tt> et 
<tt>Build-Conflicts-Indep</tt> du fichier <em>control</em>. Les dépendances 
ou les conflits qu'ils définissent doivent être résolus (comme ça a été 
défini plus haut pour les paquets binaires) pour pouvoir appeler les cibles 
de <tt>debian/rules</tt> comme suit&nbsp;:

<taglist>
            <tag><tt>Build-Depends</tt>, <tt>Build-Conflicts</tt></tag>
            <item>
              <p>
Les champs <tt>Build-Depends</tt> et <tt>Build-Conflicts</tt> doivent être
satisfaits quand l'une des cibles suivantes est appelée :
<tt>build</tt>, <tt>binary</tt>, <tt>binary-arch</tt>
                et <tt>binary-indep</tt>.
              </p>
            </item>
 <tag><tt>Build-Depends-Indep</tt>, <tt>Build-Conflicts-Indep</tt></\tag>
            <item>
              <p>
Les champs <tt>Build-Depends-Indep</tt> et <tt>Build-Conflicts-Indep</tt> 
doivent être satisfaits quand l'une des cibles suivantes est appelée :
<tt>binary</tt> et <tt>binary-indep</tt>.
              </p>
            </item>
          </taglist>
	</p>
      </sect>
    </chapt>

<chapt id="8"><heading>L'utilisation des fichiers de configuration
      </heading>


<p>
Ce chapitre est remplacé par  <ref id="config files">.

    </chapt>

<chapt id="9"><heading>Les bibliothèques partagées</heading>

<p>
On doit construire les paquets qui contiennent des bibliothèques partagées 
avec un peu de soin pour s'assurer que ces bibliothèques seront
toujours disponibles. Et particulièrement, les paquets qui demandent des
bibliothèques vitales, telle que la bibliothèque C, (actuellement : 
<em>libc6</em>).
      </p>

<p>
Tout d'abord, le paquet installera les bibliothèques partagées sous
leurs vrais noms. Par exemple, le paquet <tt>libgdbm1</tt> installera 
<tt>libgdbm.so.1.7.3</tt> en tant que <tt>/usr/lib/libgdbm.so.1.7.3</tt>. 
Aucun script <prgn>prerm</prgn> ou <prgn>postrm</prgn> ne changera le nom de 
ces 
fichiers ni ne créera de lien pour ces fichiers ; <prgn>dpkg</prgn> s'occupe
des changements de nom et cela, sans troubler les programmes en fonctionnement.
Essayer d'interférer avec ce système crée des problèmes.
      </p>

<p>
Ensuite, le paquet comportera le lien symbolique que <prgn>ldconfig</prgn>
voudra créer pour les bibliothèques partagées. Par exemple, le paquet
<prgn>libgdbm1</prgn> inclura un lien symbolique de
<tt>/usr/lib/libgdbm.so.1.7.3</tt> vers <tt>libgdbm.so.1.7.3</tt>. C'est
nécessaire pour que le lieur (<prgn>ld.so</prgn> ou 
<prgn>ld-linux.so.*</prgn>) puisse trouver la bibliothèque entre le
moment où <prgn>dpkg</prgn> l'installe et celui où <prgn>ldconfig</prgn> est 
exécuté par le script <prgn>postinst</prgn> <footnote>
<p>
Le système de gestion des paquets demande que la bibliothèque soit placée avant
le lien symbolique qui pointe vers elle dans le fichier <tt>.deb</tt>. Ainsi,
avant que <prgn>dpkg</prgn> n'installe le lien symbolique (en remplaçant le
lien précédent qui pointe sur une version plus ancienne de la bibliothèque),
la nouvelle bibliothèque est déjà en place. Par le passé, on créait la
bibliothèque dans le répertoire temporaire où l'on faisait le paquet avant de
créer le lien symbolique. Malheureusement, cela ne marchait pas toujours car
la construction du fichier <em>tar</em> pour le fichier <tt>.deb</tt>
dépendait du système de fichier sous-jacent. Des systèmes de fichiers (comme
reiserfs) réordonne les fichiers de sorte que l'ordre dans lequel on les crée 
est oublié. Avec sa version <tt>1.7.0</tt>, <prgn>dpkg</prgn> réordonne, 
si nécessaire, les fichiers lors de la construction d'un paquet. Et il n'est
plus nécessaire de se préoccuper de l'ordre de création des fichiers.
</p>
</footnote>. 
      </p>

<p>
Troisièmement, le paquet de développement associé comportera un lien
symbolique pour la bibliothèque partagée sans numéro de version. Par
exemple, le paquet <tt>libgdbm1-dev</tt> inclura un lien
symbolique de <tt>/usr/lib/libgdbm.so</tt> vers <tt>libgdbm.so.1.7.3</tt>.
Ce lien symbolique est nécessaire à <prgn>ld</prgn> quand il compile les
paquets ; il cherche en effet seulement <tt>libgdbm.so</tt>  
pour une compilation dynamique .
      </p>

<p>
Tout paquet qui installe des bibliothèques partagées dans l'un des
répertoires par défaut du lieur dynamique, (actuellement, <tt>/usr/lib</tt> et
<tt>/lib</tt>)  ou dans un répertoire listé par <tt>/etc/ld.so.conf</tt>
<footnote>
<p>
Les voici :
           <list compact="compact">
             <item><p>/usr/X11R6/lib/Xaw3d</p></item>
             <item><p>/usr/local/lib</p></item>
             <item><p>/usr/lib/libc5-compat</p></item>
             <item><p>/lib/libc5-compat</p></item>
             <item><p>/usr/X11R6/lib</p></item>
           </list>
         </p>
	</footnote>
doit appeler <prgn>ldconfig</prgn> dans son script 
<prgn>postinst</prgn> si le premier argument est <tt>configure</tt>, et 
l'appellera dans le script <prgn>postrm</prgn> si le
premier argument est <tt>remove</tt>.
      </p>

<p>
Cependant, les scripts <prgn>postrm</prgn> et <prgn>preinst</prgn> <em>ne
doivent pas</em> appeler <prgn>ldconfig</prgn> dans le cas où le paquet est 
mis à jour (voir <ref id="unpackphase">) ; en effet <prgn>ldconfig</prgn> 
voit les noms temporaires que <prgn>dpkg</prgn> donne à ces fichiers lors de 
l'installation ; et il fait pointer les liens des bibliothèques partagées sur 
ces noms, juste avant que <prgn>dpkg</prgn>, continuant l'installation, ne
change le nom de ces fichiers temporaires !
      </p>

    

<sect><heading>Comment gérer les dépendances pour les bibliothèques partagées ? Le système <tt>shlibs</tt>.</heading>

<p>
Quand un paquet contient un binaire ou une bibliothèque qui se lient à une
bibliothèque partagée, on doit s'assurer que, lors de l'installation de ce 
paquet sur le système, toutes les bibliothèques nécessaires sont aussi
installées. Cela a conduit à la création du système <tt>shlibs</tt> ; de
conception très simple, ce système demande que tout paquet qui fournit 
(champ <em>provides</em>) une bibliothèque partagée donne aussi les
informations de dépendance nécessaires à la présence de cette bibliothèque ;
ainsi tout paquet qui <em>utilise</em> une bibliothèque partagée, utilise
ces informations pour connaître les dépendances requises. Les fichiers qui
contiennent les relations entre les bibliothèques partagées et les 
informations sur les dépendances nécessaires sont les fichiers <tt>shlibs</tt>.
	</p>
<p>
Ainsi, quand on construit un paquet contenant une bibliothèque partagée,
on doit fournir un fichier <tt>shlibs</tt> utilisable par d'autres paquets ;
et quand on construit un paquet contenant une bibliothèque partagée ou un
binaire compilé, ce paquet doit exécuter <prgn>dpkg-shlibdeps</prgn> pour
ces programmes de manière à connaître les bibliothèques utilisées et donc
les dépendances nécessaires à ce paquet <footnote>
<p>
Par le passé, on appelait <prgn>ldd</prgn> pour connaître les bibliothèques
partagées requises ; maintenant on appelle <prgn>objdump</prgn>. Le seul
changement dans la manière de construire un paquet est que l'on doit aussi
exécuter <prgn>dpkg-shlibdeps</prgn> sur les bibliothèques partagées, alors
qu'avant ce n'était pas nécessaire. La suite de cette note explique les
avantages de cette méthode.
</p>
<p>
Un binaire <tt>foo</tt> utilise <em>directement</em> la bibliothèque
<tt>libbar</tt> quand il est lié explicitement à cette bibliothèque (c'est à 
dire qu'il utilise le drapeau <tt>-lbar</tt> pendant la phase de liage). Les 
autres bibliothèques dont <tt>libbar</tt> a besoin sont liées 
<em>indirectement</em> à <tt>foo</tt>, et l'éditeur de liens dynamiques les 
charge automatiquement quand il charge <tt>libbar</tt>. Un paquet aura besoin
de dépendre des bibliothèques qu'il utilise directement, et les dépendances 
de ces bibliothèques amèneront automatiquement les autres bibliothèques.
</p>
<p>
Malheureusement, le programme <prgn>ldd</prgn> indique toutes les
bibliothèques, celles directement utilisées et celles indirectement utilisées ;
ce qui signifie que les dépendances comportent des dépendances directes et
indirectes. Avec <prgn>objdump</prgn>, on évite ce problème en
indiquant seulement les bibliothèques directement utilisées.
</p>
<p>
Voici un exemple qui montre l'intérêt de ce système : on pourrait mettre à 
jour <tt>libimlib</tt> avec une version qui accepte le nouveau format 
graphique <em>dgf</em> (tout en gardant le même numéro majeur de version). En 
utilisant l'ancienne méthode <prgn>ldd</prgn>, chaque paquet qui se sert de
<tt>libimlib</tt> devrait être recompilé pour qu'il dépende aussi de
<tt>libdgf</tt>, sinon il ne marcherait pas à cause de symboles manquants.
Mais, avec le nouveau système, les paquets qui se servent de
<tt>libimlib</tt>  peuvent dépendre simplement de <tt>libimlib</tt> qui
possède elle-même la dépendance envers <tt>libdgf</tt> et ils n'auront pas
besoin d'être mis à jour.
      </p>
</footnote>.
	</p>
<p>
Les sections suivantes décrivent l'emplacement des différents fichiers
<tt>shlibs</tt>, la façon d'utiliser le programme <prgn>dpkg-shlibdeps</prgn>,
et le format du fichier <tt>shlibs</tt> ainsi que la façon de créer ces
fichiers quand un paquet contient une bibliothèque partagée.</p>
      </sect>

<sect><heading>Les fichiers <tt>shlibs</tt> sur le système</heading>
<p>
On peut trouver des fichiers <tt>shlibs</tt> à plusieurs endroits. La liste
suivante les donne dans l'ordre selon lequel <prgn>dpkg-shlibdeps</prgn> les
a lus. (Le premier qui donne l'information demandée est utilisé.)
</p>
<p>
         <list>
           <item>
             <p><tt>debian/shlibs.local</tt></p>
             <p>
Cela donne les remplacements à faire pour ce paquet. Son usage est d'écrit
plus bas (<ref id="shlibslocal">).
	    </p>
	  </item>
           <item>
             <p><tt>/etc/dpkg/shlibs.override</tt></p>
             <p>
Cela donne les remplacements à faire pour tout le système. Cette liste,
maintenue par l'administrateur local, est normalement vide.
	    </p>
	  </item>
           <item>
             <p>Les fichiers <tt>DEBIAN/shlibs</tt> dans le « répertoire de construction »</p>
             <p>
Quand on constuit un paquet, tous les fichiers <tt>debian/shlibs</tt> sont
copiés dans le répertoire temporaire de construction avec comme nom 
<tt>shlibs</tt>. Ces fichiers donne des renseignements sur toutes les
bibliothèques partagées contenues dans le paquet <footnote>
<p>
Un exemple nous aidera : disons que le paquet source <tt>foo</tt> produit
deux paquets binaires, <tt>libfoo2</tt> et <tt>foo-runtime</tt>. Pour la
construction de ces paquets, on utilise les répertoires <tt>debian/libfoo2</tt>
et <tt>debian/foo-runtime</tt> respectivement (on pourrait utiliser
<tt>debian/tmp</tt> à la place de l'un des deux). Puisque <tt>libfoo2</tt>
fournit la bibliothèque partagée <tt>libfoo</tt>, il demandera un fichier
<tt>shlibs</tt> qui sera installé dans <tt>debian/libfoo2/DEBIAN/shlibs</tt>,
et deviendra finalement <tt>/var/lib/dpkg/info/libfoo2.shlibs</tt>. Maintenant,
quand on exécute <prgn>dpkg-shlibdeps</prgn> pour l'exécutable 
<tt>debian/foo-runtime/usr/bin/foo-prog</tt>, <prgn>dpkg-shlibdeps</prgn>
examine le fichier <tt>debian/libfoo2/DEBIAN/shlibs</tt> pour savoir si les
dépendances de <tt>foo-prog</tt> en ce qui concerne les bibliothèques
sont satisfaites par les bibliothèques fournies par <tt>libfoo2</tt>. Pour
cette raison, on ne doit exécuter <prgn>dpkg-shlibdeps</prgn> qu'après que
tous les fichiers <tt>shlibs</tt> de chaque paquet binaire ont été installés
dans le répertoire de construction.
		</p>
</footnote>.
	    </p>
	  </item>
           <item>
             <p><tt>/var/lib/dpkg/info/*.shlibs</tt></p>
             <p>
Ce sont tous les fichiers <tt>shlibs</tt> de tous les paquets installés
sur le système ; ils sont maintenus par les responsables des paquets concernés.
	    </p>
	  </item>
           <item>
            <p><tt>/etc/dpkg/shlibs.default</tt></p>
              <p>
Ce fichier liste toutes les bibliothèques partagées dont les paquets n'ont
pas pu fournir de fichiers <tt>shlibs</tt> corrects. Il était utilisé quand
on a introduit le système <tt>shlibs</tt> pour la première fois ; il est
maintenant normalement vide. Il est maintenu par le responsable de 
<tt>dpkg</tt>.
	    </p>
	  </item>
	</list>
      </p>
      </sect>

<sect><heading>Comment utiliser <prgn>dpkg-shlibdeps</prgn> et les fichiers <tt>shlibs</tt> ? </heading>
<p>
Placer un appel au programme <prgn>dpkg-shlibdeps</prgn> dans le fichier
<tt>debian/rules</tt>. Si le paquet contient seulement des binaires
compilés et des bibliothèques (mais pas de scripts), on peut utiliser la 
commande :
+         <example compact="compact">
+dpkg-shlibdeps debian/tmp/usr/bin/* debian/tmp/usr/sbin/* \
+  debian/tmp/usr/lib/*
         </example>
         <example compact="compact">
dpkg-shlibdeps debian/tmp/usr/bin/* debian/tmp/usr/sbin/* \
  debian/tmp/usr/lib/*
         </example>
Sinon, on devra explicitement lister les binaires compilés et les bibliothèques
<footnote>
<p>
Quand on utilise <tt>debhelper</tt>, le programme <prgn>dh_shlibdeps</prgn>
fera le nécessaire pour vous. Il gèrera convenablement les paquets avec 
plusieurs binaires.</p>
</footnote>.
</p>
<p>
Cette commande place les informations sur les dépendances dans le fichier
<tt>debian/substvars</tt>, qui est ensuite utilisé par 
<prgn>dpkg-gencontrol</prgn>. Vous devrez placer une variable
<tt>${shlib:Depends}</tt> dans le champ <tt>Depends</tt> du fichier de
contrôle pour que cela marche.
</p>
<p>
Si <prgn>dpkg-shlibdeps</prgn> ne se plaint pas, c'est bon. Sinon, vous
pourriez avoir besoin de créer un fichier <tt>debian/shlibs.local</tt>,
comme expliqué plus bas (<ref id="shlibslocal">).
</p>
<p>
Si vous avez des paquets contenant plusieurs binaires, vous devrez appeler
<prgn>dpkg-shlibdeps</prgn> sur tous ceux qui ont des binaires compilés et des
bibliothèques. Dans ce cas, vous aurez besoin de l'option <tt>-T</tt> des
outils <tt>dpkg</tt> pour spécifier un fichier <tt>substvars</tt> différent.
Voyez <manref name="dpkg-shlibdeps" section="1"> pour des renseignements
supplémentaires sur ces options.
</p>
      </sect>

<sect id="shlibs"><heading>Le format du fichier <tt>shlibs</tt></heading>

<p>
Chaque fichier <tt>shlibs</tt> possède le même format. Les lignes
commençant par <tt>#</tt> sont des commentaires et sont ignorées. Chaque
ligne est de la forme&nbsp;:
         <example compact="compact">
<var>nom-de-bibliothèque</var> <var>nomso-version-numéro</var> <var>dependences ...\</var>
         </example>
       </p>
<p>
Nous allons expliquer cette ligne en prenant comme exemple le paquet
<tt>zlib1g</tt>, qui, au moment où est écrit ce texte, installe la
bibliothèque partagée <tt>/usr/lib/libz.so.1.1.3</tt>.
	</p>
<p>
<var>nom-de-bibliothèque</var> est le nom de la bibliothèque partagée, dans
ce cas&nbsp;: <tt>libz</tt>. (Cela doit correspondre à la partie « nom » du 
<em>nomso</em>, voyez plus bas.)
	</p>
<p>
<var>nomso-version-numéro</var> est la partie version du <em>nomso</em> de la
bibliothèque. Le <em>nomso</em> est ce qui doit coller exactement pour que la
bibliothèque soit reconnue par le lieur dynamique, et il est habituellement
de la forme&nbsp;: <tt><var>nom</var>.so.<var>version-numéromajeur</var></tt>,
et dans ce cas <tt>libz.so.1</tt><footnote>
<p>
La commande suivante peut le déterminer :
             <example compact="compact">
objdump -p /usr/lib/libz.so.1.1.3 | grep SONAME
              </example>
</p>
</footnote>.
La partie version est la partie qui suit <tt>.so.</tt>, et donc ici : 
<tt>1</tt>.
	</p>
<p>
<var>dependences</var> possède le même format qu'un champ de dépendance dans
le fichier de contrôle d'un paquet binaire. Cette partie donnera des 
renseignements sur les paquets qui sont demandés pour compiler un binaire
avec la version de la bibliothèque contenue dans le paquet. Voir
<ref id="depsyntax"> pour des précisions.
	</p>
<p>
Dans notre exemple, si la première version du paquet <tt>zlib1g</tt>, contenant
un numéro mineur égal à au moins <tt>1.3</tt>, était de <var>1:1.1.3-1</var>,
alors l'entrée <tt>shlibs</tt> pour cette bibliothèque pourra énoncer&nbsp;:
         <example compact="compact">
libz 1 zlib1g (>= 1:1.1.3)
         </example>
La dépendance pour une version particulière sert à éviter les avertissements
de lieur dynamique au sujet de l'utilisation d'anciennes bibliothèques avec
des binaires plus récents.
</p>
      </sect>

<sect><heading>Comment créer un fichier <tt>shlibs</tt> ?</heading>
<p>
Si le paquet fournit une bibliothèque partagée, on créera un fichier
<tt>shlibs</tt> en suivant le format décrit plus haut. Habituellement, on le
nomme <tt>debian/shlibs</tt> (mais si le paquet contient plusieurs binaires,
on pourra l'appeler <tt>debian/shlibs.<var>package</var></tt>). Puis on
laissera <tt>debian/rules</tt> l'installer dans la zone de contrôle&nbsp;:
         <example compact="compact">
install -m644 debian/shlibs debian/tmp/DEBIAN
         </example>
où, en cas de paquet avec de multiples binaires&nbsp;:
         <example compact="compact">
install -m644 debian/shlibs.<var>package</var> debian/<var>package</var>/DEBIA\N/shlibs
         </example>
Une autre façon de faire est de créer directement le fichier <tt>shlibs</tt>
dans la zone de contrôle à partir du fichier <tt>debian/rules</tt> sans
utiliser un fichier <tt>debian/shlibs</tt><footnote>
<p>
C'est ce que fait <prgn>dh_makeshlibs</prgn> de la suite <tt>debhelper</tt>.
</p>
</footnote>, 
puisque le fichier <tt>debian/shlibs</tt> lui-même est ignoré par le
programme <prgn>dpkg-shlibdeps</prgn>.
</p>
<p>
Comme <prgn>dpkg-shlibdeps</prgn> lit tous les fichiers <tt>DEBIAN/shlibs</tt>
de tous les paquets binaires construits à partir du paquet source, tous les
fichiers <tt>DEBIAN/shlibs</tt> seront installés avant d'appeler
<prgn>dpkg-shlibdeps</prgn> pour chaque paquet binaire.
	</p>
      </sect>

<sect id="shlibslocal">
<heading>Comment écrire le fichier <tt>debian/shlibs.local ?</tt></heading>

<p>
Ce fichier est prévu seulement pour une correction temporaire quand les
binaires ou les bibliothèques dépendent d'une bibliothèque pour laquelle
aucun fichier <tt>shlibs</tt> correct n'est produit par le paquet.
	</p>
<p>
Nous assumons que vous essayez de créer un paquet binaire <tt>foo</tt>. Quand
vous essayez d'exécuter <prgn>dpkg-shlibdeps</prgn>, vous obtenez le message
d'erreur suivant (l'option <tt>-O</tt> affiche les informations de
dépendance sur <tt>stdout</tt> au lieu de les écrire dans le fichier
<tt>debian/substvars</tt>, et les lignes ont été enveloppées pour faciliter
la lecture)&nbsp;:
         <example compact="compact">
$ dpkg-shlibdeps -O debian/tmp/usr/bin/foo
dpkg-shlibdeps: warning: unable to find dependency
  information for shared library libbar (soname 1,
  path /usr/lib/libbar.so.1, dependency field Depends)
shlibs:Depends=libc6 (>= 2.2.2-2)
         </example>
Vous pouvez alors exécuter <prgn>ldd</prgn> sur le binaire pour trouver
l'endroit exact de la bibliothèque en question&nbsp;:
         <example compact="compact">
$ ldd foo
libbar.so.1 => /usr/lib/libbar.so.1 (0x4001e000)
$ ldd foo
libbar.so.1 => /usr/lib/libbar.so.1 (0x4001e000)
libc.so.6 => /lib/libc.so.6 (0x40032000)
/lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
         </example>
Ainsi le binaire <prgn>foo</prgn> dépend de la bibliothèque partagée
<prgn>libbar</prgn>, mais aucun paquet ne donne un fichier <tt>*.shlibs</tt>
qui gère <tt>libbar.so.1</tt> dans <tt>/var/lib/dpkg/info/</tt>. Déterminons
le paquet responsable&nbsp;:
          <example compact="compact">
$ dpkg -S /usr/lib/libbar.so.1
bar1: /usr/lib/libbar.so.1
$ dpkg -s bar1 | grep Version
Version: 1.0-1
         </example>
Ce qui nous indique que le paquet <tt>bar1</tt>, version <tt>1.0-1</tt>, est
celui qu'on utilise. Maintenant nous pouvons envoyer un rapport de bogue
contre le paquet <tt>bar1</tt> et créer notre propre fichier
<tt>debian/shlibs.local</tt> pour corriger localement le problème évoqué.
Insérer la ligne suivante dans le fichier <tt>debian/shlibs.local</tt>&nbsp;:
         <example compact="compact">
libbar 1 bar1 (>= 1.0-1)
         </example>
permettra la construction du paquet.
</p>
<p>
Dès que le responsable de <tt>bar1</tt> fournit un fichier <tt>shlibs</tt>
correct, vous supprimerez cette ligne dans le fichier 
<tt>debian/shlibs.local</tt>. (Vous aurez sans doute aussi un champ
<tt>Build-Depends</tt> concernant les versions pour <tt>bar1</tt> de
manière à s'assurer que d'autres n'aient pas le même problème pour
construire votre paquet.)
	</p>
      </sect>
    </chapt>

<chapt id="10"><heading>Le système d'exploitation</heading>
	
      
      <sect>
	<heading>La hiérarchie du système de fichiers</heading>
	  
	
	<sect1>
	  <heading>La structure du système de fichiers</heading>
	    
	  <p>
L'emplacement de tous les répertoires et fichiers installés
doit être conforme au standard sur la hiérarchie du système de fichiers 
(FHS, version 2.1), sauf si cela va contre un principe de la charte Debian. 
On peut trouver la plus récente version de ce document 
dans le paquet <tt>debian-policy</tt>  ou, avec ce manuel, sur
<url id="http://www.debian.org/doc/packaging-manuals/fhs" name="FHS (Debian copy)">,
ou sur <url id="http://www.pathname.com/fhs/" name="FHS (upstream)">.
Toute question relative à la manière de suivre ce standard
peut-être posée dans la liste de diffusion
<tt>debian-devel</tt> ou à Daniel Quinlan, le coordinateur
FHS à l'adresse <email>quinlan@pathname.com</email>.
</p>
</sect1>
	    
	<sect1>
	  <heading>Les programmes spécifiques à un site</heading>
	    
	  <p>
Conformément au «&nbsp;FHS&nbsp;», aucun paquet ne doit placer de fichiers
dans<tt>/usr/local</tt>, que ce soit en les mettant dans l'archive 
qui doit être dépaquetée par <prgn>dpkg</prgn> ou que ce
soit en les manipulant dans les scripts d'installation.
</p>
	  <p>
Cependant, un paquet peut créer des répertoires vides sous <tt>/usr/local</tt>
de manière que l'administrateur système ait un endroit où placer
des fichiers locaux. S'ils sont vides, ces répertoires
seront supprimés quand on supprime le paquet.
</p>
	    
	  <p>
On notera que cela ne s'applique qu'aux répertoires <em>sous</em>
<tt>/usr/local</tt> et non pas <em>dans</em> <tt>/usr/local</tt>. 
Le répertoire <tt>/usr/local</tt> ne doit
contenir lui-même que les répertoires listés dans le FHS,
section 4.5. Cependant vous pouvez créer autant de répertoires que vous voulez
sous ces répertoires. Vous ne devez pas supprimer
les répertoires listés à la section 4.5, même si vous les avez créés.
</p>
	  <p>
Comme <tt>/usr/local</tt> peut être monté en lecture seule depuis
un serveur distant, on doit créer ces répertoires avec
les scripts de post-installation, <prgn>postinst</prgn> et on doit les
supprimer avec les scripts de pré-désinstallation, <prgn>prerm</prgn> ; ils 
ne doivent pas être dans l'archive <tt>.deb</tt>.
Ces scripts ne doivent pas échouer si l'une de ces opérations échoue.
</p>
	    
	  <p>
Par exemple, le paquet <tt>emacsen-common</tt> pourrait contenir
    <example compact="compact">
if [ ! -e /usr/local/share/emacs ]
then
  if mkdir /usr/local/share/emacs 2>/dev/null
  then
    chown root:staff /usr/local/share/emacs
    chmod 2775 /usr/local/share/emacs
  fi
fi
    </example>
dans le script <prgn>postinst</prgn>, et
          <example compact="compact">
rmdir /usr/local/share/emacs/site-lisp 2>/dev/null || true
rmdir /usr/local/share/emacs 2>/dev/null || true
          </example>
dans le script <prgn>prerm</prgn>.(Il faut remarquer qu'on utilise cette forme
pour s'assurer que le répertoire <tt>/usr/local/share/emacs</tt> sera encore 
supprimé si le script est interrompu.)
</p>
	    
	  <p>
Si vous créez un répertoire dans <tt>/usr/local</tt> pour 
«&nbsp;localiser&nbsp;» un paquet, vous vous assurerez que le paramétrage 
dans <tt>/usr/local</tt> sera prioritaire par rapport à celui dans 
<tt>/usr</tt>.
</p>

	  <p>
Cependant, puisque <tt>/usr/local</tt> et son contenu sont réservés à 
l'administrateur local, un paquet ne doit pas compter sur la présence ou 
l'absence de fichiers ou répertoires dans <tt>/usr/local</tt>  
pour toute opération normale.
</p>
<p>Le répertoire <tt>/usr/local</tt> lui-même et tous les sous-répertoires
créés par un paquet, auront (par défaut) les droits 2775 (modifiable et 
exécutable par le groupe (bit «&nbsp;set-group-id&nbsp;» positionné)). Ils 
doivent appartenir à <tt>root.staff</tt>.
</p>
</sect1>
<sect1>
<heading>Le répertoire commun pour le courrier</heading>
<p>
Le répertoire commun pour le courrier est <tt>/var/mail</tt>. Ce répertoire
fait partie du système de base et il n'appartiendra à aucun opérateur de
courrier particulier. L'utilisation de l'ancien répertoire 
<tt>/var/spool/mail</tt> est déconseillée, même si le courrier se trouve
toujours physiquement là. Pour garder, lors d'une mise à jour, une 
compatibilité avec les systèmes qui utilisent <tt>/var/spool/mail</tt> comme
répertoire de courrier, les paquets qui se servent de <tt>/var/mail</tt>
doivent dépendre de <package>libc6</package> (&gt;= 2.1.3-13), ou bien de
<package>base-files</package> (&gt;= 2.2.0), et des versions plus récentes
de ces paquets.</p>
	</sect1>
</sect>
	
      <sect>
	<heading>Les utilisateurs et les groupes</heading>
	  
<sect1>
<heading>Introduction</heading>
	<p>
Le système Debian est configuré pour utiliser soit les mots de passe
ordinaires soit les mots de passe masqués («&nbsp;shadow password&nbsp;»).
</p>
	  
	<p>
L'utilisation de quelques identifiants d'utilisateur (UIDs) et de groupe 
(GIDs) est réservée à certains paquets. Ces paquets ont besoin
d'inclure des fichiers appartenant à ces utilisateurs ou à ces groupes,
ou bien ont besoin de compiler des binaires avec ces identifiants ; c'est 
pourquoi, sur tout système Debian, ces identifiants ne pourront être utilisés 
que dans ce cadre prédéfini.
C'est une restriction importante, et on évitera d'interférer avec des 
politiques particulières d'administration système. De nombreux sites 
notamment attribuent des utilisateurs et/ou des groupes systèmes spécifiques 
à partir de 100.
</p>
	  
	<p>
En dehors de cet aspect, les identifiants seront attribués dynamiquement et
seront rangés selon un ordre raisonnable mais qui peut être redéfini.
</p>
	<p>
Seul le paquet <tt>base-passwd</tt> a le droit de modifier 
<tt>/etc/passwd</tt>, <tt>/etc/shadow</tt>, <tt>/etc/group</tt>
ou <tt>/etc/gshadow</tt>.
</p>
	  
<sect1><heading>Les classes d'« UID » et de « GID »</heading>
	<p>
Les numéros des «&nbsp;UID&nbsp;» et des «&nbsp;GID&nbsp;» sont rangés en
classes&nbsp;:
	  <taglist>
	    <tag>0-99 :</tag>
	    <item>
	      <p>
Attribués en bloc par le projet Debian, ils doivent être identiques sur tout 
système Debian. Ces identifiants apparaîtront dans les fichiers 
<tt>passwd</tt> et <tt>group</tt> de tout système Debian, tout nouvel
identifiant dans cet intervalle étant automatiquement ajouté quand le paquet 
<tt>base-passwd</tt> est mis à jour.
 </p>
		
	      <p>
Un paquet qui a besoin d'un identifiant UID ou GID unique et attribué de
manière fixe utilisera cet intervalle ; le responsable demandera
son obtention au responsable de <tt>base-passwd</tt>.
 </p>
	    </item>
		
	    <tag>100-999 :</tag>
	    <item>
	      <p>
Utilisateurs et groupes-système attribués dynamiquement. Les paquets qui 
ont besoin d'un utilisateur ou d'un groupe et qui
tolèrent que cet identifiant soit attribué dynamiquement et différemment
sur chaque système, utiliseront <tt>adduser --system</tt>
pour la création d'un tel groupe et/ou utilisateur.
Le programme <prgn>adduser</prgn> vérifie qu'un tel groupe ou utilisateur
n'existe pas déjà et utilise si nécessaire un autre identifiant dans l'
intervalle spécifié par <tt>adduser.conf</tt>.
 </p>
</item>

	    <tag>1000-29999 :</tag>
	    <item>
	      <p>
Comptes utilisateurs attribués dynamiquement. Par défaut, <prgn>adduser</prgn> 
choisit  les «&nbsp;UIDs&nbsp;» et les «&nbsp;GIDs&nbsp;» pour les comptes 
utilisateurs dans cet intervalle, bien que <tt>adduser.conf</tt> puisse 
modifier ce comportement.
 </p>
</item>

	    <tag>30000-59999 :</tag>
	    <item>
	      <p>Usage réservé.</p></item>
		
		
	    <tag>60000-64999 :</tag>
	    <item>
	      <p>
Attribués en bloc par le projet Debian, mais ils ne sont créés
qu'à la demande. Les identifiants sont attribués de manière fixe et centralisée
mais les comptes ne sont effectivement créés sur le système qu'à la demande.
 </p>
		
	      <p>
Ces identifiants sont réservés à des paquets obscurs ou à des paquets qui 
demandent de nombreux identifiants attribués de manière fixe. Ces paquets 
doivent s'assurer de l'inexistence de ces comptes dans <tt>/etc/passwd</tt> 
ou dans <tt>/etc/group</tt> et les créer eux-mêmes si nécessaire (en utilisant
si possible <prgn>adduser</prgn>).
Les paquets qui risquent d'avoir besoin de davantage d'identifiants, 
se réserveront un intervalle d'attribution plus large que de besoin, laissant
ainsi des possibilités de développement.
</p>
</item>
		
		
	    <tag>65000-65533 :</tag>
	    <item>
	      <p>Usage réservé.</p></item>
		
		
	    <tag>65534 :</tag>
	    <item>
<p>
Utilisateur <tt>nobody</tt>. Le «&nbsp;gid>&nbsp;» correspondant renvoie au 
groupe <tt>nogroup</tt>.
</p>
</item>
		
		
	    <tag>65535 :</tag>
	    <item>
	      <p>
		<tt>(uid_t)(-1) == (gid_t)(-1)</tt>. <em>Ne doit pas</em> être
utilisé car il s'agit de la valeur sentinelle pour retourner une erreur.
 </p>
	    </item>
	  </taglist>
	</p>
      </sect>
      <sect id="sysvinit">
	<heading>Les niveaux de fonctionnement du système et les scripts dans <tt>init.d</tt></heading>
	  
	
	<sect1 id="/etc/init.d">
	  <heading>Introduction</heading>
	    
	  <p>
Le répertoire <tt>/etc/init.d</tt> contient les scripts exécutés
par <prgn>init</prgn> quand le système démarre et quand l'état
de <prgn>init</prgn> (son «&nbsp;niveau de fonctionnement&nbsp;») est modifié 
(voir <manref name="init" section="8">).
</p>

          <p>
Il y a au moins deux façons, différentes mais fonctionnellement équivalentes,
de se servir de ces scripts. Pour rester simple, on décrit ici la méthode des
liens symboliques. Les scripts du responsable ne doivent cependant pas 
présumer que cette méthode est utilisée, et toute manipulation automatisée 
du comportement des différents niveaux de fonctionnement doit être faite 
avec le programme <prgn>update-rc.d</prgn> comme décrit plus bas, et non pas 
en créant ou en supprimant soi-même les liens symboliques.
Voyez la documentation du paquet <tt>file-rc</tt> pour des renseignements sur 
la mise en oeuvre de l'autre méthode.
</p>

          <p>
Ces scripts sont référencés par des liens symboliques dans les
répertoires <tt>/etc/rc<var>n</var>.d</tt>. Lorsque le niveau
de fonctionnement change, <prgn>init</prgn> recherche les scripts qu'il doit 
exécuter dans le répertoire <tt>/etc/rc<var>n</var>.d</tt>, où 
<tt><var>n</var></tt> est soit le niveau de fonctionnement demandé soit 
<tt>S</tt> pour le démarrage. 
</p>
          <p>
Les noms de ces liens sont tous de la forme 
<tt>S<var>mm</var><var>script</var></tt> ou de la forme
<tt>K<var>mm</var><var>script</var></tt> ;
<var>mm</var> est un nombre à deux chiffres et <var>script</var>
est le nom du script (qui sera le même que le
véritable script dans <tt>/etc/init.d</tt>).
</p>
	    
          <p>
Lorsque <prgn>init</prgn> change de niveau de fonctionnement, il exécute
d'abord les scripts référencés par les liens dont le nom commence
par <tt>K</tt>, chacun avec un seul argument : <tt>stop</tt>. Puis
<prgn>init</prgn> exécute les scripts préfixés par <tt>S</tt>, avec pour 
chacun un seul argument : <tt>start</tt>. (Les liens appartiennent au 
répertoire de <tt>/etc/rc<var>n</var>.d</tt> qui correspond au nouveau
niveau de fonctionnement.) Les liens <tt>K</tt> sont chargés d'arrêter les 
services et les liens <tt>S</tt> de démarrer les services au démarrage du
niveau de fonctionnement.
</p>
	  <p>
Par exemple, pour passer du niveau 2 au niveau 3, <prgn>init</prgn>
exécutera d'abord tous les scripts préfixés par <tt>K</tt> qu'il trouve dans
<tt>/etc/rc3.d</tt>, puis tous les scripts de ce répertoire préfixés par 
<tt>S</tt>.
Les liens qui commencent par <tt>K</tt> entraîneront l'exécution
des scripts qu'ils référencent avec l'argument <tt>stop</tt> alors que les
liens <tt>S</tt> entraîneront l'exécution des scripts avec
l'argument <tt>start</tt>.
</p>
	    
	  <p>
Le nombre à deux chiffres <var>mm</var> est utilisé pour
décider de l'ordre d'exécution des scripts&nbsp;: les scripts de numéros les 
plus faibles sont exécutés en priorité. Par exemple les scripts <tt>K20</tt>
seront exécutés avant les scripts <tt>K30</tt>. Cela sert quand un service 
doit être démarré avant un autre. Par exemple, il peut être nécessaire de 
démarrer le serveur de noms <prgn>bind</prgn> avant le serveur de news
<prgn>inn</prgn> afin que <prgn>inn</prgn> puisse
positionner ses listes d'accès.
Dans ce cas, le script de démarrage de <prgn>bind</prgn> doit
avoir un numéro plus faible que le script qui démarre <prgn>inn</prgn>:
      <example compact="compact">
/etc/rc2.d/S17bind
/etc/rc2.d/S70inn
      </example>
</p>

<p>
Les deux niveaux 0 (halt) et 6 (reboot) sont légèrement différents. Dans ces
niveaux, les liens préfixés par <tt>S</tt> sont toujours appelés après les 
liens préfixés par <tt>K</tt>, mais ils sont aussi appelés avec l'unique
argument <tt>stop</tt>.
	  </p>
<p>
De plus, quand le nom du script se termine par <tt>.sh</tt>, le script sera
créé dans le niveau <tt>S</tt> plutôt que d'être exécuté dans un sous-processus
«&nbsp;forké&nbsp;», et dans tous les autres niveaux il sera exécuté par le
programme <prgn>sh</prgn>.
	  </p>

	</sect1>
	  
	<sect1>
	  <heading>L'écriture des scripts</heading>
	    
	  <p>
Les paquets qui mettent en service des «&nbsp;démons&nbsp;» mettront des 
scripts dans <tt>/etc/init.d</tt> pour démarrer ou arrêter des services au 
moment de l'amorçage ou pour un changement du niveau de fonctionnement.
Ces scripts seront nommés <tt>/etc/init.d/<var>paquet</var></tt> et ne 
doivent prendre qu'un seul argument, lequel indique ce qu'il faut faire :
	    
	    <taglist>
	      <tag><tt>start</tt></tag>
	      <item><p>démarrer le service,</p></item>
		  
	      <tag><tt>stop</tt></tag>
	      <item><p>arrêter le service,</p></item>
		  
	      <tag><tt>restart</tt></tag>
	      <item><p>arrêter et redémarrer le service,</p></item>
		  
	      <tag><tt>reload</tt></tag>
	      <item><p>chargement d'une nouvelle configuration 
du service sans réellement arrêter et redémarrer le service,
 </p>
</item>
		  
	      <tag><tt>force-reload</tt></tag> <item><p> 
chargement d'une nouvelle configuration si le service le permet,
sinon redémarrer le service.
 </p>
</item>
	    </taglist>
	    
	    Les options <tt>start</tt>, <tt>stop</tt>, <tt>restart</tt>, et
<tt>force-reload</tt> seront acceptées par tous les scripts
de <tt>/etc/init.d</tt> ; l'option <tt>reload</tt> est facultative.
</p>
	    
	  <p>
Les scripts de <tt>/etc/init.d</tt> auront un comportement raisonnable quand 
ils sont appelés avec l'option <tt>start</tt> alors que le service tourne 
déjà. Il en est de même pour l'option <tt>stop</tt> quand le service
ne tourne pas. Ils ne doivent pas tuer des processus utilisateurs
appelés par mégarde.
Le meilleur moyen est généralement d'utiliser <prgn>start-stop-daemon</prgn>.
</p>
<p>
Quand un service recharge automatiquement sa configuration (comme
c'est le cas de <prgn>cron</prgn> par exemple),
l'option <tt>reload</tt> du script dans <tt>/etc/init.d</tt> 
se comportera comme si la configuration avait été rechargée avec succès.
</p>	    
	    
<p>
Les scripts dans <tt>/etc/init.d</tt> seront considérés comme des fichiers de
configuration, soit en les marquant comme des <tt>conffile</tt>s, soit en les
gérant correctement dans les scripts du responsable de paquet (voir <ref
id="config files">). C'est important car nous voulons laisser à 
l'administrateur système la possibilité d'adapter ces scripts à son système 
local -- par exemple, désactiver un service sans désinstaller le paquet,
ou bien spécifier des options particulières sur la ligne de commande au
démarrage d'un service -- tout en assurant que ses modifications ne seront
pas perdues lors de la prochaine mise à jour du paquet.
</p>

	  <p>
Ces scripts ne doivent pas échouer de façon obscure quand ils trouvent dans
le système les fichiers de configuration d'un paquet supprimé ; en effet par
défaut, <prgn>dpkg</prgn> conserve ces fichiers de configuration et ne les 
supprime qu'avec l'option <tt>--purge</tt>. En particulier, comme le script 
<tt>init</tt> lui-même est un fichier de configuration (voir 
<ref id="/etc/init.d">), il reste sur le système quand le paquet est supprimé 
avec l'option <tt>remove</tt> et non pas avec l'option <tt>purge</tt>. C'est 
pourquoi vous inclurez une instruction de <tt>test</tt> au début du script, 
comme par exemple :
	    <example compact="compact">
test -f <var>programme-exécuté-plus-tard-dans-le-script</var> || exit 0
	    </example>
</p>
<p>
 Dans les scripts <tt>init.d</tt>, il y a souvent des valeurs
que l'administrateur voudra changer fréquemment. Modifier ces scripts qui
sont souvent des <em>conffiles</em> demande que l'administrateur rajoute
ses modifications à chaque mise à jour du paquet et à chaque modification
des <em>conffiles</em>. Pour rendre la vie des administrateurs système moins
dure, on ne placera pas de telles valeurs configurables directement dans le
script mais plutôt dans un fichier <tt>/etc/default</tt> qui aura, de façon
classique, le même préfixe que le script <tt>init.d</tt>. Ce 
fichier supplémentaire sera lu quand le script démarre. Il doit contenir
seulement les définitions des variables et des commentaires dans le format
POSIX <prgn>sh</prgn>. Ce peut être aussi bien un <tt>conffile</tt> qu'un
fichier de configuration maintenu avec les scripts du responsable de paquet.
Voir <ref id="config files"> pour des précisions.
</p>

<p>
Pour s'assurer que des valeurs vitales sont toujours définies et disponibles,
le script <tt>init.d</tt>, indiquera, avant de lire le fichier 
<tt>/etc/default/</tt>, une valeur par défaut pour chaque variable du shell 
dont il se sert ; soit avant de lire le fichier <tt>/etc/default/</tt>, soit
après avoir utilisé une syntaxe de ce genre : <tt>${VAR:=default}</tt>. Et
le script <tt>init.d</tt> doit se comporter raisonnablement et sans échec 
quand le fichier <tt>/etc/default</tt> est supprimé.
	  </p>
	</sect1>

	  
	<sect1>
	  <heading>La gestion des liens</heading>
	    
	  <p>
Avec le programme <prgn>update-rc.d</prgn>, les responsables de paquet peuvent
gérer la création et la suppression des liens symboliques dans 
<tt>/etc/rc<var>n</var>.d</tt>, ou de leurs équivalents fonctionnels quand une
autre méthode est employée.
Les responsables de paquet peuvent s'en servir dans leurs scripts 
<prgn>postinst</prgn> et <prgn>postrm</prgn>.</p>

	  <p>
On ne doit pas inclure des liens symboliques dans le 
<tt>/etc/rc<var>n</var>.d</tt> du système réel, ni en créer ou en supprimer 
directement dans les scripts du responsable de paquet (cela échouera si le 
système d'information sur les niveaux de fonctionnement utilise une autre 
méthode)&nbsp;: on doit utiliser le programme <prgn>update-rc.d</prgn>. On ne
doit pas non plus inclure les répertoires <tt>/etc/rc<var>n</var>.d</tt> dans 
l'archive. (Seul le paquet <tt>sysvinit</tt> peut le faire.)
</p>
	  <p>
Par défaut, <prgn>update-rc.d</prgn> démarrera les serveurs
dans chacun des niveaux de fonctionnement du système (2, 3, 4 et 5) pour le
mode multi-utilisateurs et les arrêtera dans le niveau (0) mode halt,
le niveau (1) mode mono-utilisateur  et le niveau (6) mode reboot.
L'administrateur système pourra paramétrer les
niveaux de fonctionnement soit en ajoutant, supprimant ou déplaçant
les liens symboliques contenus dans <tt>/etc/rc<var>n</var>.d</tt> si la 
méthode des liens symboliques est utilisée, soit en modifiant 
<tt>/etc/runlevel.conf</tt> quand on utilise la méthode <tt>file-rc</tt>.</p>

	  <p>
Pour obtenir le comportement par défaut pour votre paquet,
mettez dans le script <prgn>postinst</prgn> :
	   
	    <example compact="compact">
update-rc.d <var>paquet</var> defaults &gt;/dev/null
	    </example>
	    et dans votre <prgn>postrm</prgn>
	    <example compact="compact">
if [ "$1" = purge ]; then
update-rc.d <var>paquet</var> remove &gt;/dev/null
fi
	    </example></p>
	    
	  <p>
Le numéro d'ordre d'exécution par défaut sera égal à 20. Si l'ordre ou
le moment d'exécution du script <tt>init.d</tt> sont indifférents, utilisez
cette valeur par défaut. S'ils sont importants, vous devez en discuter avec le
responsable du paquet <prgn>sysvinit</prgn> ou envoyer
un message à <tt>debian-devel</tt>. Ceci devrait vous
aider à déterminer le numéro d'ordre d'exécution.
</p>
	    
	  <p>
Pour plus d'informations sur l'utilisation d'<tt>update-rc.d</tt>,
veuillez consulter sa page de manuel
<manref name="update-rc.d" section="8">.
</p>

</sect1>
	    
	    
	<sect1>
	  <heading>L'initialisation au moment de l'amorçage</heading>
	    
          <p>
Classiquement, un autre répertoire, <tt>/etc/rc.boot</tt>, contenait les
scripts exécutés seulement au démarrage. Mais on préfère maintenant
se servir de liens de <tt>/etc/rcS.d</tt> vers les fichiers dans
<tt>/etc/init.d</tt>, comme décrit dans <ref id="/etc/init.d">.
Aucun paquet ne doit placer de fichiers dans <tt>/etc/rc.boot</tt>.</p>
</sect1>

	    
	<sect1>
	  <heading>Exemple</heading>
	    
	  <p>
Le paquet <prgn>bind</prgn>, un serveur de noms de domaine (DNS),
veut s'assurer que le serveur de noms s'exécute
à un niveau de fonctionnement multi-utilisateurs et qu'il est
correctement fermé à l'arrêt du système.
Il place un script dans <tt>/etc/init.d</tt> et le nomme
judicieusement <tt>bind</tt>.  Comme vous pouvez le constater,
le script interprète l'argument <tt>reload</tt> pour envoyer
le signal <tt>HUP</tt> au serveur de nom (ce qui provoque
le rechargement de sa configuration) ;
de cette manière, l'administrateur système peut utiliser la commande
<tt>/etc/init.d/bind reload</tt> pour recharger la configuration
du serveur de noms. Ce script possède une valeur configurable qu'on
peut utiliser pour passer des paramètres au programme <prgn>named</prgn>
lors du lancement ; cette valeur est lue dans <tt>/etc/default/bind</tt> (voir
plus bas).
</p>
	    
	  <p>
	    <example compact="compact">
#!/bin/sh
#
# Original version by Robert Leslie
# &lt;rob@mars.org&gt;, edited by iwj and cs

test -x /usr/sbin/named || exit 0

# Source defaults file.
PARAMS=''
if [ -f /etc/default/bind ]; then
  . /etc/default/bind
fi

case "$1" in
start)
   echo -n "Starting domain name service: named"
   start-stop-daemon --start --quiet --exec /usr/sbin/named \
                     -- $PARAMS
   echo "."
   ;;
stop)
   echo -n "Stopping domain name service: named"
   start-stop-daemon --stop --quiet  \
      --pidfile /var/run/named.pid --exec /usr/sbin/named
    echo "."
   ;;
restart)
    echo -n "Restarting domain name service: named"
    start-stop-daemon --stop --quiet  \
      --pidfile /var/run/named.pid --exec /usr/sbin/named
    start-stop-daemon --start --verbose --exec /usr/sbin/named \
                      -- $PARAMS
    echo "."
  ;;
force-reload|reload)
  echo -n "Reloading configuration of domain name service: named"
  start-stop-daemon --stop --signal 1 --quiet  \
      --pidfile /var/run/named.pid --exec /usr/sbin/named
  echo "."
  ;;
*)
  echo "Usage: /etc/init.d/bind {start|stop|restart|reload|force-reload}" >&2
  exit 1
  ;;
esac

exit 0
    </example>
</p>
	    
	  <p>
Le fichier de configuration <tt>/etc/default/bind</tt> est un complément pour
le script init ci-dessus ; il contient des paramètres configurables 
qu'utilise ce script. Il pourrait être créé par le script <prgn>postinst</prgn>
s'il n'existait pas, et supprimé (<em>purge</em>) par le script
<prgn>postrm</prgn>.
	  </p>
<p>
           <example compact="compact">
# Specified parameters to pass to named. See named(8).
# You may uncomment the following line, and edit to taste.
# PARAMS="-u nobody"
           </example>
         </p>
<p>
Un autre exemple sur lequel baser
les scripts de <tt>/etc/init.d</tt> se trouve dans
<tt>/etc/init.d/skeleton</tt>.
</p>
	    
	  <p>
Si ce paquet se satisfait des valeurs par défaut
de <prgn>update-rc.d</prgn>, en l'occurrence un numéro
d'ordre d'exécution égal à 20 et l'exécution dans tous les niveaux
de fonctionnement, il peut indiquer dans son script
<prgn>postinst</prgn>:
	    <example compact="compact">
update-rc.d bind defaults >/dev/null
	    </example>
et dans son script <prgn>postrm</prgn>, pour supprimer les liens
quand le paquet est <em>purgé</em> :
	    <example compact="compact">
if [ "$1" = purge ]; then
   update-rc.d bind remove >/dev/null
fi
	    </example></p>
	</sect1>
</sect>
	

      <sect>
	<heading>Les messages de la console provenant des scripts <tt>init.d</tt></heading>
	  
	<p>
Cette section décrit les formats des messages que les scripts du
répertoire <tt>/etc/init.d</tt> écrivent sur la sortie standard.
L'objectif est d'améliorer la cohérence du style Debian
en matière de séquences de démarrage et d'arrêt d'un système. Pour cette
raison, veuillez faire très attention aux détails. Nous voulons que les 
messages standardisés fassent une utilisation identique des espaces, de la 
ponctuation et de la casse des lettres.
</p>	  
	<p>
Voici une liste des règles générales à respecter pour la création
de messages en sortie. Elles peuvent être utiles si vous avez des messages non
standards qui ne sont pas abordés par les sections suivantes.
</p>
	<p>
	  <list>
	    <item>
	      <p>
 Tous les messages tiendront sur une ligne (inférieure à 80 caractères). Ils 
commenceront par une  capitale et se termineront par un point «&nbsp;.&nbsp;»
et un saut de ligne (<tt>"\n"</tt>).
 </p>
</item>		

		
<item>
	      <p>
Quand vous voulez signaler que l'ordinateur est occupé (exécution d'une
tâche particulière et non pas le démarrage ou la fermeture d'un programme),
utilisez une «&nbsp;ellipse&nbsp;», à savoir trois points <tt>...</tt>. 
Vous remarquerez que nous n'insérons pas d'espace avant ou après les points. 
Quand la tâche est terminée nous écrivons <tt>done.</tt> et un retour à 
la ligne.
 </p>
</item>
		
	    <item>
	      <p>
Concevez vos messages comme si l'ordinateur vous disait ce qu'il fait
(rendez-le poli :-), mais n'en faites pas un personnage.
Par exemple, si vous voulez dire :
		<example compact="compact">
I'm starting network daemons: nfsd mountd.
		</example>
		dites simplement :
		<example compact="compact">
Starting network daemons: nfsd mountd.
		</example>
</p>
</item>
	  </list>
</p>
	  
	<p>
Il y a des messages standards pour les situations suivantes. Ils seronts
utilisés par les scripts d'<tt>init.d</tt>.
</p>
	  
	<p>
	  <list>
	    <item>
	      <p>au lancement d'un démon.</p>
		
	      <p>
Utilisez ce format si votre script démarre un ou plusieurs démons.
Le message en sortie (une seule ligne, sans espace au début)
doit ressembler à ceci&nbsp;:
		<example compact="compact">
Starting <var>description</var>: <var>daemon-1</var> ... <var>daemon-n</var>.
		</example>
	L'élément <var>description</var> décrira le sous-système dont fait 
partie le ou les démons alors que les éléments de <var>daemon-1</var> jusqu'à 
<var>daemon-n</var> indiqueront chacun le nom du démon (habituellement le nom 
du fichier programme).
</p>			
	      <p>
Par exemple, la sortie de <tt>/etc/init.d/lpd</tt> ressemble à :
		<example compact="compact">
Starting printer spooler: lpd.
		</example>
</p>
		
	      <p>
Ce qui peut être obtenu en écrivant dans le script :
		<example compact="compact">
echo -n "Starting printer spooler: lpd"
start-stop-daemon --start --quiet --exec /usr/sbin/lpd
echo "."
		</example>
Si vous avez plusieurs démons à démarrer, vous pouvez écrire le code
suivant :
		<example compact="compact">
echo -n "Starting remote file system services:"
echo -n " nfsd"; start-stop-daemon --start --quiet nfsd
echo -n " mountd"; start-stop-daemon --start --quiet mountd
echo -n " ugidd"; start-stop-daemon --start --quiet ugidd
echo "."
		</example>
L'utilisateur peut savoir ainsi ce qui prend tant de temps et quand
le dernier démon a été démarré. Vous serez précis avec les espaces : dans 
l'exemple précédent un administrateur système
peut facilement commenter une ligne s'il ne veut pas lancer un démon
particulier; le message affiché reste correct.
 </p>
</item>
		
	    <item>
	      <p>quand un paramètre système est positionné</p>
		
	      <p>
Si vous devez positionner différents paramètres au démarrage du système,
vous utiliserez ce format :
		<example compact="compact">
Setting <var>parameter</var> to `<var>value</var>'.
		</example></p>
		
	      <p>
vous pouvez utiliser le message suivant qui place correctement les
guillemets :
		<example compact="compact">
echo "Setting DNS domainname to \`$domainname'."
		</example></p>
		
	      <p>

Il faut noter que l'apostrophe à gauche (`) est différente de l'apostrophe à 
droite (').
		</p></item> 
	      
	    <item>
	      <p>quand on arrête ou relance un démon.</p>
		
	      <p>
Quand vous arrêtez ou relancez un démon, vous devez afficher un message 
similaire à celui du démarrage en remplaçant <tt>Starting</tt> par 
<tt>Stopping</tt> ou <tt> Restarting</tt>.
 </p>
		
	      <p>
Le message à l'arrêt du démon printer sera :
		<example compact="compact">
Stopping printer spooler: lpd.
		</example></p></item>
	      
	    <item>
	      <p>quand on exécute un programme.</p>
		
	      <p>
Il y a plusieurs cas où vous devez lancer un programme soit au démarrage
soit à l'arrêt du système pour exécuter des tâches spécifiques. Par
exemple, initialiser l'heure système à l'aide de <prgn>netdate</prgn> ou 
bien tuer tous les processus à l'arrêt du système. Vos messages suivront
cet exemple :
		<example compact="compact">
Doing something very useful...done.
		</example>
Vous afficherez le <tt>done.</tt> immédiatement après la fin de la tâche
de manière que l'utilisateur soit renseigné sur le pourquoi de son attente.
Pour cela, mettez dans votre script :
		<example compact="compact">
echo -n "Doing something very useful..."
do_something
echo "done."
		</example>
</p></item>
	      
	    <item>
	      <p>Quand la configuration est rechargée</p>
		
	      <p>
Quand un démon est forcé de recharger ses fichiers de configuration,
vous utiliserez des messages qui suivent le format suivant :
		<example compact="compact">
Reloading <var>description</var> configuration...done.
		</example>
où <var>description</var> est identique au message de démarrage du démon.
</p>
</item>
	  </list></p>
      </sect>
      <sect>
	<heading>Les travaux de «&nbsp;Cron&nbsp;»</heading>
	  
	<p>
Les paquets ne doivent pas modifier le fichier de configuration
<tt>/etc/crontab</tt>, ni les fichiers contenus dans
<tt>/var/spool/cron/crontabs</tt>.
</p>
	  
	<p>
Quand un paquet veut confier une tâche au programme <prgn>cron</prgn>,
il placera un fichier de même nom que lui dans l'un des répertoires
suivants :
	  <example compact="compact">
/etc/cron.daily
/etc/cron.weekly
/etc/cron.monthly
	  </example>
Comme l'indique le nom de ces répertoires,
les fichiers  sont exécutés une fois par jour, une fois par semaine ou 
une fois par mois.
Le rythme exact est contenu dans <tt>/etc/crontab</tt>.</p>
	<p>
Tous les fichiers installés dans l'un de ces répertoires
doivent être des scripts (scripts shell, perl, etc.)
pour que l'administrateur du système local puisse facilement les modifier.
De plus ils seront traités comme des fichiers de configuration.
</p>
<p>
Quand une tâche doit s'exécuter plus souvent
que quotidiennement, le paquet installera un fichier 
<tt>/etc/cron.d/<var>paquet</var></tt>. Ce fichier a la même 
syntaxe que le fichier <tt>/etc/crontab</tt> et est traité automatiquement
par <prgn>cron</prgn>. Il doit aussi être considéré comme un fichier de 
configuration. (On remarquera que le programme <prgn>anacron</prgn> ne se sert
pas des scripts dans le répertoire <tt>/etc/cron.d</tt>. Vous ne 
l'utiliserez donc que pour des tâches qui peuvent être omises si le système
ne tourne pas.)
</p>
	<p>

Les scripts ou les entrées de la «&nbsp;crontab&nbsp;» dans ces répertoires 
doivent vérifier d'abord la présence de tous les fichiers nécessaires à
leur exécution. Sinon, il y aura des problèmes avec les paquets 
qui ont été supprimés sans l'option «&nbsp;purge&nbsp;»,
car, dans ce cas, les fichiers de configuration sont conservés.
</p>
</sect>
	  
	  
      <sect>
	<heading>Les menus</heading>

	<p>
Sur <ftpsite>ftp.debian.org</ftpsite> ou sur un miroir local, on peut trouver
le fichier <ftppath>/debian/doc/package-developer/menu-policy.txt.gz</ftppath>
qui expose la politique actuelle concernant les rubriques d'un menu.
Ce texte, <tt>menu-policy</tt>, est aussi dans le paquet 
<tt>debian-policy</tt>.
	</p>

	<p>
Le paquet Debian <tt>menu</tt> propose une interface standard entre les
paquets qui fournissent des applications ou des documents et
<em>les programmes offrant des menus</em> (aussi bien des gestionnaires de
fenêtres sous X  que des programmes qui fournissent des menus en mode
texte, comme par exemple <prgn>pdmenu</prgn>).
</p>
	  
	<p>
Les paquets renseigneront une rubrique de menu pour toutes les 
applications qui, pour leur usage normal, n'ont pas besoin 
de recevoir d'argument particulier depuis la ligne de commande.
Ainsi les utilisateurs du paquet <em>menu</em> auront automatiquement des 
rubriques de menu pour ces applications dans leurs 
gestionnaires de fenêtres et dans des shells comme <tt>pdmenu</tt>.
</p>
	  
	<p>
Veuillez-vous référer au document <em>Debian Menu System</em>
livré avec le paquet <tt>menu</tt> pour plus d'information
sur la manière de déclarer vos applications et vos documents web.
</p>
</sect>
	
      <sect>
	<heading>Outils pour le multimédia </heading>
	
	<p>
Les paquets qui proposent des solutions pour lire, afficher, jouer, composer,
modifier ou imprimer les types «&nbsp;MIME&nbsp;» déclareront cette 
capacité, et se conformeront ainsi à l'actuelle politique concernant
«&nbsp;MIME&nbsp;», telle qu'elle est définie dans le fichier 
<tt>mime-policy</tt> du paquet <tt>debian-policy</tt> ou dans le fichier
<ftppath>/debian/doc/package-developer/mime-policy.txt.gz</ftppath> ; fichier 
qu'on peut trouver sur <ftpsite>ftp.debian.org</ftpsite>
ou sur un miroir local.

	<p>
	  MIME (Multipurpose Internet Mail Extensions, RFC 2045-2049) est une
manière de coder les fichiers et les flux de données et de donner des
informations supplémentaires, telles que, par exemple, leur type (c.-à-d. 
audio ou vidéo) et leur format (c.-à-d. PNG, HTML, MP3).

	</p>
	
	<p>
La déclaration de cette capacité à traiter les types «&nbsp;MIME&nbsp;» 
permet à des programmes comme les logiciels de courrier (mua) ou les butineurs
web de faire appel à ces outils pour lire, éditer ou afficher les types 
«&nbsp;MIME&nbsp;» qu'ils ne supportent pas directement.
	</p>
      </sect>

      <sect>
	<heading>La configuration du clavier</heading>
	  
	<p>
Pour obtenir une configuration cohérente du clavier de façon que tous
les programmes interprètent les événements clavier de la même manière, 
tous les programmes de la distribution
Debian doivent suivre les directives suivantes :
</p>
	  
	<p>
Les touches suivantes doivent être interprétées ainsi&nbsp;:
	  
	  <taglist>
	    <tag><tt>&lt;--</tt></tag>
	    <item><p>supprime le caractère à gauche du curseur</p></item>
		
	    <tag><tt>Delete</tt></tag>
	    <item><p>supprime le caractère à droite du curseur</p></item>
		
	    <tag><tt>Control+H</tt></tag>
	    <item><p>emacs : le préfixe d'aide</p></item>
	  </taglist>
	  
L'interprétation des événements clavier sera indépendante du terminal utilisé 
(la console, X Window, une session rlogin ou telnet, etc.).
</p>
	  
	<p>
La liste suivante explique comment les différents programmes
seront configurés pour y arriver :
</p>
	  
	<p>
	  <list>
	    <item><p><tt>&lt;--</tt> génère KB_Backspace sous X.</p></item> 
		
	    <item><p><tt>Delete</tt> génère KB_Backspace sous X.</p></item>
		
	    <item>
	      <p>
Le mécanisme «&nbsp;X translations&nbsp;» est configuré pour que 
<tt>KB_Backspace</tt> déclenche ASCII DEL et que <tt>KB_Delete</tt> déclenche 
<tt>ESC [ 3 ~</tt> (c'est la séquence d'échappement du vt220 pour la touche 
«&nbsp;delete character&nbsp;»).
Il faut charger les ressources sur tous les serveurs
locaux «&nbsp;X&nbsp;» à l'aide de <prgn>xrdb</prgn> et ne pas utiliser les «&nbsp;défauts&nbsp;» 
des applications pour que les ressources de
translation correspondent aux choix de <prgn>xmodmap</prgn>.
</p>
</item>
		
	    <item>
	      <p>
	La console Linux est configurée pour que la touche <tt>&lt;--</tt>
déclenche DEL et <tt>Delete</tt> déclenche <tt>ESC [ 3 ~</tt>. 
</p></item>
	    <item><p>
Les applications X sont configurées pour que <tt>&lt;</tt> efface 
à gauche et <tt>Delete</tt> efface à droite. Les applications Motif 
fonctionnent déjà de cette manière.
 </p>
</item>
		
	    <item><p>Les terminaux auront stty erase à <tt>^?</tt> .</p></item>
		
	    <item><p>
L'entrée <tt>xterm</tt> dans terminfo aura <tt>ESC [ 3~</tt> 
pour <tt>kdch1</tt>, tout comme <tt>TERM=linux</tt> et <tt>TERM=vt220</tt>.
 </p>
</item>	
		
	    <item><p>
Emacs est programmé pour associer <tt>KB_Backspace</tt> ou le caractère
<tt>stty erase</tt> à <tt>delete-backward-char</tt>. Il associe 
<tt>KB_Delete</tt> ou <tt>kdch1</tt> à <tt>delete-forward-char</tt> et 
associe <tt>^H</tt> à <tt>help</tt> comme toujours.
 </p>
</item>
		
	    <item><p>
D'autres applications utilisent le caractère <tt>stty erase</tt> et 
<tt>kdch1</tt> comme deux touches d'effacement. ASCII DEL est la 
«&nbsp;suppression du caractère précédent&nbsp;». <tt>kdch1</tt> est la 
«&nbsp;suppression du caractère sous le curseur&nbsp;».
 </p>
</item>
	  </list>
</p>
	  
	<p>
Tout ceci résout le problème sauf dans les cas suivants :
	</p>
	  
	<p>
	  <list>
	    <item><p>
Certains terminaux ont une touche <tt>&lt;--</tt> qui ne peut pas
produire autre chose que <tt>^H</tt>. Sur ces terminaux l'aide
d'Emacs ne sera pas accessible à partir de <tt>^H</tt> (en supposant
que le caractère «&nbsp;stty erase&nbsp;» est prioritaire dans Emacs et qu'il 
ait été bien configuré). Les touches <tt>M-x help</tt> ou <tt>F1</tt> (si 
elles sont disponibles) peuvent être utilisées en remplacement.
 </p>
</item>
			
	    <item><p>
Certains systèmes utilisent <tt>^H</tt> pour <tt>stty erase</tt>. 
Cependant les versions modernes de <prgn>telnet</prgn> et toutes les versions
de <prgn>rlogin</prgn> diffusent les configurations <tt>stty</tt>. Presque
toutes les versions d'UNIX acceptent <tt>stty erase</tt>. Quand la 
configuration <tt>stty</tt> n'est pas reproduite correctement, on peut 
résoudre le problème en utilisant <tt>stty</tt> manuellement.
</p></item>
		
	    <item><p>
Certains systèmes (notamment des versions antérieures de Debian) utilisent
<prgn>xmodmap</prgn> pour que <tt>&lt;--</tt> et <tt>Delete</tt> 
déclenchent <tt>KB_Delete</tt>. Nous pouvons changer le comportement de 
leurs clients X à 
l'aide des mêmes ressources que nous avons utilisées ou bien 
configurer nos propres clients avec les ressources de ces systèmes dans le cas
inverse. Sur des serveurs configurés de cette manière, <tt>&lt;--</tt>
fonctionnera mais pas <tt>Delete</tt>.
 </p>
</item>
		
	    <item><p>
Certains systèmes d'exploitation ont d'autres configurations pour 
<tt>kdch1</tt> dans leur base de données <tt>terminfo</tt> pour <tt>xterm</tt>
et consort. Sur ces systèmes, la touche <tt>Delete</tt> ne fonctionnera pas 
quand vous vous connecterez depuis un système qui suit notre politique. Mais 
<tt>&lt;--</tt> fonctionnera.
 </p>
</item>
</list>
</p>
</sect>
	  
      <sect>
	<heading>Les variables d'environnement</heading>
	  
	<p>
Un programme ne doit pas dépendre des variables d'environnement
pour déterminer des valeurs par défaut
(cela impliquerait de définir ces variables globalement au niveau
du système par exemple dans <tt>/etc/profile</tt>, ce que tous les shells 
ne permettent pas).
</p>
	<p>
Quand un programme dépend de variables d'environnement
pour sa configuration, il doit prévoir, en leur absence, une configuration
raisonnable par défaut.
Si c'est difficile à faire (p.ex. quand le code source d'un programme non 
libre n'est pas disponible), le programme doit être remplacé par un petit 
shell script enveloppant («&nbsp;wrapper&nbsp;») qui positionne les variables 
d'environnement et appelle le programme initial.
</p>
	<p>
Voici un exemple de script enveloppant écrit dans ce but :
	  
	  <example compact="compact">
#!/bin/sh
BAR=${BAR:-/var/lib/fubar}
export BAR
exec /usr/lib/foo/foo "$@"
          </example></p>
	  
	<p>
De plus, comme <tt>/etc/profile</tt> est un fichier de configuration
du paquet <prgn>bash</prgn>, aucun autre paquet ne peut y ajouter
des variables d'environnement ou des commandes.
</p>
</sect>
</chapt>

    <chapt id="11">
	<heading>Les fichiers</heading>
	  
	
	<sect>
	  <heading>Les fichiers binaires</heading>
	    
	  <p>
Deux paquets ne doivent pas installer des programmes qui ont des
fonctions différentes tout en ayant le même nom.
(Le cas de deux programmes avec les mêmes fonctionnalités
mais des implémentations différentes est traité <em>via</em> 
«&nbsp;alternatives&nbsp;» ou par le mécanisme «&nbsp;Conflicts&nbsp;». Voir
<ref id="maintscripts"> et <ref id="conflicts">.)
Si ce cas se produit, un des deux programmes doit changer de nom.
Les responsables rapporteront ce problème sur la liste de distribution
<tt>debian-devel</tt> pour essayer de trouver un consensus. Si aucun 
consensus n'est trouvé, les noms des <em>deux</em> programmes doivent être 
changés.
</p>
	    
	  <p>
Généralement on utilisera les paramètres de compilation suivants :
              <example compact="compact">
CC = gcc 
CFLAGS = -O2 -g -Wall # sane warning options vary between programs 
LDFLAGS = # none 
install -s # (or use strip on the files in debian/tmp)
             </example></p>
	    
	  <p>
On remarquera que tous les binaires installés sont épurés de tout
symbole, soit en utilisant l'option <tt>-s</tt> de <prgn>install</prgn>,
soit en appliquant le programme <prgn>strip</prgn> sur les binaires
après qu'ils ont été copiés dans <tt>debian/tmp</tt> mais avant
qu'une arborescence ne soit faite pour le paquet.
</p>
	  <p>
L'option <tt>-N</tt> ne sera pas utilisée. Dans les systèmes <tt>a.out</tt> 
cela pouvait être utile pour de tout petits binaires, mais cela n'a pas 
d'intérêt dans les systèmes «&nbsp;ELF&nbsp;».
</p>

<p>
Les symboles de débogage sont utiles pour la détection des erreurs, la 
recherche dans un «&nbsp;core dump&nbsp;» (envoyé par un utilisateur pour un 
rapport de bogue), ou bien dans la phase de développement d'un logiciel. C'est
pourquoi on construira un paquet avec des instructions pour le débogage de la
manière suivante : si la variable d'environnement <tt>DEB_BUILD_OPTIONS</tt>
contient la chaîne <tt>debug</tt>, on compile le logiciel avec les 
informations de débogage (habituellement on ajoute le drapeau <tt>-g</tt> à
<tt>CFLAGS</tt>). Cela permet la construction d'une arborescence avec les
informations de débogage. Si la variable d'environnement 
<tt>DEB_BUILD_OPTIONS</tt> contient <tt>nostrip</tt>, on n'épure pas les
fichiers durant la phase d'installation. Cela permet de produire un paquet
avec des informations de débogage <footnote><p> Argument : compiler
par défaut avec l'option -g gaspille davantage de cycles CPU puisque les
informations sont de toute manière enlevées ; cela peut avoir un impact 
significatif sur l'efficacité des <em>autobuilders</em>. Une façon standard
de construire des variantes avec des informations de débogage facilite 
la construction de binaires ou de bibliothèques  puisqu'elle permet
de documenter la façon d'obtenir ce genre de compilation&nbsp;; on ne doit pas
avoir à modifier «&nbsp; à la main&nbsp;» <tt>debian/rules</tt> ou des
<tt>Makefile</tt>s.
</p></footnote>.
Le petit makefile suivant explique comment tester chaque condition ; vous
aurez sans doute à l'adapter aux conditions de votre paquet. 
             <example compact="compact">
CFLAGS = -O2 -Wall
INSTALL = install
INSTALL_FILE    = $(INSTALL) -p    -o root -g root  -m  644
INSTALL_PROGRAM = $(INSTALL) -p    -o root -g root  -m  755
INSTALL_SCRIPT  = $(INSTALL) -p    -o root -g root  -m  755
INSTALL_DIR     = $(INSTALL) -p -d -o root -g root  -m  755

ifneq (,$(findstring debug,$(DEB_BUILD_OPTIONS)))
CFLAGS += -g
endif
ifeq (,$(findstring nostrip,$(DEB_BUILD_OPTIONS)))
INSTALL_PROGRAM += -s
endif
           </example>
	  
<p>
C'est au responsable du paquet de décider des meilleures options
de compilation. Certains binaires (comme ceux qui font des 
calculs intensifs) fonctionnent mieux avec certaines options 
(p.ex. <tt>-O3</tt>) ; faites comme vous voulez. Utilisez ces options avec 
discernement ; pour de bonnes raisons, pas seulement pour elles-mêmes.
Ne craignez pas de remplacer les options qu'avait choisies l'auteur du 
programme original : elles sont souvent inappropriées dans votre environnement.
</p>
</sect>
	    
	<sect>
	  <heading>Les bibliothèques</heading>
	    
	  <p>
Toutes les bibliothèques doivent avoir une version partagée dans le paquet 
<tt>lib</tt> et une version statique dans le paquet <tt>lib-dev</tt>.
La version partagée doit être compilée avec les options <tt>-fPIC</tt>
mais pas la version statique. En d'autres termes, tous les fichiers
<tt>*.c</tt> doivent être compilés deux fois.
</p>
		    
	  <p>
Vous devez indiquer l'option <tt>-D_REENTRANT</tt> de <prgn>gcc</prgn>
quand vous compilez une bibliothèque (statique ou dynamique) pour qu'elle
soit compatible avec les «&nbsp;threads&nbsp;» Linux.
</p>
	    
	  <p>
On remarquera que toutes les bibliothèques partagées qu'on installe doivent 
être épurées de tout symbole par :
	    <example compact="compact">
strip --strip-unneeded <var>your-lib</var>
	    </example> 
(L'option <tt>--strip-unneeded</tt> fait que <prgn>strip</prgn> enlève 
uniquement les symboles qui ne sont pas utiles au mécanisme de réallocation.)
Les bibliothèques partagées fonctionnent parfaitement bien quand elles
sont épurées, car les symboles de liens dynamiques
sont dans une autre partie du fichier objet «&nbsp;ELF&nbsp;» <footnote> <p>
Vous pourriez aussi utiliser les options <tt>--remove-section=.comment</tt> et
<tt>--remove-section=.note</tt> sur les bibliothèques partagées et sur les
exécutables, et l'option <tt>--strip-debug</tt> sur les bibliothèques 
statiques.
            </p>
</footnote>.
</p>

	  <p>
Il faut noter que dans certaines circonstances, il peut être utile d'installer
une bibliothèque non épurée, p.ex. pour la construction d'un paquet d'aide au 
débogage.
</p>
<p>
Les fichiers objet partagés (comme les fichiers <tt>.so</tt>) qui ne sont
pas des bibliothèques publiques, c'est à dire que des exécutables tiers (les
binaires d'autres paquets) ne peuvent s'y lier, seront installés dans des
sous-répertoires de <tt>/usr/lib</tt>. De tels fichiers n'ont pas à se plier
aux règles qui gouvernent les bibliothèques partagées ordinaires&nbsp; mais
ils ne doivent pas être exécutables et seront épurés <footnote>
<p>
Les «&nbsp;plug-ins&nbsp;», ces objets internes partagés, chargés 
dynamiquement par des programmes en utilisant 
<manref name="dlopen" section="3">, en sont un exemple.
	    </p>
	  </footnote>.
</p>	
<p>
Les paquets contenant des bibliothèques partagées qui peuvent être liées à
d'autres binaires mais qui, pour quelque raison <em>contraignante</em>, ne
peuvent être installées dans le répertoire <tt>/usr/lib</tt>, peuvent
installer les bibliothèques partagées dans des sous-répertoires de
<tt>/usr/lib</tt>&nbsp;; dans ce cas, ils ajouteront ce répertoire dans
<tt>/etc/ld.so.conf</tt> avec le script de <em>post-installation</em> du
paquet et le supprimeront avec le script de <em>post-removal</em>.
	</p>

	<p>
Un nombre toujours croissant de paquets utilisent <prgn>libtool</prgn> pour 
l'édition de liens. La plus récente version de «&nbsp;GNU libtools 
(>= 1.3a)&nbsp;» peut se servir avantageusement des meta-données contenues 
dans les fichiers (<tt>*.la</tt>) de <prgn>libtool</prgn>. Le principal
avantage de ces fichiers est que <prgn>libtool</prgn> peut conserver ces 
meta-données et donc y accéder en fonction des bibliothèques qu'il construit. 
<prgn>Libtool</prgn> cherche ces fichiers et les renseignements
utiles qu'ils contiennent à propos des bibliothèques (p.ex. les bibliothèques 
nécessaires pour une édition de liens statiques). Ils sont aussi 
<em>indispensables</em> aux programmes utilisant <tt>libltdl</tt> <footnote>
<p>
Sans doute, <prgn>libtool</prgn> peut faire de l'édition de liens avec des 
bibliothèques qui n'ont pas de fichier <tt>.la</tt>&nbsp;; mais, n'étant qu'un 
simple script shell, il peut augmenter considérablement le temps de 
compilation d'un paquet s'il doit, pour chaque bibliothèque et chaque 
fois qu'elle est liée, déduire tous ces renseignements des premiers principes.
Avec l'apparition de «<prgn>libtool-1.4</prgn> (et dans une moindre mesure de 
<prgn>libtool-1.3</prgn>), les fichiers <tt>.la</tt> gardent des 
renseignements sur les dépendances entre bibliothèques qui ne peuvent pas 
être nécessairement déduits une fois détruit le fichier <tt>.la</tt>.
	</p>
	  </footnote>.
	<p>
Les paquets qui se servent de <prgn>libtool</prgn> pour créer des 
bibliothèques partagées mettront les fichiers <tt>.la</tt> dans les 
paquets <tt>-dev</tt> ; dans le cas où un paquet compte sur la bibliothèque
<tt>libltdl</tt> de <prgn>libtool</prgn>, les fichiers <tt>.la</tt> iront dans
le paquet de la bibliothèque. 
	</p>
	
	<p>
Vous devez vous assurer que vous n'utilisez que les versions diffusées des 
bibliothèques partagées pour construire vos paquets ; dans le cas contraire, 
les autres utilisateurs ne pourront pas exécuter vos binaires correctement.
Produire des paquets sources qui dépendent de compilateurs
non autorisés est habituellement une mauvaise idée.
</p>
</sect>
	<sect>
	  <heading>Les bibliothèques partagées</heading>
	    
	  <p>
Un paquet qui contient des bibliothèques partagées sera séparé
en plusieurs paquets binaires.
</p>
	  <p>
Pour une bibliothèque classique constituée d'un environnement de développement
 et d'un kit fonctionnel comprenant simplement des bibliothèques partagées, 
vous devez créer deux paquets : 
<tt><var>nom-de-bibliothèque</var><var>version-so</var></tt>, où 
<var>version-so</var> est le numéro de version du nom-so de la bibliothèque
partagée <footnote>
<p>
Le nom-so est le nom du fichier objet partagé : c'est ce qui, entre le moment 
de la construction de l'exécutable et celui de son fonctionnement, doit être
exactement le même pour que l'éditeur de liens dynamiques soit capable de faire
marcher le programme. Par exemple, si le nom-so de la bibliothèque est
<tt>libfoo.so.6</tt>, le paquet de la bibliothèque sera appelé
<tt>libfoo6</tt>.</p>
	  </footnote>
et <tt><var>nom-de-bibliothèque</var><var>version-so</var>-dev</tt>.
</p>

	  <p>
Si vous préférez ne gérer qu'une version de développement à la fois, vous 
pouvez nommer le paquet de développement 
<tt><var>nom-de-bibliothèque</var>-dev</tt> ; sinon, vous pouvez utiliser les 
mécanismes de gestion de conflit de <prgn>dpkg</prgn> (voir
<ref id="conflicts">) pour vous assurer que 
l'utilisateur ne peut installer qu'une seule version de développement à la 
fois. (Plusieurs versions de développement auront sans doute les 
mêmes fichiers d'en-tête, ce qui créera un conflit de nom en cas 
d'installation multiple.) En général, la 
version de développement aura une dépendance vers la bonne version de la 
bibliothèque fonctionnelle, afin que la compilation et l'édition de liens 
s'effectuent correctement. La variable de substitution 
<tt>${Source-Version}</tt> peut être utile dans ce cas.
</p>
	  <p>
Un paquet qui utilise une bibliothèque partagée aura une dépendance 
vers le nom du paquet de la bibliothèque partagée,
<tt><var>nom-de-bibliothèque</var><var>version-so</var></tt>. 
Quand le nom-so est modifié, les deux versions de la bibliothèque
peuvent cohabiter pendant le passage de l'ancienne à la nouvelle.
</p>
	  <p>
Si votre paquet contient des programmes d'aide au fonctionnement
qui utilisent la bibliothèque partagée, vous ne devez pas les mettre dans le 
paquet de la bibliothèque partagée. Si vous le faites, vous ne pourrez pas 
installer plusieurs versions de la bibliothèque sans créer des conflits
de noms de fichiers. À la place, vous pouvez soit créer un
troisième paquet pour ces binaires fonctionnels (le paquet peut s'appeler 
<tt><var>nom-de-bibliothèque</var>-runtime</tt>
-- notez l'absence de <var>version-so</var> dans le nom du paquet), soit 
inclure ces binaires dans le paquet de développement si celui-ci est petit.
</p>
	  <p>
Si vous construisez plusieurs bibliothèques partagées à partir d'un même 
arbre de sources, vous pouvez les regrouper dans le même paquet de 
bibliothèques, sachant que vous devrez changer tous leurs nom-so 
simultanément (pour éviter des conflits de noms de fichiers lors de
l'installation de différentes versions de ce paquet).
</p>

<p>
Les bibliothèques partagées ne doivent pas être
installées comme exécutables, puisque l'éditeur de liens dynamiques ne
le demande pas et que tenter d'exécuter une bibliothèque
partagée se traduit pas un «&nbsp;core dump&nbsp;».
</p>
</sect>
	    
	<sect id="scripts">
	  <heading>Les scripts</heading>
	    
	  <p>
Tous les scripts de commandes, y compris les scripts inclus dans un paquet 
par le responsable et utilisés par <prgn>dpkg</prgn>, commenceront 
par «&nbsp;<tt>#!</tt>&nbsp;» et le nom du shell interpréteur.
</p>
	    
	  <p>
	Pour les scripts Perl, c'est «&nbsp;<tt>#!/usr/bin/perl</tt>&nbsp;».</p>
	    
	  <p>
Les scripts shell (<prgn>sh</prgn> et <prgn>bash</prgn>) commenceront presque 
systématiquement par <tt>set -e</tt> pour que les erreurs soient 
détectées. Tous les scripts utiliseront <tt>set -e</tt> ou 
vérifieront l'état de sortie de <em>toutes</em> les commandes.
</p>
	    
	  <p>
L'interpréteur shell de base <tt>/bin/sh</tt> peut être
un lien symbolique vers n'importe quel shell compatible POSIX, si 
<tt>echo -n</tt> ne produit pas une nouvelle ligne <footnote><p>
La charte Debian indique que <tt>/bin/sh</tt> suit la norme POSIX, mais
<tt>echo -n</tt> est largement utilisé dans la communauté Linux (dans cette 
charte, dans les sources du noyau Linux, dans beaucoup de scripts Debian, 
etc.). Ce mécanisme est valable mais n'est pas demandé par POSIX,
d'où cet ajout explicite. D'autre part, la rumeur dit que ce mécanisme
doit devenir de toute façon obligatoire sous LSB.</footnote>. 
Les scripts shell indiquant <tt>/bin/sh</tt> comme interpréteur n'utiliseront 
donc que des caractéristiques POSIX. Si un script a besoin des 
caractéristiques non-POSIX d'un interpréteur, celui-ci doit être spécifié 
dans la première ligne du script (par exemple <tt>#!/bin/bash</tt>). Son paquet
doit dépendre du paquet qui fournit le shell (à moins que le
paquet ne soit marqué «&nbsp;Essential&nbsp;», comme par exemple pour
<prgn>bash</prgn>).
</p>
	  <p>
Quand c'est possible, on peut vouloir limiter les scripts aux 
caractéristiques POSIX de manière à utiliser l'interpréteur <tt>/bin/sh</tt>. 
Si votre script fonctionne avec <prgn>ash</prgn>, il est probablement 
conforme à POSIX, mais en cas de doute, utilisez <tt>/bin/bash</tt>.
</p>
	  <p>
Les scripts Perl détecteront les erreurs survenant lors de tous les 
appels système, comme <tt>open</tt>, <tt>print</tt>, <tt>close</tt>, 
<tt>rename</tt> et <tt>system</tt>.
</p>
<p>
Les shells <prgn>csh</prgn> et <prgn>tcsh</prgn> seront évités comme langage 
de script. Référez-vous au
document <em>Csh Programming Considered Harmful</em> (NdT: Pourquoi
programmer en Csh est risqué), l'une des FAQs du groupe
usenet <tt>comp.unix.*</tt>. Il peut être trouvé sur
<url id="http://language.perl.com/versus/csh.whynot"> <footnote>
<p>
On peut le trouver sur
<url id="http://www.cpan.org/doc/FMTEYEWTK/versus/csh.whynot">
ou sur <ftpsite>ftp.cpan.org</ftpsite> dans
          <ftppath>/pub/perl/CPAN/doc/FMTEYEWTK/versus/csh.whynot</ftppath>.
	    </p>
	  </footnote>.
Si un paquet original utilise des scripts <prgn>csh</prgn>
vous devez vous assurer qu'ils commencent par
<tt>#!/bin/csh</tt> et vous devez rendre votre paquet
dépendant du paquet virtuel <prgn>c-shell</prgn>
</p>
	  <p>
Tout script qui crée des fichiers dans des répertoires où tout le monde peut 
écrire, (p.ex. dans <tt>/tmp</tt>) doit utiliser un mécanisme qui 
provoquera une erreur si un fichier de même nom existe déjà.
</p>
	    
	  <p>
À cet usage, le système Debian de base fournit
les utilitaires <prgn>tempfile</prgn> et <prgn>mktemp</prgn>.
</p></sect>
	    
	<sect>
	  <heading>Les liens symboliques</heading>
	    
	  <p>
En général, les liens symboliques à l'intérieur d'un répertoire de premier 
niveau seront relatifs alors que les liens symboliques qui pointent 
d'un répertoire de premier niveau vers un autre répertoire de premier niveau 
seront absolus. (Un répertoire de premier niveau est un sous-répertoire
du répertoire racine <tt>/</tt>.)
</p>

	  <p>
De plus, les liens symboliques doivent utiliser un nom de chemin le plus 
court possible ; on évitera par exemple le chemin <tt>foo/../bar</tt>.
</p>
	  <p>
On remarquera que pour créer un lien relatif avec <prgn>ln</prgn>
il n'est pas nécessaire que le fichier cible soit relatif au répertoire où est 
exécuté <prgn>ln</prgn> ; de même il n'est pas nécessaire de se déplacer dans 
le répertoire où vous désirez créer le lien.
Donnez simplement à <prgn>ln</prgn> comme premier argument
la chaîne de caractères qui représentera la cible du lien (cette
chaîne doit être un chemin relatif au répertoire contenant le lien).
</p>
	  <p>
Par exemple, dans votre <prgn>Makefile</prgn> ou
dans <tt>debian/rules</tt>, vous pouvez écrire :
	    <example compact="compact">
ln -fs gcc $(prefix)/bin/cc 
ln -fs gcc debian/tmp/usr/bin/cc 
ln -fs ../sbin/sendmail $(prefix)/bin/runq 
ln -fs ../sbin/sendmail debian/tmp/usr/bin/runq
	    </example></p>
	    
	  <p>
Un lien symbolique vers un fichier comprimé aura toujours
le même suffixe que le fichier référencé.
(Par exemple, si le fichier <tt>foo.gz</tt> est
référencé par un lien symbolique, le nom du lien doit
aussi se terminer par «&nbsp;<tt>.gz</tt>&nbsp;», comme par exemple
<tt>bar.gz</tt>.)
</p>
</sect>
	    
	<sect>
	  <heading>Les fichiers de périphérique</heading>
	    
	  <p>
Un paquet ne doit pas contenir de fichiers de périphérique
dans son arborescence.
</p>
	  <p>
Si un paquet a besoin d'un fichier de périphérique particulier
qui n'est pas inclus dans le système de base, il doit
appeler <prgn>MAKEDEV</prgn> dans le script <prgn>postinst</prgn>,
après en avoir demandé l'autorisation à l'utilisateur.
</p>
	  <p>
Un paquet ne doit pas supprimer de fichier de périphérique
dans le script <prgn>postrm</prgn> ou dans un autre script.
Ceci doit être laissé à l'initiative de l'administrateur système.
</p>
	  <p>
Debian utilise les périphériques série <tt>/dev/ttyS*</tt>. Les programmes qui 
utilisent les anciens périphériques <tt>/dev/cu*</tt> seront
modifiés pour utiliser <tt>/dev/ttyS*</tt>.
</p></sect>
	    
      <sect id="config files">
	  <heading>Les fichiers de configuration </heading>
	<sect1>
	  <heading>Définitions</heading>
	  <p>
	    <taglist>
	      <tag>fichier de configuration </tag>
	      <item><p>
C'est un fichier qui influe sur le fonctionnement d'un programme,
ou bien qui donne des renseignements particuliers à un site ou à un
hôte, autrement dit un fichier qui singularise le comportement d'un programme.
Classiquement, les fichiers de configuration sont faits pour être modifiés
par l'administrateur système (s'il en a besoin ou s'il le souhaite) de
manière à se conformer à la politique locale ou bien à obtenir un
fonctionnement plus utile au site.
</p>
              </item>


	      <tag><tt>conffile</tt></tag>
	      <item><p>
C'est un fichier répertorié dans le fichier <tt>conffiles</tt>
d'un paquet ; et <prgn>dpkg</prgn> en fait un usage particulier
(voir <ref id="configdetails">).
</p>
              </item>
            </taglist>
	  </p>

	  <p>
Cette distinction est importante ; ce ne sont pas des concepts
interchangeables. Presque tous les <tt>conffile</tt>s sont des fichiers de
configuration, mais beaucoup de fichiers de configuration ne sont pas des
<tt>conffiles</tt>.

	  <p>
Il faut noter que les scripts qui renferment des informations de configuration
(ainsi la plupart des fichiers de <tt>/etc/default</tt> et de
<tt>/etc/cron.{daily,weekly,monthly}</tt>) sont <em>de facto</em> des 
fichiers de configuration et seront traités comme tels.
</p>
	</sect1>
<sect1>
<heading>Emplacement</heading>

<p>
Tout fichier de configuration créé ou utilisé par un paquet doit se trouver
dans le répertoire <tt>/etc</tt>. S'ils sont nombreux, on envisagera la
création d'un sous-répertoire de <tt>/etc</tt> qu'on nommera d'aprés le
le nom du paquet.
</p>
<p>
Quand un paquet crée ou utilise des fichiers de configuration qui ne sont
pas dans <tt>/etc</tt> et qu'il n'est pas facile de modifier ce programme
pour qu'il utilise <tt>/etc</tt>, on mettra quand même les fichiers dans
<tt>/etc</tt> et on créera des liens symboliques vers ces fichiers depuis
les emplacements voulus par le paquet.
	  </p>
	</sect1>
<sect1>
<heading>Comportement</heading>
<p>
La gestion des fichiers de configuration doit se conformer aux principes
suivants&nbsp;:
<list compact="compact">
              <item>
                <p>
les changements locaux doivent être préservés pendant
la mise à jour d'un paquet ;
</p>
              </item>
              <item>
                <p>
les  fichiers de configuration doivent être préservés quand le paquet est 
supprimé ; ils ne sont détruits que si le paquet est
supprimé avec «&nbsp;purge&nbsp;».
</p>
          </item>
            </list>
</p>
<p>
La façon simple d'obtenir cela, c'est que le fichier de configuration soit
un <tt>conffile</tt>. C'est parfait quand on peut distribuer une version par
défaut qui marche pour la plupart des installations, bien que quelques
administrateurs puissent vouloir la modifier. Cela suppose que la version par
défaut fasse partie du paquet et que les scripts du responsable du paquet
ne la modifient pas pendant l'installation (ou à quelque autre moment).
</p>
<p>
Pour faire que les changements locaux soient préservés correctement, nul
paquet ne peut contenir des liens «&nbsp;en dur&nbsp;», ou en créer, vers des
«&nbsp;conffiles&nbsp;»<footnote><p>
Argument : Il y a deux problèmes avec les liens «&nbsp;en dur&nbsp;». Le 
premier, c'est que certains «&nbsp;éditeurs&nbsp;» casse le lien quand ils 
modifient l'un des fichiers,
et les deux fichiers peuvent devenir involontairement différents. Le second,
c'est qu'il arrive que <prgn>dpkg</prgn> casse le lien pendant une mise à
jour de <tt>conffile</tt>s.</p>
          </footnote>.
	  </p>
<p>
L'autre façon, c'est d'utiliser les scripts du responsable de paquet.
Dans ce cas, le fichier de configuration ne doit pas être un <tt>conffile</tt>
et ne doit pas faire partie du paquet. Si la configuration correcte d'un paquet
demande un fichier, c'est au responsable du paquet,
via ses scripts, de créer, mettre à jour, maintenir et supprimer un tel
fichier.(Voir <ref id="6"> pour des précisions.) Ces scripts 
doivent être idempotents (c.-à-d. ils doivent fonctionner
correctement si <prgn>dpkg</prgn> a besoin de les relancer à cause d'erreurs
survenues pendant l'installation ou la suppression) ; ils doivent
comprendre toutes les manières de <prgn>dpkg</prgn> en ce qui
concerne l'appel des scripts ; ils ne doivent pas remplacer, autrement dit
massacrer, la configuration de l'utilisateur sans lui demander ; ils ne
doivent pas poser des questions sans intérêt (surtout pendant les mises à
jour) ; bref, ils doivent être de bons citoyens.
</p>
<p>
Ces scripts n'ont pas à configurer toutes les options possibles d'un paquet,
mais seulement celles qui sont nécessaires à son bon fonctionnement sur un
système donné. Idéalement, un sysadmin ne devrait faire aucune autre
configuration que celle faite presque automatiquement par le script
<tt>postinst</tt>.
</p>
<p>
Une manière commune de faire est de créer un script
<tt><var>package</var>-configure</tt> qu'appellera le script <tt>postinst</tt>
du paquet si et seulement si le fichier de configuration n'existe pas déjà.
Parfois, il est bon d'avoir un fichier d'exemple ou un fichier modèle
utilisable par les scripts du responsable. On mettra ces fichiers
dans <tt>/usr/share/&lt;package&gt;</tt> avec un lien symbolique
pour <tt>/usr/share/doc/&lt;package&gt;/examples</tt> si ce sont des fichiers
d'exemples ; ces fichiers sont des fichiers parfaitement ordinaires pour
<prgn>dpkg</prgn> (ce <em>ne sont pas </em> des fichiers de configuration).
</p>
          <p>
On ne doit pas mélanger ces deux manières de gérer les fichiers de
configuration car alors la folie guette : <prgn>dpkg</prgn> voudra
remplacer le fichier à chaque mise à jour du paquet.
</p>
        </sect1>

<sect1>
          <heading>Le partage des fichiers de configuration </heading>
          <p>
On doit indiquer un <em>conflit</em> entre des paquets qui ont le même
fichier <tt>conffile</tt>. (C'est une application de la règle générale qui veut
qu'on ne partage pas des fichiers. Ni les <em>alternatives</em> ni les 
<em>diversions</em> ne sont appropriés dans ce cas&nbsp;; en particulier, 
<prgn>dpkg</prgn> ne gère pas bien les <tt>conffile</tt>s déviés (diverted).)
	  </p>
	  <p>
Les scripts d'un responsable de paquet ne doivent modifier le 
<tt>conffile</tt> d'<em>aucun</em> paquet, même celui du paquet auquel ils
appartiennent.</p>

	  <p>
Quand deux paquets ou plus ont le même fichier de configuration et qu'il est
raisonnable d'installer les deux paquets, on doit définir l'un des
paquets comme le <em>propriétaire</em> du fichier de configuration, et
ce sera le paquet qui gère ce fichier comme un fichier de configuration. Les 
autres paquets qui utilisent le fichier de
configuration doivent déclarer une dépendance envers ce paquet s'ils ont
besoin de ce fichier de configuration pour leur fonctionnement. Quand
ils ne l'utilisent que s'il est présent et qu'ils sont capables de
fonctionner sans lui, ces paquets n'ont pas besoin de déclarer de
dépendance.</p>

	  <p>
Si l'on veut que deux ou plusieurs paquets apparentés partagent un fichier de
configuration <em>et</em> que chacun d'eux soit capable de le modifier, il
faut faire ce qui suit :

	    <enumlist compact="compact">
	      <item>
		<p>
L'un des paquets apparentés (le paquet «&nbsp;propriétaire&nbsp;») doit gérer 
le fichier de
configuration avec les scripts du responsable de paquet comme c'est décrit
dans les sections précédentes :</p>
	      </item>
	      <item><p>
le le paquet «&nbsp;propriétaire&nbsp;» fournira aussi un programme que les 
autres paquets utiliseront pour modifier le fichier de configuration ;</p>
	      </item>
	      <item>
		<p>
les paquets apparentés doivent se servir de ce programme pour faire
les modifications voulues sur le fichier de configuration. Ils dépendront alors
de la garantie donnée quant à la disponibilité de ce programme, 
ou bien ils accepteront avec élégance de ne pouvoir modifier 
le fichier de configuration si ce programme n'est pas disponible. (C'est une
addition au fait que le fichier de configuration pourrait même ne pas
exister dans ce dernier scénario.)
</p>
	      </item>
	    </enumlist></p>
	  <p>
Quelques fois, il convient de créer un nouveau paquet qui fournit
l'infrastructure de base pour les autres paquets et qui gère les fichiers
de configuration partagés (on peut consulter le paquet <tt>sgml-base</tt>
comme exemple).</p>
	</sect1>

	<sect1>
	  <heading>Les fichiers de configuration de l'utilisateur («&nbsp;dotfiles&nbsp;»)</heading>

	  <p>
Les fichiers dans <tt>/etc/skel</tt> sont copiés automatiquement dans les 
comptes des nouveaux utilisateurs par <prgn>adduser</prgn>. Aucun programme
ne renverra à la présence de ces fichiers dans <tt>/etc/skel</tt>.
</p>

	  <p>
Ainsi, quand un programme, pour fonctionner correctement, a besoin
qu'un fichier «&nbsp;.fichier&nbsp;» existe par avance dans <tt>$HOME</tt>, 
le paquet installera ce fichier dans <tt>/etc/skel</tt> (et le 
considèrera comme un fichier de configuration.
</p>

	  <p>
Cependant, avoir un programme qui, pour fonctionner correctement, a besoin 
de fichiers «&nbsp;.fichier&nbsp;» (des fichiers qu'il ne crée pas lui même, 
j'entends), est une mauvaise idée. Et l'installation par défaut de Debian
devrait configurer les programmes d'une manière aussi proche que possible de
la configuration originelle par défaut.
</p>
	  <p>
Ainsi, le programme d'un paquet Debian, qui a besoin d'une quelconque
configuration pour fonctionner correctement, sera configuré globalement pour 
le système à l'aide d'un fichier placé dans <tt>/etc</tt>. C'est uniquement 
dans le cas où le programme n'accepte pas de configuration globale au site, 
et si le responsable du paquet n'a pas le temps d'ajouter un fichier de 
configuration par défaut, qu'un tel fichier pourra être placé dans 
<tt>/etc/skel</tt>.
</p>
	  <p>
<tt>/etc/skel</tt> sera aussi vide que possible. C'est d'autant plus 
nécessaire qu'il n'existe pas de mécanisme simple (ou même désirable) pour 
s'assurer que les 
fichiers «&nbsp;.fichier&nbsp;» nécessaires sont copiés dans les comptes des 
utilisateurs existants à l'installation du paquet.
</p>

	</sect1>
      </sect>
      
      <sect>
	<heading>Les fichiers d'écoute («&nbsp;log file&nbsp;»)</heading>
	<p>

	<p>
Les fichiers d'écoute se nomment habituellement
<tt>/var/log/<var>paquet</var>.log</tt>. Si vous avez de nombreux fichiers 
d'écoute ou si vous avez besoin d'un répertoire pour des raisons de droits 
(<tt>/var/log</tt> ne peut être modifié que par <tt>root</tt>), vous créerez 
habituellement un répertoire nommé <tt>/var/log/<var>paquet</var></tt> où
vous mettrez ces fichiers.
</p>
	<p>
Une rotation des fichiers d'écoute doit être assurée de manière qu'ils
ne grandissent pas indéfiniment ;
la meilleure façon de procéder est de mettre un fichier de configuration pour 
la rotation des fichiers dans le répertoire <tt>/etc/logrotate.d</tt> et 
d'utiliser les facilités apportées par <em>logrotate</em> <footnote>
<p>
L'approche traditionnelle pour les fichiers d'écoute était d'utiliser 
«&nbsp;cron&nbsp;» et de simples shell scripts pour monter des combines 
<em>ad hoc</em> pour la rotation des fichiers d'écoute. Cette 
approche, grandement paramétrable, demandait beaucoup de travail au 
<em>sysadmin</em>. Bien que le premier système Debian ait apporté une 
aide en installant automatiquement un système qui pouvait être pris 
comme modèle, cela ne fut pas considéré comme suffisant.
</p>  
	<p>
Une meilleure idée est d'utiliser <prgn>logrotate</prgn>, un programme 
développé par Red Hat, qui centralise la gestion de 
l'écoute. Il possède à la fois un fichier de configuration 
(<tt>/etc/logrotate.conf</tt>) et un répertoire où les paquets peuvent 
déposer leurs configurations pour la rotation des fichiers, 
(<tt>/etc/logrotate.d</tt>).
        </p>
</footnote>.
Voici un bon exemple de fichier de configuration de «&nbsp;logrotate&nbsp;» 
(pour plus de renseignements voir <manref name="logrotate " section="8">) :
	  <example compact="compact">
/var/log/foo/* {
rotate 12
weekly
compress
postrotate
/etc/init.d/foo force-reload
endscript
}
	  </example> 	  
	  Cela fait tourner tous les fichiers sous <tt>/var/log/foo</tt>, 
sauve 12 compressions, et demande au démon de recharger ses informations de
configuration après la rotation des fichiers.
	</p>
	
	<p>
Les fichiers d'écoute seront supprimés quand le paquet est 
«&nbsp;purgé&nbsp;» (mais pas quand le paquet est simplement supprimé). Ce
sera fait par le script <prgn>postrm</prgn> quand il est appelé avec 
l'argument <tt>purge</tt> ( voir <ref id="removedetails">). 
	</p>
      </sect>
     	    
	<sect>
	  <heading>Permissions et propriétaires</heading>
	    
	  <p>
Les règles de cette section sont des directives pour une utilisation 
élémentaire. Quand c'est nécessaire, vous pouvez vous écarter de certains 
détails. Cependant, dans ce cas, sécurisez ce que vous
faites et restez aussi cohérent que possible avec le système. Vous devriez
probablement en discuter aussi dans <prgn>debian-devel</prgn>.
</p>
	  <p>
Les fichiers appartiendront à <tt>root.root</tt>. Ils seront
modifiables uniquement par le propriétaire et seront lisibles 
par tous (exécutables si nécessaire) c'est à dire 644 ou 755.
</p>
	  <p>
Les répertoires auront le mode 755 ou, pour ceux qui doivent être 
modifiables par un groupe, le mode 2775. La propriété du répertoire sera 
cohérente avec le mode -- si le répertoire a comme mode 2775, il 
appartiendra au groupe qui a besoin d'y accéder.</p>
	    
	  <p>
Les exécutables qui sont «&nbsp;setuid&nbsp;» et «&nbsp;setgid&nbsp;» auront 
respectivement les modes 4755 et 2755, et ils appartiendront à l'utilisateur 
ou au groupe approprié. On n'interdira pas leur lecture (par des modes 
comme 4711 ou 2711 ou même 4111) ; en effet cela n'apporte aucun gain de 
sécurité puisque n'importe qui peut obtenir les binaires dans les paquets 
Debian qui sont librement disponibles ; c'est simplement gênant. Pour la même 
raison vous ne restreindrez pas les droits en lecture ou en exécution 
des exécutables «&nbsp;non-set-id&nbsp;».
</p>
	  <p> 
Certains programmes «&nbsp;setuid&nbsp;» doivent être restreints à certains 
groupes d'utilisateurs en se servant des permissions sur les fichiers. Dans 
ce cas, ils appartiendront à «&nbsp;l'uid&nbsp;» pour lesquels ils sont 
«&nbsp;set-id&nbsp;» et au groupe qui aura des droits d'exécution. Ils auront
le mode 4754 ; cela ne sert à rien de les rendre
illisibles aux utilisateurs qui n'ont pas les droits d'exécution.
</p>
	  <p>
On peut permettre que, pour suivre sa politique locale de sécurité, un 
administrateur système puisse reconfigurer un paquet en changeant
les permissions des fichiers binaires&nbsp;: il peut utiliser 
<prgn>dpkg-statoverride</prgn> pour cela, comme c'est décrit plus bas
<footnote>
<p>
Les fichiers ordinaires (à l'exception des <tt>conffile</tt>s et d'autres
fichiers similaires) installés par <prgn>dpkg</prgn> ont normalement
leurs droits réinitialisés avec les droits de la distribution lors de la 
réinstallation d'un paquet. Cependant, l'utilisation du programme 
<prgn>dpkg-statoverride</prgn> annule ce comportement par défaut. Si vous
utilisez cette méthode, vous penserez à décrire ce programme dans la
documentation du paquet&nbsp;; en tant qu'apport relativement récent à
Debian, il est probablement peu connu.
</footnote>.
Une autre méthode est de créer un groupe comprenant les utilisateurs autorisés
à utiliser le programme et de rendre tous les exécutables <em>setuid</em>
exécutables seulement par ce groupe.
        </p>

	  <p>
Si vous avez besoin d'un nouvel utilisateur ou groupe pour votre paquet, vous 
avez deux possibilités. La première est de rendre cet utilisateur ou ce 
groupe propriétaire d'un ou plusieurs fichiers de votre paquet. La deuxième
est de compiler l'identifiant (plutôt que le nom) d'utilisateur ou de groupe 
dans le binaire. Dans ce cas vous avez besoin d'un identifiant attribué de 
façon fixe.
</p>
	  <p>
Si vous avez besoin d'un identifiant attribué de façon fixe, vous devez alors 
demander un identifiant d'utilisateur ou de groupe au 
responsable du système de base, <tt>base-passwd</tt> et vous ne devez pas 
livrer votre paquet avant d'avoir reçu un tel identifiant. Quand vous l'avez 
reçu, vous devez faire dépendre votre paquet d'une version du système de base 
dans laquelle l'identifiant est présent dans <tt>/etc/passwd</tt> ou dans 
<tt>/etc/group</tt>. Alternativement, vous pouvez modifier votre paquet pour 
qu'il crée lui-même l'utilisateur ou le groupe avec le bon identifiant 
(en utilisant <tt>adduser</tt>) dans les scripts <prgn>preinst</prgn> ou
<prgn>postinst</prgn>. (Utiliser <prgn>postinst</prgn> est préférable si c'est
possible&nbsp;; sinon, on aura besoin d'une pré-dépendance envers le paquet
<tt>adduser</tt>.)
</p>
	    
	  <p>
D'un autre coté, un programme peut être capable, en fonctionnement, de 
déterminer l'«&nbsp;uid&nbsp;» ou le «&nbsp;gid&nbsp;» à partir du nom d'un 
groupe de façon à utiliser un identifiant attribué de façon dynamique. Dans 
ce cas vous choisirez un nom d'utilisateur ou de groupe approprié, vous en 
discuterez dans <prgn>debian-devel</prgn>, vous vérifierez avec le responsable
du système de base que ce nom est unique et vous vous assurerez qu'ils 
(la liste <prgn>debian-devel</prgn>) ne préfèrent pas un identifiant attribué 
de manière fixe. Quand tout cela a été vérifié, vous devez modifier votre 
paquet pour qu'il crée, si nécessaire, l'utilisateur ou le groupe avec 
<prgn>adduser</prgn> dans les scripts <prgn>preinst</prgn> ou
<prgn>postinst</prgn> (à nouveau, ces derniers sont préférables si c'est 
possible).
</p>	   
	  <p>
Il faut noter que changer la valeur numérique d'un identifiant associé
à un nom est une opération très difficile. Elle implique de rechercher
dans le système de fichier tous les fichiers concernés. Réfléchissez
sérieusement au meilleur choix entre «&nbsp;id&nbsp;» statique ou dynamique,
car modifier votre choix ultérieurement posera des problèmes.
</p>

<sect1><heading>L'utilisation du programme <prgn>dpkg-statoverride</prgn></heading>
<p>
Cette section ne se veut pas normative&nbsp;: c'est une description de
l'utilisation du programme <prgn>dpkg-statoverride</prgn>.
	  </p>
<p>
Le programme <prgn>dpkg-statoverride</prgn> remplace le paquet
<tt>suidmanager</tt>. Les paquets qui utilisaient <tt>suidmanager</tt>
auront un champ <tt>Conflicts: suidmanager (<< 0.50)</tt> et les appels à
<tt>suidregister</tt> et à <tt>suidunregister</tt> seront simplement
supprimés des scripts des responsables de paquet.
	  </p>
<p>
Quand un administrateur-système souhaite installer un fichier (un répertoire,
etc.) avec un système de permissions différent de celui du paquet Debian
distribué, il peut se servir de <prgn>dpkg-statoverride</prgn> pour dire
à <prgn>dpkg</prgn> d'utiliser un système particulier à chaque installation
du fichier. Ainsi, le responsable du paquet distribuera les fichiers avec
un système de permissions normal et laissera l'administrateur-système faire
ses modifications. Par exemple, un démon, qui est normalement 
<em>setuid root</em> mais qui pourrait parfois être utilisé sans être
<em>setuid</em>, sera installé <em>setuid</em> dans le fichier <tt>.deb</tt>.
Puis, l'administrateur-système local changera cela s'il le souhaite. Quand il
y a deux façons de faire, le responsable de paquet peut utiliser
<tt>debconf</tt> pour trouver la préférée, et appeler 
<prgn>dpkg-statoverride</prgn> dans ses scripts pour prendre en compte les
choix de l'administrateur-système.
	  </p>
<p>
Le programme <prgn>dpkg-statoverride</prgn> est donc essentiellement un
outil pour administrateur-système et les scripts de responsable de paquet
ne devraient pas en avoir besoin. Il y a cependant une situation où des
appels à <prgn>dpkg-statoverride</prgn> peuvent être nécessaires dans ces
scripts&nbsp;; il s'agit des paquets qui se servent d'identifiants 
d'utilisateur ou de groupe attribués dynamiquement. Dans cette situation, où
<tt>sysuser</tt> est un identifiant dynamiquement attribué, il peut être
utile de se servir, dans le <prgn>postinst</prgn> du paquet, de quelque chose
comme&nbsp:
           <example>
for i in /usr/bin/foo /usr/sbin/bar
do
  if ! dpkg-statoverride --list $i >/dev/null
  then
    dpkg-statoverride --update --add sysuser root 4755 $i
  fi
done
           </example>
Quand le paquet est <em>purgé</em>, on peut faire sans condition les appels 
correspondants <tt>dpkg-statoverride --remove</tt>.
	  </p>
	</sect1>
      </sect>
    </chapt>

    <chapt id="12">
       <heading>Programmes personnalisés</heading>
	
      <sect id="arch-spec">
	<heading>Les chaînes de spécification d'architecture</heading>
	  
	<p>
Quand un programme doit fournir une <em>chaîne de spécification
d'architecture</em>, le format suivant sera utilisé&nbsp;:
<var>arch</var>-<var>os</var><footnote>
<p>
Actuellement, <prgn>dpkg-archictecture</prgn> reconnait les architectures et 
les systèmes d'exploitation suivants&nbsp;:
les architectures&nbsp;: <tt><var>arch</var></tt> est l'une des valeurs 
suivantes : <tt>alpha</tt>, <tt>arm</tt>, <tt>hppa</tt>, <tt>i386</tt>, 
<tt>ia64</tt>, <tt>m68k</tt>, <tt>mips</tt>, <tt>mipsel</tt>, 
<tt>powerpc</tt>, <tt>s390</tt>, <tt>sh</tt>, <tt>sheb</tt>, <tt>sparc</tt>
et <tt>sparc64</tt>. Les systèmes d'exploitation&nbsp;:  
<tt>linux</tt>, <tt>gnu</tt>, <tt>freebsd</tt> et <tt>openbsd</tt>. 
L'utilisation  de <tt>gnu</tt> dans cette chaîne est
réservé pour le système d'exploitation «&nbsp;GNU-Hurd&nbsp;».
</p>
	  </footnote>.
	</p>

	<p>
On remarquera que nous ne voulons pas utiliser 
<tt><var>arch</var>-debian-linux</tt> dans la chaîne  
<tt><var>architecture</var>-<var>vendor</var>-<var>os</var></tt>
car cela rendrait nos programmes incompatibles avec les autres distributions 
Linux. Notez aussi que nous n'utilisons pas 
<tt><var>arch</var>-unknown-linux</tt>, car <tt>unknown</tt> ne sonne pas 
très bien.
</p>
</sect>
	  
	  
      <sect>
	<heading>Les «&nbsp;démons&nbsp;»</heading>
	  
	<p>
Les fichiers de configuration <tt>/etc/services</tt>,
<tt>/etc/protocols</tt> et <tt>/etc/rpc</tt> sont gérés par le paquet
<prgn>netbase</prgn> et ne doivent pas être modifiés par d'autres paquets.
</p>
	  
	<p>
Quand un paquet a besoin d'une nouvelle entrée dans l'un de ces fichiers,
son responsable contactera le responsable du paquet <prgn>netbase</prgn>,
qui ajoutera cette entrée et produira une nouvelle version du paquet
<prgn>netbase</prgn>.
</p>
	  
	<p>
Le fichier de configuration <tt>/etc/inetd.conf</tt> ne doit pas être modifié 
par les scripts d'un paquet sauf si c'est via le script 
<prgn>update-inetd</prgn> ou le module Perl <tt>DebianNet.pm</tt>. Voir la
documentation pour savoir comment ajouter des entrées.
</p>
	<p>
Quand un paquet veut ajouter un exemple d'entrée dans
<tt>/etc/inetd.conf</tt>, cette entrée doit être précédée par un seul
caractère «&nbsp;#&nbsp;». De telles lignes sont traitées comme des
commentaires de l'utilisateur  par le script <prgn>update-inetd</prgn> et
ne seront pas modifiées ou activées lors des mises à jour des paquets.
</p>
</sect>
	  
      <sect>
<heading>L'utilisation des pseudo-ttys et la modification de «&nbsp;wtmp&nbsp;», 
«&nbsp;utmp&nbsp;» et «&nbsp;lastlog&nbsp;»</heading>
	  
	<p>
Certains programmes ont besoin de créer des pseudo-ttys.
On doit le faire avec les «&nbsp;Unix98&nbsp;» ptys si la bibliothèque 
«&nbsp;C&nbsp;» le permet. Le programme résultant ne doit pas être installé 
«&nbsp;setuid root&nbsp;», à moins que d'autres fonctions ne le demandent.</p>
	
	<p>
Les fichiers <tt>/var/run/utmp</tt>, <tt>/var/log/wtmp</tt> et
<tt>/var/log/lastlog</tt> doivent être modifiables par le groupe 
<tt>utmp</tt>. Les programmes qui ont besoin de modifier ces fichiers 
doivent appartenir au groupe <tt>utmp</tt>.
	</p>
      </sect>

      <sect>
	<heading>Les éditeurs de texte et les pagineurs</heading>
	  
	<p>
Certains programmes appellent un éditeur ou un pagineur pour modifier
ou afficher un document texte. Comme de nombreux éditeurs et pagineurs sont
disponibles dans la distribution Debian, l'administrateur système et les
utilisateurs pourront choisir leur éditeur ou leur pagineur préféré.
</p>
	<p>
De plus, chaque programme choisira un éditeur et/ou un pagineur 
par défaut si l'utilisateur ou l'administrateur système n'en a pas choisi un.
</p>
	  
	<p>
Ainsi chaque programme qui appelle un éditeur ou un pagineur doit
utiliser les variables d'environnement EDITOR ou PAGER pour déterminer
l'éditeur et/ou le pagineur que l'utilisateur souhaite employer. Si ces
variables ne sont pas définies, les programmes <tt>/usr/bin/editor</tt>
et <tt>/usr/bin/pager</tt> seront, respectivement, utilisés.
</p>
	<p>
Ces deux fichiers sont gérés par l'outil de <prgn>dpkg</prgn>, 
«&nbsp;alternatives&nbsp;». Tout paquet,
fournissant un éditeur ou un pagineur, doit employer le script
«&nbsp;update-alternatives&nbsp;» pour déclarer ces programmes.
</p>
	  
	<p>
Lorsqu'il est très difficile d'adapter un programme pour qu'il utilise
les variables EDITOR et PAGER, ce programme peut être configuré
pour utiliser respectivement <tt>/usr/bin/sensible-editor</tt> et
<tt>/usr/bin/sensible-pager</tt> comme éditeur ou pagineur. Ce sont
deux scripts fournis par le système Debian de base qui testent les
variables EDITOR ou PAGER et lancent les programmes appropriés ou bien
exécutent par défaut <tt>/usr/bin/editor</tt> ou <tt>/usr/bin/pager</tt>
quand la variable n'est pas définie.
</p>
	<p>
Un programme peut aussi se servir de la variable d'environnement VISUAL
pour connaître l'éditeur choisi par l'utilisateur. Si elle existe, elle
prend le pas sur la variable EDITOR. Et c'est ce que fait
<tt>/usr/bin/sensible-editor</tt>.</p>


	<p>
Un paquet n'a pas besoin de dépendre d'<tt>editor</tt> ou de <tt>pager</tt>,
et il n'y a pas besoin de paquets virtuels pour cela
<footnote>
<p>
Le système Debian de base fournit déjà un éditeur et
un pagineur.</p>
	  </footnote>.
</p>

      <sect id="web-appl">
	<heading>Serveurs et applications Web</heading>
	  
	<p>
Cette section décrit les emplacements et les «&nbsp;URL&nbsp;» qui seront
employés par tous les serveurs et applications Web dans le système Debian.
</p>
	  
	<p>
	  <enumlist>
	    <item>
<p>Les fichiers exécutables cgi-bin sont installés dans le répertoire
		<example compact="compact">
/usr/lib/cgi-bin/<var>cgi-bin-name</var>
		</example>
et seront référencés par
		<example compact="compact">
http://localhost/cgi-bin/<var>cgi-bin-name</var>
		</example></p></item>
		
		
	    <item><p>L'accès aux documents HTML</p>
		
	      <p>
Les documents HTML d'un paquet sont conservés dans 
<tt>/usr/share/doc/<var>package</var></tt> et peuvent être référencés par
		<example compact="compact">
http://localhost/doc/<var>paquet</var>/<var>nom-de-fichier</var>
		</example></p>
<p>
Le serveur web restreindra l'accés à l'arborescence des documents pour que
seuls les clients appartenant à cette machine puissent consulter ces documents.
Quand le serveur ne peut contrôler les accés, il ne fournira aucun accés, ou
questionnera, pendant l'installation, au sujet d'un tel accés.
</p>
</item>
		
		
	    <item><p>La racine des documents Web</p>
		
	      <p>
Les applications Web éviteront de conserver des fichiers dans la racine
des documents Web. Il faut utiliser, à la place, le répertoire
/usr/share/doc/<var>paquet</var> pour les documents et déclarer
l'application Web via le paquet menu. Si l'accès à la racine des
documents Web est inévitable alors il faut utiliser
		<example compact="compact">
/var/www
		</example> 
comme racine des documents. Cela peut être juste un lien symbolique
vers l'emplacement où l'administrateur a mis la véritable racine
des documents.
 </p>
</item>
</enumlist>
</p>
</sect>
	  
	  
      <sect id="mail-transport-agents">
	<heading>Le courrier : transport, distribution et lecture des messages.</heading>
	  
	<p>
Les paquets Debian qui traitent le courrier électronique, que ce soient les 
agents utilisateurs (MUA: Mail User Agents) ou les agents de transport 
(MTA: Mail Transport Agent), doivent respecter les directives de 
configuration qui suivent. Le non-respect de celles-ci peut entraîner la 
perte de messages, la présence de lignes <tt>From:</tt> incorrectes et 
d'autres dommages sérieux !
</p>
	  
	<p>
Le répertoire pour le courrier est <tt>/var/mail</tt> et l'interface 
pour envoyer des courriers est <tt>/usr/sbin/sendmail</tt> (conformément au 
FHS). Sur des systèmes plus anciens, le répertoire du courrier peut être
physiquement situé dans <tt>/var/spool/mail</tt> mais les accès à ce répertoire
se feront par le lien symbolique <tt>/var/mail</tt>. Le répertoire pour le 
courrier fait partie du système de base et n'appartient pas au paquet MTA.
</p>
	  
<p>
Dans le système Debian, tous les MUA, MTA, MDA et autres programmes de 
gestions des boîtes aux lettres (comme les démons IMAP) doivent verrouiller
les boîtes aux lettres de façon à permettre l'usage de NFS. Cela signifie
que le verrouillage de type <tt>fcntl()</tt> doit être associé avec celui
de type point («&nbsp;dot locking&nbsp;»). Pour éviter les situations inextricables, un programme utilisera d'abord <tt>fcntl()</tt> et ensuite le
verrouillage «&nbsp;point&nbsp;» ou bien implantera si possible les deux 
méthodes à la fois<footnote><p>Quand il n'est pas possible d'établir les deux 
modes de verrouillage, le système ne doit pas attendre que le second mode soit
mis en place, mais doit enlever le premier mode, attendre un certain temps
et recommencer le verrouillage.</footnote>. Pour faire cela, il est
conseillé d'employer les fonctions <tt>maillock</tt> et <tt>mailunlock</tt> 
données dans le paquet <tt>liblockfile*</tt><footnote>
            <p>
Pour utiliser ces fonctions, il faut avoir une dépendance envers 
<tt>liblockfile</tt> version &gt;&gt;1.01.</p>
          </footnote>.
        </p>


	<p>
Les boîtes aux lettres ont généralement le mode 660
<tt><var>utilisateur</var>.mail</tt> à moins que l'administrateur-système n'en
ait décidé autrement. Un MUA peut supprimer une boîte aux lettres (sauf
si elle n'a pas les permissions standards). Dans ce cas, le MTA ou
un autre MUA doit la recréer au besoin. Le groupe <tt>mail</tt> doit 
pouvoir modifier les boîtes aux lettres.
</p>
	<p>
La file d'attente du courrier a le mode 2775
<tt>root.mail</tt> et les MUA doivent appartenir au groupe <tt>mail</tt> 
pour effectuer le verrouillage mentionné précédemment (et doivent évidemment
s'interdire l'accès aux boîtes aux lettres des autres utilisateurs
en employant ce privilège).
</p>
	<p>
<tt>/etc/aliases</tt> est le fichier contenant les alias du système
de messagerie (par exemple postmaster, usenet, etc.) -- c'est l'un des
fichiers que l'administrateur système et les scripts <prgn>postinst</prgn>
peuvent modifier. Après avoir modifié <tt>/etc/aliases</tt>, le programme
ou l'administrateur doit exécuter <prgn>newaliases</prgn>. Tous les
paquets MTA doivent contenir un programme <prgn>newaliases</prgn>,
même s'il ne fait rien. Cependant les anciens paquets MTA ne le
faisant pas, les programmes ne doivent pas échouer si
<prgn>newaliases</prgn> ne peut être trouvé. À cause de cela, tous les
MTA doivent posséder les champs <tt>Provides</tt>, <tt>Conflicts</tt> et
<tt>Replaces: mail-transport-agent</tt> dans leur fichier de contrôle.
</p>
	  
	<p>
La convention consistant à écrire <tt>forward to <var>adresse</var></tt>
dans la boîte aux lettres elle-même n'est pas supportée. Utilisez
un fichier <tt>.forward</tt> à la place.
</p>
	<p>
L'emplacement du programme <prgn>rmail</prgn> utilisé par UUCP pour
les messages entrants sera <tt>/usr/sbin/rmail</tt>.
De même le programme <prgn>rsmtp</prgn>, qui reçoit des lots SMTP via UUCP,
sera placé dans <tt>/usr/sbin/rsmtp</tt> s'il est supporté.
</p>
	<p>
Quand un programme veut savoir quel nom d'hôte  employer, par exemple, pour les
messages sortants (mail et news) qui sont créés localement,
il utilisera le fichier <tt>/etc/mailname</tt>. Il contient
la partie située après le nom d'utilisateur et le signe <tt>@</tt> (at)
des adresses électroniques des utilisateurs de la machine (suivi
par un retour à la ligne).
</p>
	  
	<p>
Un tel programme s'assurera de l'existence de ce fichier. S'il existe,
il sera employé sans commentaire (le script de configuration
d'un MTA peut vouloir interroger l'utilisateur même s'il trouve
ce fichier). S'il n'existe pas, il demandera une valeur à
l'utilisateur (en utilisant de préférence <prgn>debconf</prgn>) et la 
stockera dans <tt>/etc/mailname</tt> puis
l'emploiera pour la configuration du paquet. Le message d'invite
sera explicite afin d'indiquer que ce nom ne sera pas utilisé
seulement par ce paquet. Par exemple dans cette situation, le paquet 
<tt>INN</tt> pourrait dire&nbsp;:
	  <example compact="compact">
Please enter the `mail name' of your system.  This is the
hostname portion of the address to be shown on outgoing
news and mail messages.  The default is
<var>syshostname</var>, your system's host name.  Mail
name [`<var>syshostname</var>']:
	  </example>
	  où <var>syshostname</var> est la sortie de  <tt>hostname
	    --fqdn</tt>.
</p>
</sect> 
	  
	  
      <sect>
	<heading>La configuration du système de «&nbsp;News&nbsp;»</heading>
	  
	<p>
Tous les fichiers de configuration relatifs aux serveurs et aux
clients NNTP (news) seront placés dans le répertoire <tt>/etc/news</tt>.
</p>
	  
	<p>
Quelques points de configuration s'appliquent à de nombreux paquets
concernant les news (clients et serveurs) sur la machine :

	  <taglist>
	    <tag><tt>/etc/news/organization</tt></tag>
	    <item><p>c'est une chaîne qui apparaîtra dans le champ 
organisation de l'en-tête de chaque
message posté par les clients NNTP de la machine.
 </p>
</item>
		
	    <tag><tt>/etc/news/server</tt></tag>
	    <item><p>Contient soit le FQDN du serveur NNTP principal soit
localhost si la machine locale est un serveur NNTP.
 </p>
</item>
	  </taglist>
	  
D'autres fichiers de portée générale peuvent être ajoutés s'ils sont requis 
pour la configuration commune à plusieurs paquets concernant les news.
</p>
</sect>
	  
      <sect>
	<heading>Les programmes pour le système X Window</heading>
	  
        <sect1>
          <heading>Le support de X et la priorité des paquets</heading>

	<p>
On doit configurer pour le système X Window les programmes qui peuvent l'être,
et on doit déclarer toutes les dépendances nécessaires à leur fonctionnement
sous «&nbsp;X&nbsp;». Quand ces dépendances sont pour un paquet
dont la priorité est une priorité supérieure à celles des paquets X dont il
dépend, les binaires spécifiques à «&nbsp;X&nbsp;» peuvent être mis dans un
paquet distinct, ou bien des versions alternatives du paquet avec support de
«&nbsp;X&nbsp;» peuvent être fournies, ou bien encore la priorité du paquet
peut être abaissée.
</p>
	</sect1>

<sect1><heading> Les paquets fournissant un serveur X</heading>

<p>
<em>Les paquets qui fournissent un serveur «&nbsp;X&nbsp;» </em> et qui,
directement ou indirectement, communiquent avec le matériel d'entrée et
d'affichage, déclareront dans leurs données de contrôle qu'ils fournissent
le paquet virtuel <tt>xserver</tt>
          <footnote>
            <p>
Cela met en oeuvre la pratique actuelle et offre une
vraie politique pour l'utilisation du paquet virtuel <tt>xserver</tt>,
lequel apparaît dans la liste des paquets virtuels. En résumé, les serveurs
«&nbsp;X&nbsp;» qui communiquent directement avec le matériel d'entrée et 
d'affichage ou via un autre sous-système (p.ex. GGI) fourniront
<tt>xserver</tt>. Des choses comme <tt>Xvfb</tt>, <tt>Xnest</tt> et
<tt>Xprt</tt> ne doivent pas le faire.
	    </p>
	  </footnote>.
	  </p>
	</sect1>
<sect1>
<heading>Les paquets fournissant un émulateur de terminal</heading>

<p>

Les paquets qui fournissent un émulateur de terminal pour le
système X Window et qui correspondent aux critères énumérés plus bas,
déclareront dans leurs données de contrôle qu'ils fournissent le paquet
virtuel <tt>x-terminal-emulator</tt>. Ils se déclareront comme une
alternative pour <tt>/usr/bin/x-terminal-emulator</tt>, avec une priorité
égale à 20.
</p>
<p>
Pour être un <tt>x-terminal-emulator</tt>, un programme doit&nbsp;:
<list compact="compact">
<item><p>
se comporter comme un terminal DEC VT100 ou un terminal compatible.
</p></item>
<item><p>
accepter l'option de ligne de commande <tt>-e <var>command</var></tt> qui
crée une nouvelle fenêtre de terminal<footnote>
<p>
Une nouvelle fenêtre de terminal ne signifie pas nécessairement une nouvelle
fenêtre X de plus haut niveau directement liée au gestionnaire de 
fenêtres&nbsp;; elle pourrait être, si l'application qui émule le terminal
était codée ainsi, une nouvelle «&nbsp;vue&nbsp;» dans une interface pour
plusieurs documents (MDI, multiple-document interface).
		    </p>
		  </footnote>
et exécuter la <var>command</var> spécifiée.
</p></item>
<item><p>
accepter l'option de ligne de commande <tt>-T <var>title</var></tt> qui
crée une nouvelle fenêtre de terminal avec comme titre <var>title</var>.
</p></item>
</list>
</p>
</sect1>

<sect1><heading>Les paquets fournissant des gestionnaires de fenêtres</heading>

<p>
Les paquets qui fournissent des gestionnaires de fenêtres déclareront dans 
leurs données de contrôle qu'ils fournissent le paquet virtuel 
<tt>x-window-manager</tt>. Ils se déclareront comme une alternative pour 
<tt>/usr/bin/x-window-manager</tt>, avec une priorité qu'on calculera ainsi :
<list compact="compact">
            <item>Commencez avec une priorité égale à 20.</item>
            <item>
<p>
Si le gestionnaire de fenêtres permet le système des menus de Debian, on
ajoutera 20 points si cela se fait avec la configuration par défaut du
paquet (c.-à-d. qu'il n'y a pas besoin, pour obtenir cette fonctionnalité,
de modifier des fichiers de configuration appartenant au système ou à 
l'utilisateur) ; si l'on doit modifier des fichiers de configuration , on
ajoutera seulement 10 points.</p>
</item>
<item>
<p>
Si le gestionnaire de fenêtres autorise, dans sa configuration par défaut, le 
redémarrage d'une session X avec un <em>nouveau</em> gestionnaire de fenêtres 
(sans tuer le serveur X), on ajoutera 10 points ; sinon, rien.
</p>
</item>
</list>
	  </p>
	</sect1>

<sect1>
<heading>Les paquets fournissant des fontes</heading>
<p>
Les paquets qui fournissent des fontes pour le système X Window
<footnote>
<p>
Dans le cadre de cette charte, une «&nbsp;fonte pour le système X Window&nbsp;»
est une fonte accessible par des requêtes utilisant le protocole X. Les
fontes pour la console Linux, pour les formateurs PostScript, etc., ne
rentrent pas dans cette catégorie. Tous les outils qui rendent disponibles de
telles fontes pour le système X Window doivent se conformer cependant à cette
règle.</p>
	    </footnote>
doivent faire un certain nombre de choses pour s'assurer à la fois qu'ils 
sont disponibles sans avoir à modifier la configuration du serveur 
X ou du serveur de fontes, et qu'ils n'abîment pas les fichiers utilisés
par d'autres paquets pour déclarer les renseignements qui les concernent.
<enumlist>
           <item>
<p>
Les fontes de tout type offertes pour le système X Window doivent être dans des
paquets distincts des binaires, bibliothèques ou de la documentation (sauf
celle liée à la fonte fournie, par exemple leur licence). Quand une ou
plusieurs fontes sont nécessaires à l'exploitation correcte du paquet auquel
elles sont associées, le paquet qui les contient peut être placé dans un 
champ <em>Recommends</em>&nbsp;; si elles n'apportent que des améliorations,
on peut utiliser un champ <em>Suggests</em>. Les paquets ne doivent pas
dépendre de paquets contenants des fontes<footnote>
<p>
Le serveur X peut en effet récupérer des fontes sur le système de fichiers
local ou, à travers le réseau, sur un serveur de fontes pour X&nbsp;; le
système Debian des paquets ne permet que l'utilisation du système de fichiers
local.
</p>
</footnote>.
		</p>
	      </item>
<item>
<p>
Les fontes BDF seront converties en fontes PCF avec le programme
<prgn>bdftopcf</prgn> (disponible dans le paquet <tt>xutils</tt>),
<tt>gzip</tt>ées, et placées dans un répertoire qui correspond à leur
définition : 
<list compact="compact">
                  <item><p>
                      Les fontes à 100 dpi seront mises dans
<tt>/usr/X11R6/lib/X11/fonts/100dpi/</tt> ;
		      </p></item>
                  <item><p>
                      Les fontes à 75 dpi seront mises dans
                      <tt>/usr/X11R6/lib/X11/fonts/75dpi/</tt> ;
                  </p></item>
                  <item><p>
Les fontes à chasse fixe, les fontes pour le curseur, ainsi que
d'autres fontes de faible définition seront mises dans
                      <tt>/usr/X11R6/lib/X11/fonts/misc/</tt>.
		      </p></item>
                </list>
            </p>
</item>
            <item><p>
les fontes «&nbsp;Speedo&nbsp;» seront mises dans
<tt>/usr/X11R6/lib/X11/fonts/Speedo/</tt>.
           </p> </item>
<item><p>
les fontes «&nbsp;Type 1&nbsp;» seront mises dans
                <tt>/usr/X11R6/lib/X11/fonts/Type1/</tt>.
Si des fichiers de métrique sont disponibles, ils peuvent aussi être placés 
là.
         </p>   </item>
            <item><p>
On ne doit pas créer ni utiliser d'autres répertoires dans 
<tt>/usr/X11R6/lib/X11/fonts/</tt> que ceux répertoriés dans la liste qui 
précède. (Les répertoires <tt>PEX</tt>, <tt>CID</tt> et <tt>cyrillic</tt> 
font exception 
pour des raisons historiques, mais l'installation de fichiers dans ces 
répertoires reste déconseillée.) 
</p>
</item>
            <item>
<p>
Au lieu de mettre directement des fichiers dans les répertoires cités dans
la liste qui précède, les paquets peuvent fournir des liens symboliques 
dans le répertoire des fontes pointant vers l'emplacement réels des fichiers 
dans l'arborescence. Un tel emplacement doit se conformer au «&nbsp;FHS&nbsp;».
		</p></item>
            <item><p>
Les paquets ne contiendront pas à la fois les versions à 75 dpi et les versions
à 100 dpi d'une fonte. Si les deux sont disponibles, elles seront fournies
dans des paquets distincts dont les noms seront étiquetés <tt>-75dpi</tt>
ou <tt>-100dpi</tt>.</p></item>
            <item><p>
Les fontes destinées au répertoire <tt>misc</tt> ne doivent pas être mises
dans les mêmes paquets que ceux des fontes à 75 dpi ou 100 dpi mais elles 
seront fournies dans un paquet distinct étiqueté <tt>-misc</tt>.
</p>
</item>
            <item>
<p>
Les paquets ne doivent pas fournir les fichiers <tt>fonts.dir</tt>,
<tt>fonts.alias</tt>  ou <tt>fonts.scale</tt> dans un répertoire de fontes.
<list compact="compact">
                  <item><p>
les fichiers <tt>fonts.dir</tt> ne doivent en aucun cas être fournis ;
                  </p></item>
                  <item><p>
si besoin est, les fichiers <tt>fonts.alias</tt> et <tt>fonts.scale</tt>
seront fournis dans le répertoire
<tt>/etc/X11/fonts/<var>fontdir</var>/<var>paquet</var>.<var>extension</var></tt>
où <var>fontdir</var> est le nom du répertoire de
<tt>/usr/X11R6/lib/X11/fonts/</tt> dans lequel sont conservées les fontes
du paquet correspondant (p.ex.<tt>75dpi</tt> ou <tt>misc</tt>), où
<var>paquet</var> est le nom du paquet qui fournit ces fontes, et où
<var>extension</var> correspond au contenu du fichier, soit <tt>scale</tt>
soit <tt>alias</tt>.
</p>
</item>
                </list>
		</p>
            </item>
            <item>
<p>
Les paquets doivent déclarer une dépendance envers le paquet 
<tt>xutils (&gt;&gt; 4.0.3)</tt> dans leurs données de contrôle.
		</p>
	      </item>
<item><p>
Les paquets qui fournissent un ou plusieurs fichiers <tt>fonts.scale</tt> tels
qu'ils sont décrits plus haut, doivent appeler le programme
<prgn>update-fonts-scale</prgn>, pour chaque répertoire où est installée une 
fonte, <em>avant</em> d'appeler le programme <prgn>update-fonts-dir</prgn>
pour ce répertoire. Cet appel doit se faire à la fois dans le script
<prgn>postinst</prgn> (pour tous les arguments) et dans le script
<prgn>postrm</prgn> (pour tous les arguments sauf <tt>upgrade</tt>).
	  </p>
</item>
            <item>
<p>
Les paquets qui fournissent un ou plusieurs de ces fichiers
<tt>fonts.alias</tt> dont on vient de parler, doivent appeler le programme
<prgn>update-fonts-alias</prgn> pour chaque répertoire où ils installent des 
fontes. Cet appel doit se faire à la fois dans le script
<prgn>postinst</prgn> (pour tous les arguments) et dans le script
<prgn>postrm</prgn> (pour tous les arguments sauf <tt>upgrade</tt>).
          </p>
</item>


            <item>
<p>
Les paquets doivent appeler le programme <prgn>update-fonts-dir</prgn>
pour chaque répertoire où ils installent des
fontes. Cet appel doit se faire à la fois dans le script
<prgn>postinst</prgn> (pour tous les arguments) et dans le script
<prgn>postrm</prgn> (pour tous les arguments sauf <tt>upgrade</tt>).
          </p>
</item>
<item>
<p>
Les paquets ne doivent pas proposer, pour les noms des fontes qu'ils
fournissent, des alias qui entrent en conflit avec les alias déjà utilisés
par des fontes d'autres paquets.
</p></item>
<item>
<p>
Les paquets ne doivent pas fournir des fontes qui ont le même nom pour
l'enregistrement XLFD que celui donné par une fonte déjà en usage.
</p>
</item>
          </enumlist>
        </p>
	</sect1>

<sect1>
<heading>Les fichiers « défaut » des applications</heading>
<p>
Les fichiers « défaut » des applications doivent être 
installés dans le répertoire <tt>/etc/X11/app-defaults/</tt> 
(on peut utiliser un répertoire particulier dans <tt>/etc/X11/</tt>
comme l'indique le manuel 
<em>X Toolkit Intrinsics - C Language Interface</em>).
On ne les déclarera pas comme des <tt>conffile</tt>s et on ne les
traitera pas non plus comme des fichiers de configuration. Les paquets ne
doivent pas fournir le répertoire <tt>/usr/X11R6/lib/X11/app-defaults/</tt>.
	  </p>
<p>
Le paramétrage des ressources X des programmes peut aussi se faire par
l'intermédiaire d'un fichier portant le même nom que celui du paquet mis
dans le répertoire <tt>/etc/X11/Xresources/</tt> et qui doit être
enregistré comme <tt>conffile</tt> ou traité comme un fichier de configuration
<footnote>
<p>
Ce mécanisme n'est pas identique à celui d'<em>app-defaults</em>&nbsp;; les
fichiers <em>app-defaults</em> sont liés au binaire client du système de
fichiers local, alors que les ressources X sont stockées dans le serveur X
et influencent tous les clients qui se connectent.
	      </p>
	    </footnote>.

<em>Important :</em> les paquets 
qui installent des fichiers dans le répertoire <tt>/etc/X11/Xresources/</tt> 
doivent déclarer un conflit avec le paquet <tt>xbase 
(&lt;&lt;3.3.2.3a-2)</tt> ; si ce n'est pas fait, le paquet peut détruire un 
<em>fichier</em> <tt>/etc/X11/Xresources</tt> préexistant qui a pu être
paramétré par l'administrateur-système
       </p>
	</sect1>
<sect1>
<heading>Questions concernant le répertoire d'installation</heading>

<p>
Les paquets qui utilisent le système X Window ne seront pas configuré pour
installer des fichiers sous le répertoire <tt>/usr/X11R6/</tt> à moins qu'ils
n'utilisent <prgn>imake</prgn>. La hiérarchie du répertoire 
<tt>/usr/X11R6/</tt> sera tenue comme déconseillée par tous les paquets sauf 
le système X Window lui-même et les paquets qui utilisent le programme 
<prgn>imake</prgn> fourni par ce système&nbsp;; dans ce cas, les paquets 
peuvent quitter le répertoire <tt>/usr/X11R6/</tt> selon la volonté du 
responsable de paquet
<footnote>
<p>
Les programmes qui utilisent <prgn>Imake</prgn> sont dispensés car, tant 
qu'ils sont correctement écrits, les chemins qu'ils utilisent pour 
localiser les ressources et s'installer sont tirés entièrement de la
configuration du système X Window. Et donc, au cas où le système X Window
bougerait vers <tt>/usr/X11R7/</tt>, <tt>/usr/X12/</tt> ou juste un 
simple <tt>/usr/</tt>,  les paquets n'auraient qu'à être recompilés avec les
paquets de développement des bibliothèques du système X Window.
	      </p>
	    </footnote>.
<p>
Les programmes qui utilisent les programmes GNU <prgn>autoconf</prgn> et
<prgn>automake</prgn> sont facilement configurés au moment de la compilation
pour utiliser <tt>/usr/</tt> au lieu de <tt>/usr/X11R6/</tt>, et cela sera
fait à chaque fois que c'est possible. On placera les fichiers de 
configuration des gestionnaires de fenêtres et des gestionnaires d'affichage 
dans un sous-répertoire de <tt>/etc/X11/</tt> correspondant au nom du 
paquet&nbsp;; cela est dû à l'interpénétration étroite de ces programmes et 
du mécanisme du système X Window. Les programmes applicatifs utiliseront le 
répertoire <tt>/etc/</tt>
sauf si cette charte impose autre chose. L'installation de fichiers dans des 
sous-répertoires de <tt>/usr/X11R6/include/X11/</tt> et de 
<tt>/usr/X11R6/lib/X11/</tt> est autorisée mais déconseillée ; les 
responsables de paquet détermineront s'ils peuvent utiliser des 
sous-répertoires de <tt>/usr/lib/</tt> et de <tt>/usr/share/</tt>. (On 
encourage l'usage de liens symboliques des répertoires de X11R6 vers d'autres 
endroits conformes au «&nbsp;FHS&nbsp;» si les programmes ne sont pas 
facilement configurables pour chercher ailleurs leurs fichiers.) Les paquets ne
doivent pas fournir -- ou  y installer des fichiers -- les répertoires
<tt>/usr/bin/X11/</tt>, <tt>/usr/include/X11/</tt> ou
<tt>/usr/lib/X11/</tt>. Les fichiers d'un paquet feront cependant
référence à ces répertoires plutôt qu'à leurs homologues de X11R6, 
<tt>/usr/X11R6/bin/</tt>, <tt>/usr/X11R6/include/X11/</tt> et
<tt>/usr/X11R6/lib/X11/</tt> quand les ressources qui sont référencées
n'ont pas été placées dans des endroits conformes au «&nbsp;FHS&nbsp;».
</p>
	</sect1>
<sect1>
<heading>Les bibliothèques <em>OSF/Motif</em> et <em>OpenMotif</em></heading>
 
	<p>
Les programmes qui demandent les bibliothèque <em>OSF-Motif</em> et 
<em>OpenMotif</em><footnote>
<p>
Dans ce document, on regroupe les deux termes sous le nom de «&nbsp;Motif&nbsp;».</p>
	    </footnote>, 
bibliothèques non conformes aux «&nbsp;DFSG&nbsp;», seront compilés et 
testés avec «&nbsp;LessTif&nbsp;» (une libre ré-implémentation de 
«&nbsp;Motif&nbsp;»). Quand le responsable du paquet juge que 
le programme ne fonctionne pas suffisamment bien avec «&nbsp;LessTif&nbsp;»
pour être distribué et supporté, mais qu'il fonctionne correctement quand
il est compilé avec «&nbsp;Motif&nbsp;», il créera alors deux versions du
paquet ; l'une qui sera liée de façon statique à «&nbsp;Motif&nbsp;» et
dont le nom sera étiqueté «&nbsp;-smotif&nbsp;», et l'autre qui sera liée
de façon dynamique à «&nbsp;Motif&nbsp;» et dont le nom sera étiqueté 
«&nbsp;-dmotif&nbsp;». Les deux versions liées à «&nbsp;Motif&nbsp;» sont
dépendantes de logiciels non conformes aux «&nbsp;DFSG&nbsp;» et donc ne
peuvent être mis dans la section «&nbsp;main&nbsp;» de la distribution ; si 
le logiciel lui-même est conforme aux «&nbsp;DFSG&nbsp;»  il peut être mis 
dans la section «&nbsp;contrib&nbsp;».Toutes les versions connues de
«&nbsp;OSF-Motif&nbsp;» autorisent la redistribution sans restrictions de 
binaires liés de façon statique ou dynamique à cette bibliothèque, mais 
c'est au responsable de paquet de déterminer si la licence  
de la version de «&nbsp;Motif&nbsp;» qu'il possède le permet.
	</p>
	</sect1>
      </sect>
	  
	  
<sect>
<heading>Les programmes et modules Perl</heading>
<p>
Les programmes et modules Perl suivront la norme actuelle pour Perl telle
qu'elle est définie dans le fichier
<ftpsite>ftp.debian.org</ftpsite> 
<ftppath>/debian/doc/package-developer/perl-policy.txt.gz</ftppath>, ou
sur votre miroir local. De plus, ce fichier fait partie du paquet
<tt>debian-policy</tt>.</p>
      </sect>
     <sect>
	<heading>Les programmes emacs lisp</heading>
	  
	<p>
Veuillez consulter le «&nbsp;Debian Emacs Policy&nbsp;» (documenté dans
<tt>debian-emacs-policy.gz</tt> du paquet <prgn>emacsen-common</prgn>)
pour les détails concernant la création de paquets de programmes
emacs lisp.
</p>
</sect>
	  
	  
      <sect>
	<heading>Les jeux</heading>
	  
	<p>
Les permissions de <tt>/var/lib/games</tt> sont 755 , propriétaire 
<tt>root</tt> et groupe <tt>root</tt>.
</p>
	  
	<p>
Chaque jeu décide de ses propres règles de sécurité.
</p>
	  
	<p>
Les jeux qui demandent des accès privilégiés et protégés à des
fichiers de scores, de sauvegardes de parties, etc., peuvent appartenir
à <tt>root.games</tt> et être exécutables par le groupe <tt>games</tt> 
(mode 2755) et doivent utiliser des fichiers et des répertoires avec
des permissions appropriées (770 <tt>root.games</tt> par exemple).
Ils ne doivent pas être exécutable par un utilisateur (set-user-id),
car cela entraîne des problèmes de sécurité. (Si un attaquant arrive
à corrompre un jeu «&nbsp;set-user-id&nbsp;», il peut alors remplacer 
l'exécutable d'autres utilisateurs, forçant les autres joueurs de ces jeux à 
exécuter un cheval de Troie. Avec un programme «&nbsp;set-group-id&nbsp;»,
l'attaquant n'a accès qu'à des données de jeu moins 
importantes. S'il veut accéder aux comptes des autres joueurs, cela lui 
demandera des efforts beaucoup plus importants).
</p>
	  
	<p>
Certains paquets, comme les programmes «&nbsp;fortune&nbsp;», sont configurés
par leurs auteurs originaux pour interdire la lecture de leurs fichiers
de données ou d'autres informations statiques,
de manière qu'ils ne puissent être accessibles que par les programmes 
«&nbsp;set-id&nbsp;» fournis. Vous ne ferez pas de même dans un paquet 
Debian : n'importe qui peut télécharger le fichier <tt>.deb</tt> et y lire 
les données, cela n'a donc pas de sens d'avoir des fichiers non lisibles. 
Créer des fichiers accessibles en lecture implique aussi que vous n'avez pas 
à construire des programmes «&nbsp;set-id&nbsp;», ce qui réduit le risque de 
trous de sécurité.
</p>
	<p>
	  Conformément au «&nbsp;FHS&nbsp;», les binaires des jeux seront
installés dans le répertoire <tt>/usr/games</tt>. Cela s'applique
aussi aux jeux utilisant le système <em>X Window</em>. On installera les 
pages de manuel des jeux («&nbsp;X&nbsp;» et «&nbsp;non-X&nbsp;») dans
<tt>/usr/share/man/man6</tt>.
</p>
</sect>
</chapt>
      
    <chapt id="13"><heading>La documentation</heading>
	
      
      <sect>
	<heading>Les pages du manuel</heading>
	  
	<p>
On installera les pages de manuel sous la forme d'un source
<prgn>nroff</prgn>, à l'emplacement approprié dans <tt>/usr/share/man</tt>.
Vous utiliserez uniquement les sections 1 à 9 (voir le FHS pour
plus de détails). Vous ne devez pas installer de
pages «&nbsp;cat&nbsp;» préformatées.
</p>
<p>
Chaque programme, utilitaire ou fonction aura une page de manuel associée
dans le même paquet. On suggère aussi que chaque fichier de configuration
ait une page de manuel associée.
</p>	  
	<p>
Quand il n'y a pas de page de manuel pour un programme, un utilitaire, une 
fonction particulière ou un fichier de configuration  et qu'un bogue a été 
rapporté au système Debian de suivi de bogues, on créera un lien symbolique de
cette page vers la page de manuel <manref name="undocumented" section="7">. 
Ce lien symbolique peut être créé à partir de <tt>debian/rules</tt> comme 
suit&nbsp;:
	  <example compact="compact">
ln -s ../man7/undocumented.7.gz \
debian/tmp/usr/share/man/man[1-9]/<var>le-nom-de-la-page</var>.[1-9].gz
	  </example> 
Cette page de manuel indique que l'absence de page de manuel a déjà
été signalée comme un bogue, ainsi vous ne pouvez faire le lien que si tel
est le cas (vous pouvez le rapporter vous-même si vous le souhaitez).
Ne fermez pas le rapport de bogue tant qu'une page de manuel adéquate
n'est pas disponible.
</p>
	  
	<p>
Vous pouvez faire suivre une plainte concernant l'absence d'une page du manuel
aux auteurs originaux, et signaler qu'un rapport de bogue a été envoyé au 
système Debian de suivi des bogues. Même si le projet GNU ne considère pas en
général l'absence d'une page du manuel comme un bogue, nous oui. S'ils vous
répondent qu'ils ne considèrent pas cela comme un bogue, laissez quand même 
le bogue ouvert dans notre système de suivi.
</p>
	  
	<p>
Les pages de manuel seront installées comprimées via <tt>gzip -9</tt>.
</p>
	<p>
Si une page de manuel doit être accessible via différents noms, il est
préférable d'utiliser un lien symbolique plutôt que la fonctionnalité
<tt>.so</tt>, mais il est inutile de bricoler les parties
incriminées dans les sources originaux pour changer les <tt>.so</tt>
en liens symboliques (à moins que ce soit trivial).
Ne créez pas de lien physique dans les répertoires des pages du manuel
et ne mettez pas de chemin absolu dans les directives <tt>.so</tt>.
Le nom du fichier dans le <tt>.so</tt> d'une page du manuel sera
relatif à la racine des pages (habituellement <tt>/usr/share/man</tt>).
Si l'on ne crée pas de liens (liens symboliques, liens «&nbsp;en dur&nbsp;» 
ou des directives <tt>.so</tt>) dans le système de fichiers pour les autres 
noms de cette page, on ne comptera pas sur <prgn>man</prgn> pour trouver la
page de manuel sous ces noms à partir des seuls renseignements contenus dans
l'en-tête de la page<footnote>
<p>
Cette faculté demande à <prgn>man</prgn> un temps de calcul déraisonnable
pour trouver une page de manuel, rapporter qu'elle n'existe pas et
transférer dans sa base de données une information qui devrait rester dans le
système de fichier. Elle est déconseillé et cessera d'exister à l'avenir.
	    </p>
	  </footnote>.
</p>
</sect>
	  
      <sect>
	<heading>Les documents «&nbsp;Info&nbsp;»</heading>
	  
	<p>

On installera les documents «&nbsp;Info&nbsp;» dans <tt>/usr/share/info</tt>.
Ils seront comprimés avec <tt>gzip -9</tt>.
</p>
	<p>
Votre paquet appellera <prgn>install-info</prgn>, dans le script 
<prgn>postinst</prgn>, appelé par exemple avec un argument <tt>configure</tt>,
pour mettre à jour le fichier <tt>dir</tt> de «&nbsp;Info&nbsp;»&nbsp;:
	  <example compact="compact">
install-info --quiet --section Development Development \
/usr/share/info/foobar.info
	  </example></p>
	  
	<p>
Il est judicieux de spécifier une section pour l'emplacement de votre
programme ; cela se fait avec l'option <tt>--section</tt>.
Pour déterminer la section à utiliser, vous devez consulter
<tt>/usr/share/info/dir</tt> sur votre système et choisir la plus adéquate
(ou créer une nouvelle section si aucune des sections actuelles n'est
adaptée). Notez que l'option <tt>--section</tt> prend deux arguments ;
le premier est une expression régulière pour rechercher une section
existante (indépendamment de la casse), le second est utilisé pour la création
d'une nouvelle section.
</p>
	<p>
Vous retirerez les entrées dans le script <prgn>prerm</prgn> appelé avec un
argument <tt>remove</tt>&nbsp;:
	  <example compact="compact">
install-info --quiet --remove /usr/share/info/foobar.info
	  </example></p>
	  
	<p>
Si <prgn>install-info</prgn> ne trouve pas une entrée descriptive dans
le fichier Info, vous devrez en fournir une. Voir
<manref name="install-info" section="8"> pour des précisions.
</p>
</sect>
      
      <sect>
	<heading>Documentations supplémentaires</heading>
	
	<p>
Le responsable d'un paquet peut installer toute documentation supplémentaire 
qui vient avec ce paquet. Les documents texte seront placés dans le 
répertoire <tt>/usr/share/doc/<var>paquet</var></tt>,
et comprimés avec <tt>gzip -9</tt> à moins qu'ils soient petits.
</p>
	
	<p>
Si un paquet contient une importante documentation dont la majorité des
utilisateurs du paquet n'a pas besoin, vous la mettrez dans un paquet binaire
distinct. Ainsi elle ne prendra pas d'espace disque sur
les machines d'utilisateurs qui n'en ont pas besoin ou qui ne veulent
pas l'installer.
</p>

	
	<p>
Il est souvent judicieux de mettre les fichiers texte d'informations
(<tt>README</tt>, changelogs et autres) provenant du paquet source
dans <tt>/usr/share/doc/<var>paquet</var></tt> au sein des paquets binaires.
Bien entendu, vous n'avez pas besoin de fournir les instructions
de compilation et d'installation.
</p>

<p>
Aucun programme ne renverra à des fichiers de <tt>/usr/share/doc</tt>, et
l'administrateur système pourra les supprimer sans «&nbsp;planter&nbsp;»
un programme. Tout fichier référencé par un programme et qui est utile
en tant que documentation indépendante utile sera installé dans 
<tt>/usr/share/<var>paquet</var>/</tt> et lié symboliquement avec
<tt>/usr/share/doc/<var>paquet</var>/</tt>.
	</p>

</sect>
 
      <sect id="usrdoc">
      <heading>L'accès à la documentation</heading>

       <p>
Les précédentes versions de Debian plaçaient toute la documentation 
supplémentaire dans <tt>/usr/doc/<var>paquet</var></tt>. Afin de migrer
en douceur vers <tt>/usr/share/doc/<var>paquet</var></tt>, chaque paquet
doit maintenir un lien symbolique <tt>/usr/doc/<var>paquet</var></tt> qui
pointe vers <tt>/usr/share/doc/<var>paquet</var></tt>, qui est la place réelle 
de sa documentation<footnote> Ces liens symboliques seront détruits un jour,
mais ils doivent exister pour des raisons de compatibilité jusqu'à ce que tous
les paquets aient pris en compte cette règle et que la charte debian soit
changée en conséquence.</footnote>. Le lien symbolique doit être créé au 
moment de l'installation du paquet ; il ne peut être contenu dans le paquet
lui-même à cause de problèmes avec <prgn>dpkg</prgn>. Une façon raisonnable
de faire est de mettre, dans le script <prgn>postinst</prgn><footnote>
<p>
Le script de <tt>debhelper</tt>, <prgn>dh_installdocs</prgn> fait ça 
automatiquement.</p>
	  </footnote>, ce qui suit&nbsp;:
          <example compact="compact">
if [ "$1" = "configure" ]; then
 if [ -d /usr/doc -a ! -e /usr/doc/<var>paquet</var> \
    -a -d /usr/share/doc/<var>paquet</var> ]; then
 ln -sf ../share/doc/<var>paquet</var> /usr/doc/<var>paquet</var>
 fi
fi
          </example>
et dans le script <prgn>prerm</prgn>:
          <example compact="compact">
if [ \( "$1" = "upgrade" -o "$1" = "remove" \) \
  -a -L /usr/doc/<var>paquet</var> ]; then
  rm -f /usr/doc/<var>paquet</var>
fi
          </example>
	</p>
      </sect>
     
    
  <sect>
	<heading>Les formats préférés pour la documentation </heading>
	
	<p>
L'unification de la documentation Debian se fait autour d'HTML.
</p>
	
	<p>
Si votre paquet comprend une importante documentation dans un format balisé
qui peut être converti en d'autres formats, vous livrerez
si possible la version HTML dans le paquet binaire, dans le répertoire
<tt>/usr/share/doc/<var>paquet-approprié</var></tt> ou un de ces 
sous-répertoires
<footnote>
 <p> 
 Le raisonnement : ce qui importe ici, c'est que les documents HTML 
 soient disponibles dans <em>certains</em> paquets, et pas
 nécessairement dans le paquet binaire principal.
 </p>
</footnote>.

</p>
	<p>
Le responsable de paquet peut fournir à sa guise d'autres formats, comme 
PostScript.
</p>
</sect>
      
      <sect id="copyrightfile">
	<heading>Les informations de copyright</heading>
	
	<p>
Chaque paquet doit être accompagné d'une copie <em>verbatim</em> de son 
copyright ainsi que de sa licence de distribution dans le fichier
<tt>/usr/share/doc/<var>paquet</var>/copyright</tt>. Ce fichier ne doit 
pas être comprimé ni être un lien symbolique.
</p>
	<p>
De plus, le fichier de copyright doit préciser où ont été obtenus
les fichiers sources originaux (s'ils existent) et expliquera brièvement 
quelles modifications ont été faites à ces fichiers dans la version Debian. Il
nommera les auteurs originaux  et le(s) responsable(s) Debian 
qui ont oeuvré à la création du paquet.
</p>

<p>
Une copie du fichier installé dans 
<tt>/usr/share/doc/<var>paquet</var>/copyright</tt> sera faite dans le
<tt>debian/copyright</tt> du paquet source.</p>

	<p>
<tt>/usr/share/doc/<var>paquet</var></tt> peut être un lien symbolique 
vers un répertoire de <tt>/usr/share/doc</tt> seulement si, de deux paquets 
provenant tous les deux de la même source, le premier possède une relation 
«&nbsp;Depends&nbsp;» avec le second. Ces règles sont importantes car 
on doit pouvoir extraire les copyrights par des moyens automatiques.
</p>
	<p>
Les paquets distribués sous la licence «&nbsp;UCB BSD&nbsp;», la licence 
«&nbsp;Artistic&nbsp;», la licence «&nbsp;GNU GPL&nbsp;» ou la licence 
«&nbsp;GNU LGPL&nbsp;» feront respectivement référence aux fichiers 
<tt>/usr/share/common-licenses/BSD</tt>,
	  <tt>/usr/share/common-licenses/Artistic</tt>,
	  <tt>/usr/share/common-licenses/GPL</tt> et
	  <tt>/usr/share/common-licenses/LGPL</tt>, plutôt que de les citer
dans le fichier de copyright.
</p>
	
	<p>
Vous ne devez pas utiliser le fichier copyright comme un fichier 
<tt>README</tt> général. Si votre paquet possède un tel fichier, vous 
l'installerez dans <tt>/usr/doc/<var>paquet</var>/README</tt> ou 
<tt>README.Debian</tt> ou dans un autre endroit approprié.
</p>
</sect>

<sect>
<heading>Exemples</heading>

<p>
On installera tous les exemples (configuration, fichiers source, autres) dans 
un répertoire <tt>/usr/share/doc/<var>package</var>/examples</tt>.
Ces fichiers ne seront pas utilisés par un quelconque programme.
Ils ne sont là qu'en tant que documentation, et pour le seul bénéfice de 
l'administrateur système et des utilisateurs.
On installera les exemples concernant une architecture particulière dans un 
répertoire <tt>/usr/lib/<var>paquet</var>/examples</tt> et les fichiers dans
<tt>/usr/share/doc/<var>paquet</var>/examples</tt> seront des liens 
symboliques. Ou bien, ce dernier répertoire sera un lien vers le premier.
</p>
</sect>

<sect id="instchangelog">
<heading>Les fichiers «&nbsp;Changelog&nbsp;»</heading>

<p>
Les paquets qui ne sont pas originaires de Debian doivent contenir,
dans <tt>/usr/share/doc/<var>paquet</var></tt>, une copie compactée nommée
<tt>changelog.Debian.gz</tt> du fichier <tt>debian/changelog</tt> qui est dans
l'arborescence des sources.
S'il existe un «&nbsp;changelog&nbsp;» original, il sera accessible en fichier
texte comme <tt>/usr/share/doc/<var>paquet</var>/changelog.gz</tt>.
Si le «&nbsp;changelog&nbsp;» original est distribué comme fichier HTML,
il sera rendu disponible en tant que
<tt>/usr/share/doc/<var>paquet</var>/changelog.html.gz</tt> et le
<tt>changelog.gz</tt> sera produit en utilisant p.ex.
<tt>lynx -dump -nolist</tt>.
Si le changelog original n'est pas déjà conforme 
à cette convention, alors cela peut être réalisé soit en renommant ce fichier 
soit en créant un lien symbolique, c'est à la convenance du responsable
du paquet<footnote><p> Argument : on n'a pas à chercher dans deux endroits
les «&nbsp;changelogs&nbsp;» originaux simplement parcequ'ils ont des noms
différents ou parce qu'ils sont dans un format HTML.</footnote>.
</p>

<p>
Ces fichiers seront installés comprimés par <tt>gzip -9</tt>, car 
ils grossissent avec le temps même s'ils commencent petitement.
</p>

<p>
Quand un paquet a un seul changelog, utilisé à la fois comme
changelog Debian et changelog original car le responsable principal est le même
que le responsable Debian, on appellera simplement ce changelog :
<tt>/usr/share/doc/<var>paquet</var>/changelog.gz</tt>. S'il y a un 
responsable principal mais pas de changelog source, on appellera toujours le 
changelog Debian : <tt>changelog.Debian.gz</tt>.
</p>
</sect>
</chapt>
<appendix id="pkg-scope">
<heading>Introduction : la portée des ces annexes</heading>
<p>
Ces annexes sont tirées essentiellement <em>verbatim</em> du 
<em>Packaging Manual</em>, version 3.2.1.0,  dont l'usage est maintenant 
déconseillé. Elles contiennent les chapitres qui peuvent aider les 
responsables de paquet et qui n'ont pas été inclus dans la Charte elle-même. 
La plupart de ces sections ne sont sans doute pas pertinentes pour une
charte ; elles seront vues comme une documentation du système d'empaquetage.
Veuillez remarquer que ces appendices ont été incluses pour leur utilité et
pour des raisons historiques : elles faisaient parties du paquet 
«&nbsp;policy&nbsp;» et n'ont pas encore intégré la documentation de
<prgn>dpkg</prgn>. Cependant, elles sont utiles et sont donc présentées ici.
      </p>
<p>
On ne s'est pas assuré qu'ils étaient compatibles avec le contenu de la 
Charte&nbsp;; s'il y a contradiction, la version de la Charte prime. On ne 
s'est pas assuré non plus qu'aucune partie des chapitres restants du vieux 
<em>Packaging Manual</em> n'a été oubliée. Ces deux choses seront faites en 
temps et en heure.
      </p>
<p>
<prgn>dpkg</prgn> est un ensemble de programmes servant à la création, 
l'installation et la suppression des fichiers des paquets binaires sur les 
systèmes Unix
<footnote> <prgn>dpkg</prgn> est conçu d'abord pour Debian GNU-Linux, mais
peut fonctionner sur, ou être porté vers, d'autres systèmes.</footnote>.
      </p>
<p>
Les paquets binaires sont conçus pour la gestion des programmes exécutables
installés (habituellement des binaires compilés) et de leurs données 
associées, bien que les exemples de code source et la documentation fassent 
partie de certains paquets.
      </p>
<p>
Ce manuel décrit les aspects techniques de la création des paquets binaires 
Debian (fichiers <tt>.deb</>). Il documente le comportement des
programmes de gestion des paquets <prgn>dpkg</prgn>, 
<prgn>dselect</prgn> et al., et la manière dont ils interagissent avec les 
paquets.
      </p>
<p>
Il précise aussi les interactions entre le coeur de <prgn>dselect</prgn> et les
méthodes d'accès qu'il utilise pour installer réellement les paquets
sélectionnés, et décrit comment créer une nouvelle méthode d'accès.
      </p>
<p>
Ce manuel ne détaille pas les options et l'utilisation des outils de création
et d'installation des paquets. Il est donc souhaitable de le lire
conjointement avec les pages de manuel de ces programmes.
      </p>
<p>
Les utilitaires qui sont fournis avec <prgn>dpkg</prgn> pour gérer
les problèmes de configuration des différents systèmes, tels
que <prgn>update-rc.d</prgn> et <prgn>install-info</prgn> ne sont pas non 
plus décrits en détail, voyez leurs pages de manuel.
      </p>
<p>
Ce manuel ne décrit pas les principes imposés aux paquets Debian, tels
que les permissions sur les fichiers et répertoires, la documentation,
les procédures d'installation sur le serveur, etc. On consultera le
<em>Debian packaging policy manual</em> pour ces détails. (Beaucoup de ces
principes seront utiles même quand on ne veut pas installer un paquet  
dans une distribution du serveur.)
      </p>
<p>
On supposera que le lecteur est familier avec le manuel de l'administrateur
système <prgn>dpkg</prgn>. Malheureusement ce document n'existe pas encore.

      </p>
<p>
La version Debian du programme GNU <prgn>hello</prgn> de la <em>FSF</em> est 
proposé comme exemple aux personnes qui souhaitent créer des paquets Debian. 
Le paquet Debian <prgn>debmake</prgn> est un outil recommandé pour la 
création et
la maintenance des paquets Debian. Bien qu'utiles, ces outils et les
exemples ne peuvent cependant dispenser de la lecture de la Charte.
      </p>
    </appendix>

<appendix id="pkg-binarypkg"><heading>Les paquets binaires (annexe tirée de l'ancien <em>Packaging Manual</em>)</heading>
<p>
Un paquet binaire comporte deux parties principales. La première comprend 
divers fichiers d'information de contrôle et des scripts utilisés
par <prgn>dpkg</prgn> lors de l'installation ou de la désinstallation. Voir
<ref id="pkg-controlarea">.
      </p>
<p>
La deuxième partie est une archive contenant les fichiers et les
répertoires à installer.
      </p>
<p>
À l'avenir les paquets binaires pourront contenir d'autres composants,
comme des sommes de contrôles ou des signatures numériques. Le format
de l'archive est décrit dans la page de manuel de <tt>deb(5)</tt>.
      </p>
<p>
<sect id="pkg-bincreating"><heading>Comment créer les fichiers d'un paquet ? -- <prgn>dpkg-deb</prgn></heading>
<p>
Toutes les manipulations des fichiers d'un paquet binaire se font avec 
<prgn>dpkg-deb</prgn>&nbsp;; c'est le seul programme qui connaisse le format. 
(<prgn>dpkg-deb</prgn> peut être appelé par <prgn>dpkg</prgn>, car 
<prgn>dpkg</prgn> reconnaît que les options qui lui sont données appartiennent
à <prgn>dpkg-deb</prgn> et l'appelle avec ces arguments.
	</p>
<p>
Pour créer un paquet binaire, on doit créer une arborescence qui
contient tous les fichiers et répertoires destinés à la partie « données »
du système de fichiers du paquet. Dans les paquets Debian au format
source, ce répertoire, <tt>debian/tmp</>, est habituellement relatif à la
racine de l'arborescence du paquet source.
	</p>
<p>
Avec les versions actuelles de <prgn>dpkg</prgn>, les identifiants <em>uid</em>
(utilisateur) et les identifiants <em>gid</em> (groupe) utilisés seront les
mêmes pour le système <em>sur</em> lequel on construit que pour le système 
<em>pour</em> lequel on construit.
	</p>
<p>
On doit ajouter un répertoire spécial à la racine de la mini
arborescence créée&nbsp;: <prgn>DEBIAN</prgn>. Il contiendra les
fichiers de contrôle, notamment le fichier de contrôle des
paquets binaires (voir <ref id="pkg-controlfile">).
	</p>
<p>
Le répertoire <tt>DEBIAN</tt> n'apparaîtra pas dans l'archive du système
de fichiers du paquet, et ainsi ne sera pas créé par <prgn>dpkg</prgn>
quand le paquet sera installé.
	</p>
<p>
Quand le paquet est prêt, on appellera&nbsp;:
<example>
dpkg --build <var>répertoire</var>
</example>
	</p>
<p>
Le paquet sera construit dans <tt><var>répertoire</var>.deb</tt>. 
(<prgn>dpkg</prgn> sait que <tt>--build</tt> est une option de
<prgn>dpkg-deb</prgn> et il appelle <prgn>dpkg-deb</prgn> avec ces arguments
pour construire le paquet.)
	</p>
<p>
Voir les pages de manuel <manref name="dpkg-deb" section="8">
pour savoir comment examiner le contenu de ce fichier fraîchement créé.
Les sorties des commandes suivantes peuvent être éclairantes&nbsp;:
<example>
dpkg-deb --info <var>filename</var>.deb
dpkg-deb --contents <var>filename</var>.deb
dpkg --contents <var>filename</var>.deb
</example>
Pour voir le copyright d'un paquet, on peut utiliser cette commande&nbsp;:
<example>
dpkg --fsys-tarfile <var>filename</var>.deb | tar xof usr/share/doc/<var>\*</var>c\opyright | less
</example>
	</p>
      </sect>
<sect id="pkg-controlarea">
<heading>Les fichiers de contrôle d'un paquet</heading>
<p>
La partie contenant les informations de contrôle d'un paquet binaire est une
collection de fichiers dont les noms sont connus par <prgn>dpkg</prgn>.
<prgn>dpkg</prgn> traitera le contenu de ces fichiers d'une manière spéciale -
certains d'entre eux contiennent des informations utilisées pour 
l'installation ou la suppression d'un paquet&nbsp;; les autres sont des
scripts dont le responsable de paquet désire l'exécution.
	</p>
<p>
Il est possible de mettre d'autres fichiers dans la zone de contrôle du
paquet, mais ce n'est pas une bonne idée (de toute façon ils seront ignorés).
	</p>
<p>
Voici une brève liste  des fichiers de contrôle utilisés par
<prgn>dpkg</prgn> et un résumé de ce qu'ils font.
	</p>
<p>
<taglist>
<tag><tt>control</tt>
<item>
<p>
C'est le principal fichier de description utilisé par <prgn>dpkg</prgn>. Il
indique le nom et la version du paquet, donne sa description pour les
utilisateurs, établit les relations avec les autres paquets, etc.
Voir <ref id="pkg-controlfile">.
	      </p>
<p>
Ce fichier est créé par le programme <prgn>dpkg-gencontrol</prgn>, avec 
l'aide de <prgn>dpkg-shlibdeps</prgn>, à partir des informations
contenues dans le paquet source. Voir <ref id="pkg-sourcetools">.
	      </p>
<p>
<tag><tt>postinst</tt>, <tt>preinst</tt>, <tt>postrm</tt>, <tt>prerm</tt></tag>
<item>
<p>
Ce sont des fichiers exécutables (habituellement des scripts) que
<prgn>dpkg</prgn> exécute pendant l'installation, la mise à jour ou
la suppression des paquets. Ils permettent de traiter les particularités
d'un paquet ou celles qui nécessitent un traitement plus
compliqué que celui fourni par <prgn>dpkg</prgn>. Quand et comment ils sont 
appelés est indiqué dans <ref id="6">.
	      </p>
<p>
Il est très important de rendre ces scripts idempotents
<footnote>
Cela signifie : ils s'exécutent correctement ou échouent ; mais, s'ils sont 
appelés de nouveau, ils ne doivent pas se planter, mais s'assurer que tout 
est à sa place.</footnote>.
Qu'une erreur survienne (l'utilisateur interrompt <prgn>dpkg</prgn>, etc.)
il ne faut pas laisser à l'utilisateur un paquet défectueux.
	      </p>
<p>
Les scripts de maintenance peuvent compter sur un 
terminal de contrôle et peuvent interagir avec l'utilisateur. S'ils ont
besoin de demander des mots de passe, d'utiliser une interaction plein
écran ou quelque chose de similaire, on utilisera <tt>/dev/tty</tt>, étant 
donné que <prgn>dpkg</prgn> peut rediriger 
les entrées/sorties standards du script afin d'enregistrer la
procédure d'installation. De même, puisque ces scripts peuvent être
exécutés avec la sortie standard redirigée dans un tube à des fins 
d'enregistrement, les scripts Perl indiqueront <tt>$|=1</> afin que la sortie 
soit imprimée immédiatement plutôt que bufférisée.
	      </p>
<p>
Chaque script retournera zéro en cas de succès ou autre chose en cas d'échec.
	      </p>
<p>
</item>
<tag><tt>conffiles</tt>
</tag>
<item>
<p>
Ce fichier contient une liste des fichiers de configuration qui doivent être 
gérés automatiquement par <prgn>dpkg</prgn> (voir <ref id="pkg-conffiles">).
Il faut remarquer que tous les fichiers de configuration ne sont pas
nécessairement listés là.
	      </p>
	    </item>
<tag><tt>shlibs</tt>
</tag>
<item>
<p>
Ce fichier contient une liste des bibliothèques partagées fournies par
le paquet avec les informations de dépendances pour chacune. Elle est utilisée
par <prgn>dpkg-shlibdeps</prgn> quand il détermine quelles dépendances sont
nécessaires dans un fichier de contrôle de paquet. Le format du fichier
<tt>shlibs</> est décrit dans <ref id="shlibs">.
	      </p>
	    </item>
	  </taglist>
</p>
<sect id="pkg-controlfile">
<heading>Le principal fichier de contrôle : <tt>control</tt></heading>
<p>
Le plus important fichier de contrôle, utilisé par <prgn>dpkg</prgn>
quand il installe un paquet, est le fichier <tt>control</tt>. Il contient
toutes les statistiques vitales du paquet.
	</p>
<p>
Les fichiers de contrôle des paquets binaires construits à partir des sources 
Debian sont faits par un outil spécial <prgn>dpkg-gencontrol</prgn> qui lit 
<tt>debian/control</tt> et <tt>debian/changelog</tt> pour trouver les 
informations dont il a besoin. Voir <ref id="pkg-sourcepkg"> pour des 
précisions.
	</p>
<p>
Les champs d'un fichier de contrôle d'un paquet binaire sont&nbsp;:
<list compact="compact">
<item>
<p><qref id="pkg-f-Package"><tt>Package</tt></qref> (obligatoire)</p>
</item>
<item>
<p>
<qref id="4"><tt>Version</tt></qref> (obligatoire)</p>
</item>
<item>
<p>
<qref id="pkg-f-Architecture"><tt>Architecture</tt></qref> (obligatoire)
<footnote>
<p>
Ce champ apparaîtra dans tous les paquets, même si <prgn>dpkg</prgn> n'en a 
pas besoin, afin que les vieux paquets
puissent être toujours installés.</p></footnote>
	      </p>
	    </item>
<item>
<p>
<qref id="7"><tt>Depends</tt>, <tt>Provides</tt> et al.</qref>
	      </p>
	    </item>
<item>
<p>
<qref id="pkg-f-Essential"><tt>Essential</tt></qref>
	      </p>

	    </item>
<item>
<p>
<qref id="pkg-f-Maintainer"><tt>Maintainer</tt></qref>
	      </p>
	    </item>
<item>
<p>
<qref id="pkg-f-classification"><tt>Section</tt>, <tt>Priority</tt></qref>
	      </p>
	    </item>
<item>
<p>
<qref id="pkg-f-Source"><tt>Source</tt></qref></p>
	    </item>
<item>
<p><qref id="descriptions"><tt>Description</tt></qref></p>
	    </item>
<item>
<p>
<qref id="pkg-f-Installed-Size"><tt>Installed-Size</tt></qref>
	      </p>
	    </item>
	  </list>
<p>
Une description de la syntaxe des fichiers de contrôle et du but de ces
champs est disponible dans <ref id="pkg-controlfields">.
	</p>
      </sect>
<sect>
<heading>Les timbres à date</heading>
<p>
<p>
Les responsables de paquets préserveront, autant que possible,
les dates de modification des fichiers sources d'un paquet<footnote>
<p>
L'idée est que la connaissance de l'âge d'un fichier apporte
certaines informations ; par exemple, on peut reconnaître l'ancienneté de telle
documentation en regardant la date de modification. Et donc il serait bon de
préserver les dates de modifications des fichiers sources.</p>
          </footnote>.
</p>
      </sect>
    </appendix>

<appendix id="pkg-sourcepkg">
<heading> Les paquets sources (annexe tirée de l'ancien<em> Packaging Manual</em>)</heading>
<p>
Les paquets binaires de la distribution Debian sont créés à partir des
paquets sources, lesquels sont dans un format spécial pour faciliter la 
construction automatique des binaires.
      </p>
<p>
Une version précédente du format source Debian est devenue obsolète.
Les instructions pour convertir les vieux paquets sont données dans 
la charte Debian.
      </p>

<sect id="pkg-sourcetools">
<heading> Les outils pour gérer les paquets sources</heading>
<p>
De nombreux outils sont fournis pour manipuler les paquets sources.
Ils emballent et déballent les sources, aident à la construction
des paquets binaires et gérent la distribution des nouvelles versions.
	</p>
<p>
Ils sont présentés ici et leurs usages habituels décrits ; pour de plus 
amples informations, voir <manref name="dpkg-source" section="1">.
	</p>
<p>
Le paquet <prgn>hello</prgn> est un exemple de construction de paquet source 
Debian et de la mise en oeuvre des utilitaires qui y sont impliqués.
	</p>
<sect1>
<heading> <prgn>dpkg-source</prgn> - faire et défaire un paquet source Debian</heading>

<p>
Ce programme est fréquemment utilisé sur la ligne de commande ; il est
aussi appelé à partir des scripts de construction automatique de paquet, tel 
que <prgn>dpkg-buildpackage</prgn>.
	  </p>
<p>
Il est appelé ainsi pour dépaqueter un paquet&nbsp;:
<example>
dpkg-source -x <var>.../path/to/filename</var>.dsc
</example>
	  </p>
<p>
avec <tt><var>filename</var>.tar.gz</tt> et <tt><var>filename</var>.diff.gz</tt> (si c'est utile) dans le même répertoire. Il dépaquette dans
<tt><var>package</var>-<var>version</var></tt>, et, si utile, 
<tt><var>package</var>-<var>version</var>.orig</tt>, dans le répertoire
actuel.
	  </p>
<p>
Pour créer un paquet, on utilise :

<example>
    dpkg-source -b <var>paquet</var>-<var>version</var>
</example>
	  </p>
<p>

Les fichiers <tt>.dsc</tt>, <tt>.tar.gz</tt> et <tt>.diff.gz</tt> seront
créés (si c'est utile) dans le répertoire courant. <prgn>dpkg-source</prgn> 
n'efface pas l'arborescence des sources. Ceci doit être fait séparément, si 
nécessaire.
	  </p>
<p>
Voir aussi <ref id="pkg-sourcearchives">.
	  </p>
	</sect1>
<sect1>
<heading><prgn>dpkg-buildpackage</prgn> - script de contrôle pour la 
construction de paquet</heading>
<p>
<prgn>dpkg-buidpackage</prgn> est un script qui fait appel à 
<prgn>dpkg-source</prgn>, aux cibles de <tt>debian/rules</tt> :
<tt>clean</tt>, <tt>build</tt> et <tt>binary</tt>, à
<prgn>dpkg-genchanges</prgn> et à <prgn>pgp</prgn> pour construire un paquet 
signé, source et binaire, installable sur le serveur.
	  </p>
<p>
Il est généralement utilisé sur la ligne de commande, à la racine du répertoire
source à créer ou à détruire. Il peut être invoqué sans arguments.
Les arguments utiles sont&nbsp;:
<taglist compact="compact">
<tag><tt>-uc</tt>, <tt>-us</tt></tag>
<item>

<p>
ne pas crypter, avec PGP, respectivement le fichier <tt>.changes</tt>
et le fichier paquet source <tt>.dsc</tt>.
		</p>
	      </item>
<tag><tt>-p<var>pgp-command</var></tt></tag>
<item>
<p>
Invoque la commande <var>pgp-command</var>
au lieu de chercher <tt>pgp</tt> dans la variable <tt>PATH</>.
<var>pgp-command</var> doit avoir le même comportement que <prgn>pgp</prgn>.
		</p>
	      </item>
<tag><tt>-r<var>root-command</var></tt></tag>
<item>
<p>
Quand les privilèges de root sont nécessaires, invoque
la commande <var>root-command</var>. <var>root-command</var> invoquera
son premier argument comme une commande, dans le <tt>PATH</tt> si nécessaire,
et passera son second argument et les autres à la commande qu'il appelle.
Si aucune <var>root-command</var> n'est fournie, 
<prgn>dpkg-buildpackage</prgn> ne fera rien pour obtenir les 
privilèges de root ; ainsi, pour la plupart des programmes, il devra être 
appelé par root pour démarrer.
		</p>
	      </item>
<tag><tt>-b</tt>, <tt>-B</tt></tag>
<item>
<p>
Deux types de construction et d'installation pour les binaires,
voir <manref name="dpkg-source" section="1">.
		</p>
	      </item>
	    </taglist></p>
	</sect1>
 <sect1>
<heading><prgn>dpkg-gencontrol</prgn> - créer des fichiers de contrôle pour
les paquets binaires</heading>
<p>
Ce programme est habituellement appelé à partir du fichier 
<tt>debian/rules</tt> (voir <ref id="pkg-sourcetree">) depuis la racine de 
l'arborescence source.
</p>
<p>
On l'appelle juste avant que ne soit établi le système des permissions pour 
les fichiers et les répertoires du répertoire temporaire où le paquet est 
construit et avant la construction du paquet par <prgn>dpkg-deb/</prgn>
<footnote>Il en est ainsi afin que le fichier de contrôle produit possède les bonnes
permissions.</footnote>.
	  </p>
<p>
<prgn>dpkg-gencontrol</prgn> doit être appelé après que tous les fichiers du
paquet ont été mis en place dans le répertoire temporaire de construction,
afin que le calcul de la taille du paquet installé soit correct.
	  </p>
<p>
Il faut aussi que <prgn>dpkg-gencontrol</prgn> soit exécuté après
<prgn>dpkg-shlibdeps</prgn> afin que les variables de substitutions, créées par
<prgn>dpkg-shlibdeps</prgn> dans le fichier <tt>debian/substvars</tt>, soient
disponibles.
	  </p>
<p>
Un paquet qui crée un seul paquet binaire et qui le construit
dans le répertoire <tt>debian/tmp</> relatif à la racine du paquet
source, appellera simplement&nbsp;: dpkg-gencontrol.
	  </p>
<p>
Les sources qui construisent plusieurs binaires utiliseront&nbsp;:
<example>
dpkg-gencontrol -Pdebian/tmp-<var>pkg</var> -p<var>paquet</var>
</example>
L'argument <tt>P</tt> indique à <prgn>dpkg-gencontrol</prgn> que le paquet est
en train de se construire dans un répertoire différent de celui par défaut
et l'argument <tt>-p</tt> indique le fichier de contrôle qui sera créé.
	  </p>
<p>
<prgn>dpkg-gencontrol</prgn> ajoute aussi des informations à la liste des 
fichiers dans <tt>debian/files</tt> ; cela peut servir à un prochain appel à
<prgn>dpkg-genchanges</prgn>.
	  </p>
	</sect1>
<sect1>
<heading><prgn>dpkg-shlibdeps</prgn> - les dépendances des bibliothèques partagées</heading>
<p>
Ce programme est habituellement appelé à partir du fichier <tt>debian/rules</>,
juste avant <prgn>dpkg-gencontrol</prgn> (voir <ref id="pkg-sourcetree">),
à la racine de l'arborescence source.
	  </p>
<p>
Les arguments sont des exécutables <footnote>
<p>
Dans une prochaine version de dpkg, <prgn>dpkg-shlibdeps</prgn> serait aussi
appelé pour les bibliothèques partagées.
<p>
Ils peuvent être spécifiés soit dans les emplacements de l'arborescence source
où ils sont créés soit dans les emplacements de l'arborescence temporaire de 
construction où ils sont installés avant la création du paquet binaire.
	      </p>
	    </footnote> pour lesquels les dépendances des bibliothèques
partagées seront incluses dans le fichier de contrôle du paquet.
	  </p>
<p>
Si certaines bibliothèques partagées doivent seulement justifier d'un
<tt>Recommends</> ou d'un <tt>Suggests</>, ou si certaines demandent un
<tt>Pre-Depends</>, ceci peut être réalisé en utilisant l'option
<tt>-d</><em>dependency-field</> avant ces exécutables
(chaque option <tt>-d</> prend effet jusqu'au prochain <tt>-d</>).
	  </p>
<p>
<prgn/dpkg-shlibdeps/ ne modifie pas directement le fichier de contrôle.
Par défaut, il ajoute au fichier <tt>debian/substvars</> des variables comme
<tt>shlibs:Depends</>. Ces variables doivent être référencées dans les champs 
de dépendance du fichier de contrôle source dans les sections propres aux 
paquets binaires.
	  </p>
<p>
Par exemple, le paquet <prgn>procps</prgn>/ crée deux types de binaires, des 
binaires C simples comme <prgn>ps</prgn> qui demandent une pré-dépendance, et 
des binaires utilisant <prgn>ncurses</prgn> comme <prgn>top</prgn> qui ne
demandent qu'une <em>recommandation</em>.
Cela peut être indiqué dans le fichier <tt>debian/rules</tt> par&nbsp;:
<example>
dpkg-shlibdeps -dPre-Depends ps -dRecommends top
</example>
et ensuite dans le fichier principal de contrôle <tt>debian/control</tt>&nbsp;:
<example>
<var>...</var>
Package: procps
Pre-Depends: ${shlibs:Pre-Depends}
Recommends: ${shlibs:Recommends}
<var>...</var>
</example>
	  </p>
<p>
Les sources qui produisent plusieurs paquets binaires avec des exigences 
différentes pour les dépendances envers les bibliothèques partagées peuvent 
utiliser l'option <tt>-p<var>varnameprefix</var></tt> pour annuler le préfixe 
<tt>shlib:</tt> par défaut (un seul appel à <prgn>dpkg-shlibdeps</prgn>
par réglage de cette option). Ils peuvent ainsi produire plusieurs ensembles 
de variables de dépendance, chacune de la forme 
<tt><var>varnameprefix</var>:<var>dependencyfield</var></tt>, auxquelles 
peuvent se référer les parties appropriées des fichiers de contrôle des 
paquets binaires.
	  </p>
	</sect1>

<sect1>
<heading><prgn>dpkg-distaddfile</prgn> - ajouter un fichier à <tt>debian/files</tt></heading>
<p>
Certaines installations de paquets sur le serveur nécessitent d'inclure 
d'autres fichiers que les fichiers des paquets sources et binaires.
	  </p>
<p>
<prgn>dpkg-distaddfile</prgn> ajoute un fichier dans <tt>debian/files</> afin
qu'il soit inclus dans le fichier <tt>.changes</tt> lorsque 
<prgn>dpkg-genchanges</prgn> sera lancé.
	  </p>
<p>
Il est habituellement invoqué à partir de la cible <prgn>binary</prgn> du 
fichier <tt>debian/rules</tt>&nbsp;:
<example>
dpkg-distaddfile <var>filename</var> <var>section</var> <var>priority</var>
	    </example>
L'argument <var>filename</var> est relatif au répertoire où 
<prgn>dpkg-genchanges</prgn> s'attend à le trouver, généralement au-dessus de 
la racine de l'arborescence source. La règle de <tt>debian/rules</tt> devrait 
placer ce fichier juste avant ou juste après l'appel à 
<prgn>dpkg-distaddfile</prgn>.
	  </p>
<p>
Les arguments <var>section</var> et <var>priority</var> sont placés sans 
modification dans le fichier résultant <tt>.changes</tt>. Voir
<ref id="pkg-f-classification">.
	  </p>
	</sect1>

<sect1>
<heading><prgn>dpkg-genchanges</prgn> - créer un fichier de contrôle de
l'installation sur le serveur <tt>.changes</tt></heading>
<p>
Ce programme est généralement appelé par des scripts de construction automatique de paquet tels que <prgn>dpkg-buildpackage</prgn> mais peut être aussi 
appelé sur la ligne de commande.
	  </p>
<p>
Il est habituellement exécuté à la racine de l'arborescence source construite,
et quand il est invoqué sans arguments, il écrira un simple fichier 
<tt>.changes</> basé sur les informations des fichiers de contrôle et de changement des paquets sources, et des paquets
sources et binaires qui ont dû être construits.
	  </p>
	</sect1>

<sect1>
<heading><prgn>dpkg-parsechangelog</prgn> - produire une représentation du fichier <tt>changelog</tt></heading>
<p>
Ce programme est utilisé en interne par <prgn>dpkg-source</prgn> et al.
Il peut être aussi occasionnellement utilisé dans <tt>debian/rules</> et 
ailleurs.
Il analyse un fichier <em>changelog</>, par défaut <tt>debian/changelog</tt>,
et affiche sur la sortie standard une représentation des informations 
contenues faite selon le format d'un fichier de contrôle.
	  </p>
	</sect1>

<sect1 id="pkg-dpkgarch"><heading><prgn>dpkg-architecture</prgn> - informations
sur les systèmes de construction et d'installation</heading>

<p>
On peut utiliser ce programme sur la ligne de commande ; mais il est aussi
appelé par <tt>dpkg-buildpackage</tt> ou <tt>debian/rules</tt> pour
déterminer les variables d'environnement qui indiquent les architectures 
utilisées pour la construction et pour l'installation pendant le processus
de construction du paquet.
	  </p>
	</sect1>
      </sect>

<sect id="pkg-sourcetree"><heading> L'arborescence debianisée</heading>
<p>
La structure de l'archive source, décrite ci-dessous, a été conçue pour 
permettre à une arborescence source débianisée et ses informations de 
contrôle associées d'être facilement dupliquée et transportée. L'arborescence 
source débianisée comprend une version du programme original, certains 
fichiers ajoutés pour le processus de débianisation, ainsi que tous les
changements nécessaires réalisés sur les codes sources et scripts 
d'installation.
	</p>
<p>
Les fichiers supplémentaires créés pour Debian sont dans le répertoire 
<tt>debian</tt> à la racine de l'arborescence source débianisée. Ils sont 
décrits ci-dessous.
	</p>

<sect1 id="pkg-debianrules"><heading><tt>debian/rules</tt> - le script principal de construction</heading> 
<p>
Ce fichier est un <em>makefile</em> exécutable, qui contient les règles 
spécifiques au paquet pour compiler et construire les binaires à partir des 
paquets sources.
	  </p>
<p>
Il doit commencer par <tt>#!/usr/bin/make -f</tt> de manière à pouvoir être
appelé par son nom plutôt que par un <prgn>make</prgn> explicite.
	  </p>
<p>
Puisqu'un script <tt>debian/rules</tt> interactif ne peut pas compiler un
paquet automatiquement et empêche une reproduction de ce paquet binaire par
d'autres personnes, toutes les <em>cibles exigées</em> doivent être
non interactives. Au minimum, les cibles exigées sont celles qu'appelle
<prgn>dpkg-buildpackage</prgn>, à savoir, <em>clean</em>, <em>binary</em>,
<em>binary-arch</em>, <em>binary-indep</em>, et <em>build</em>. Il s'ensuit
qu'une cible dont dépendent ces cibles, doit être aussi non interactive.
        </p>
<p>
Les cibles nécessaires sont&nbsp;:
<taglist>
<tag><tt>build</tt></tag>
<item>
<p>
Configuration non interactive et compilation du paquet. Quand un paquet
possède une routine interactive de configuration préalable à la construction,
le paquet source débianisé sera construit après cette opération
afin qu'il puisse être construit sans exécuter à nouveau cette configuration.
	      </p>
<p>
Un paquet peut aussi proposer les deux cibles <tt>build-arch</tt> et 
<tt>build-indep</tt>. Si la cible <tt>build-arch</tt> existe, elle fera
toute la configuration non interactive et la compilation nécessaire pour
créer les paquets binaires pour chaque architecture (ce sont les paquets
dont le champ <tt>Architecture</tt> dans le fichier <tt>debian/control</tt>
est différent de <tt>all</tt>). De même, si la cible <tt>build-indep</tt>
existe, elle fera toute la configuration non interactive et la compilation
nécessaire pour créer les paquets binaires indépendant d'une architecture (ce
sont les paquets dont le champ <tt>Architecture</tt> dans le fichier
<tt>debian/control</tt> vaut <tt>all</tt>). La cible <tt>build</tt> dépendra
des cibles <tt>build-arch</tt> et <tt>build-indep</tt> qui sont données par
le fichier <em>rules</em>.
		</p>
<p>
Quand manque l'une des cibles <tt>build-arch</tt> et <tt>build-indep</tt> (ou
les deux), un appel à <tt>debian/rules</tt> avec l'une des cibles manquantes
provoquera un code d'erreur égal à 2. Quand une cible manque, <prgn>make</prgn>
produit automatiquement ce code.
		</p>
<p>
Pour certains paquets, notamment ceux où le même arbre source est compilé de 
différentes façons pour obtenir deux paquets binaires, la cible <tt>build</> 
n'a aucun sens. Pour ces paquets, il est bon de prévoir deux cibles ou plus 
(<tt>build-a</> et <tt>build-b</>, p.ex.) pour chaque manière de construire 
le paquet et une cible <tt>build</> qui ne produit rien. La cible 
<tt>binary</> s'occupera de construire le paquet pour chaque cas possible et 
de créer le paquet binaire de chacun d'eux.
	      </p>
<p>
Les cibles <tt>build</>, <tt>build-arch</tt> et <tt>build-indep</tt> ne 
doivent pas effectuer d'actions qui exigent les privilèges de root.
	      </p>
<p>
La cible <tt>build</> peut avoir besoin d'exécuter d'abord la
cible <tt>clean</>. Voir ci-dessous.
	      </p>
<p>
Quand un paquet possède une routine de configuration qui prend du temps, ou 
quand le <em>makefile</> est pauvrement conçu, ou quand <tt>build</tt> a 
d'abord besoin d'exécuter <tt>clean</tt>, il est alors intéressant d'exécuter 
<prgn>touch build</prgn> quand le processus de construction est terminé. Cela 
assurera que si <tt>debian/rules build</tt> est exécuté à nouveau, il 
ne reconstruira pas le programme complet.
	      </p>
	    </item>
<tag><tt>binary</tt>, <tt>binary-arch</tt>, <tt>binary-indep</tt></tag>
<item>

<p>
La cible <tt>binary</tt> doit être tout ce qui est nécessaire à
l'utilisateur pour construire le(s) paquet(s) binaire(s). Toutes ces cibles
doivent être non interactives. Cette cible a deux parties : 
<tt>binary-arch</tt> construit les paquets binaires qui sont spécifiques 
à une architecture particulière, et <tt>binary-indep</tt> construit les
paquets qui ne le sont pas.
              </p>
<p>
<tt>binary</tt> peut être (et c'est communément le cas) une cible sans
commande, qui dépend simplement de <tt>binary-arch</tt> et de
<tt>binary-indep</tt>.
              </p>
<p>
Les deux cibles <tt>binary-*</tt> dépendront de la cible
<tt>build</tt> ci-dessus, afin que le paquet soit
construit s'il ne l'a pas déjà été. Elle créera ensuite les paquets binaires
pertinents en utilisant <prgn>dpkg-gencontrol</prgn> pour créer leurs fichiers
de contrôle et <prgn>dpkg-deb</prgn> pour construire les binaires et les
placer dans le répertoire parent du répertoire racine.
              </p>
<p>
Si l'une des deux cibles <prgn>binary-*</prgn> n'a rien à faire (ce sera
toujours le cas si le source crée un seul paquet binaire, qu'il soit
dépendant de l'architecture ou pas), elle doit tout de même exister,
et doit toujours se dérouler correctement.
              </p>
<p>
<ref id="pkg-binarypkg"> décrit la construction de paquets binaires.
	      </p>
<p>
La cible <tt>binary</tt> doit être invoquée avec les privilèges de root.
	      </p>
	    </item>

<tag><tt>clean</tt></tag>
<item>
Cette cible doit nettoyer les effets obtenus par les cibles
<tt>build</tt> et <tt>binary</tt>, mais elle doit laisser les
fichiers de sortie créés par la cible <tt>binary</tt> dans le répertoire
parent. Cette cible ne doit pas être interactive.
              </p>
<p>
Si un fichier <tt>build</tt> est créé par <prgn>touch</prgn> à la fin
de la cible <tt>build</tt>, comme suggéré ci-dessus, c'est la première
chose qui sera effacée par la cible <tt>clean</tt> ; ainsi
<tt>build</tt>, exécutée de nouveau après un nettoyage (<tt>clean</tt>)
interrompu, ne pensera pas que tout est déjà fait.
	      </p>
<p>
La cible <tt>clean</tt> doit être invoquée par root, si
<tt>binary</tt> a été invoquée depuis le dernier <tt>clean</tt>, ou
si <tt>build</tt> a été invoquée par root (étant donné que
<tt>build</tt> peut créer des répertoires par exemple).
              </p>
            </item>

<tag><tt>get-orig-source</tt> (facultatif)</tag>
<item>
<p>
Cette cible va chercher la plus récente version du paquet original dans un
site d'archive autorisé (par FTP ou WWW, par exemple), s'occupe des
arrangements nécessaires pour le mettre sous la forme d'un fichier tar (une
archive source) décrite ci-dessus, et le laisse dans le répertoire en cours.
              </p>
<p>
Cette cible peut être invoquée dans n'importe quel répertoire et s'occupera
de supprimer tous ses fichiers temporaires.
              </p>
<p>
Elle est facultative mais la proposer, quand c'est possible, est une bonne
idée.
	      </p>
	    </item>
	  </taglist>
<p>
Les cibles <tt>build</tt>, <tt>binary</tt> et <tt>clean</tt>
doivent être invoquées avec comme répertoire actuel, le répertoire de plus
haut niveau du paquet.
        </p>
<p>
Des cibles supplémentaires peuvent exister dans <tt>debian/rules</tt>, soit
comme des interfaces publiées ou non documentées soit pour l'utilisation
interne du paquet.
        </p>
<p>
Ce sont les variables de <prgn>make</prgn> à travers
<prgn>dpkg-architecture</prgn> qui déterminent l'architecture <em>sur</em>
laquelle et celle <em>pour</em> laquelle on construit. On peut obtenir, aussi 
bien pour la machine sur laquelle on construit que pour la machine pour 
laquelle on construit, la chaîne indiquant l'architecture Debian et la chaîne
indiquant l'architecture à la façon <em>GNU</em>. Voici une liste de
variables acceptées par <prgn>make</prgn> :
<list compact="compact">
            <item>
              <p><tt>DEB_*_ARCH</tt> (L'architecture Debian)</p>
</item>
            <item>
              <p><tt>DEB_*_GNU_TYPE</tt> (L'architecture indiquée à la
                façon <em>GNU</em>)</p>
            </item>
            <item>
              <p><tt>DEB_*_GNU_CPU</tt> (La partie CPU de
<tt>DEB_*_GNU_TYPE)</tt></p>
            </item>
            <item>
<p><tt>DEB_*_GNU_SYSTEM</tt> (La partie système de <tt>DEB_*_GNU_TYPE)</tt></p>
          </list>
        </p>
<p>
où <tt>*</tt> représente <tt>BUILD</tt> pour une indication de la
machine <em>sur</em> laquelle on construit, ou bien <tt>HOST</tt> pour une 
indication de la machine <em>pour</em> laquelle on construit.
        </p>
<p>
On peut assurer une compatibilité ascendante dans le fichier <em>rules</em>
en fixant par défaut les bonnes variables à des valeurs adéquates ;
veuillez consulter la documentation de <prgn>dpkg-architecture</prgn>
pour des précisions.
        </p>
<p>
Il est important de comprendre que la chaîne <tt>DEB_*_ARCH</tt> détermine
seulement l'architecture Debian sur ou pour laquelle on construit. On
ne l'utilisera pas pour avoir des renseignements sur le CPU ou le
système ; les variables GNU sont là pour ça.
        </p>
	</sect1>

<sect1><heading><tt>debian/control</tt></heading>
<p>
Ce fichier contient des informations indépendantes des versions sur le paquet 
sources et sur les paquets binaires qu'il crée.
	  </p>
<p>
C'est une série d'ensembles de champs de contrôle, chacun syntaxiquement 
similaire à un fichier de contrôle de paquet binaire. Les ensembles sont 
séparés par une ou plusieurs lignes vides. Le premier ensemble contient en 
général les informations sur le paquet source ; chaque ensemble suivant décrit 
un paquet binaire que l'arbre source construit.
	  </p>
<p>
La syntaxe et la sémantique des champs sont décrites ci-dessous dans
<ref id="pkg-controlfields">.
	  </p>
<p>
Les champs généraux (indépendant des paquets binaires) sont&nbsp;:
<list compact="compact">
<item>
<p><qref id="pkg-f-Source"><tt>Source</tt></qref> (obligatoire)</\p>
</item>
<item>
<p><qref id="pkg-f-Maintainer"><tt>Maintainer</tt></qref></p>
</item>
<item>
<p>
<qref id="pkg-f-classification"><tt>Section</tt> et <tt>Priority</tt></qref>
(classement, obligatoire)
		</p>
	      </item>
<item>
<p>
<qref id="7"><tt>Build-Depends</tt> et al.</qref> (interrelations
entre les paquets sources)
		</p>
	      </item>
<item>
<p>
<qref id="pkg-f-Standards-Version"><tt>Standards-Version</tt>\</qref>
		</p>
	      </item>
	    </list>
<p>
Les champs pour les paquets binaires sont&nbsp;:
<list compact="compact">
<item>
<p><qref id="pkg-f-Package"><tt>Package</tt></qref> (obligatoire)\</p>
	      </item>
<item>
<p><qref id="descriptions"><tt>Description</tt></qref></p>
</item>
<item>
<p>
<qref id="pkg-f-classification"><tt>Section</tt> et <tt>Priority</tt></qref> (classement)</p>
	      </item>
<item>
<p>
<qref id="7"><tt>Depends</tt> et al.</qref> (interrelations entre
paquets binaires)</p>
	      </item>
	    </list>
<p>
Ces champs sont utilisés par <prgn>dpkg-gencontrol</prgn> pour créer
les fichiers de contrôle pour les paquets binaires (voir ci-dessus),
par <prgn>dpkg-genchanges</prgn> pour créer le fichier <tt>.changes</tt>
qui accompagne l'installation sur le serveur et par <prgn>dpkg-source</prgn> 
quand il crée le fichier de contrôle source <tt>.dsc</> comme une partie
de l'archive source.
	  </p>
<p>
Les champs peuvent contenir des références à des variables, leurs valeurs
seront substituées par <prgn>dpkg-gencontrol</prgn>, 
<prgn>dpkg-genchanges</prgn> ou <prgn>dpkg-source</prgn> quand ils créeront 
les fichiers de sortie. Voir <ref id="pkg-srcsubstvars"> pour des précisions.
	  </p>
<p>
<sect2><heading>Les champs définis par l'utilisateur</heading>
<p>
Des champs utilisateurs supplémentaires peuvent être ajoutés au fichier
de contrôle du paquet source. Ces champs seront ignorés, ne seront pas
copiés dans les fichiers de contrôle des paquets sources ou binaires
(par exemple) ou dans les fichiers de contrôle de l'installation sur le
serveur.
	    </p>
<p>
Quand on souhaite ajouter des champs supplémentaires non supportés à
ces fichiers de sortie, on utilisera le mécanisme décrit ci-dessous.
	    </p>
<p>
Les champs du fichier principal de contrôle de source
avec des noms commençant par X, suivis par une ou plusieurs lettres
<tt>BCS</> et un trait d'union -, seront copiés vers les fichiers de sortie.
Seule la partie du nom du champ qui se trouve après le trait d'union sera
utilisée dans le fichier de sortie.
Si la lettre <tt>B</tt> est utilisée, le champ apparaîtra dans les fichiers
de contrôle des paquets binaires, si c'est la lettre <tt>S</tt>, dans les 
fichiers de contrôle de paquet source, et si c'est la lettre <tt>C</tt>, dans 
les fichiers de contrôle de l'installation sur le serveur (<tt>.changes</>).
	    </p>
<p>
Par exemple, le fichier principal de contrôle de source
contient le champ suivant&nbsp;:

<example>
   XBS-Comment: I stand between the candle and the star.
</example>

alors les fichiers de contrôle des paquets sources et binaires contiendront
le champ&nbsp;:
<example>
Comment: I stand between the candle and the star.
             </example>
	    </p>
	  </sect2>
	</sect1>

<sect1 id="pkg-dpkgchangelog"><heading><tt>debian/changelog</tt></heading>

<p>
Ce fichier enregistre les changements faits sur les parties spécifiques Debian
d'un paquet
<footnote>Bien qu'il n'y ait rien qui empêche un auteur qui est aussi
le responsable Debian de l'utiliser pour tous les changements, il devra
être renommé si les auteurs et les responsables Debian deviennent
physiquement différents.</footnote>.
	  </p>
<p>
Il possède un format spécial qui permet aux outils de construction de paquets
de découvrir quelle version du paquet est en train de se construire
et de trouver d'autres informations spécifiques à la version.
	  </p>
<p>
Le format est une série d'entrées comme celles-ci&nbsp;:
<example>
<var>package</var> (<var>version</var>) <var>distribution(s)</var>; urgency=\<var>urgency</var>
 * <var>change details</var>
<var>more change details</var>
* <var>even more change details</var>
	    </example>
	  </p>
<p>
<var>package</var> et <var>version</var> sont le nom du paquet source et le
numéro de version.
	  </p>
<p>
<var>distribution(s)</var> listent les distributions où cette version
sera placée quand elle est installée sur le serveur. Le champ
<tt>Distributions</tt> est copié dans le fichier <tt>.changes</tt>.
	  </p>
<p>
<var>urgency</var> est la valeur pour le champ <tt>Urgency</>
dans le fichier <tt>.changes</> pour l' installation sur le serveur. Voir
<ref id="pkg-f-Urgency">. Il n'est pas possible de spécifier une
<em>urgency</> contenant des virgules&nbsp;; les virgules sont utilisées
pour séparer les couples (mot clé=valeur) dans le format du fichier
d'enregistrement de <tt>dpkg</tt> (bien qu'il n'y ait pour
l'instant qu'un seul mot clé utile&nbsp;: <tt>urgency</>).
	  </p>
<p>
L'énoncé des modifications peut tenir sur des séries de ligne commençant au 
moins par deux espaces, mais par convention, chaque modification commence par 
une étoile * et un espace, les lignes de continuation sont indentées pour les 
amener en face du texte de la ligne précédente. Les lignes vides peuvent
être utilisées pour séparer des groupes de modifications.
	  </p>
<p>
Le nom du responsable et son adresse ne sont pas nécessairement
les mêmes que ceux du responsable habituel du paquet. Ils doivent
correspondre à la personne qui s'est occupée de cette version.
Les informations seront copiées dans le fichiers <tt>.changes</tt>,
et utilisées plus tard pour envoyer un accusé de réception quand
l'installation sur le serveur sera terminée.
	  </p>
<p>
La date doit être dans le format défini par la RFC 822
<footnote>Elle est créée par le programme <prgn>822-date</prgn>.</footnote>&nbsp;;
elle doit inclure le nom du fuseau horaire (timezone) spécifié
numériquement, et en option le nom du fuseau ou son abréviation.
	  </p>
<p>
La première ligne de «&nbsp;titre&nbsp;» avec le nom du paquet doit commencer
sur la marge de gauche, la ligne de «&nbsp;fin&nbsp;» avec les informations sur
le responsable et la date doit être précédée par un seul espace. Les 
informations sur le responsable et la date doivent être
séparées exactement par deux espaces.
	  </p>
<p>
Un mode Emacs pour modifier ce format est disponible&nbsp;:
<tt>debian-changelog-mode</>. On peut sélectionner ce
mode automatiquement quand on édite un fichier <tt>changelog</>
Debian en ajoutant une clause de variables locales à la
fin du fichier <tt>changelog</tt>.
	  </p>

<sect2><heading>Comment définir des formats alternatifs pour le fichier
<tt>changelog</tt></heading>
<p>
Il est possible d'utiliser un format différent de celui proposé,
en fournissant un analyseur pour le format qu'on veut utiliser.
          </p>

<p>
Pour que <tt>dpkg-parsechangelog</tt> exécute l'analyseur, on incluera une
ligne à l'intérieur des quarante dernières lignes du fichier correspondant à
l'expression rationnelle Perl suivante&nbsp;:
<tt>\schangelog-format:\s+([0-9a-z]+)\W</tt>. La partie entre parenthèses sera
le nom du format. Par exemple, on pourrait dire&nbsp;:
<example>
@@@ changelog-format: joebloggs @@@
</example>
Les noms des formats pour changelog sont des chaînes non vides d'alphanumériques.</p>

<p>
Quand une telle ligne existe, <tt>dpkg-parsechangelog</tt> cherche l'analyseur
dans <tt>/usr/lib/dpkg/parsechangelog/<var>format-name</var></tt> ou dans
<tt>/usr/local/lib/dpkg/parsechangelog/<var>format-name</var></tt>&nbsp;;
c'est une erreur de ne pas le trouver, ou qu'il ne soit pas exécutable. Le 
format changelog par défaut est <tt>dpkg</> et un analyseur est fourni
avec le paquet <tt>dpkg</tt>.
	    </p>
<p>
L'analyseur sera invoqué, au début du fichier, avec le changelog ouvert sur 
l'entrée standard. Il lira le fichier (ou le parcourra avec seek) pour 
trouver l'information et la retourner analysée sur la sortie standard sous la 
forme d'une série de champ de contrôle dans le format standard. Par défaut, 
il retournera seulement les informations les plus récentes du fichier 
changelog&nbsp;; il acceptera l'option <tt>-v</><em>version</> pour retourner 
les informations de changement de toutes les versions présentes strictement 
supérieures <em>version</> et rendre une erreur pour une version non présente 
dans le fichier changelog.
	    </p>
<p>
Les champs sont&nbsp;:
<list compact="compact">
<item>
<p><qref id="pkg-f-Source"><tt>Source</tt></qref></p>
               </item>
<item>
<p><qref id="4"><tt>Version</tt></qref> (obligatoire)</p>
		</item>
<item>
<p>
<qref id="pkg-f-Distribution"><tt>Distribution</tt></qref>(obligatoire)</p>
		</item>
	      <item>
<p><qref id="pkg-f-Urgency"><tt>Urgency</tt></qref> (obligatoire)</p>
		</item>
<item>
<p><qref id="pkg-f-Date"><tt>Date</tt></qref></p>
</item>
<item>
<p><qref id="pkg-f-Changes"><tt>Changes</tt></qref>
                   (obligatoire)</p>
		</item>
	      </list>
<p>
Si plusieurs versions sont retournées (à cause de l'utilisation
de l'option <tt>-v</>), la valeur <tt>urgency</> sera la plus grande listée 
par toutes les versions requises et sera suivie par les commentaires 
concaténés 
(séparés par un espace) de toutes les versions requises&nbsp;; les 
champs&nbsp;: maintainer, version, distribution et date proviennent toujours 
de la version la plus récente.
	    </p>
<p>
Pour le format du champ <tt>Changes</> voir <ref id="pkg-f-Changes">.
	    </p>
<p>
Si le format du fichier <tt>changelog</> analysé laisse toujours ou presque 
toujours une ligne vide entre les notes de modifications individuelles, ces 
lignes vides seront supprimées, pour rendre la sortie résultante plus compacte.
	    </p>
<p>
Si le format de changelog ne contient pas de date ou d'information sur le nom 
du paquet, ces informations seront omises en sortie. L'analyseur ne doit pas 
essayer de les synthétiser ou de les trouver à partir d'autres sources. 
	    </p>
<p>
Si le fichier changelog n'a pas le format attendu, l'analyseur se terminera 
avec un statut différent de zéro, plutôt que d'essayer de se débrouiller tant 
bien que mal et créer des sorties incorrectes.
	    </p>
<p>
Un analyseur de changelog ne doit pas être interactif.
          </p>
	  </sect2>
</sect1>

<sect1 id="pkg-srcsubstvars"><heading><tt>debian/substvars</tt> et les variables de substitution</heading>

<p>
Quand <prgn/dpkg-gencontrol/, <prgn/dpkg-genchanges/ et
<prgn/dpkg-source/ créent des fichiers de contrôle, ils procèdent au
remplacement des variables qu'ils doivent écrire dans ces fichiers. Les
substitutions de variable sont de la forme
<tt>${<var>variable-nom</var>}</tt>.
Le fichier facultatif <tt>debian/substvars</tt> contient les remplacements de
variable à utiliser. On peut aussi fixer directement les variables dans le
fichier <tt>debian/rules</> en utilisant l'option <tt>-V</> des commandes
d'empaquetage des sources ; certaines variables prédéfinies sont disponibles.
        </p>
<p>
Le fichier <tt>debian/substvars</tt> est habituellement créé et modifié
dynamiquement par les cibles de <tt>debian/rules</tt>, et dans ce cas, il
doit être supprimé par la cible <tt>clean</tt>.
        </p>

<p>
Voyez <manref name="dpkg-source" section="1"> pour plus de détails sur les
remplacements de variables source, et sur le format de
<tt>debian/substvars</tt>.
        </p>
      </sect1>

<sect1><heading><tt>debian/files</tt></heading>
<p>
<p>
Ce fichier n'est pas un fichier permanent de l'arborescence source ; il est
utilisé pendant la construction des paquets pour enregistrer quels
fichiers sont en train d'être créés. <prgn>dpkg-genchanges</prgn>
l'utilise quand il crée un fichier <tt>.changes</tt>.
        </p>
<p>
Ce fichier ne doit pas exister dans le paquet source qu'on propose, et il
doit être supprimé par la règle <tt>clean</> (ainsi que n'importe quel fichier
temporaire ou de sauvegarde tel que <tt>files.new</tt>
<footnote><tt>files.new</> est utilisé
temporairement par <prgn>dpkg-gencontrol</prgn> et
<prgn>dpkg-distaddfile</prgn> ; ils écrivent une nouvelle version
de <tt>files</> avant de le renommer, pour éviter de laisser
une copie corrompue, si une erreur se produit.</footnote>).
Il peut aussi être sage, pour garantir un nouveau départ, de l'enlever ou
de le vider au début de la cible <tt>binary</tt>.
        </p>

<p>
Quand <prgn>dpkg-gencontrol</prgn> est exécuté pour un paquet binaire, il
ajoute une entrée dans le fichier <tt>debian/files</tt> pour le fichier
<tt>.deb</tt> qui sera créé quand <tt>dpkg-deb --build</tt> sera
exécuté pour ce paquet binaire. Ainsi pour la plupart des paquets, il n'y a
rien d'autre à faire que de supprimer ce fichier dans la cible
<tt>clean</tt>.
        </p>

<p>
Si un chargement de paquet inclut des fichiers autres que ceux du paquet
source ou des paquets binaires dont les fichiers de contrôle ont été créés par
<prgn>dpkg-gencontrol</prgn>, ces fichiers seront placés dans le
répertoire parent du répertoire racine du paquet et
<prgn>dpkg-distaddfile</prgn> sera appelé pour ajouter ces fichiers à la liste
<tt>debian/files</tt>.
        </p>
      </sect1>

<sect1><heading><tt>debian/tmp</tt></heading>
<p>
C'est l'emplacement temporaire, pour la construction des paquets
binaires par la cible <tt>binary</tt>. Le répertoire <tt>tmp</tt> sert
de racine à l'arbre du système de fichier qui est en train de se
construire (par exemple en utilisant la règle d'installation du
<prgn>Makefile</prgn> du paquet original et en le redirigeant dans
<tt>tmp</tt>), et il contient aussi le sous-répertoire <tt>DEBIAN</tt>. Voir
<ref id="pkg-bincreating">.
	  </p>
<p>
Si plusieurs paquets binaires sont créés à partir du même arbre
source, il est habituel d'utiliser plusieurs répertoires
<tt>debian/tmp-truc</>, par exemple <tt>tmp-a</>
ou <tt>tmp-doc</>.
	  </p>
<p>
Quelques soient les répertoires <tt>tmp</> créés et utilisés par
<tt>binary</>, la cible <tt>clean</> doit bien sûr les effacer.
	  </p>
	</sect1>
      </sect>

<sect id="pkg-sourcearchives"><heading>Les paquets sources en tant qu'archive</heading>
<p>
Sur les sites FTP, les paquets sources contiennent trois fichiers reliés
entre eux. On doit avoir les trois bonnes versions pour pouvoir
les utiliser.
	</p>
<p>
<taglist>
<tag>Le fichier de contrôle des sources Debian - <tt>.dsc</tt></tag>
<item>
<p>
Ce fichier contient une série de champs, identifiés et séparés comme les
champs dans le fichier de contrôle d'un paquet binaire. Les champs sont
listés ci-dessous&nbsp;; leur syntaxe est décrite ci-dessus dans
<ref id="pkg-controlfields">.
<list compact="compact">
<item>
<p><qref id="pkg-f-Source"><tt>Source</tt></qref></p>
</item>
<item>
<p><qref id="4"><tt>Version</tt></qref></p>
</item>
<item>
<p><qref id="pkg-f-Maintainer"><tt>Maintainer</tt></qref></\p>
</item>
<item>
<p><qref id="pkg-f-Binary"><tt>Binary</tt></qref></p>
</item>
<item>
 <p><qref id="pkg-f-Architecture"><tt>Architecture</tt></qref></p>
</item>
<item>
<p>
<qref id="7"><tt>Build-Depends</tt> et
+                         al.</qref> (interrelations entre paquets sources)</p>
		  </item>
<item>
<p>
<qref id="pkg-f-Standards-Version"><tt>Standards-Version</tt></qref></p>
</item>
<item>
<p>
<qref id="pkg-f-Files"><tt>Files</tt></qref></p>
		  </item>
		</list>
<p>
Le fichier de contrôle du paquet source est créé par <prgn>dpkg-source</prgn>
quand il crée l'archive source, à partir des autres fichiers
dans le paquet source, décrit ci-dessus. Quand on le déballe, il est
vérifié par rapport aux autres fichiers et répertoires dans les autres
parties du paquet source, comme décrit ci-dessous.
	      </p>
	    </item>

<tag>L'archive source originelle - <tt><var>package</var>_<var>upstream-version</var>.orig.tar.gz</tt></tag>
<item>
C'est un fichier <prgn>tar</prgn> compressé (avec <prgn>gzip -9</prgn>)
contenant le code source de l'auteur original du programme. Le fichier
<prgn>tar</prgn> est déballé dans un répertoire <em>paquet-version-
originale</><tt>.orig</>. Il ne contient aucun fichier en dehors de
ses sous-répertoires.
	      </p>
	    </item>
<tag>fichier <tt>diff</> de Débianisation - <tt><var>package</var>_<var>upstream_version-revision</var>.diff.gz</tt></tag>
<item>
<p>
C'est un fichier <tt>diff</> unifié (<tt>diff -u</tt>) donnant les
changements requis pour modifier le source original en source Debian.
Ces changements peuvent inclure seulement la modification ou la création de
simples fichiers. Les permissions des fichiers, les cibles des
liens symboliques et les caractéristiques des fichiers spéciaux ou
tubes ne peuvent pas être changés et aucun fichier ne doit être
enlevé ou renommé.
	      </p>
<p>
Tous les répertoires dans le fichier <tt>diff</> doivent exister, sauf
le sous-répertoire <tt>debian</> à la racine de l'arbre source, qui
sera crée par <prgn/dpkg-source/, si nécessaire, lors de
l'extraction.
	      </p>
<p>
Le programme <prgn/dpkg-source/ rendra automatiquement exécutable le
fichier <tt>debian/rules</> (voir ci-dessous).</p>
	    </item>
	  </taglist>
<p>
S'il n'y a pas de code source original, par exemple, si le paquet a été
spécialement préparé pour Debian ou si le responsable Debian est le
même que le responsable original, le format est alors légèrement
différent&nbsp;: il n'y pas de fichier <tt>diff</> et le fichier
<prgn/tar/ est nommé <em>paquet-version</><tt>.tar.gz</> et
contient un répertoire <em>paquet-version</>.
	</p>
      </sect>

<sect><heading>Comment dépaqueter un paquet source Debian sans <prgn>dpkg-source</prgn></heading>

<p>
<prgn>dpkg-source -x</prgn> est la manière recommandée pour dépaqueter un
paquet source Debian. Cependant, si le programme n'est pas disponible,
il est possible de faire comme suit&nbsp;:

<enumlist compact="compact">
<item>
<p>
<em>Détarer</em> le fichier <tt>tar</tt>, pour créer un répertoire
<tt>.orig</>.</p>
	    </item>
<item>
<p>
Changer le nom du répertoire <tt>.orig</tt> en <tt><var>package</var>-<var>version</var></tt>.</p>
	    </item>
<item>
<p>
Créer le sous-répertoire <tt>Debian</tt> à la racine de l'arborescence source.
	      </p>
	    </item>
<item>
<p>
Appliquer le fichier <tt>diff</> en utilisant <tt>patch -p0</tt>.
	      </p>
	    </item>
<item>
<p>
<em>Détarer</em> le fichier <tt>tar</tt> de nouveau, si l'on veut une copie du
code source original à côté de la version débianisée.
	      </p>
	    </item>
	  </enumlist>
<p>
Il n'est pas possible de créer une archive source Debian valide sans
utiliser <prgn>dpkg-source</prgn>. En particulier, essayer d'utiliser
<prgn/diff/ directement pour créer le fichier <tt>.diff.gz</> ne
fonctionnera pas.
	</p>

<sect1><heading>Restrictions sur les objets dans les paquets source</heading>

<p>
Un paquet source ne peut pas contenir des liens «&nbsp;en dur&nbsp;»<footnote>
<p>On ne les détecte pas encore pendant la phase de construction du paquet
source, mais seulement pendant la phase d'extraction.</p>
          </footnote><footnote>
<p>
À l'avenir, les liens «&nbsp;en dur&nbsp;» pourraient être autorisés d'une 
manière ou d'une autre, mais cela demandera beaucoup de travail.
            </p>
          </footnote>,
des fichiers spéciaux pour les <em>device</em>, des <em>sockets</em> ou des fichiers
<em>setuid</em> ou <em>setgid</em><footnote>
<p>
Les répertoires <em>setgid</em> sont autorisés.
            </p>
          </footnote>.
        </p>
<p>
Les outils de paquetage source gèrent les modifications entre les
fichiers sources originaux et ceux débianisés en utilisant <prgn>diff</prgn>
et <prgn>patch</prgn>. Modifier l'arbre source original inclus dans
<tt>.orig.tar.gz</> en un source débianisé ne doit pas impliquer de
changements qui ne peuvent pas être maintenus par ces outils. Les
changements problématiques qui provoquent une erreur de la part de
<prgn>dpkg-source</prgn> pour construire le paquet source sont&nbsp;:
<list compact="compact">
<item><p>
Ajouter ou enlever des liens symboliques, des sockets ou des tubes ;
		</p>
	      </item>
<item><p>
Changer les cibles des liens symboliques ;</p>
	      </item>
<item><p>
Créer des répertoires autre que <tt>debian</> ;</p>
	      </item>
<item><p>
Changer le contenu des fichiers binaires. </p>
	      </item>
	    </list>
Les modifications qui provoqueront un avertissement de la part de
<prgn/dpkg-source/ sont&nbsp;:
<list compact="compact">
<item><p>
Enlever des fichiers, des répertoires ou des liens
<footnote>Changer le nom d'un fichier n'est pas traité spécialement. C'est vu
comme l'effacement d'un ancien fichier (qui provoque un avertissement,
mais il est ignoré autrement) et la création d'un
nouveau.</footnote> ;</p>
	      </item>
<item><p>
Les fichiers textes modifiés où ils manquent le retour chariot final
(aussi bien dans l'arborescence source originale que celle modifiée).
		</p>
	      </item>
	    </list>
Les changements qui ne sont pas représentés et qui ne sont pas détectés
par <prgn>dpkg-source</prgn> sont&nbsp;:
<list compact="compact">
<item><p>Changer les permissions des fichiers (autres que
<tt>debian/rules</>) et des répertoires.</p>
	      </item>
	    </list>
	  </p>
<p>
Le répertoire <tt>Debian</tt> et <tt>debian/rules</> sont manipulés 
spécialement par <prgn>dpkg-source</prgn>. Avant d'appliquer les changements, 
il créera le répertoire <tt>debian</>, après quoi il rendra exécutable par
tout le monde le fichier <tt>debian/rules</tt>.
	  </p>
	</sect1>
      </sect>
    </appendix>

 <appendix id="pkg-controlfields"><heading>Les fichiers de contrôle et leurs
champs (annexe tirée de l'ancien <em>Packaging Manual</em>)</heading>

<p>
Beaucoup d'outils de la suite <tt>dpkg</> manipulent les données dans
un format commun, connu sous le nom de fichiers de contrôle.
Les paquets source et binaire ont des données de contrôle comme les
fichiers <tt>.changes</> qui contrôlent l'installation des fichiers sur le
serveur, et les bases de données internes à <tt>dpkg</> sont dans
un format similaire.
      </p>
<p>
 <sect><heading> La syntaxe des fichiers de contrôle</heading>

<p>
Un fichier consiste en un ou plusieurs paragraphes comportant des champs. Ces
paragraphes sont séparés par des lignes blanches. Certains fichiers de
contrôle n'autorisent qu'un seul paragraphe ; d'autres en autorisent
plusieurs, et dans ce cas, chaque paragraphe fait souvent référence à un
paquet différent.
</p>
<p>
Chaque paragraphe est une série de champs contenant des données ; chaque champ
est constitué d'un nom, suivi par deux-points et la valeur associée. Il se
termine à la fin de la ligne. Les espaces horizontaux (espaces et
tabulations) peuvent apparaître immédiatement avant la valeur ou après, mais
là, ils sont ignorés ; par convention, il y a un espace après les deux-points.
	</p>
<p>
Certaines valeurs de champ peuvent déborder sur plusieurs lignes ; dans ce cas
chaque nouvelle ligne <em>doit</em> commencer par un espace ou une tabulation.
Tous les espaces ou tabulations restants en fin de ligne sont ignorés.
        </p>
<p>
Sauf indications contraires, une seule ligne de données est
autorisée et les espaces ne sont pas significatifs dans le corps du
champ. Les espaces ne doivent jamais apparaître dans les noms (de
paquets, d'architectures, de fichiers, etc), dans les numéros de version
ou entre les éléments de relations de version à plusieurs caractères.
        </p>
<p>
Les noms de champs sont indépendants de la casse ; en général, ceux-ci sont
écrits en commençant par une majuscule puis en mélangeant majuscules et
minuscules comme dans les exemples plus bas.
</p>
<p>
Les lignes vides ou les lignes contenant seulement des espaces ou des
tabulations ne sont pas autorisées à l'intérieur des valeurs de champ ou
entre les champs - ce qui signifierait un nouveau paragraphe.
        </p>
<p>
Il est important de noter que plusieurs champs sont facultatifs
pour ce qui concerne <prgn>dpkg</prgn> et ses outils associés ; mais ils
doivent apparaître dans chaque paquet Debian, et leur omission peut
entraîner des problèmes. Quand on écrit des fichiers de contrôle pour
les paquets Debian, on <em>doit</em> lire la charte Debian en même
temps que les détails ci-dessous et la liste des champs pour un fichier
particulier.
</p>
      </sect>

<sect><heading> La liste des champs</heading>
<sect1 id="pkg-f-Package"><heading><tt>Package</tt></heading>

<p>

Le nom du paquet binaire. Les noms de paquet sont constitués de
caractères alphanumériques et des caractères <tt>+</tt>, <tt>-</tt>, <tt>.</tt>
(plus, moins, point)<footnote>
Les caractères <tt>@</tt> <tt>:</tt> <tt>=</tt> <tt>%</tt> <tt>_</tt> (at, 
deux-points, égal, pourcent, souligné) étaient autorisés et sont toujours 
acceptés quand ils sont trouvés dans un fichier de paquet, mais ne doivent 
pas être utilisés dans les nouveaux paquets.</footnote>.
	  </p>
<p>
Ils doivent contenir au moins deux caractères et commencer par un caractère
alphanumérique.
Dans la version courante de dpkg, ils sont triés par ordre alphabétique
en tenant compte des majuscules <footnote>C'est une erreur</footnote>;
utilise des noms de paquets en minuscule à moins que le paquet que tu
construis (ou est référencé dans d'autres champs) utilise déjà des
majuscules.
	  </p>
	</sect1>

<sect1 id="pkg-f-Version"><heading><tt>Version</tt></heading>

<p>
Ce champ donne le numéro de version des paquets source ou binaire - voir
<ref id="4">.
	  </p>
	</sect1>

<sect1 id="pkg-f-Architecture"><heading><tt>Architecture</tt></heading>
<p>
Ce champ est une chaîne de caractères correspondant à une architecture&nbsp;;
c'est un simple mot pour l'architecture Debian.
	  </p>
<p>
<prgn>dpkg</prgn> comparera l'architecture déclarée d'un paquet binaire avec
sa propre valeur compilée avant de l'installer.
	  </p>
<p>
La valeur spéciale <tt>all</> indique que le paquet est indépendant de
l'architecture.
	  </p>
<p>
Dans le fichier principal <tt>debian/control</> du paquet source, ou dans
le fichier de contrôle des paquets sources <tt>.dsc</>, une liste des
architectures (séparée par des espaces) est aussi autorisée, tout comme
la valeur spéciale <tt>any</>.
Une liste indique que le source construira un paquet dépendant de
l'architecture, et fonctionnera correctement seulement sur les
architectures listées. <tt>any</> indique que même si le paquet source
n'est pas dépendant d'une architecture particulière et devrait bien se
compiler sur n'importe laquelle, les paquets binaires produits ne sont
pas indépendants des architectures mais sera par contre spécifique à
l'architecture courante de construction.
	  </p>
<p>
Dans un fichier <tt>.changes</>, le champ <tt>Architecture</> liste la
ou les architectures des paquets qui sont installés sur le serveur. Ce sera 
une liste ; si le source du paquet est aussi installé, l'entrée spéciale 
<tt>source</> est aussi présente.
	  </p>
<p>
Voir <ref id="pkg-debianrules"> pour des informations sur la manière
d'obtenir l'architecture pour le processus de construction.
	  </p>
	</sect1>

<sect1 id="pkg-f-Maintainer"><heading><tt>Maintainer</tt></heading>

<p>
Ce champ contient le nom du responsable et son adresse électronique.
Le nom vient d'abord, suivi par l'adresse électronique entre
les signes inférieur et supérieur <tt>&lt;&gt;</tt> (au format RFC822).
	  </p>
<p>
Si le nom du mainteneur contient un point alors le champ entier ne
fonctionnera pas directement comme une adresse électronique à cause
d'un problème dans la syntaxe spécifiée dans la RFC822 ; un programme
utilisant ce champ comme une adresse doit vérifier cela et corriger le
problème si nécessaire (par exemple en mettant entre parenthèses le nom
et en le déplaçant à la fin, et en amenant l'adresse électronique
devant).
	  </p>
<p>
Le fichier <tt>.changes</> ou les données analysées de
changelog contiennent le nom et l'adresse électronique de la personne
responsable de cette version particulière  - ce n'est pas
forcément le responsable habituel du paquet.
	  </p>
<p>
Ce champ est habituellement facultatif tant qu'il concerne <tt>dpkg</>,
mais son absence provoque généralement un avertissement lors de la
construction de paquets.</p>
	</sect1>

<sect1 id="pkg-f-Source"><heading><tt>Source</tt></heading>
<p>
Ce champ identifie le nom du paquet source.
	  </p>
<p>
Dans un fichier principal de contrôle de source ou dans un
fichier <tt>.changes</> ou dans un fichier <tt>.dsc</> ou dans les
données analysées de changelog, ce champ peut seulement contenir le nom du
paquet source.</p>
<p>

Dans un fichier de contrôle d'un paquet binaire (ou dans un fichier
<tt>Packages</>), il peut être suivi par un numéro de version entre
parenthèses<footnote>En général, on laisse un espace après le nom du
paquet si un numéro de version est spécifié.</footnote>.
Ce numéro de version peut être omis (et l'est par <tt>dpkg-
gencontrol</>) s'il a la même valeur que le champ <tt>Version</> du
paquet binaire en question. Le champ lui-même peut être omis d'un
fichier de contrôle d'un paquet binaire quand le paquet source possède
le même nom et la même version que le paquet binaire.
	  </p>
	</sect1>

<sect1><heading>Les champs de relation entre paquets : <tt>Depends</tt>,
<tt>Pre-Depends</tt>, <tt>Recommends</tt> <tt>Suggests</tt>, <tt>Conflicts</tt>, <tt>Provides</tt>, <tt>Replaces</tt></heading>
<p>
Ces champs décrivent les relations du paquet avec les autres paquets.
Leurs syntaxes et sémantiques sont décrites dans <ref id="7">.
	  </p>
	</sect1>

<sect1 id="pkg-f-Description"><heading><tt>Description</tt></heading>
<p>
Dans un paquet binaire, dans le fichier <tt>Packages</> ou le fichier
principal de contrôle du source, ce champ contient une description du
paquet binaire, dans un format spécial. Voir <ref id="descriptions">
pour des précisions.
	  </p>
<p>
Dans un fichier <tt>.changes</>, il contient un résumé de la description
des paquets installés sur le serveur. La partie du champ avant la première 
nouvelle ligne est vide&nbsp;; ensuite chaque ligne possède le nom d'un 
paquet binaire et la ligne de résumé de la description de ce paquet binaire.
Chaque ligne est indentée par un espace.
	  </p>
	</sect1>

<sect1 id="pkg-f-Essential"><heading><tt>Essential</tt></heading>
<p>
C'est un champ booléen qui peut apparaître seulement dans un fichier de
contrôle d'un paquet binaire (ou dans le fichier <tt>Packages</>) ou
dans un paragraphe concernant les champs d'un paquet dans un fichier 
principal de contrôle de source.
	  </p>
<p>
S'il est positionné à <tt>yes</tt>, <tt>dpkg</tt> et <tt>dselect</tt>
refuseront d'enlever ce paquet (bien qu'il puisse être mis à niveau
et/ou déplacer). L'autre valeur possible est <tt>no</tt>, ce qui est la
même chose que de n'avoir pas de champ du tout.
	  </p>
	</sect1>

<sect1 id="pkg-f-classification"><heading><tt>Section</tt> et <tt>Priority</tt></heading>

<p>
Ces deux champs classent le paquet. La <tt>Priority</> représente
l'importance du paquet installé ; la <tt>Section</> représente un secteur
d'applications dans laquelle le paquet a été classé.
	  </p>
<p>
Quand ces champs apparaissent dans le fichier <tt>debian/control</>, ils
donnent les valeurs des sous-champs priorité et section du champ
<tt>Files</> du fichier <tt>.changes</>, et donnent les valeurs par
défaut de la section et de la priorité pour les paquets binaires.
	  </p>
<p>
La section et la priorité sont représentées (mais pas comme des champs
séparés) dans les informations  pour chaque fichier dans le champ
<qref id="pkg-f-Files"><tt>-File</tt></qref> d'un fichier <tt>.changes</>. La 
valeur de la section dans un fichier <tt>.changes</> est utilisée pour 
décider où sera installé le paquet dans une archive FTP.
	  </p>
<p>
Ces champs ne sont pas utilisés par <tt>dpkg</>, mais par <tt>dselect</>
quand il trie les paquets et sélectionne la valeurs par défaut. Voir la
charte Debian pour les priorités en usage et les critères
pour sélectionner les priorités pour les paquets Debian ; et regarder une
archive FTP Debian pour obtenir la liste actuelle des priorités.</p>
<p>

Ces champs peuvent apparaître dans les fichiers de contrôle des paquets
binaires, dans ce cas, ils fournissent une valeur par défaut au cas où
les fichiers <tt>Packages</> ne possèdent pas l'information. <tt>dpkg</>
et <tt>dselect</> n'utiliseront seulement la valeur d'un fichier
<tt>.deb</> que s'ils n'ont pas d'autres informations ; une valeur listée
dans un fichier <tt>Packages</> sera toujours prioritaire.
Par défaut <tt>dpkg-genchanges</> n'inclut pas la section et la priorité
dans le fichier de contrôle d'un paquet binaire - utilise les options
<tt>-isp</tt>,<tt>-is</tt> ou <tt>-ip</tt> pour réaliser cette opération.
	  </p>
	</sect1>

<sect1 id="pkg-f-Binary"><heading><tt>Binary</tt></heading>
<p>
Ce champ est une liste de paquets binaires.
<p>

Quand il apparaît dans un fichier <tt>.dsc</>, il représente la liste
des paquets binaires qu'un paquet source peut produire.
Il ne produit pas nécessairement tous ces paquets binaires pour chaque
architecture. Le fichier de contrôle source ne contient pas les détails
sur les architectures qui sont les plus appropriées pour les paquets
binaires.</p>
<p>

Quand il apparaît dans un fichier <tt>.changes</>, il liste les noms des
paquets binaires actuellement installés sur le serveur.</p>
<p>

La syntaxe est une liste de paquets binaires séparée par des
virgules<footnote>Par convention, il y a un espace après chaque
virgule.</footnote>.
Actuellement, les paquets doivent être séparés en utilisant seulement
des espaces dans le fichier <tt>.changes</>.
	  </p>
	</sect1>

<sect1 id="pkg-f-Installed-Size"><heading><tt>Installed-Size</tt></heading>
<p>
Ce champ apparaît dans les fichiers de contrôle des paquets binaires, et
dans les fichiers <tt>Packages</>. Il donne la capacité totale du disque
nécessaire pour installer le paquet.</p>
<p>

L'espace disque est représenté en Kilo-octets comme un nombre décimal
simple.</p>
	</sect1>

<sect1 id="pkg-f-Files"><heading><tt>Files</tt></heading>
<p>
Ce champ contient la liste des fichiers avec des informations sur chacun
d'eux. L'information exacte et la syntaxe exacte varient avec le
contexte. Dans tous les cas, la partie du contenu du champ sur la même
ligne que le nom du champ est vide. Le reste du champ est une ligne par
fichier, chaque ligne est indentée par un espace et contient un nombre
de sous-champs séparés par des espaces.</p>
<p>

Dans le fichier <tt>.dsc</> (contrôle des sources Debian), chaque ligne
contient la somme de contrôle MD5, la taille et le nom du fichier tar et
(éventuellement) le fichier diff qui représente le reste du paquet
source<footnote>C'est la partie qui n'est pas <tt>.dsc</>.</footnote>.
Les formes exactes des noms de fichier sont décrites dans
<ref id="pkg-sourcearchives">.</p>
<p>

Dans le fichier <tt>.changes</>, il contient une ligne par fichier
chargé. Chaque ligne contient la somme de contrôle, la taille, la
section et la priorité et le nom du fichier. La section et la priorité
sont les valeurs des champs correspondants dans le fichier principal de
contrôle source - voir <ref id="pkg-f-classification">.Si aucune section ou
priorité n'est spécifiée alors <tt>-</> doit être utilisé, bien que les
valeurs de section et de priorité doivent être spécifiées pour installer
correctement les nouveaux paquets.</p>
<p>

La valeur spéciale <tt>byhand</> pour la section dans un fichier
<tt>.changes</> indique que le fichier en question n'est pas un fichier
ordinaire de paquet et doit être installé  à la main par les responsables
de la distribution. Si la valeur de la section est <tt>byhand</> alors
la valeur de la priorité devrait être <tt>-</>.
<p>

Si une nouvelle révision Debian d'un paquet est chargée et qu'aucune
archive originale source n'est distribuée, le fichier <tt>.dsc</> doit
toujours contenir l'entrée du champ <tt>Fields</> pour l'archive
originale source <em>package-upstream-version</><tt>.orig.tar.gz</> mais
le fichier <tt>.changes</> devrait l'omettre. Dans ce cas, l'archive
originale source sur le site de distribution doit être exactement, octet
par octet, l'archive originale source qui a été utilisée pour créer le
fichier <tt>.dsc</> et le fichier diff qui a été installé sur le serveur.
	  </p>
	</sect1>

<sect1 id="pkg-f-Standards-Version"><heading><tt>Standards-Version</tt></heading>
<p>
Ce champ contient la version la plus récente des standards (la charte Debian 
le manuel du programmeur dpkg et les textes associés) auxquels
le paquet se conforme. Le champ est mis à jour manuellement lors de
l'édition du paquet source pour se conformer aux nouveaux standards ; il
peut parfois être utilisé pour signaler qu'un paquet a besoin d'une
attention particulière.</p>
<p>

Son format est le même que le numéro de version sauf que epoch et la
révision Debian ne sont pas autorisés - voir <ref id="4">.</p>
	</sect1> 

<sect1 id="pkg-f-Distribution"><heading><tt>Distribution</tt></heading>
<p>
Dans un fichier <tt>.changes</> ou dans la sortie analysée de changelog,
ce champ contient le ou les noms (séparés par des espaces) de la ou des
distributions où cette version du paquet devrait être ou a été
installée. Les noms de distribution suivent les règles des noms de
paquets (voir <ref id="pkg-f-Package">).
	  </p>
<p>
Les valeurs des distributions actuelles sont&nbsp;:
<taglist>

<tag>stable
<item>C'est la version à jour de Debian GNU-Linux. Une
nouvelle version apparaît approximativement tous les 3 mois après que le
code de <em>développement</> a été <em>gelé</> pendant un mois de
test. Une fois que la distribution est <em>stable</>, seule la
correction d'erreurs majeures est autorisée. Quand les changements sont
faits sur cette distribution, le chiffre mineur de la version est
incrémenté (par exemple: 1.2 devient 1.2.1 puis 1.2.2, etc).

<tag>unstable
<item>Cette valeur de distribution fait référence à une partie en cours
de développement de l'arbre de distribution Debian. Les nouveaux
paquets, les nouvelles versions de paquets et la correction d'erreur
vont dans le répertoire <em>unstable</>. Travailler avec cette
distribution est de ta seule responsabilité.

<tag>contrib
<item>Les paquets avec cette valeur de distribution ne respectent pas
les critères pour être inclus dans la distribution principale Debian
tels qu'ils sont définis dans la charte Debian, mais respectent les critères
pour une distribution <em>contrib</>. Il n'y a actuellement aucune
distinction entre les paquets <em>stable</> et <em>unstable</> dans les
distributions <em>contrib</> et <em>non-free</>. Utilise à bon escient
le chargement de cette distribution.

<tag>non-free
<item>Comme les paquets de la section <em>contrib</>, les paquets dans
la distribution <em>non-free</> ne respectent pas certains critères pour
pouvoir être inclus dans la distribution principale Debian comme défini
dans la charte Debian. De nouveau, utilise à bon escient cette
distribution.

<tag>experimental
<item>Les paquets de cette distribution sont considérés par
leurs responsables comme étant d'utilisation risquée. Souvent, ils 
représentent les paquets en béta-test ou en cours de développement provenant 
de sources
variées que le responsable veut faire tester, mais ne sont pas prêts pour
être inclus dans l'arbre de distribution Debian. À utiliser à ses
risques et périls.
		</p>
	      </item>
<tag>frozen
<item>De temps en temps, (généralement, tous les 3 mois) la distribution
<em>unsable</> rentre dans un état « de gel » dans l'attente d'une version
<em>stable</>. Pendant cette période de test (habituellement 4
semaines), seules les corrections d'erreurs existantes ou récemment
découvertes sont autorisées.
<p>

</taglist>

On listera <em>toutes</> les distributions où le paquet sera installé. Sauf 
dans des circonstances inhabituelles les
installations vers <em>stable</> doivent aussi aller dans <em>frozen</>
(si il existe) et dans <em>unstable</>.
De même, les installations dans <em>frozen</> iront aussi dans
<em>unstable</>.</p>
	</sect1>

<sect1 id="pkg-f-Urgency"><heading><tt>Urgency</tt></heading>
<p>
Ce champ est une description de l'importance d'une mise à jour d'une
version à l'autre. Il contient un simple mot-clé qui prend
habituellement une de ces valeurs <tt>LOW</tt>, <tt>MEDIUM</tt> ou 
<tt>HIGH</tt> suivi par un commentaire optionnel (séparé par un espace) qui est
généralement entre parenthèses. Par exemple&nbsp;:
<example>
Urgency: LOW (HIGH for diversions users)
</example>
	  </p>
<p>
Ce champ apparaît dans le fichier <tt>.changes</> et dans les changelogs
analysées&nbsp;; sa valeur apparaît comme valeur de l'attribut <tt>urgency</>
dans le changelog de <tt>dpkg</>-style (voir <ref id="pkg-dpkgchangelog">).
	  </p>
<p>
Les mot-clé ne tiennent pas compte de la casse.</p>
	</sect1>

<sect1 id="pkg-f-Date"><heading><tt>Date</tt></heading>
<p>
Dans les fichiers <tt>.changes</> et les changelogs analysés, ce champ donne
la date de la construction de paquet ou de la dernière édition.
	  </p>
	</sect1>

<sect1 id="pkg-f-Format"><heading><tt>Format</tt></heading>
<p>
Le champ apparaît dans les fichiers <tt>.changes</>, et spécifie une
révision de format pour le fichier. Le format décrit ici est la version
<tt>1.5</>. La syntaxe de la valeur du format est la même que la
numérotation de la version des paquets, sauf que epoch et la révision
Debian ne sont pas autorisés - voir <ref id="4">.
	  </p>
	</sect1>

<sect1 id="pkg-f-Changes"><heading><tt>Changes</tt></heading>
<p>
Dans un fichier <tt>.changes</> ou dans un changelog analysé, ce champ
contient les données lisibles des changements, décrivant les différences
entre la dernière version et celle courante.
	  </p>
<p>
Il ne doit rien y avoir dans ce champ avant le première nouvelle ligne&nbsp;;
toutes les lignes suivantes doivent être indentées par au moins un
espace; les lignes vides doivent être représentées par une ligne
contenant seulement un espace et un point.
<p>

Chaque information de changement de version doit être précédée par une
ligne de « titre » donnant au moins la version, la ou les distributions
et l'urgence, d'une façon lisible.
<p>

Si les données de plusieurs versions sont retournées, l'entrée de la
plus récente version doit être retournées d'abord, et les entrées
doivent être séparées par une ligne vide (la ligne de « titre » peut aussi
être suivi par une ligne vide).
	  </p>
	</sect1>
<sect1 id="pkg-f-Filename"><heading><tt>Filename</tt> et <tt>MSDOS-Filename</tt></heading>
<p>
Ces champs dans les fichiers <tt>Packages</> donnent les noms de
fichiers d'un paquet dans une distribution, par rapport à la racine de
la hiérarchie Debian. Si le paquet a été découpé en plusieurs morceaux,
les parties sont toutes listées dans l'ordre, séparées par des espaces.
	  </p>
	</sect1>
<sect1 id="pkg-f-Size"><heading><tt>Size</tt> et <tt>MD5sum</tt></heading>
<p>
Ces champs dans les fichiers <tt>Packages</> donnent la taille (en
octets, exprimée en décimal) et la somme de contrôle MD5 du ou des
fichiers qui composent le paquet de la distribution. Si le paquet est
découpé en plusieurs parties, les valeurs pour ces parties sont listées
dans l'ordre, séparées par des espaces.
	  </p>
	</sect1>

<sect1 id="pkg-f-Status"><heading><tt>Status</tt></heading>
<p>
Ce champ dans le fichier status de <tt>dpkg</> enregistre si
l'utilisateur veut un paquet installé, enlevé ou laissé tout seul, s'il
est défectueux (nécessite une réinstallation) ou non et son état actuel
sur le système. Chaque partie de ces informations est un simple mot.
	  </p>
	</sect1>
<sect1 id="pkg-f-Config-Version"><heading><tt>Config-Version</tt></heading>
<p>
Si un paquet n'est pas installé, ou non configuré, ce champ dans le
fichier status de <tt>dpkg</> enregistre la dernière version de ce
paquet qui a été configurée avec succès.
	  </p>
	</sect1>

<sect1 id="pkg-f-Conffiles"><heading><tt>Conffiles</tt></heading>
<p>
Ce champ dans le fichier status de <tt>dpkg</> contient des informations
sur les fichiers de configuration automatiquement gérés et maintenus par un
paquet. Ce champ <em>ne doit pas</> apparaître n'importe où dans un
paquet&nbsp;!</p>
	</sect1>

<sect1><heading>Champs obsolètes</heading>
<p>
Ils sont toujours reconnus par <tt>dpkg</> mais ne doivent plus
apparaître n'importe où.
<taglist compact="compact">
<tag><tt>Revision</tt></tag>
<tag><tt>Package-Revision</tt></tag>
<tag><tt>Package_Revision</tt></tag>
<item>
<p>La partie revision Debian d'une version de paquet a été dans un champ de 
fichier de contrôle séparé. Ce champ était présent à travers plusieurs noms.
		</p>
	      </item>
<tag><tt>Recommended</tt></tag>
<item><p>ancien nom de <tt>Recommends</tt></p>
	      </item>
<tag><tt>Optional</tt></tag>
<item><p>ancien nom de <tt>Suggests</tt>.</p>
	      </item>
<tag><tt>Class</tt></tag><item><p>ancien nom de <tt>Priority</tt>.</p>
	      </item>
	    </taglist></p>
	</sect1>
      </sect>
    </appendix>

<appendix id="pkg-conffiles"><heading>La gestion des fichiers de configuration (annexe tirée de l'ancien <em>Packaging Manual</em>)</heading>

<p>
<prgn>dpkg</prgn> peut faire de la gestion automatique de fichiers de 
configuration des paquets.
      </p>
<p>

Que ce mécanisme soit adéquat, dépend d'un certain nombre de facteurs ;
mais fondamentalement, pour tout fichier de configuration, il y a deux 
approches.
      </p>
<p>

Une méthode simple est de mettre la meilleure configuration possible
dans le paquet et d'utiliser le mécanisme des <em>conffile</em> de
<prgn>dpkg</prgn> pour faire les mises à jour.
Il est peu probable que l'utilisateur veuille modifier le fichier, mais il 
faut que cela soit possible sans perdre les modifications&nbsp;;
et un nouveau paquet avec une version modifiée du fichier est 
mis à jour rarement ; c'est la meilleure approche.
      </p>
<p>

La méthode radicale est de construire le fichier de configuration à partir
du script <tt>postinst</>, et de prendre la responsabilité de résoudre
automatiquement les erreurs des versions précédentes du paquet. C'est
justifié si le fichier est nécessairement différent sur chaque système.
      </p>

<sect><heading> <prgn>Dpkg</prgn> et la gestion automatique des fichiers de
configuration.</heading>

<p>
Un paquet peut contenir un fichier dans la zone de contrôle appelé
<tt>conffiles</tt>. Ce fichier doit être une liste de noms de fichier de
configuration nécessitant une gestion automatique ; les noms sont séparés par 
un retour chariot. Les noms de fichiers seront des noms absolus,
et les fichiers référencés doivent réellement exister dans le
paquet.
	</p>
<p>

Quand un paquet est mis à jour, <prgn>dpkg</prgn> traitera les fichiers de
configuration pendant l'étape de configuration, juste avant d'exécuter
le script <tt>postinst</tt> du paquet.
	</p>
<p>

Pour chaque fichier, il vérifie si la version du fichier inclus dans le
paquet est la même que celle du fichier inclus dans la dernière version du
paquet (celui à partir duquel on fait la mise à jour). <prgn>dpkg</prgn>
compare aussi la version actuellement installée sur le système avec celle
donnée dans la dernière version du paquet.<p>

Quand ni l'utilisateur ni le responsable du paquet n'ont changé le fichier,
il est laissé tel quel. Si l'un ou l'autre l'ont modifié, les nouvelles 
versions sont prises en compte : si l'utilisateur modifie son fichier, mais 
le responsable ne donne pas de nouvelle version, les modifications de 
l'utilisateur sont conservées (silencieusement) ; si le 
responsable donne une nouvelle version et l'utilisateur n'a pas modifié son 
fichier, la nouvelle version sera installée (avec un message d'avertissement).
Si les deux ont modifié le fichier, l'utilisateur est averti du problème et 
doit résoudre les différences lui-même.
	</p>
<p>

La comparaison est faite en calculant le MD5 des fichiers et en stockant
ce MD5 comme s'il était inclus dans la plus récente version du
paquet.
	</p>
<p>

Quand un paquet est installé pour la première fois, <prgn>dpkg</prgn>
installera le fichier qui l'accompagne, à moins que cela ne
signifie le remplacement d'un fichier existant sur le système de
fichiers.
	</p>
<p>

Cependant, notons que <prgn>dpkg</prgn> ne remplacera pas un conffile qui a 
été supprimé par l'utilisateur (ou par un script).
C'est nécessaire parce qu'avec certains programmes, un fichier
manquant produit un effet difficile ou impossible à réaliser d'une autre
manière ; un fichier manquant ne sera pas remplacé
si l'utilisateur en a décidé ainsi.<p>

Notons qu'un paquet ne doit pas modifier un conffile géré par 
<prgn>dpkg</prgn>/ dans ses scripts de maintenance. Faire cela amènera 
<prgn>dpkg</prgn> à donner à l'utilisateur des options confuses ou
dangereuses pour la mise à jour des fichiers de configuration quand le
paquet est mis à niveau.
	</p>
      </sect>

<sect><heading>La gestion de la configuration entièrement faite par les
scripts du responsable de paquet.</heading>

<p>
Pour les fichiers qui contiennent des informations spécifiques telles
que le nom de l'hôte, les informations sur le réseau, il est
préférable de créer le fichier dans le script <prgn>postinst</prgn> du
paquet.
	</p>
<p>

Ceci impliquera l'examen de l'état du reste du système pour
déterminer valeurs et autres informations, et peut aussi impliquer
de demander à l'utilisateur des informations qui n'ont pas pu être
obtenues autrement.
	</p>
<p>

Quand on utilise cette méthode, il y a un nombre important de problèmes à
considérer&nbsp;:
	</p>
<p>

Si l'on découvre une erreur dans le programme qui crée le fichier de
configuration, ou si le format d'un fichier change d'une version à la
suivante, on devra modifier le script <tt>postinst</> pour le
corriger ; habituellement cela veut dire, éditer le fichier de
configuration installé et enlever le problème ou changer la syntaxe. On
devra faire ça avec soin&nbsp;: l'utilisateur peut avoir
changé le fichier, peut-être pour fixer le problème que le script est
en train de traiter&nbsp;; on devra détecter ces situations et les traiter
correctement.<p>

Si l'on choisit cette voie, c'est alors une bonne idée de mettre le
programme qui crée le fichier de configuration dans un programme séparé
dans <tt>/usr/sbin</>, appelé par convention
<tt><var>package</var>config</tt> et de l'exécuter si nécessaire, à partir du
script de post-installation. Le programme <tt><var>package</var>config</tt>
ne doit pas écraser une configuration existante - si son mode opératoire
s'applique à une première installation (non pas une reconfiguration
arbitraire ultérieure), on doit vérifier si une configuration existe déjà, et 
utiliser l'option <tt>--force</tt> pour la remplacer.
	</p>
      </sect>
    </appendix>


<appendix id="pkg-alternatives"><heading> Versions alternatives d'une interface
- <prgn>update-alternatives</prgn> (annexe tirée de l'ancien <em>Packaging Manual</em>)</heading>

<p>
Quand plusieurs paquets fournissent tous des versions différentes du
même programme ou fichier, il est utile que le système en sélectionne un
par défaut, tout en autorisant l'administrateur système à le changer et à 
faire respecter ses décisions.</p>
<p>

Par exemple, il y a plusieurs versions de l'éditeur <prgn>vi</prgn>, et il n'y
a aucune raison d'empêcher leur installation, chacun
sous son propre nom (<prgn>nvi</prgn>, <prgn>vim</prgn>, etc.). Néanmoins, il 
est souhaitable que le nom <tt>vi</tt> se réfère à quelque chose, au
moins par défaut.
</p>
<p>
Si tous les paquets impliqués coopèrent, ceci peut être fait par
<prgn>update-alternatives</prgn>.
      </p>
<p>

Chaque paquet fournit sa propre version sous son propre nom, et appelle
<prgn>update-alternatives</prgn> dans le script <prgn>postinst</prgn> pour 
enregistrer sa version (et dans le script <prgn>prerm</prgn> pour l'enlever).
      </p>
<p>

Voir le manuel en page <manref name="update-alternatives" section="8">
pour des précisions.
      </p>
<p>

Si <prgn>update-alternatives</prgn> ne semble pas approprié, on peut essayer
d'utiliser les déviations.</p>
    </appendix>

<appendix id="pkg-diversions"><heading> Les déviations - remplacer la version 
d'un fichier contenue dans un paquet.</heading>

<p>
Quand <prgn/dpkg/ réinstalle un paquet, on peut faire que tel ancien fichier
ne soit pas remplacé et que le nouveau fichier correspondant soit mis ailleurs.
      </p>
<p>
Une utilisation locale de cette technique peut être de remplacer la version
d'un fichier contenue dans un paquet ; un paquet peut aussi s'en servir pour
remplacer tel fichier d'un autre paquet ou bien pour mettre à sa place un
« wrapper ».
      </p>
<p>
Avant de décider de l'utilisation d'une déviation, lire 
<ref id="pkg-alternatives">, pour savoir si on veut vraiment une déviation
plutôt que plusieurs versions différentes d'un même programme.
      </p>
<p>

Il y a une liste des déviations qui est lue par <prgn>dpkg</prgn> et mise à
jour par un programme spécial <prgn>dpkg-divert</prgn>. Voir
<manref name="dpkg-divert" section="8">
pour plus de renseignements sur ses arguments.
      </p>
<p>
Quand un paquet souhaite remplacer un fichier par un autre, il doit
appeler <prgn/dpkg-divert/ dans son fichier « preinst » pour ajouter la
déviation et changer le nom du fichier existant. Par exemple, supposons qu'un
paquet <prgn/smailwrapper/ souhaite installer un « wrapper » pour
<tt>/usr/sbin/smail</tt>&nbsp;:

<example>
   if [ install = "$1" -o upgrade = "$1" ]; then
       dpkg-divert --package smailwrapper --add --rename \
                   --divert /usr/sbin/smail.real /usr/sbin/smail
   fi
</example>
Le test de <tt>$1</> est nécessaire afin que le script n'essaye pas
d'ajouter encore la déviation quand <prgn/smailwrapper/ est mis à
jour. L'option <tt>--package smailwrapper</> assure que la copie du fichier
<prgn>/usr/sbin/smail</> contenue dans le paquet <tt>smailwrapper</>
évitera la déviation et s'installera comme la vraie version.<p>

Le <tt>postrm</> fait l'inverse :
<example>
   if [ remove = "$1" ]; then
       dpkg-divert --package smailwrapper --remove --rename \
                   --divert /usr/sbin/smail.real /usr/sbin/smail
   fi
</example>
Il ne faut pas essayer de remplacer un fichier vital pour la marche
du système. Il y a en effet un moment, quand on utilise <tt>dpkg</>, après
que le fichier a été dévié, mais avant que <tt>dpkg</> ait installé
la nouvelle version, où le fichier n'existe pas.</p>
    </appendix>

</book>
</debiandoc>

<html><head>
<title>Le manuel de programmation de dpkg - Script de maintenance de paquet et procédure d'installation</title>
<link rev=made href="mailto:cure@cnam.fr">
</head><body>
<h1>
Le manuel de programmation de dpkg - chapitre 6<br>
Script de maintenance de paquet et procédure d'installation
</h1>

<hr>
<h2><A name="s-maintenance-1">
6.1 Introduction aux scripts de gestion de paquet
</A></h2>

Il est possible de fournir des scripts avec le paquet que <code>dpkg</code>
exécutera pour toi quand ton paquet est installé, mis à jour ou enlevé.<P>

Ces scripts s'appellent <code>preinst, postinst, prerm</code> et <code>postrm</code>
dans la zone de contrôle du paquet. Ce sont des fichiers exécutables
propres; si ce sont des scripts (ce qui est recommandé), ils doivent
commencer par la convention habituelle <code>#!</code>. Ils doivent être
lisible et exécutable par n'importe qui, et non modifiable.<P>

<code>dpkg</code> teste le statut de sortie de ces scripts. Il est important
qu'ils se terminent avec un statut différent de zéro, s'il y a une
erreur, afin que <code>dpkg</code> puisse arrêter son traitement. Pour les
scripts shell, ceci signifie que tu as presque toujours besoin
d'utiliser <code>set -e</code> (ce qui est généralement vrai quand on écrit
des scripts shell, en fait). Il est aussi important, bien sûr, qu'ils ne
se terminent pas avec un statut différent de zéro si tout se passe bien.<P>

Il est nécessaire pour les procédures de recouvrement d'erreurs que les
scripts soient idempotents; c'est à dire, appeler le même script
plusieurs fois dans la même situation ne doit pas provoquer de
problèmes. Si le premier appel échoue, ou s'arrête au milieu du chemin
pour une raison ou une autre, le second appel devrait faire les choses
qui n'ont pas été faites la première fois, s'il y en a, et sortir avec
succès.<P>

Quand un paquet est mis à jour, une combinaison des scripts du vieux et
du nouveau paquet est appelée dans presque toutes les autres étapes de
la procédure de mise à jour. Si tes scripts sont devenus plus
compliqués, tu dois faire attention à cela, et peut être vérifier les
arguments de tes scripts.<P>

Techniquement parlant, le script <code>preinst</code> est appelé avant d'installer
(une version particulière de) un paquet, et <code>postinst</code>
après; le script <code>prerm</code> avant d'effacer (une version de) un paquet
et <code>postrm</code> après.<P>

Les programmes appelés à partir des scripts ne devraient pas normalement
avoir de chemin préfixé. Avant que l'installation démarre, <code>dpkg</code>
vérifie pour voir si les programmes <code>ldconfig, start-stop-daemon,
install-info</code> et <code>update-rc.d</code> peuvent être trouvés via la
variable d'environnement <code>PATH</code>. Ces programmes, et n'importe quel
autre programme qu'on s'attend à trouver dans le <code>PATH</code>, devraient
donc être appelés sans nom de chemins absolu.
Les scripts de maintenance ne devraient pas non plus réinitialiser le
<code>PATH</code>, bien qu'ils peuvent choisir de le modifier en ajoutant
devant ou à la fin un répertoire spécifique à un paquet.
Ces considérations s'appliquent vraiment à tous les scripts shell.<P>
<hr>
<h2><A name="s-maintenance-2">
6.2 Résumé des façons dont les scripts de maintenance sont
appelés
</A></h2>

<ul>
<li><em>nouveau-preinst</em> <code>install</code><p><li><em>nouveau-preinst</em> <code>install</code> <em>vieille-version</em><p><li><em>nouveau-preinst</em> <code>upgrade</code> <em>vieille-version</em><p><li><em>vieux-preinst</em> <code>abort-upgrade</code> <em>nouvelle-version</em><p></ul>


<ul>
<li><em>postinst</em> <code>configure</code> <em>version-configurée-plus-
récemment</em><p><li><em>vieux-postinst</em> <code>abort-upgrade</code> <em>nouvelle-version</em><p><li><em>postinst-conflictuel</em> <code>abort-remove in-favour</code>
<em>paquet nouvelle-version</em><p><li><em>postinst-déconfiguré</em> <code>abort-deconfigure in-favour</code>
<em>paquet-installation-échoué version</em> <code>removing</code> <em>paquet-
conflictuel version</em><p></ul>


<ul>
<li><em>prerm</em> <code>remove</code> <em>vieille-version</em><p><li><em>vieux-prerm</em> <code>upgrade</code> <em>nouvelle-version</em><p><li><em>nouveau-prerm</em> <code>failed-upgrade</code> <em>nouvelle-version</em><p><li><em>postrm-conflictuel</em> <code>remove in-favour</code>
<em>paquet nouvelle-version</em><p><li><em>postrm-déconfiguré</em> <code>deconfigure in-favour</code>
<em>paquet-installé version</em> <code>removing</code> <em>paquet-
conflictuel version</em><p></ul>


<ul>
<li><em>postrm</em> <code>remove</code><p><li><em>postrm</em> <code>purge</code><p><li><em>vieux-postrm</em> <code>upgrade</code> <em>nouvelle-version</em><p><li><em>nouveau-postrm</em> <code>failed-upgrade</code> <em>vieille-version</em><p><li><em>nouveau-postrm</em> <code>abort-install</code><p><li><em>nouveau-postrm</em> <code>abort-install</code> <em>vieille-version</em><p><li><em>nouveau-postrm</em> <code>abort-upgrade</code> <em>vieille-version</em><p><li><em>postrm-disparu</em> <code>disappear</code> <em>ecraseur nouvelle-version</em><p></ul>

<hr>
<h2><A name="s-maintenance-3">
6.3 Détails des phases d'installation et de mise à jour
</A></h2>

La procédure sur installation/mis à jour/écrasement/effacement (c'est à
dire en exécutant <code>dpkg --unpack</code>, ou l'étape unpack de <code>dpkg --
install</code>) est la suivante. Dans chaque cas, si un erreur se produit, les
actions sont généralement exécuter en arrière - ce qui signifie que les
scripts de maintenance sont exécutés avec des arguments différents dans
l'ordre inverse. Ce sont les appels 'recouvrement d'erreur' listés ci-
dessous.

<ol>
<li><ol>
<li>Si une version du paquet est déjà installée, appel
	   <pre>		vieux-prerm upgrade nouvelle-version
	   </pre>

     <p><li>Si cela donne une erreur (c'est à dire un status de fin
différent de zéro), dpkg essayera plutôt:
	   <pre>		nouveau-prerm failed-upgrade vieille-version
	   </pre>
	  Recouvrement d'erreurs, dans les deux cas ci-dessus:
	   <pre>	vieux-postinst abort-upgrade nouvelle-version
	   </pre>

     <p></ol>

<p><li>Si un paquet conflictuel est enlevé en même temps:
     <ol>
<li>Si n'importe quels paquets dépend de ce paquet conflictuel et
 <code>--auto-deconfigure</code> est spécifié, appel pour chaque paquet:
	<pre>	prerm-déconfiguré deconfigure in-favour
	paquet-installé version
	removing paquet-conflictuel version
        </pre>

	Recouvrement d'erreurs:
	<pre>	postrm-déconfiguré abort-deconfigure in-favour
	paquet-échoué-installé version
	removing paquet-conflictuel version
        </pre>
	Les paquets déconfigurés sont indiqués comme nécessitant une
configuration, afin que si <code>--install</code> est utilisé, ils seront
configurés de nouveau, si possible.

     <p><li>Pour préparer, l'effacement du paquet conflictuel, appel:
	<pre>	prerm-conflictuel remove in-favour
	 paquet nouvelle-version
	</pre>
	Recouvrement d'erreurs:
	<pre>	postinst-conflictuel abort-remove in-favour
	 paquet nouvelle-version
        </pre>

	<p></ol>

<p><li><ol>
<li>Si le paquet est mis à jour, appel:
	<pre>	nouvelle-preinst upgrade vieille-version
        </pre>

     <p><li>Autrement si le paquet a des fichiers de configuration d'une
          version précédemment installée (c'est à dire, il ne reste
	  plus que les fichiers de configuration):
	<pre>	nouveau-preinst install vieille-version
	</pre>

     <p><li>Autrement (c'est à dire, le paquet a été complètement
effacé):
	<pre>	nouveau-preinst install
	</pre>

	Les versions de recouvrement d'erreurs, respectivement:
	<pre>	nouveau-postrm abort-upgrade vieille-version
	nouveau-postrm abort-install vieille-version
	nouveau-postrm abort-install
	</pre>

     <p></ol>

<p><li>Les nouveaux fichiers du paquet sont installé, écrasant ceux qui
peuvent déjà être sur le système, par exemple, les fichiers d'une
vieille version du même paquet ou d'un autre paquet (les sauvegardes des
vieux fichiers sont là, et si quelque chose se passe mal, dpkg essayera
de les remettre à leur place dans la partie de recouvrement d'erreurs).<P>
C'est une erreur pour un paquet de contenir des fichiers qui sont sur le
système dans d'autre paquet, à moins que <code>Replaces</code> soit utilisé
(voir <A href="ch-relation.html#s-relation-5"><code>Replaces</code> - écraser les fichiers et remplacer les
paquets, section 8.5</A>). Pour
l'instant l'option <code>--force-overwriting</code> est disponible, le
dégradant en un avertissement, mais ce ne sera pas toujours le cas.<P>
C'est une erreur beaucoup plus grave pour un paquet de contenir un
fichier ou autre chose qu'un répertoire où un autre paquet a un
répertoire (de nouveau, à moins que <code>Replaces</code> ne soit utilisé).
Cette erreur peut être éviter si c'est l'effet recherché, en utilisant
<code>--force-overwrite-dir</code>, mais ce n'est pas conseillé.<P>
Les paquets qui s'écrasent mutuellement des fichiers produisent des
comportements qui bien que déterministe est difficile à comprendre pour
un administrateur système. Cela nous amène à des programmes &quot;manquants&quot;
si par exemple, un paquet est installé qui écrase un fichier d'un autre
paquet, et puis est effacé de nouveau<A href="footnotes.html#20" name="fr20">[20]</A>.<P>
Un répertoire ne sera jamais remplacé par un lien symbolique vers un
répertoire et vice versa; à la place, l'état existant (lien symbolique
ou non) est conservé et <code>dpkg</code> suivra les liens s'il y en a.
<p><li><ol>
<li>Si le paquet est mis à jour, appel:
	<pre>	vieux-postrm upgrade nouvelle-version
	</pre>
   <p><li>Si cela échoue, <code>dpkg</code> essayera:
	<pre>	nouveau-postrm failed-upgrade vieille-version
	</pre>
	Les recouvrements d'erreur, dans les deux cas:
	<pre>	vieux-preinst abort-upgrade nouvelle-version
	</pre>

	C'est le point de non retour - si <code>dpkg</code> atteint ce point,
	il ne reviendra pas en arrière de ce point, si une erreur
survient. Ceci laissera le paquet dans un mauvais état, qui nécessitera
une réinstallation réussie pour remettre en état, mais c'est quand
<code>dpkg</code> commence à faire des choses irréversibles.
	
	<p></ol>

<p><li>Tous les fichiers qui étaient dans la version précédent du paquet,
mais pas dans le nouveau, sont effacés.
<p><li>La nouvelle liste de fichiers remplace la précédente.
<p><li>Les nouveaux scripts de maintenance remplacent les anciens.
<p><li>Les paquets dont les fichiers ont été écrasés pendant
l'installation, et qui ne sont pas nécessaires pour les dépendances,
sont considérés comme effacés. Pour ce paquets:
	<ol>
<li><code>dpkg</code> appelle:
	      <pre>              postrm-disparu disappear ecraseur version-ecraseur
	      </pre>

	<p><li>Les scripts de maintenance du paquet son effacés.

	<p><li>Il est inscrit dans la base de données des statuts
comme étant dans un état incorrect, non installé (ses fichiers de config
sont ignorés plutôt que d'être enlevé par <code>dpkg</code>). Remarque que ce
paquet disparu n'a pas appelé son script prerm, car <code>dpkg</code> ne sait
pas à l'avance que le paquet est écrasé.

	<p></ol>

<p><li>Les fichiers du paquet qui sont aussi listés dans les listes de
fichiers des autres paquets sont enlevés de ces listes (ce qui
lobotomisera la liste de fichiers du paquet conflictuel, s'il y en a
un).
<p><li>Les fichiers de sauvegarde faits pendant l'installation, ci-
dessus, sont effacés.
<p><li>Le nouveau statuts du paquet est correct et enregistré comme
installé. C'est un autre point de non retour - si l'effacement d'un
paquet conflictuel échoue, nous ne pouvons pas défaire le reste de
l'installation; le paquet conflictuel est dans un état à moitié enlevé.
<p><li>S'il y avait un paquet conflictuel, nous avons utilisé les actions
d'effacement (décrites ci-dessus), en commençant par l'effacement des
fichiers conflictuels du paquet (les fichiers qui sont aussi dans le
paquet installé ont déjà été effacés de la liste des fichiers
conflictuels du paquet, et ne doivent pas être enlevés maintenant).
<p></ol>

<hr>
<h2><A name="s-maintenance-4">
6.4 Détails de la configuration
</A></h2>
Quand nous configurons un paquet (ceci arrive avec <code>dpkg --
install</code>, ou avec <code>--configure</code>), nous mettons à jour d'abord les
fichiers de configuration (conffiles) et ensuite appelons:
<pre>posinst configure version-configurée-la-plus-récente</pre>

Aucune actions n'est tenté pour défaire les erreurs pendant la
configuration.<P>

S'il n'y a pas de version configurée plus récente, <code>dpkg</code> passera
un argument nul; les vieilles versions de <code>dpkg</code> peuvent passer
<code>&lt;unknow&gt;</code> (avec les signes supérieur et inférieur) dans ce cas. Même
les plus vieux ne passent pas de second argument du tout, dans n'importe
quelles circonstances.<P>
<hr>
<h2><A name="s-maintenance-5">
6.5 Détails de l'effacement et/ou de la configuration de purge
</A></h2>

<ol>
<li><em>prerm</em> <code>remove</code>
<p><li>Les fichiers du paquet sont effacés (sauf conffiles).
<p><li><em>postrm</em> <code>remove</code>
<p><li>Tous les scripts de maintenance sont effacés sauf postrm.
Si nous n'effaçons pas le paquet, la procédure s'arrête là. Remarque que
les paquets qui n'ont pas de postrm et conffiles sont automatiquement
purgés pendant l'effacement, comme il n'y pas de différence, sauf pour
le statut de <code>dpkg</code>.
<p><li>Le conffiles et les fichiers de sauvegarde (-files,
<code>#*#</code>files, %-files, <code>.dpkg-{old, new, tmp}</code>, etc.) sont
effacés.
<p><li><em>postrm</em> <code>purge</code>
<p><li>La liste des fichiers du paquet est effacée.
<p></ol>


Aucune tentative n'est faite pour défaire les erreurs durant
l'effacement.<P>
<hr>
Le manuel de programmation de dpkg
- <A href="index.html#copyright">Copyright ©1996 Ian Jackson
Copyright ©1997 David Curé et Christian Jacolot pour
           la version française.</A>
<br>
<A href="index.html#toc">Table des matières</A>; <A href="index.html#abstract">résumé</A>; <A href="ch-descript.html">suivant</A>; <A href="ch-versions.html">précédent</A>.
<br>
<address>20 décembre 1997<br>
D. Cure <A href="mailto:cure@cnam.fr">cure@cnam.fr</A><br>
C. Jacolot <A href="mailto:jacolot@ubolib.univ-brest.fr">jacolot@ubolib.univ-brest.fr</A></address>
</body></html>
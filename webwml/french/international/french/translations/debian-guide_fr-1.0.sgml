<!doctype debiandoc system>
<book>
<title>Guide d'introduction à Debian GNU-Linux</title>

<author>John Goerzen et Ossama Othman</author> 
<author>Traduction française de Patrice Karatchentzeff
<email>p.karatchentzeff@free.fr</email>

<version>Traduction du document du 2 octobre 2000</version>
<abstract>
Ceci est la version française du guide d'introduction à la
distribution Debian GNU-Linux.
</abstract>
<copyright>
Copyright &copy 1998, 1999, 2000 Software in the Public Interest, Inc

<p>
Il est autorisé de faire et de distribuer des copies modifiées du
présent document sous les conditions de reproduction déclarées dans la
«&nbsp;GNU General Public License&nbsp;» ainsi que dans tous les
autres paragraphes où les conditions particulières de
<em>copyright</em> s'appliquent, et que le résultat dérivé du
précédent manuel dans son intégralité soit redistribué dans les mêmes
conditions.
 
<p>
Il est autorisé de faire et de distribuer des copies traduites de ce
manuel dans d'autres langues dans les conditions des versions
modifiées. La «&nbsp;GNU General Public License&nbsp;» peut être
incluse en version traduite approuvée par la <em>Free Software
foundation</em> à la place de la version anglaise du document.

<p>
Vous pouvez comme vous le souhaîter distribuer des versions exactes ou
modifiées du présent document en respectant les termes de la
«&nbsp;GNU General Public License&nbsp;», à l'exception des sections
clairement marquées avec un <em>copyright</em> séparé.
</copyright>

<toc  sect>
<chapt> Remerciements
<p>
De nombreuses personnes ont contribué à ce manuel. Nous aimerions toutes
les remercier et nous allons essayer ici.
<p>
En espérant n'oublier personne parmi les nombreux collaborateurs à ce
manuel, nous remercions : Havoc Pennington, Ardo van Rangelooij,
Larry Greenfield, Thalia Hooker, Day Irmiter, James Treacy, Graig
Sawyer, Oliver Elphick, Ivan E. Moore, Eric Fischer, Mike Touloumtzis
et le <em>Projet de documentation de Linux</em> pour leur travail sur
ce qu'est devenu le <em>Guide d'introduction à Debian GNU-Linux</em>.
<p>
Nous remercions Richard Stallman de la <em>Free Software
Foundation</em> pour ses conseils et pour l'édition.
<p>
Nous disons un gros merci à Bruce Perens, Sven Rudolph, Igor Grobman,
James Treacy, Adam Di Carlo, Tapio Lehtonen et Stéphane Bortzmeyer
pour leurs travaux sur ce qui allait devenir une collection de
documents d'installation.
<p>
Enfin, nous souhaitons vivement remercier les centaines de développeur
Debian et que les milliers d'auteurs de logiciels libres qui nous ont
donnés matière à penser et à écrire.
</chapt>
<chapt> Préface

<p>
 <em>«&nbsp;La liberté est la plus radicale de toutes les idées.&nbsp;»</em>
<p>
Cette citation de Nathaniel Branden décrit bien, à nos yeux, le mouvement du
logiciel libre. En l'espace de quelques décennies, à peine, l'informatique a
transformé la vie de tout un pan de l'humanité. Par notre engagement dans le
mouvement du logiciel libre, nous accentuons ce changement en offrant au plus
grand nombre d'individus et de communautés la possibilité d'accéder
pleinement aux ressources logicielles qui, dès lors, ne sont plus la
chasse gardée de certains éditeurs et de leurs développeurs. Composants
essentiels de cet objectif, ce livre et ce cédérom contiennent un précieux
lot de logiciels libres, plus d'un millier de paquets, dont le plus populaire
des serveurs web. Vous pouvez utiliser ces logiciels pour n'importe quoi, du
dessin à la gestion de bases de données SQL.
<p>
La révolution de Logiciel Libre a pris l'industrie par surprise. Linux,
conçu à partir de zéro il y a moins de dix ans, est devenu le noyau
favori des auteurs de logiciels libres. Les idées et les expériences
accumulées depuis ont propulsé Linux et les outils GNU de la <em>Free
Sofware Foundation</em> aux avant-postes partout dans le monde. Des
systèmes libres, comme celui de Debian GNU-Linux, rassemblent des
milliers d'applications. Et qu'on ne s'y trompe pas, leur stabilité et
leur puissance dépassent celles de bien des systèmes vedettes de
l'industrie traditionnelle.
<p>
De nos jours, le système GNU-Linux joue un rôle dominant dans les
serveurs Internet, parmi les fournisseurs d'accès, dans les
universités, parmi les passionnés et dans le monde de la recherche
informatique.  Le système Debian GNU-Linux a mis la puissance des
logiciels libres au service de tous, des ordinateurs portables aux
engins spatiaux.
<p>
De très nombreuses entreprises dans le monde ont connu les
satisfactions et les avantages qui découlent de l'utilisation de
logiciels libres. Cette puissance et cette stabilité impressionnantes
de même que la possibilité de communiquer directement avec l'auteur
des programmes que vous utilisez, la capacité de les modifier à
volonté, si, bien sûr, vous avez appris à le faire, et le support
technique convivial  que vous pouvez obtenir en ligne, en rien
comparable, se combinent pour transformer l'usage au quotidien d'un
ordinateur en une expérience pleine de découvertes et, surprise ! 
d'émotions.
<p>
Entrer dans l'univers du logiciel libre, c'est sûrement la meilleure
chose que vous ayez faite avec votre ordinateur; le faire à partir
d'une Debian GNU-Linux, c'est d'autant mieux : elle est puissante,
robuste, très bien documentée et, en prime, ludique !
<p>
Bienvenue à la révolution !
 <p>
 - John Goerzen.
</chapt>
 <chapt> Introduction

<p>
Nous sommes heureux d'avoir la chance de vous présenter Debian. Avant
d'entamer la discussion sur GNU-Linux, nous aimerions d'abord parler
un peu de ce qu'est exactement Debian - ce qu'elle fait et qu'elle
sont ses buts dans le monde vaste du Logiciel Libre.

<sect> Qu'est-ce que Debian ?

<p>
Debian est un système d'exploitation (OS pour <em>Operating
System</em>) libre pour votre ordinateur. Un système d'exploitation
est un rassemblement de programmes élémentaires et d'utilitaires qui
font fonctionner votre ordinateur. Au coeur du système se trouve le
noyau. Le noyau est le programme le plus fondamental de votre
ordinateur. Il s'occupe de toutes les tâches élémentaires et permet de
lancer les autres programmes. Debian utilise le noyau Linux, un
ensemble de logiciels entièrement libres initié par Linus Torvalds et
supportant des milliers de logiciels dans le monde. Une part
importante des outils de base qui forment le système d'exploitation
vient du projet GNU (<em>http://www.gnu.org/</em>) et ces outils
sont aussi libres.

<p>
Une autre facette d'un système d'exploitation est la partie logiciels
applicatifs: ce sont les programmes qui vous aident dans votre travail, de
l'édition de documents en passant par les jeux jusqu'à l'écriture
d'autres programmes. Debian rassemble plus de 1500 paquets (ce sont
des logiciels pré-empaquetés dans un format pratique pour
l'installation sur votre machine) tous libres.

<p>
Le système Debian ressemble un peu à une pyramide. À la base se trouve
le noyau Linux. Juste au-dessus se trouve les outils de base, la
plupart en provenance du mouvement GNU. Ensuite, on trouve les
logiciels applicatifs que vous utilisez sur votre ordinateur; la
plupart d'entre eux sont aussi d'origine GNU. Les développeurs Debian
agissent comme des architectes et des coordinateurs: ils organisent
avec soin le système en ajustant l'ensemble dans un système
d'exploitation cohérent et stable: Debian GNU-Linux.

<p>
La philosophie d'un système GNU-Linux est de répartir ses
fonctionnalités en un ensemble de petites tâches élémentaires. De
cette façon, il est aisé d'ajouter une nouvelle fonctionnalité en
combinant les petits bouts de programmes de nouvelle façon. Debian est
un jeu de construction: vous pouvez construire toutes sortes de choses
avec.

<p>
Lorsque vous utilisez votre système d'exploitation, vous désirez
réduire la quantité de travail pour effectuer une tâche donnée. Debian
vous fournit quantité d'outils pour vous aider mais seulement si vous
connaissez ce que font ces outils. Perdre une heure à faire
fonctionner quelque chose pour l'abandonner ensuite n'est pas très
productif. Ce guide a pour but de vous apprendre ces outils de base
qui sont le coeur de Debian: quels outils utilisés dans certains cas
et comment les combiner.

<sect1> Qui est l'auteur de Debian ?

<p>
Debian est un projet de développement à travers Internet basé sur le
volontariat. Il y a plusieurs centaines de volontaires travaillant
dessus. La plupart sont responsables d'un petit nombre de paquets de
logiciel et connaissent très bien les logiciels qu'ils empaquètent.

<p>
Ces volontaires travaillent de concert en respectant un ensemble de
directives dans la façon d'assembler un paquet. Ces directives sont
développées en coopération sur Internet lors de discussions dans des
listes de diffusion.
</sect1>
</sect>

<sect> Un système d'exploitation multi-tâches et multi-utilisateurs.

<p>
Comme nous l'avons précédemment mentionné dans la section 3.1,
l'architecture de Debian GNU-Linux vient directement de celle
d'Unix. À la différence des systèmes d'exploitation comme le DOS,
Windows et MacOS, on trouve habituellement le système GNU-Linux sur de
grands serveurs et des systèmes multi-utilisateurs.

<p>
Ceci veut donc dire que Debian possède des avantages que les
précédents systèmes n'ont pas. Il autorise un nombre important de
personnes à utiliser le système en même temps, tant que chaque
utilisateur possède son propre terminal. <footnote>Un terminal est un
simple écran et clavier qui sont connectés à l'ordinateur à travers le
réseau, par l'intermédiaire d'un modem, ou directement. Votre clavier
et l'écran forment alors un terminal qui est directement rattaché à
l'ordinateur. Ce terminal spécial est souvent appelé
<em>console</em></footnote> Pour autoriser de nombreux utilisateurs à
travailler simultanément, Debian doit gérer de nombreux programmes et
applications en même temps. Cette faculté s'appelle le
<em>multi-tâches</em>.

<p>
Une grande partie de la puissance (et de la complexité) des systèmes
GNU-Linux proviennent de ces deux fonctionnalités. Par exemple, le
système doit avoir une solution pour empêcher un utilisateur de
détruire accidentellement les fichiers d'un autre utilisateur. Le
système d'exploitation doit aussi coordonner les nombreux programmes
tournant en même temps et s'assurer qu'ils n'utilisent pas la même
ressource, comme le disque dur, ensemble.

<p>
Si vous gardez à l'esprit la raison pour laquelle Debian a été créée,
de nombreux de ses aspects vont alors avoir plus de sens. Vous
apprendrez à tirer parti de la puissance de ces fonctionnalités.
</sect>


<sect> Qu'est-ce qu'un logiciel libre ?

<p>
Lorsque les développeurs et les utilisateurs de Debian parlent de
logiciels libres, ils pensent à liberté plutôt qu'à
gratuité. <footnote>NDT: En anglais, le <em>free</em> de <em>free
software</em> veut aussi bien dire libre que gratuit d'où une
confusion souvent ignorée du profane entre logiciel libre et
gratuit.</footnote> Debian est libre dans le sens où vous êtes libre
de la modifier et de la redistribuer, et vous aurez toujours accès au
code source pour le faire. Les «&nbsp;Directives du Logiciel Libre de
Debian&nbsp;»
(<em>https://www.debian.org/social_contract#guidelines</em>) décrivent
avec plus de détails ce que Debian appelle exactement libre. La <em>
Free Software Foundation </em>, (<em>http://www.fsf.org</em>), à
l'origine du projet GNU, est aussi une excellente source
d'information. Vous pouvez trouver plus de détails sur le libre sur
le site web de Debian (<em>https://www.debian.org</em>). Un des travaux
les plus connus en la matière est un essai de Richard Stallman
«&nbsp;Why Software should be free<footnote>Pourquoi les logiciels
devraient être libres ?</footnote> ?&nbsp;»
(<em>http://www.fsf.org/philosophy/shoudbefree.html</em>). Jetez-y
donc un coup d'oeil pour connaître les raisons pour lesquelles nous
supportons les logiciels libres comme nous le faisons. Récemment, des
gens ont commencé à appeler les logiciels libres des logiciels
<em>Open Source</em> (à code ouvert); ces deux termes sont
interchangeables.

<p>
Il se peut que vous vous demandiez pourquoi certaines personnes
prennent sur leur temps libre et passent des heures à écrire des
logiciels et  les empaqueter soigneusement juste pour les
donner. Les réponses à cette question sont aussi variées que les
contributeurs.

<p>
Beaucoup croient au partage de l'information et à la liberté de
coopérer avec quelqu'un d'autre et ils pensent que le logiciel libre
encourage cette pratique. Une longue tradition de mise en avant de ces
valeurs, parfois appelée l'Éthique du Hacker<footnote> Notez bien que
le terme «&nbsp;<em>hacker</em>&nbsp;» ne doit pas être confondu avec
celui de « <em>cracker</em>&nbsp;». Pour faire simple, un
<em>hacker</em> est un être bienveillant tandis qu'un <em>cracker</em>
est malveillant. Les films et les autres formes de média utilisent la
plupart du temps à tord le terme <em>hacker</em> au lieu de celui de
<em>cracker</em></footnote>, a commencé dans les années cinquante. Le
Projet Debian GNU-Linux a été fondé sur les bases de l'éthique de
liberté des logiciels libres, sur le partage et la coopération.

<p>
D'autres désirent apprendre davantage sur les ordinateurs. De plus en
plus de gens recherchent des solutions pour éviter les prix sans cesse
croissants des logiciels propriétaires. C'est une communauté
grandissante d'utilisateurs qui ne cesse d'apprécier tous les
logiciels libres qu'elle a reçu d'autres personnes.

<p>
De nombreuses personnes dans les universités créent des logiciels
libre pour favoriser le résultat de leur recherche dans des domaines
non exploités. Certaines entreprises aident à maintenir certains
logiciels libres et ont ainsi leur mot à dire dans la direction du
développement - il n'y a pas de solutions plus rapide pour obtenir une
nouvelle fonctionnalité que de l'implémenter vous-même ou d'embaucher
un consultant pour le faire. Les entreprises sont aussi intéressées
par la plus grande souplesse et la possibilité de choisir entre
plusieurs vendeurs pour le support.

<p>
Quelques autres personnes voient les logiciels libres comme un bien
social qui démocratise l'accès à l'information et prévient d'une
centralisation excessive de l'infrastructure de l'information
mondial. Bien sûr, beaucoup d'entre nous trouve cela tout simplement
sympa.

<p>
Debian est tant rattachée au logiciel libre que nous avons pensé qu'il
serait bien de tout formaliser dans un document. Notre <em>Contrat
Social</em> (<em>https://www.debian.org/social_contract</em>) nous
promet que Debian sera toujours composée à 100% de logiciels
libres. Lorsque vous installez un paquet de la distribution
<em>main</em> de Debian, vous pouvez être certain qu'il respecte nos
Directives du Logiciel Libre.

<p>
Bien que Debian croit aux logiciels libres, il y a des cas où
certaines personnes désirent ajouter des logiciels propriétaires sur
leurs machines. Dans la mesure du possible, Debian le supporte; bien
que les logiciels propriétaires ne sont pas inclus dans la partie
<em>main</em> de la distribution Debian, on peut parfois les trouver
sur le site ftp dans le répertoire <em>non free</em>. Et il y a un
nombre grossissant de paquets dont le but unique est d'installer des
logiciels propriétaires que nous ne sommes pas autorisés nous-mêmes à
distribuer !

<p>
Il est important de bien distinguer les logiciels <em>commerciaux</em>
de ceux <em>propriétaires</em>. Les logiciels propriétaires ne sont
pas des logiciels libres; les logiciels commerciaux sont des logiciels
vendus contre de l'argent. Debian autorise les logiciels commerciaux,
mais pas les propriétaires, à faire partie de la distribution
<em>main</em>. Rappelez-vous bien que l'expression <em>logiciel
libre</em> ne se rapporte pas au prix; il est parfaitement possible de
vendre un logiciel libre. Pour un peu plus de clarification sur la
terminologie employée, voir <em>http://www.fsf.org/philosophy/categories.html</em>.
</sect>

<sect> Au sujet de ce livre

<p>
Ce livre a été conçu pour les lecteurs fraîchement arrivés à
Debian GNU-Linux. Il n'est pas nécessaire d'avoir des connaissances
sur le système GNU-Linux ou tout autre système de type Unix mais il
est nécessaire d'avoir quelques connaissances de base sur les
ordinateurs et leurs composants. Il vous faut connaître les
différentes parties d'un ordinateur et ce que l'on peut faire avec.

<p>
De façon générale, ce tutoriel essaie de vous aider à comprendre ce
qui se passe à l'intérieur d'un système Debian. L'idée est de vous
rendre apte à résoudre de nouveaux problèmes et de tirer le meilleur
parti de votre ordinateur. Ainsi, vous rencontrerez plein de théories
et de faits amusants dans les différents aspects des «&nbsp;How
To<footnote>Littéralement: Comment faire...</footnote>&nbsp;» de ce
manuel.

<p>
Nous aimerions recevoir vos commentaires sur ce livre ! Vous pouvez
joindre les auteurs debian-guide_fr-1.0_chap1.sgmlà
<em>debian-guide@complete.org</em>. Nous sommes tout particulièrement
intéressés par le fait de savoir comment ce livre a pu vous aider et
comment le rendre meilleur. Si vous avez des commentaires ou bien que
vous pensez que ce livre est la meilleure chose depuis l'apparition du
pain brioché, alors, s'il vous plaît, envoyez-nous un courriel.

<p>
N'envoyez pas s'il vous plaît de questions techniques aux auteurs sur
Debian car il y a plein de forum pour cela. Allez au chapitre 17 pour
obtenir de l'information ou de l'aide. N'envoyez des courriels qu'au
sujet du livre à proprement parlé à l'adresse ci-dessus.

 
<sect1> Comment lire ce livre

<p>
La meilleure façon d'apprendre n'importe quel programme informatique
est de l'utiliser. La plupart des gens pensent que se contenter de
lire un livre sans utiliser le programme n'est pas bénéfique. La
meilleur voie pour apprendre Unix et GNU-Linux est encore de les
utiliser. Utilisez GNU-Linux pour tout ce que vous pouvez. Sentez vous
libre d'expérimenter !

<p>
Debian n'est pas aussi intuitive que certains autres systèmes
d'exploitation. Il vous sera certainement nécessaire de lire au moins
quelques chapitres de ce livre. La puissance et la complexité de
GNU-Linux le rendent difficile au premier abord mais bien plus
rentable par la suite.

<p>
Pour apprendre, nous vous suggérons de lire un petit peu, et de
jouer ensuite un petit peu. Continuez de bidouiller jusqu'à ce que
vous soyez à l'aise avec les concepts, et alors seulement poursuivez
la lecture du livre. Vous trouverez une variété importante de sujets
traités parmi lesquels certains vous intéresseront. Après quelque
temps, vous serez assez confiant pour utiliser des commandes sans
savoir exactement ce qu'elles font. Ce sera une bonne chose.

<p>
Si jamais vous vous trompez en tapant une commande ou que ne savez pas
comment sortir d'un programme, appuyez sur CTRL-c (la touche
<em>Ctrl</em> et la lettre minuscule <em>c</em> doivent être pressées
simultanément). Cela stoppe la plupart du temps le programme.
</sect1>

<sect1> Conventions typographiques

<p>
Avant d'aller plus en avant, il est important de se familiariser avec
les conventions typographiques utilisées dans ce livre.

<p>
Quand vous aurez à presser simultanément plusieurs touches, une
notation comme CTRL-a sera utilisée. Cela signifie «&nbsp;pressez la touche
<em>Ctrl</em> et pressez la touche de la lettre minuscule <em>a</em>
». Certains claviers ont à la fois la touche <em>Alt</em> et
<em>Meta</em>; la plupart des ordinateurs n'ont  que la
touche <em>Alt</em> mais celle-ci  va  simuler le comportement
de la touche <em>Meta</em>. Donc, si vous n'avez pas de touche
<em>Meta</em>, utilisez la touche <em>Alt</em> à la place.

<p>
Les touches comme <em>Alt</em> et <em>Meta</em> sont appelées des
<em>modificateur</em> parce qu'elle change le mécanisme des touches
standard comme la lettre <em>A</em>. Parfois, il est nécessaire
d'avoir recours à plusieurs modificateurs simultanément. Par exemple,
<em>Meta-Ctrl-a</em> signifie d'appuyer simultanément sur les touches
<em>Meta</em>, <em>Ctrl</em> et <em>a</em> minuscule.

<p>
Quelques touches ont une notation spéciale. Par exemple,
<em>Entrée</em> (<em>RET</em>, la touche avec une flèche descendante et
allant à gauche), <em>Suppr</em> (<em>Suppr</em> ou quelque fois le
<em>retour arrière</em> (la touche avec une flèche vers la gauche)),
<em>Échap</em> (<em>Échappement</em> ou <em>Esc</em>). Ces touches
portent généralement un nom bien explicite.

<p>
Les espaces utilisés dans les expressions signifient d'appuyer sur les
touches séquentiellement. Par exemple, <em>CTRL-a x RET</em> signifie
d'appuyer simultanément sur <em>Ctrl</em> et <em>a</em>, puis sur la
lettre <em>x</em> et enfin sur la touche <em>Entrée</em>.

<p>
Dans certaines sections, le texte en <em>caractère gras</em> servira à
marquer le texte de l'utilisateur, celui en <em>italique</em> des
commentaires sur un point donné de la partie et tout autre type de
texte servira au renvoi de la commande. Pour certaines commandes très
courtes, vous pourrez rencontrer un autre format, en surimpression
avec un <prgn>espacement fixe</prgn>.
</sect1>
</sect>
</chapt>

<chapt> Bien débuter

<p>
<em>«&nbsp;Une journée de plusieurs centaines de kilomètres doit
commencer par un petit pas&nbsp;» - Lao-Tseu</em>

<p>
Maintenant que vous avez vu les idées et la philosophie se cachant
derrière Linux et Debian, il est temps de l'installer sur votre
matériel ! Nous allons commencer par parler des préparatifs à
l'installation de Debian, notamment en partitionnant le disque et
finir par comment démarrer l'installation de votre système.

<sect> Matériel supporté

<p>
Debian n'impose pas un matériel requis, si ce n'est celui supporté
par le noyau Linux et les outils GNU.

<p>
Plutôt que de tenter de décrire toutes les différentes configurations
matérielles qui sont supportées sur la plateforme PC, cette section
contient des informations générales et des pointeurs où trouver de
l'information supplémentaire.

<p>
Il y a deux excellents endroits pour vérifier des informations
détaillées. La liste du matériel supporté par Debian
(<em>https://www.debian.org/releases/slink/i386/ch-hardware-req.en.html</em>)
et le HOWTO du Projet de Documentation Linux
<em>Compatibility-HOWTO</em>
(<em>http://metalba.unc.edu/LDP/HOWTO/Hardware-HOWTO.html</em>). Pour
des informations sur le support des cartes vidéos, vous pouvez aussi
jeter un coup d'oeil à <em>XFree86</em>
(<em>http://www.xfree86.org/</em>) sur leur site web.

<sect1> Espace disque et de mémoire

<p>
Vous devez avoir au minimum 4 Mo de mémoire et 35 Mo d'espace
disponible sur votre disque. Si vous désirez installer un nombre
raisonnable de logiciels, avec en particulier le système X Window, et
quelques programmes de développement ainsi que des bibliothèques, vous
aurez certainement besoin d'au moins 300 Mo. Pour une installation
complète, il vous faudra 800 Mo. Pour installer <em>tous</em> les
paquets de Debian, il vous faudra probablement environ 2
Go. Actuellement, tout installer n'a pas de sens car certains paquets
procurent le même service.

</sect1>
</sect>

<sect> Avant de commencer

<p>
Avant de commencer, assurez-vous bien de sauvegarder toutes vos
données présentes sur le système. La procédure d'installation peut
détruire toutes les données d'un disque dur ! Les programmes utilisés
lors de l'installation sont assez sûrs et nombreux ont des années
d'existence et d'exploitation; mais un faux mouvement de votre part
peut vous coûter cher. Même après avoir sauvegardé vos données,
réfléchissez bien lors de vos réponses et de vos actions. Deux minutes
de réflexion peuvent vous épargner des heures de travail non
nécessaire.

<p>
Debian s'efforce au mieux de partager la place avec un ou plusieurs
autres systèmes d'exploitation. Si vous prévoyez cette option,
assurez-vous d'avoir le cédérom original ou les disquettes pour
pouvoir réinstaller les autres systèmes d'exploitation. Si vous
repartitionnez votre disque de boot, il se peut que vous ayez à
réinstaller le système d'amorçage<footnote><em>boot loader</em> en
anglais. C'est le responsable de la procédure de choix du système
d'exploitation au démarrage.</footnote> ou le système dans son
intégralité.

<sect1> Les informations nécessaires

<p>
Si votre ordinateur est connecté à un réseau vingt-quatre heures sur
vingt-quatre (<em>i-e</em> par une connexion Ethernet ou similaire et
non par une connexion <prgn>ppp</prgn>), vous devez demander à votre
administrateur les informations suivantes:

<p>
<list>
<item> Votre nom d'hôte («&nbsp;<em>hostname</em>&nbsp;»);
<item> Votre nom de domaine («&nbsp;<em>domain name</em>&nbsp;»);
<item> L'adresse IP de votre ordinateur;
<item> L'adresse IP de votre réseau;
<item> Le masque réseau utilisé par votre réseau;
<item> L'adresse de votre réseau de diffusion  en usage sur votre réseau («&nbsp;<em>broadcast</em>&nbsp;»);
<item> L'adresse IP de la passerelle de routage par défaut («&nbsp;<em>gateway</em>&nbsp;»), si votre réseau en possède une;
<item> Le système de votre réseau que vous devrez utiliser comme serveur DNS;
<item> La façon dont vous vous connectez au réseau via <em>ethernet</em>;
<item> Vérifiez si votre interface <em>Ethernet</em> est de type PCMCIA, et dans l'affirmative, relevez le type du contrôleur.
</list>

<p>
Si votre seule connexion réseau est celle du téléphone via
<prgn>ppp</prgn>, ou tout autre type équivalent de connexion, il n'est
pas nécessaire de s'occuper du paramètrage réseau avant la fin
d'installation. Voir la partie 13.1 concernant le paramètrage d'une
connexion <prgn>ppp</prgn> sous Debian.
</sect1>
</sect>

<sect> Partitionner son disque dur

<p>
Avant d'installer la Debian sur votre ordinateur, il est généralement
de bon ton de planifier à l'avance l'organisation de votre disque
dur. Une partie de ce travail consiste à partitionner le disque.

<sect1> Travaux préliminaires

<p>
Le partitionnement d'un disque consiste simplement au fait de le
diviser en parties. Chaque partie sera indépendante des autres. C'est
un peu comme ajouter des murs à l'intérieur d'une maison: après,
décorer une pièce n'affecte pas l'aspect des autres pièces.

<p>
Si vous avez déjà un système d'exploitation sur votre disque (Windows
95, Windows NT, DOS, etc.) et que vous désirez installer Debian
GNU-Linux au même endroit, il sera probablement nécessaire de
repartitionner le disque. De manière générale, transformer une
partition contenant déjà un système de fichier détruit toutes les
informations le contenant. Ainsi, vous devez absolument faire une
sauvegarde de toutes vos données avant tout repartitionnement. Pour
reprendre l'analogie avec la maison, vous devrez probablement retirer
tous les ornements d'un mur avant de le déplacer ou sinon, vous
risqueriez des les endommager. Heureusement, il existe une possibilité
pour certains utilisateurs; voir partie 4.3.6 pour plus
d'informations.

<p>
Dans le cas le plus simple, le système GNU-Linux demande au moins une
partition pour fonctionner. Vous pouvez avoir une seule partition
contenant tout le système d'exploitation et vos fichiers
personnels. De nombreuses personnes optent pour un partitionnement
plus important pour le système GNU-Linux. Il y a deux raisons de
subdiviser son système avec un nombre plus important de petites
partitions. La première est pour une raison de sécurité. Si quelque
chose arrive et corrompt le système de fichiers, seule une partition
est généralement affectée. Ainsi, il n'est simplement nécessaire que
de remplacer la portion incriminée (à l'aide des sauvegardes que vous
avez pris soin d'effectuer consciencieusement). Au minimum, vous allez
devoir créer ce que l'on appelle généralement une <em>partition
root</em> ou <em>partition racine</em>. Elle contient les composants
essentiels du système. Si une autre partition est corrompue, vous
pouvez toujours amorcer votre système pour essayer de le réparer. Cela
peut vous épargner les ennuis d'une réinstallation complète du système
à partir de zéro.

<p>
La seconde raison est généralement plus critique dans un environnement
commercial, mais elle dépend énormément de la finalité du
système. Supposons que quelque chose échappe à tout contrôle et
qu'elle se mette à dévorer l'espace disque disponible. Si le programme
en question a des privilège de super-utilisateur (<em>root</em>), le
système lui réservant un pourcentage du disque non disponible pour
les utilisateurs, vous pouvez tout à coup vous retrouver sans
ressource disque. Ce n'est vraiment pas une bonne idée étant donné que
le système en a besoin tout le temps (au moins au travers de la zone
d'échange<footnote>plus communément appelée le
<em>swap</em>.</footnote>) pour de nombreux usages. Par exemple, des
courriels non sollicités, comme le <em>spam</em>, peuvent
rapidement saturer une partition. En utilisant de nombreuses
partitions, vous pouvez vous protéger de ce genre de problème. Pour
garder l'exemple du courrier électronique, placer le répertoire
<em>/var/spool/mail</em> dans sa propre partition n'empêchera pas le
système de continuer à fonctionner, même en cas de saturation par
<em>spam</em>.

<p>
Une autre raison apparaît lorsque vous avez des disques IDE de grande
capacité et que vous n'utilisez ni le mode LBA ni un pilote de
surcharge.<footnote>Voir le manuel de votre disque pour une
description de ces fonctionnalités.</footnote> Dans ce cas, il est
nécessaire de placer la partition racine à l'intérieur des 1024
premiers cylindres de votre disque dur, ce qui représente généralement
environ 524 méga-octets. Voir la partie 4.3.3 pour obtenir plus
d'informations à ce sujet.

<p>
La plupart des gens pensent qu'une partition d'échange est aussi une
nécessité absolue alors que ce n'est pas exact. Le <em>swap</em> est
une zone de stockage du système d'exploitation qui l'utilise comme une
<em>mémoire virtuelle</em> en complément de la mémoire vive. La placer
dans une partition séparée offre des performances accrues. Il est
aussi possible de forcer Linux à utiliser un simple fichier comme zone
d'échange mais ce n'est pas recommandé.

<p>
Le seul réel inconvénient à utiliser des partitions multiples est
qu'il est généralement difficile d'appréhender à l'avance ses
besoins. Si vous sous-dimensionnez vos partitions, soit vous aurez à
réinstaller le système, soit vous aurez à jongler en déplaçant
quantité de choses pour faire de la place dans la partie
sous-taillée. D'un autre côté, si la partition est surdimensionnée,
vous perdrez de la place qui pourrait être utilisée pour autre chose...
</sect1> 

<sect1> Planifier l'usage du système

<p>
Les besoins en place sur un disque et son schéma de partitionnement
sont fortement dépendants du type d'installation que vous avez décidé
de créer.

<p>
Pour vous faciliter la vie, Debian offre un certain nombre de
<em>profils</em> par défaut dont certains sont énumérés un peu plus
loin. Les profils sont de simples jeux de paquets pré-sélectionnés en
vue d'une tâche particulière sur votre système. L'installation est
facilitée car tous les paquets requis dans le profil voulu sont
automatiquement marqués à installer. Chaque profil fournit la taille
globale du système après installation. Même si vous n'utilisez pas ces
profils, cette aparté est important pour planifier car il vous permet
de vous donner une idée de la taille de votre ou vos partitions
suivant vos besoins. La liste suivante donne quelques profils ainsi
que la taille associée:

<list>
<item><prgn>Server_std</prgn>
<p>
Ceci est une petite configuration de serveur utile pour de très
petites machines qui ne conviendraient plus à un usage courant pour un
utilisateur. Elle possède par défaut un serveur FTP, un serveur web,
DNS, NIS et POP. Cela occupe environ 50 Mo. Bien sûr, ceci correspond
simplement à la taille des logiciels installés ; toutes les données
que vous aurez à traiter sont à rajouter.
<item><prgn>Dialup</prgn>
<p>
Ceci est typique d'une configuration classique de bureau avec un
système X Window, des applications graphiques, du son, de l'édition,
etc. La taille de l'ensemble des paquets occupe près de 500 Mo.
<item><prgn>Work_std</prgn>
<p>
Cette configuration convient aux petites machines ne pouvant supporter
X Window et ses applications graphiques. C'est aussi parfait pour un
ordinateur portable ou mobile. Cela occupe environ 140 Mo. Il est
possible aussi d'avoir une configuration sous X avec moins de 100 Mo.
<item><prgn>Devel_comp</prgn>
<p>
Ceci est un environnement de travail rassemblant tous les paquets de
développement populaires comme PERL, C et C++. Cela demande environ
475 Mo. En rajoutant X et quelques autres paquets utiles, vous devriez
tourner autour de 800 Mo pour ce type d'installation.
</list>

Garder en mémoire que ces tailles n'incluent pas toutes les données
généralement présentes sur un disque, comme les fichiers des
utilisateurs, les courriels et les données. Il est toujours préférable
d'être généreux avec la taille de vos propres données et fichiers. De
plus, le répertoire Debian <em>/var</em> contient quantités
d'informations du système. Les fichiers de gestionnaire d'installation
des paquets peut facilement occuper 20 Mo de disque. En général, vous
devriez allouer au moins 50 Mo pour le répertoire <em>/var</em> car
les journaux de bord<footnote>plus communément appelés les fichiers de
<em>log</em></footnote>du système sont aussi stockés là. 
</sect1>

<sect1> Les limitations des disques PC

<p>
Les BIOS des PC ajoutent de nouvelles contraintes au partitionnement
de disque. Il y a une limite au nombre de partitions
<em>primaires</em> et <em>logique</em> qu'un disque peut contenir. En
plus, il y a des limites à la taille de l'endroit où le BIOS va
chercher ses informations d'amorçage. On peut trouver plein
d'informations à ce sujet dans le mini-HOWTO Partition
(<em>http://metalab.unc.edu/LDP/HOWTO/mini/Partition.html</em>). Cette
partie va inclure une bref résumé pour vous aider à affronter la
plupart des situations.

<p>
Les partitions <em>primaires</em> sont les partitions originelles des
disques durs de PC. On ne pouvait en créer plus de quatre. Pour
s'affranchir de cette limitation, les partitions <em>étendues</em> ou
<em>logiques</em> ont été inventées. En configurant une de vos
partitions <em>primaires</em> en <em>étendue</em>, vous pouvez
subdiviser la zone de cette partition en partitions logiques. Le
nombre de partitions logiques que vous pouvez créer est beaucoup moins
limité que le nombre de partitions primaires. Dans tous les cas, vous
ne pouvez créer qu'une seule partition étendue par disque.

<p>
Linux limite le nombre de partitions par disque à quinze partitions
pour les disques SCSI (trois partitions primaires utilisables et douze
partitions logiques) et soixante trois partitions pour les disques IDE
(trois partitions primaires et soixante partitions logiques).

<p>
La dernière chose qu'il est nécessaire de connaître au sujet du BIOS
du PC est que votre partition racine - c'est-à-dire la partition
contenant l'image du noyau - doit être incluse dans les 1024 premiers
cylindres de votre disque. Puisque généralement votre partition
racine est aussi votre partition d'amorçage, il faut vous assurer que
votre partition racine se trouve bien à l'intérieur des 1024 premiers
cylindres.

<p>
Si vous avez un disque de grande capacité, il se peut que vous
utilisiez des techniques de translation de cylindres à l'intérieur de
votre BIOS comme la translation LBA (On peut se référer pour plus
d'informations au sujet des disques de grande capacité dans le
<em>Large Disk mini-HOWTO</em>
(<em>http://metalab.unc.edu/LDP/HOWTO/mini/Large-Disk.html</em>)). Si
vous utilisez ce schéma de translation de cylindres, votre partition
d'amorçage doit se trouver à l'intérieur de la représentation
translatée des 1024 cylindres.
</sect1>

<sect1> Nom de périphériques sous Linux

<p>
Les noms des disques et partitions sous Linux peuvent être différents
que ceux utilisés par d'autres systèmes d'exploitation. Vous devez
connaître ces noms que Linux utilise au moment de la création et du
montage des partitions. On trouve un schéma élémentaire dans la table
suivante.

<p>
<example>
 ----------------------------------------------------------
|       Périphériques              |     Nom sous Linux    |
|----------------------------------------------------------|		
| Premier lecteur de disquette     | /dev/fd0  	           |
| Second lecteur de disquette      | /dev/fd1  	           |
| Première partition sur /dev/hda  | /dev/hda1 	           |
| (typiquement C: dans d'autres OS)|                       |
| Cinquième partition sur /dev/hdc | /dev/hdc5 	           |
| Seconde partition sur /dev/sdb   | /dev/sdb2 	           |
| Disque IDE sur la première nappe | /dev/hda  	           |
| IDE en maître ou cédérom         |                       |
| Disque IDE sur la première nappe | /dev/hdb  	           |
| IDE en esclave ou cédérom        |                       |
| Disque IDE sur la seconde nappe  | /dev/hdc  	           |
| IDE en maître ou cédérom         |           	           |
| Disque IDE sur la seconde nappe  | /dev/hdd  	           |
| IDE en esclave ou cédérom        |                       |
| Premier disque SCSI              | /dev/sda  	           |
| Second disque SCSI et les autres | /dev/sbb et ainsi de  |
|                                  | suite                 |
| Premier port série (COM1 dans    | /dev/ttyS0	           |
| d'autres OS)                     |                       |
| Second, troisième, etc. port     | /dev/ttyS1, /dev/ttyS2|
| série                            |  etc.                 |
| Unités de sauvegarde SCSI (à     | /dev/st0, /dev/st1,   |
| rembobinage automatique)         | etc.                  |
| Unités de sauvegarde SCSI (à     | /dev/nst0, /dev/nst1, |
| rembobinage non automatique)     | etc.                  |
| Cédéroms SCSI                    | /dev/scd0, /dev/scd1, |
 ----------------------------------------------------------
</example>

<p>
Les partitions de chaque disque sont représentées en ajoutant un
chiffre au numéro de disque. Par exemple, les noms <em>hda1</em> et
<em>hda2</em> représentent les première et seconde partitions du
premier disque IDE de votre système. Linux représente les partitions
primaires avec le nom du périphérique plus les nombres 1 à 4. Par
exemple, la première partition primaire du premier disque IDE est
<em>/dev/hda1</em>. Les partitions logiques sont numérotées à partir
de 5 donc la première partition logique est <em>/dev/hda5</em>. Garder
bien en mémoire que la partition étendue - c'est-à-dire la partition
primaire contenant les partitions logiques - n'est pas utilisable en
tant que tel. Ceci s'applique aussi bien aux disques SCSI qu'aux disques
IDE.

<p>
Imaginons que vous ayez un système avec deux disques SCSI, un à
l'adresse 2 et l'autre à l'adresse 4. Le premier disque, à l'adresse
2, est appelé <em>sda</em> tandis que le second est appelé
<em>sdb</em>. Si le disque <em>sda</em> a trois partitions, elles
seront appelées <em>sda1, sda2</em> et <em>sda3</em>. On applique le
même raisonnement pour les partitions du disque <em>sdb</em>. Remarquez
que si vous possédez deux adaptateurs pour bus SCSI (contrôleurs),
l'ordre des périphériques peut porter à confusion. La meilleure
solution dans ce cas est encore de regarder les messages de
<em>boot</em>, en supposant que vous connaissez le modèle de vos
périphériques.
</sect1>

<sect1> Schéma de partitionnement recommandé

<p>
Comme décrit auparavant, il est recommandé d'avoir une petite
partition racine séparée et une grosse pour <em>/usr</em> s'il y a
suffisamment de place. Pour la plupart des utilisateurs, ce
partitionnement est très largement suffisant. Ceci est spécialement
recommandé si vous avez un petit disque car la création de nombreuses
partitions peut vous faire perdre de la place.

<p>
Dans certains cas, il se peut que vous ayez besoin d'une partition
<em>/usr/local</em> séparée si vous planifier l'installation de
nombreux programmes non-inclus dans Debian. Si votre machine est un
serveur de courriel, vous aurez besoin d'une partition séparée pour
<em>/var/spool/mail</em>. Mettre <em>/tmp</em> sur sa propre partition
de 20 à 32 Mo est aussi une bonne idée. Si vous préparez un serveur
avec un grand nombre de comptes d'utilisateurs, c'est généralement une
bonne idée de préparer une grande partition séparée contenant
<em>/home</em> à des fins de sauvegarde des comptes des utilisateurs.
De façon générale, le partitionnement varie énormément d'un ordinateur
à l'autre et dépend essentiellement de son usage.

<p>
Pour des systèmes très complexes, vous devez aller jeter un coup
d'oeil au <em>Multi Disks HOWTO</em>
(<em>http://metalab.unc.edu/LDP/HOWTO/Multi-Disk-HOWTO.html</em>). Il
contient de nombreuses informations techniques pour les gens désirant
configurer des serveurs.

<p>
La taille de la partition de <em>swap</em> doit aussi être étudiée. Il
y a beaucoup de points de vue à ce sujet. Une règle approximative qui
ne fonctionne pas trop mal est d'avoir autant de <em>swap</em> que de
mémoire vive, quoiqu'il ne soit pas nécessaire de dépasser 64 Mo pour la
plupart des utilisateurs. Elle ne doit pas non plus être plus petite
que 16 Mo non plus. Bien sûr, il y a des tas d'exceptions. Si vous
essayez de résoudre simultanément 10 000 équations avec une machine
dotée de 256 Mo de mémoire vive, vous pouvez avoir besoin d'un
giga-octet (si ce n'est plus...) de <em>swap</em>.

<p>
Par exemple, considérons une machine dotée de 32 Mo de mémoire vive et
d'un disque IDE de 1,7 Go sur <em>/dev/hda</em>. Il y a une partition
de 500 Mo pour un autre système d'exploitation sur
<em>/dev/hda1</em>. Une partition de <em>swap</em> de 32 Mo est
utilisée en <em>/dev/hda3</em> et le reste, environ 1,2 Go, sur
<em>/dev/hda2</em> est la partition Linux.
</sect1>

<sect1> Partitionnement avant installation

<p>
Il existe deux moments différents pendant lesquels partitionner: avant ou
après l'installation de Debian. Si votre ordinateur est entièrement
consacré à Debian, vous pouvez partitionner pendant l'installation
comme décrit dans la partie 5.5. Si vous avez une
machine équipée de plus d'un système d'exploitation, vous devez
généralement laisser l'autre système créer ses propres partitions.

<p>
Les paragraphes suivant contiennent des informations sur la manière de
partitionner votre premier système d'exploitation avant l'installation
de Debian. Remarquez que vous allez avoir besoin de savoir comment
relier les noms des périphériques de votre système d'exploitation à
ceux des partitions Linux.

<p>
<em>Partitionner à partir de DOS ou Windows</em>

<p>
Si vous manipuler des partitions FAT ou NTFS existantes, il est
recommandé d'utiliser soit les outils natifs de Windows ou DOS, soit
le schéma plus loin. Sinon, il n'est pas nécessaire de partitionner à
partir de DOS ou Windows: les outils de partitionnement de Linux font
généralement un travail de meilleure qualité.

<p>
<em>Réduire une partition existante</em>

<p>
Un des cas les plus classiques d'installation est de le faire sur un
système contenant déjà le DOS (y compris Windows 3.1), Win32 (comme
Windows 95, 98 ou NT) ou OS/2 et d'y ajouter Debian sur le même disque
sans détruire l'ancien système. Comme décrit précédemment, réduire la
taille d'une partition existante conduit presque immanquablement à la
perte des données qu'elle contient, du moins sans prendre de
précautions. La méthode que nous allons décrire ici, bien que ne
garantissant pas de protéger vos données, marche très bien en
pratique. Mais vous <em>devez faire une sauvegarde</em> par
précaution.

<p>
Avant d'aller plus loin, vous devez savoir comment vous comptez
diviser votre disque. La méthode décrite ici découpe seulement la
partition initiale en deux morceaux. Un contiendra l'ancien système
d'exploitation. L'autre sera utilisé par Debian. Pendant
l'installation de Debian, on vous laissera le choix de partitionner la
partie Debian à votre convenance, pour le <em>swap</em> ou pour le
système de fichiers.

<p>
L'idée est de rassembler l'ensemble des données de la partition à son
début de façon à ce que l'on ne perde rien lors de la réduction. Il
est important de déplacer les données par paquets aussi petits que
possible de façon à réduire les chances qu'un fichier soit écrit en
fin de partition et réduise ainsi la taille disponible que vous pouvez
extraire de cette partition.

<p>
La première chose que vous devez faire est une copie de FIPS qui est
disponible dans le répertoires <em>tools</em> de votre cédérom
Debian. Cette disquette doit être bootable. Sous DOS, une disquette
bootable peut être créée en utilisant la commande <prgn> sys a:</prgn>
sur un support précédemment formaté ou bien <prgn>format a; /s</prgn>
pour une disquette non formatée. Dézipez l'archive et copiez les
fichiers RESTORRB.EXE, FIPS.EXE et ERRORS.TXT sur la disquette
bootable. FIPS est fourni avec une très bonne documentation que l'on
vous recommande de lire. Vous devez absolument la lire si vous
utilisez une compression de disque ou un gestionnaire de disque. Créer
la disquette et lisez la documentation <em>avant</em> de poursuivre.

<p>
L'étape suivante consiste à déplacer toutes les données au début de la
partition. DEFRAG, qui est fourni en standard dans les versions de DOS
6.0 et supérieures, peut très bien effectuer cette tâche. Regardez la
documentation de FIPS pour une liste d'outils analogues. Remarquez
bien que si vous utilisez Windows 95 ou plus, vous devez lancer DEFRAG
de cet environnement car le DOS ne connaît pas le système de fichier
VFAT utilisé pour accepter les noms longs dans les versions 95 et
ultérieures de Windows.

<p>
Après avoir défragmenté le disque (ce qui peut prendre un certain
temps sur les disques de grande capacité), rebooter sur la disquette
FIPS que vous avez créée. Taper tout simplement <prgn>a:\ fips</prgn> et
suivez les instructions.

<p>
Remarquez au passage qu'il existe de nombreux autres gestionnaires de
partitions que celui-ci, au cas où FIPS ne fonctionnerait pas bien
pour vous.
</sect1>

<sect1> Les étapes d'installation de Debian
<p>

Pour installer Debian la première fois, il vous faudra passer par les
différentes étapes suivantes:

<list>
<item> Booter sur le système d'installation;
<item> Configurer le système de base;
<item> Installer le système de base;
<item> Booter sur le système de base précédemment installé;
<item> Installer le reste du système.
</list>

<p>
Booter sur le système d'installation, pour la première étape,
s'effectue généralement avec la disquette de
secours<footnote><em>Rescue floppy</em> dans la distribution
Debian.</footnote> ou sur le cédérom.

<p>
Aussitôt que vous avez booté le système Linux, le programme
<prgn>dbootstrap</prgn> se lance et vous guide pour effectuer la seconde
étape, la configuration du système de base. Cette étape est décrite en
détail dans le chapitre suivant.

<p>
Le <em>système de base Debian</em> est un ensemble de paquets de base
recquis pour faire tourner Debian avec un système minimal et de façon
autonome. <prgn>dbootstrap</prgn> va vous l'installer à partir du cédérom,
comme décrit dans la partie 5. À partir du moment où vous avez
installé et configuré le système de base, votre machine est
complètement autonome.

<p>
La dernière étape consiste à installer le reste du système
Debian. Ceci va inclure les applications et les documents que vous
utilisez vraiment sur votre ordinateur, comme le système X Window, des
éditeurs, des interpréteurs de commandes (plus connus sous leur
vocable anglaise <em>shell</em>) et des environnements de
développements. Ceci se fait à partir du cédérom. À partir de ce
point, vous aurez à utiliser les outils standard de gestion de
paquets sous Debian comme <prgn>dselect</prgn>. Cette étape est décrite
dans la partie 5.20.
</sect1>
</sect> 

<sect> Choisir son support d'installation

<p>
Il faut choisir dans un premier temps le support à partir duquel vous
installerez le système. Ensuite, il faut choisir la méthode
d'installation du système de base.

<p>
Pour booter sur la procédure d'installation, vous avez les choix
suivants: un cédérom bootable, des disquettes ou un système de
chargement au boot différent de celui fourni sous Linux.

<p>
Booter avec les cédéroms est bien entendu la manière la plus facile
d'installer Debian. Mais toutes les machines ne supportent pas cette
méthode et il se peut que vous ayez besoin d'utiliser les disquettes.
Booter à partir de disquettes est supporté pour la plupart des
plateformes. La façon de le faire est décrit à la partie 4.4.2.

<sect1> Installation à partir du cédérom

<p>
Si votre machine supporte de booter sur un cédérom, vous n'avez pas
besoin de disquette. Mettez le cédérom dans son lecteur, éteignez
votre ordinateur et rallumez-le. Vous devriez voir un écran d'accueil
avec un curseur de boot en bas. Vous pouvez passez alors directement à
la partie 4.5.

<p>
Si votre ordinateur ne «&nbsp;voit&nbsp;» pas vos cédéroms Debian, la solution
la plus simple est de se fabriquer deux disquettes de boot
(description dans la partie suivante) et de les utiliser pour lancer
Debian. Mais ne vous inquiétez pas: Debian en aura alors fini avec les
deux disquettes et elle trouvera le cédérom sans problème.
</sect1>

<sect1> Installation à partir de disquettes

<p>
Ce n'est pas difficile de booter à partir des disquettes. En effet,
votre cédérom contient toutes les informations pour créer les
disquettes nécessaires. Il vous sera demandé d'avoir deux
disquettes. Nommez la première <em>Disquette d'installation-secours
Debian 2.1</em> et la seconde <em>Disquette de modules-pilotes Debian
2.1</em>.

<p>
<em> Créer des disquettes à partir des images de disquettes </em>

<p>
Les images des disquettes sont des fichiers contenant l'ensemble
complet des éléments de la disquette de boot sous forme binaire. Les
images de disquette, comme <em>resc1440.bin</em>, ne peuvent être
copiées directement sur la disquette. Un programme spécial est utilisé
pour recopier les images des fichiers au format binaire.

<p>
La première étape consiste à obtenir une invite DOS. Dans Windows 95,
et supérieur, vous pouvez l'obtenir en double-cliquant sur l'icône
MS-DOS ou en allant dans <em>Démarrer -> Programme ->
MS-DOS</em>. Ensuite, insérer le cédérom Debian GNU-Linux dans son
lecteur. Déplacez-vous alors dessus. Dans la plupart des cas, il
s'agit de D:

<p>
<example>
C:\WINDOWS>D:
</example>

<p>
Maintenant, déplacez-vous dans le répertoire contenant les images des
disquettes:

<p>
<example>
D:\> CD \DISTS\SLINK\MAIN\DISKS-I386\2.1.8-1999-02-22
</example>

<p>
Si vous obtenez une erreur, vérifiez bien ce que vous avez tapé. Si
l'erreur persite, déplacez-vous manuellement dans
<prgn>\DISTS\SLINK\MAIN\DISKS-I386</prgn> et taper alors
<prgn>DIR</prgn> et allez alors dans le répertoire précité. Remarquez
que les commandes ci-dessus, et peut-être celles données un peu plus
loin, peuvent tenir sur une seule ligne sur votre écran même si elles
tiennent sur plusieurs lignes ici.

<p>
Maintenant, vous êtes prêt à créer la première des deux
disquettes. Lancer le programme <prgn>rawrite2</prgn> pour les écrire:

<p> 
<example>
D:\DISTS\SLINK\MAIN\DISKS-I386\2.1.8-1999-02-22>rawrite2
RaWrite 2.0 - Write disk file ta raw floppy diskette<footnote> Pour
écrire un fichier du disque dur vers une disquette au format
binaire.</footnote>
</example>
<p>
<prgn>Rawrite2</prgn> lance ainsi ses messages de démarrage. Ensuite, il
demande le nom du fichier et le lecteur de disquette:

<p>
<example>
Enter disk image source file name<footnote>Entrer le nom du
fichier image cible</footnote>: resc1440.bin 
Enter target diskette drive<footnote>Entrer le nom du lecteur de
disquette</footnote>: a:
</example>

<p>
<prgn>Rawrite2</prgn> vous demande maintenant de bien vouloir insérer une
disquette dans le lecteur de disquette. Faîtes-le et appuyez sur
<em>Entrée</em>

<p>
<example>
Please insert a formatted diskette into drive A: and press -ENTER-<footnote>Veuillez insérer une disquette formatée dans le lecteur A et appuyez sur Entrée</footnote>:
</example>

<p>
À ce moment, <prgn>rawrite2</prgn> va créer la première des deux
disquettes. Il vous faut répéter le processus pour la seconde
disquette:

<p>
<example>
D:\DISTS\SLINK\MAIN\DISKS-I386\2.1.8-1999-02-22>rawrite2
RaWrite 2.0 - Write disk file ta raw floppy diskette
Enter disk image source file name: drv1440.bin 
Enter target diskette drive: a:
Please insert a formatted diskette into drive A: and press -ENTER- :
</example>

<p>
À partir de maintenant, les disquettes sont prêtes: vous pouvez les
utiliser pour booter.

<p>
<em> Booter sur Debian</em>

<p>
Vous êtes maintenant prêt à booter sur Debian. Éteignez votre système
d'exploitation en cours et placez la disquette d'installation-secours
dans le lecteur de disquette. Rallumez votre ordinateur. Vous devriez
avoir un écran de bienvenue et un curseur de prompteur en bas.
</sect1>
</sect>

<sect> Booter sur la procédure d'installation

<p>
Vous devriez avoir à ce stade un curseur de boot. Presser simplement
sur <em>Entrée</em> à cet endroit.

<p>
Après avoir appuyé sur la touche <em>Entrée</em>, vous devriez voir le
message <prgn>Loading...</prgn> et ensuite <prgn>Uncompressing
Linux....</prgn> et une quantité d'informations partout sur l'écran,
voire sur plusieurs, au sujet du matériel de votre
système. Généralement, vous pouvez ignorer ces messages. Linux
recherche un grand nombre de périphériques variés et vous indique ce
qu'il trouve et ce qu'il ne trouve pas. Ne vous inquiétez pas de tous
ces messages à ce moment là. Attendez simplement jusqu'à ce que vous
aperceviez l'écran de choix en couleur. Si vous avez des problèmes,
voir le chapitre 17.
</sect>

</chapt>
<chapt> Installation pas à pas

<p>
<prgn>dbootstrap</prgn> est le nom du programme qui est lancé après avoir
booté sur la procédure d'installation. Il est responsable de la
configuration initiale du système et de l'installation du système de
base.

<p>
Le travail principal de <prgn>dbootstrap</prgn> et celui de la
configuration de base du système sont de configurer certains éléments
basiques de votre système. Par exemple, cela inclut votre adresse IP,
votre nom de domaine et quelques autres paramètres de configuration
réseau, en cas de besoin. Cela comprend aussi la configuration des
modules du noyau qui sont les pilotes chargés par le noyau. Ces
modules comprennent les pilotes de sauvegarde externe, les pilotes
réseau, le support multilingues et plein d'autres
périphériques. Configurer ces choses fondamentales est fait
prioritairement car elles sont souvent nécessaires au bon
fonctionnement ultérieur de la machine lors des étapes de
configurations suivantes.

<p>
<prgn>dbootstrap</prgn> est une application simple orientée
caractères. Elle est très facile à utiliser. Généralement, elle vous
guide à travers chaque étape du processus d'installation de façon
linéaire. Vous pouvez aussi revenir en arrière et répéter une étape si
vous vous êtes trompé. La navigation à l'intérieur de
<prgn>dbootstrap</prgn> s'effectue à l'aide des flèches du clavier, des
touches <em>Entrée</em> et <em>Tab</em>.

<sect> Sélection d'un écran monochrome ou couleur

<p>
Une fois que le système a terminé de booter, <prgn>dbootstrap</prgn> est
invoqué. La première chose que <prgn>dbootstrap</prgn> vous demande
concerne votre écran. Vous devez voir une fenêtre de dialogue <em>Select
Color or Monochrome display</em> (Sélectionner un écran
couleur ou monochrome). Si votre moniteur est capable
d'afficher de la couleur, appuyez sur <em>Entrée</em>. L'écran devrait
alors passer du noir et blanc en couleur. Déplacez-vous à l'aide des
flèches sur le bouton <em>Next</em> (suivant) et pressez alors de
nouveau la touche <em>Entrée</em> pour continuer l'installation.
</sect>

<sect> Menu principal d'installation de Debian GNU/Linux

<p>
Il se peut que vous aperceviez une boîte de dialogue disant <em>The
installation program is determining the current state of your system
and the next installation step should be performed</em> (Le
programme d'installation est en train de déterminer l'état actuel de
votre système et l'étape suivante d'installation ne devrait pas
tarder). C'est une phase pendant laquelle le programme
d'installation cherche à détecter automatiquement ce que vous aurez
probablement besoin de faire ensuite. Dans certains cas, il se peut
que vous n'aperceviez même pas cette boîte de dialogue.

<p>
Pendant toute la procédure d'installation, vous aurez affaire au menu
principal, intitulé <em>Debian GNU-Linux Installation Main Menu</em>
(Menu principal d'installation de Debian GNU-Linux). Les choix situés
en haut du menu changent au fur et à mesure pour indiquer votre
progression dans l'installation du système. Phil Hughes écrivait dans
le <em>Linux Journal</em> (<em>http://www.linuxjournal.com</em>) que
vous pouviez apprendre à un poulet à installer une Debian ! Il
soulignait ainsi le fait que le menu de la procédure d'installation
consistait essentiellement à appuyer sur la touche <em>Entrée</em>. Le
premier choix du menu d'installation est l'action suivante que vous
aurez à effectuer si le système ne détecte pas que vous l'avez déjà
fait. Si vous sélectionnez <em>Next</em> (suivant) ici, l'étape
suivante dans l'installation du système est sélectionnée.
</sect>

<sect> Configurer le clavier

<p>
Assurez-vous que le bouton <em>Next</em> est mis en surbrillance et
appuyez sur <em>Entrée</em> pour entrer dans le menu de configuration
du clavier.

<p>
Déplacez le curseur lumineux vers le clavier sélectionné et appuyer
sur <em>Entrée</em>. Utilisez les flèches pour vous déplacer. Dans de
nombreux cas, vous n'aurez qu'à sélectionner
<em>U.S. layout</em><footnote>NDT: surtout pas pour nous francophones
car vous risqueriez de vous arracher les cheveux... Prenez bien soin
de sélectionner un clavier conforme à vos origines (française, suisse,
belge ou canadienne) si tel est le cas.</footnote>.
</sect>

<sect> Dernière chance de sauvegarder vos données !

<p>
Ne vous a-t-on pas déjà dit de sauvegarder vos disques ? Voici la
première occasion de les détruire et la dernière chance de sauvegarder
vos vieux systèmes. Si vous n'avez encore sauvegardé vos disques,
sortez la disquette ou le cédérom de son lecteur, éteignez le système
puis faîtes vos sauvegardes.
</sect>

<sect> Partitionner un disque dur

<p>
Quelque soit le choix proposé par le menu de sélection <em>Next</em>,
vous pouvez utiliser les flèches « haut » et « bas » pour sélectionner
<em>Partition a Hard Disk</em> (Partitionner un disque
dur). Allez-y et à partir de là, appuyez sur
<em>Entrée</em>.

<p>
Le menu de <em>Partition a Hard Disk</em> vous présente une liste de
type de disques que vous pouvez partitionner et lance une application
de partitionnement appelée <prgn>cfdisk</prgn>. Vous devez créer au moins
une partition <em>Linux native</em> (de type 83) et vous aurez
probablement besoin d'une partition <em>Linux swap</em> (de type 82)
comme expliqué plus loin dans cette partie.

<p>
Vous devez créer maintenant les partitions dont vous aurez besoin pour
installer Debian. Par exemple, on supposera que vous partionnerez un
disque dur vierge.

<p>
La partition de boot doit se trouver à l'intérieur des 1024 premiers
cylindres de votre disque dur (voir paragraphe 4.3.3). En gardant cela
à l'esprit, utilisez la flèche droite pour mettre en surbrillance le
menu <em>New</em> (nouveau) et pressez alors sur <em>Entrée</em>. On
vous demandera alors de créer soit une partition <em>primaire</em>
soit une partition <em>logique</em>. Pour vous assurer que la
partition contenant l'information de boot soit bien dans les 1024
premiers cylindres, créez en premier votre partition primaire. La
partition primaire sera votre partition <em>Linux native</em>.

<p>
Mettez en surbrillance le menu principal et appuyez sur la touche
<em>Entrée</em>. Vous devez ensuite entrer la largeur de votre future
partition. Si vous ne savez pas quelle taille lui donner, allez voir
la partie 4.3.2. Ne pas oublier de laisser une place suffisante pour
la partition de <em>swap</em> (voire la partie 4.3.5). Entrez la
taille de la partition que vous désirez et presser sur
<em>Entrée</em>. Ensuite, il vous sera demandé si vous voulez la
placer au début de l'espace disponible ou à la fin. Placez la au début
pour être sûr d'être à l'intérieur des 1024 premiers cylindres. Mettez
en surbrillance <em>Beginning</em> et tapez sur <em>Entrée</em>. À ce
moment, vous devriez être retourné à l'écran principal. Remarquez bien
que la partition que vous venez de créer est maintenant affichée. Par
défaut, c'est une partition <em>Linux native</em>. Cette partition
doit maintenant être rendue amorçable. Assurez-vous que le menu
<em>Bootable</em> est en surbrillance et appuyez sur la touche
<em>Entrée</em>. On doit maintenant voir apparaître la champ
<em>Boot</em> dans cette partition dans la colonne <em>Flags</em> .

<example>
IMPRESSION D'ÉCRAN DE CFDISK
</example>

<p>
Avec la place restante, créez une nouvelle partition primaire. En
utilisant la flèche de direction du clavier, mettez en surbrillance le
champ <em>free space</em> (espace disponible) dans la liste des
partitions. Mettez en surbrillance maintenant le champ <em>New</em> et
faîtes de même que lorsque vous avez fabriqué la première partiton
primaire. Remarquez qu'elle est aussi affichée comme une partition
<em>Linux native</em>. Puisque vous allez la dédier au <em>swap</em>,
il va falloir la signaler comme telle. Assurez-vous de bien l'avoir
mis en surbrillance et ensuite appuyez sur la flèche gauche du clavier
jusqu'à ce que le menu <em>Type</em> soit mis en surbrillance. Pressez
alors sur la touche <em>Entrée</em>. On vous présente alors une liste
de types de partitions supportées. Le type <em>Linux swap</em> devrait
déjà être sélectionné. Si tel n'était pas le cas, entrez le numéro
dans la liste correspondant au <em>swap</em> (82) et pressez sur
<em>Entrée</em>. Votre partition de <em>swap</em> doit maintenant se
présenter sous forme de <em>Linux swap</em> dans la colonne <em>FS
Type</em> de l'écran principal.

<p>
Votre écran <prgn>cfdisk</prgn> devrait ressembler à celui de la
figure 5.1. Les chiffres peuvent différer mais les colonnes
<em>Flags</em> et <em>FS Type</em> doivent être identiques.

<p>
Jusqu'à maintenant, rien sur votre disque n'a été modifié. Si vous êtes
content de votre partionnement, appuyez sur la flèche gauche jusqu'à
<em>write</em> et appuyez alors sur la touche <em>Entrée</em>. Votre
disque dur est maintenant partitionné. Quittez l'application
<prgn>cfdisk</prgn> en sélectionnant le menu <em>Quit</em>. Une fois
quitté <prgn>cfdsik</prgn>, vous devez vous retrouvez dans
<prgn>dbootstrap</prgn>, l'application d'installation de Debian.
</sect>

<sect> Initialiser et activer une partition de <em>swap</em>

<p>
Cela doit être le choix suivant après avoir créé une partition de
disque (<em>initialize and Activate a Swap Partition</em>). Vous avez
le choix d'initialiser et d'activer une nouvelle partition de
<em>swap</em>, d'activer une partition déjà initialisée ou bien de
faire sans partition de <em>swap</em>.

<p>
Une partition de <em>swap</em> est chaudement recommandée mais vous
pouvez faire sans si vous insistez et que votre système a plus de 4 Mo
de mémoire vive. Si vous désirez le faire, sélectionnez le choix
<em>Do Without a Swap Partition</em> (Faire sans partition de
<em>swap</em>) du menu et allez directement à la partie suivante.

<p>
Il est toujours possible de réinitialiser une partition de
<em>swap</em>. Ainsi, sélectionnez <em>Initialize and Activate a Swap
Partition</em> (Activer et initialiser une partition de <em>swap</em>)
si vous n'êtes pas sûr de ce que vous faîtes. Dans un premier temps,
le menu va vous proposer une boîte de dialogue dans laquelle vous
pourrez lire <em> Please select the partition to activate as a swap
device</em> (veuillez sélectionner la partition à activer comme
<em>swap</em>). Le choix par défaut devrait être la partition de
<em>swap</em> que vous venez de paramétrer; si tel est le cas, appuyez
simplement sur la touche <em>Entrée</em>.

<p>
Ensuite, on vous propose d'activer l'option de recherche des blocs non
lisibles, causés par des défauts sur la surface des plateaux des disques
sur l'intégralité de la partition. Ceci est très utile si vous avez
des disques MFM, RLL ou de vieux SCSI. Dans tous les cas, cela ne peut
pas faire de mal (bien que cela demande pas mal de temps). La plupart
des disques modernes fonctionnant correctement n'ont pas besoin de
cette étape car ils possèdent leur propre mécanisme interne pour
s'affranchir des blocs défectueux.

<p>
Finalement, vous obtenez un message de confirmation car
l'initialisation va détruire toutes les données présentes
antérieurement sur la partition. Si tout est correct, sélectionnez
<em>Yes</em>. L'écran s'allumera lorsque le programme d'initialisation
tournera.
</sect>

<sect> Initialiser une partition Linux

<p>
À cet endroit, le choix suivant devrait s'intituler <em>Initialize a
Linux Partition</em> (Initialiser une partition Linux). Si ce n'est
pas le cas, soit vous n'avez pas achevé correctement le processus de
partitionnement, soit vous n'avez pas rempli un des menus concernant
la partition de <em>swap</em>.

<p>
Vous pouvez initialiser une partition Linux, ou bien vous pouvez en
monter<footnote> francisation de <em>mount</em> qui est passé dans le
langage courant. On trouve parfois <em>mounter</em> qui est assez
laid il faut bien l'avouer :-)</footnote> une précédemment
initialisée. Remarquez bien que <prgn>dbootstrap</prgn> ne fera pas de
mise à jour d'un vieux système sans le détruire. Si vous êtes en train
de mettre à jour, Debian peut très bien le faire tout seul et il n'est
pas nécessaire d'utiliser <prgn>dbootstrap</prgn>. Les <em>releases
notes</em> de la Debian 2.1 contiennent les instructions de mise à
jour<footnote>https://www.debian.org/releases/slink/i386/releases-notes/ch-upgrading.en.html</footnote>.

<p>
Si vous utilisez de vieilles partitions non vides, c'est-à-dire que
vous voulez juste nettoyer ce qu'il y a dessus, il suffit de les
initialiser (ce qui écrase tous les fichiers). De plus, vous devez
initialiser toutes les partitions que vous avez créées lors de l'étape
de partitionnement. La seule raison pour laquelle vous pourriez
omettre d'initialiser une partition à cette étape serait de monter une
partition que vous auriez déjà faîte à l'aide des disquettes
d'installation.

<p>
Sélectionnez le menu <em>Next</em> pour initialiser et monter la
partition de disque « / ». La première partition que vous montez ou
que vous initialisez sera montée comme « / » (prononcer
<em>root</em><footnote>se prononce « route »...</footnote>
(racine)). On vous proposera, à l'instar de l'initialisation du
<em>swap</em> de vérifier les blocs défectueux. Cela ne mange pas de
pain de le faire mais cela peut prendre dix minutes ou plus si vous
possédez des disques de grande capacité.

<p>
Une fois la partition / de montée, le menu suivant devrait être
<em>Install Operating system and modules</em> (Installer le système
d'exploitation et ses modules) à moins que vous n'ayez pas terminé une
des étapes précédentes. Vous pouvez utiliser les flèches de
déplacement pour sélectionner les menus d'initialisation ou de montage
de partitions de disques si vous avez d'autres partitions à
fabriquer. Si vous avez créé des partitions séparées pour
<em>/var</em>, <em>/usr</em> ou d'autres systèmes de fichiers, c'est
le moment de les initialiser et de les monter.

<sect1> Monter une partition précédemment initialisée.

<p>
Un pendant à l'étape <em>Initialise a Partition</em> (Initialiser une
partition) est celle de <em>Mount a Previously-Initialised
Partition</em> (Monter une partition précédemment
initialisée). Utilisez la si vous recommencez une installation qui a
été interrompue ou bien si vous montez des partitions déjà
initialisées.
</sect1>
</sect>

<sect> Installation du système d'exploitation et ses modules
 
<p>
Cela doit être l'étape suivante après avoir monté la partition racine,
sauf si vous avez déjà effectué cette tâche précédemment avec
<prgn>dbootstrap</prgn>. Vous devrez confirmer dans un premier temps
que le périphérique que vous avez monté sur la partition racine est
bien le bon. Par la suite, il vous sera proposé un ensemble de
périphériques à partir desquels vous pourrez installer le noyau et les
modules; ce sera généralement soit un cédérom soit le premier lecteur
de disquette.

<p>
Si vous faîtes l'installation à partir de disquettes, vous aurez à
travailler avec la disquette de secours (<em>Rescue Floppy</em>) qui
est déjà probablement dans le lecteur et ensuite avec la disquette de
pilotes (<em>Drivers Floppy</em>).
</sect>

<sect> Configuration du support PCMCIA

<p>
Il y a une autre étape <em>avant</em> la configuration des
modules de pilotes de périphériques appelée « Configuration du
support PCMCIA » (<em>Configure PCMCIA Support</em>). Elle est utilisé
pour activer le support PCMCIA.

<p>
Si vous avez une extension PCMCIA mais que vous ne l'utilisez pas pour
installer votre système Debian (c'est-à-dire installation avec une
carte ethernet PCMCIA), il n'est pas nécessaire de configurer le
support PCMCIA ici. Il est très facile de le configurer et de
l'activer plus tard, à la fin de l'installation. Dans tous les cas, si
vous devez installer quand même une extension PCMCIA pour le réseau,
vous devez la choisir ici et son support sera configuré antérieurement
à celui du réseau.

<p>
Si vous avez besoin de PCMCIA, sélectionnez l'autre choix en dessous
de « Configuration des modules de pilotes de périphériques »
(<em>Configure Device Driver Modules</em>). On vous demandera alors le
nom du contrôleur PCMCIA de votre système. Dans la plupart des cas, ce
sera <prgn>i82365</prgn>. Quelques fois, vous pourrez aussi rencontrer
<prgn>tcic</prgn>. Votre vendeur-fournisseur d'ordinateur portable
doit vous procurer l'information. Vous pouvez généralement laisser les
autres champs d'options vides. Attention, certains matériels ont des
besoins particuliers; le <em>PCMCIA-HOWTO</em>
(<em>http://metalab.unc.edu/LDP/HOWTO/PCMCIA-HOWTO.html</em>) contient
plein d'informations au cas où les options par défaut ne
conviendraient pas.

<p>
Dans certains cas exceptionnels, il se peut que vous ayez à modifier
le fichier <em>/etc/pcmcia/config.opts</em>. Vous devez ouvrir votre
seconde console virtuelle (<em>Alt-F2</em>) et éditer le fichier
dedans pour reconfigurer votre extension PCMCIA. Vous pouvez aussi
forcer un rechargement des modules par l'intermédiaire de
<prgn>insmod</prgn> et <prgn>rmmode</prgn>.

<p>
Une fois que votre interface PCMCIA est correctement configurée et
installée, il vous faut passer à la configuration des pilotes de
périphériques comme décrit dans le paragraphe suivant.
</sect>

<sect>Configuration des modules de pilotes de périphériques

<p>
Sélectionnez le menu <em>Configure Device Driver Modules</em>
(configuration des modules de pilotes de périphériques) et passez en
revue les périphériques présents sur votre système. Configurez les
pilotes de ces périphériques et ces derniers seront chargés lors des
amorçages de votre système.

<p>
Il n'est pas nécessaire de tout configurer à cette étape; ce qui est
crucial est d'avoir configuré les périphériques requis pour
l'installation d'un système de base.

<p>
Une fois le système installé, vous pouvez reconfigurer les modules à
+tout moment grâce au programme <prgn>modconf</prgn>.

<sect1> Configuration du réseau

<p>
Vous aurez à configurer le réseau même si vous n'en avez pas. Dans ce
cas, vous n'aurez qu'à répondre aux deux premières questions -
<em>Choose the hostname</em> (Choisir le nom de domaine) et <em>Is
your systeme connected to a network ?</em> (Est-ce que votre système
est connecté à un réseau?).

<p>
Si vous êtes connecté à un réseau, les informations de la partie 4.2.1
vous seront nécessaires. Si votre connexion principale au réseau
utilise <prgn>ppp</prgn>, il ne vous faut PAS configurer le réseau
ici.

<p>
<prgn>dbootstrap</prgn> va vous poser un certain nombre de questions
au sujet de votre réseau. Vous les obtiendrez à partir du paragraphe
4.2.1. Le système va au final faire un résumé des informations réseau
et vous demander une confirmation. Ensuite, vous devrez spécifier le
périphérique réseau que votre connexion réseau principale
utilise. Généralement, il s'agit de <prgn>eth0</prgn> (le premier
périphérique Ethernet). Sur un ordinateur portable, on rencontre plus
souvent comme périphérique réseau principal une interface
<prgn>pcmcia</prgn>.

<p>
Voici quelques détails techniques pratiques: le programme s'assure que
l'adresse réseau IP est bien la résultante d'un <prgn>AND</prgn> de
votre adresse IP et de celle de votre masque réseau. Il s'assure aussi
que votre adresse de réseau de diffusion est bien la résultante d'un
<prgn>OR</prgn> de votre adresse IP avec l'inverse des bits de
l'adresse du masque réseau. Il s'assure aussi que votre passerelle de
routage est identique à votre serveur DNS. Vous pouvez les changer une
fois le système installé, si nécessaire, en éditant le fichier
<em>/etc/init.d/network</em> (sur un système Debian, les
<em>daemons</em> sont lancés par scripts dans le répertoire
<em>/etc/init.d</em>).
</sect1>
</sect>

<sect> Installation du système de base.

<p>
Lors la phase <em>Install the Base System</em> (Installation du
système de base), on vous proposera une liste de périphériques à
partir desquels installer votre système de base. Vous devrez
sélectionner ici le périphérique cédérom.

<p>
Il apparaîtra alors un champ pour spécifier le chemin vers le fichier
<em>base2_1.tgz</em>. Si vous avez une version officielle du support
Debian, la valeur par défaut devrait être correcte. Sinon, entrez le
chemin où le système de base peut être trouvé, relativement au point
de montage du support. Comme lors de l'étape <em>Install Operating
System Kernel and Modules</em>, vous pouvez soit laisser
<prgn>dbootstrap</prgn> trouver seul le fichier ou taper le chemin
dans le champ.

<sect1> Configuration du système de base

<p>
À ce moment, vous avez chargé tous les fichiers qui font un système
Debian minimal mais vous devez faire quelques ajustements de
configuration avant que le système ne se lance.

<p>
On vous demandera de sélectionner la zone horaire (<em>time
zone</em>). Il y a de nombreuses façons de spécifier votre zone
horaire; nous vous suggérons d'aller dans le tableau
<em>Directories</em> et de sélectionner votre pays (ou
continent). Cela change les zones horaires disponibles donc allez-y et
sélectionnez votre localité (c'est-à-dire, pays, province, état ou
ville) dans le tableau <em>Timezones</em>.

<p>
Ensuite, on vous demandera si votre horloge système est réglée sur
l'heure GMT ou sur une heure locale. Sélectionnez GMT (c'est-à-dire,
répondez <em>Yes</em>) si vous ne désirez faire tourner que Linux sur
votre ordinateur; sélectionnez l'heure local (<em>local time</em>)
(c'est-à-dire, <em>No</em>) si vous utilisez un système autre que
Debian. Les systèmes Unix en général (et Linux en particulier)
utilisent l'heure GMT comme horloge système en interne et la convertissent
en heure locale pour les utilisateurs. Cela permet de garder des
traces des sauvegardes journalières au fil des ans et autorise aussi
un utilisateur à se loguer à partir d'une autre zone horaire pour
utiliser individuellement son heure locale sur son terminal.
</sect1>

<sect1> Faire que Linux soit bootable directement à partir du disque dur

<p>
Si vous choisissez de booter directement sur Linux à partir du disque
dur, on vous demandera d'installer un secteur d'enregistrement
principal (<em>master boot record</em> ou encore <em>MBR</em>). Si
vous utilisez un gestionnaire d'amorce (<em>boot manager</em>) (et c'est
probablement le cas si vous ne savez pas ce que c'est) et que vous
n'avez pas d'autres systèmes d'exploitation sur votre machine,
répondez <em>Yes</em> à cette question<footnote>Make Linux Bootable
Directly from the Hard Disk</footnote>. Remarquez bien que dans ce
cas, il ne vous sera plus possible de booter le DOS normalement sur
votre machine par exemple. Faîtes donc bien attention.  Si vous
répondez <em>Yes</em>, la question suivante concernera l'endroit
chercher Linux pour booter au démarrage. Cela doit se régler dans la
<em>partition bootable</em> - celle qui doit être chargée à partir du
disque dur.

<p>
Remarquez bien que booter différents systèmes d'exploitation sur une
seule machine relève un peu de la cuisine. Ce livre ne documente pas
l'ensemble des nombreux gestionnaires d'amorçage, qui varient beaucoup
selon l'architecture et même selon les sous architectures. Vous devrez
lire la documentation de votre gestionnaire d'amorçage pour avoir plus
d'informations. Dans tous les cas, gardez bien à l'esprit qu'en
travaillant sur les gestionnaires d'amorçage, il ne faut jamais être
trop prudent...

<p>
Le gestionnaire d'amorçage standard pour les architectures i386 est
appelé <prgn>LILO</prgn>. C'est un programme complexe qui offre plein
de fonctionnalités, avec entre autre, un support du lancement de DOS,
NT et OS/2. Pour obtenir plus d'informations à ce sujet, vous pouvez
lire la documentation dans <em>/usr/doc/lilo</em> après que votre
système ait été configuré.
</sect1>
</sect>

<sect> Fabriquer une disquette de boot

<p>
Vous devrez faire une disquette de boot (<em>Boot floppy</em>) même si
vous avez prévu de booter directement à partir du disque. La raison
est qu'il est toujours possible d'avoir un défaut d'installation à
partir de <prgn>dbootstrap</prgn> mais jamais à partir d'une
disquette. Sélectionnez <em>Make a Boot Floppy</em> (Fabriquer une
disquette de boot) à partir du menu principal et insérer une disquette
vierge directement. Assurez-vous que la disquette n'est pas protégée
en écriture car le logiciel va la formater et écrire dessus. Écrivez
dessus <em>Boot personnalisé</em> et protégez la en écriture une fois
qu'elle a été fabriquée.
</sect>

<sect> Le moment de vérité

<p>
Le premier boot de votre système de son propre chef est ce que les
ingénieurs en électronique appellent le <em>test de la fumée</em>. Si
vous avez une disquette dans son lecteur, retirez-la. Puis
sélectionnez le menu <em>Reboot the system</em> (Rebooter le système).

<p>
Si vous bootez directement sur Debian et que le système ne se lance
pas, utilisez soit votre support original d'installation (par exemple,
les disquettes de secours), soit votre disquette de boot personnalisé
si vous en avez créé une, et relancez votre système. Si vous
n'utilisez pas la disquette de boot personnalisé, il vous sera
probablement nécessaire d'ajouter des arguments lors du boot. Si vous
bootez via la disquette de secours ou tout autre support similaire,
il vous sera nécessaire de spécifier <prgn>rescue root=rootfs</prgn>
où <prgn>rootfs</prgn> est votre partition racine, comme
<em>/dev/hda1</em>.

<p>
Debian devrait alors booter, et vous devriez voir les mêmes messages
que lorsque vous avez booté la première fois le système, avec ensuite
quelques nouveaux messages.
</sect>

<sect> Ajouter un mot de passe root

<p>
Le compte root est aussi appelé le compte <em>super-utilisateur</em>;
c'est un utilisateur qui permet d'outrepasser tous les systèmes de
protection sur votre système. Le compte root ne devrait être utilisé
que pour des tâches d'administration et pour une durée aussi courte que
possible.

<p>
Chaque mot de passe créé devrait contenir six à huit caractères,
mélangeant minuscules et majuscules ainsi que des caractères de
ponctuation. Faîtes très attention en choisissant le mot de passe de
root car ce compte est vraiment très sensible. Évitez tous mots
contenus dans un dictionnaire ou bien tout renseignement personnel qui
peut être deviné.

<p>
Si quelqu'un vous demande un jour le mot de passe de root, soyez très
prudent. Vous ne devriez jamais avoir à le donner, à moins de
ne pas être le seul à administrer la machine.
</sect>

<sect> Créer un compte utilisateur ordinaire

<p>
Le système va alors vous demander de créer un compte utilisateur
ordinaire (<em>Create an Ordinary User</em>). Ce compte pourrait être
votre compte principal personnel. Vous ne <em>devez pas utiliser</em>
le compte root pour une utilisation ordinaire quotidienne ou comme
compte personnel.

<p>
Pourquoi donc ? Il est beaucoup plus difficile d'endommager le système
en étant un simple utilisateur qu'en root ; le système de fichiers est
bien protégé. Une autre raison est que vous pouvez à votre insu faire
tourner un <em>troyen</em><footnote>programme planqué sous un autre
pour ouvrir des brèches de sécurité dans votre système </footnote> -
c'est-à-dire un programme qui pourra utiliser les avantages du
super-utilisateur pour compromettre la sécurité du système dans votre
dos... Tout bon livre d'administration Unix traite ce sujet en
détail. Il est nécessaire d'en lire un si ce sujet est nouveau pour
vous.

<p>
Nommez le compte utilisateur à votre convenance. Si votre nom est John
Smith, vous pouvez utiliser « smith », « john », « jsmith » ou « js ».
</sect>


<sect> Support des mots de passe cachés.

<p>
Ensuite, on vous demandera si vous voulez activer les mots de passe
cachés (<em>shadow Password</em><footnote>terme tellement usité qu'il
vaut mieux le connaître...</footnote>). C'est un système
d'authentification qui sécurise un peu plus votre système Linux. Nous
vous recommandons ainsi de l'activer. La reconfiguration du <em>shadow
password</em> peut être faite ultérieurement avec le programme
<prgn>shadowconfig</prgn>.
</sect>

<sect> Retirer le support PCMCIA

<p>
Si vous n'utilisez pas d'interface PCMCIA, vous pouvez choisir de la
retirer maintenant. Cela permettra de faire un démarrage plus propre;
cela permet de remplacer votre noyau plus facilement (l'interface
PCMCIA requiert un grand nombre de dépendances entre les pilotes
PCMCIA, les modules du noyau et le noyau proprement dit). De façon
général, vous n'avez pas besoin du support PCMCIA si vous n'utilisez
pas de portable...
</sect>

<sect> Sélection et installation de <em>profil</em>

<p>
Le système va maintenant vous demander si vous désirez utiliser les
configurations prédéterminées offertes par Debian. Il est toujours
possible d'installer paquet par paquet ce que l'on veut installer sur
une nouvelle machine. C'est la tâche de <prgn>dselect</prgn> dont la
description se trouve plus loin. Mais cela peut être une longue tâche
avec les milliers de paquets disponibles dans Debian !

<p>
Ainsi, vous avez la possibilité de choisir à la place des
<em>tâches</em> ou des <em>profils</em>. Une <em>tâche</em> est la
finalité du travail que vous allez effectuer avec la machine, comme la
programmation en PERL, le traitement HTML ou bien la mise en page de
document en chinois. Vous pouvez choisir de nombreuses
<em>tâches</em>. Un <em>profil</em> est une catégorie de machines,
comme serveur de réseau ou station de travail personnelle. À la
différence des tâches, vous ne pouvez choisir qu'un profil à la fois.

<p>
Pour résumé, si vous êtes pressé, choisissez un profil. Si vous avez
plus de temps, choisissez le profil personnalisé (<em>Custom
Profile</em>) et sélectionnez un ensemble de tâches. Si vous avez
beaucoup de temps et que vous désirez être minutieux avec le contrôle
de ce qui sera ou non installé, sortez de cette étape et lancez-vous
dans la toute puissance de <prgn>dselect</prgn>.

<p>
Ensuite, vous allez entrer dans <prgn>dselect</prgn>.  Si vous avez
sélectionné des tâches ou des profils, n'oubliez pas de sauter
l'étape <em>Select</em> (Sélectionner) de <prgn>dselect</prgn> car les
sélections ont déjà été effectuées.

<p>
Un petit avertissement en ce qui concerne la taille des tâches telle
qu'elles sont présentées: la taille présentée pour chaque tâche est la
somme des tailles de ses paquets. Si vous choisissez deux tâches qui
se partagent certains paquets, le véritable espace disque requis sera
inférieur à la somme des tailles de deux tâches.

<p>
Une fois que vous avez ajouté tous les <em>logins</em> (root et
personnel(s)), vous vous retrouvez dans le programme
<prgn>dselect</prgn>. <prgn>dselect</prgn> vous permet de sélectionner
les paquets à installer sur votre système. Si vous avez un cédérom ou
un disque dur contenant les paquets additionnels de Debian que vous
désirez installer sur votre système, ou bien si vous êtes connecté à
Internet, cela vous facilitera la vie. Sinon, vous pouvez quitter
<prgn>dselect</prgn> et le relancer plus tard après avoir ramener les
paquets Debian sur votre système. Vous devez être super-utilisateur
(root) quand vous voulez vous servir de <prgn>dselect</prgn>. Pour en
savoir plus <prgn>dselect</prgn>, voir section suivante.
</sect>

<sect> Installation de paquets avec <prgn>dselect</prgn>

<p>
Il est maintenant temps d'installer les paquets de logiciels de votre
choix sur votre système Debian. Ceci est effectué via l'outil de
gestion des paquets de Debian, <prgn>dselect</prgn>.

<sect1> Introduction

<p>
Cette partie documente <prgn>dselect</prgn> pour les utilisateurs
débutants. Elle n'a pas pour but de tout expliquer alors n'hésitez pas
à vous servir des écrans d'aide pour en savoir plus.

<p>
<prgn>dselect</prgn> est utilisé pour sélectionner quel paquet vous
désirez installer (il y a à l'heure actuelle près de 2250 paquets dans
la Debian 2.1). Cela serait fait pour vous durant
l'installation. C'est un outil très puissant et quelque fois un peu
complexe. Ainsi, posséder quelques connaissances sur lui avant de
l'utiliser est fortement recommandé. Une utilisation incongrue de
<prgn>dselect</prgn> peut gravement endommager votre système.

<p>
<prgn>dselect</prgn> va vous accompagner durant le processus
d'installation décrit ci-après:

<list>
<item> Choix de la méthode d'accès à utiliser
<item> Mise à jour de la liste des paquets disponibles, si possible
<item> Sélection des paquets que vous voulez sur votre système
<item> Installation et mis à jour des paquets désirés
<item> Configuration des paquets non configurés
<item> Enlèvement des paquets non désirés
</list>


<p>
À chaque fois qu'une étape est achevée avec succès,
<prgn>dselect</prgn> vous emmène automatiquement à la
suivante. Effectuez chaque étape dans l'ordre sans en omettre une.

<p>
Nous parlons ici et là dans ce document de lancer un autre
<em>shell</em>. Linux a six sessions de contrôle ou shell disponibles
en même temps. Vous pouvez circuler entre eux en pressant la
combinaison <em>Alt-F1</em> jusqu'à <em>Alt-F6</em>. Il vous suffit
alors de vous loguer dans un nouveau shell. La console utilisée lors
de l'installation est la première, c'est-à-dire <prgn>tty1</prgn>
alors presser <em>Alt-F1</em> si vous désirez y retourner.
</sect1>

<sect1> Une fois que <prgn>dselect</prgn> est lancé

<p>
Une fois dans <prgn>dselect</prgn>, vous devriez avoir l'écran suivant:

<p>
<example>
Debian Linux 'dselect' package handling frontend.
0. [A]ccess Choose the access method to use.
1. [U]pdate Update list of available packages, if possible.
2. [S]elect Request which packages you want on your system.
3. [I]nstall Install and upgrade wanted packages.
4. [C]onfig Configure any packages that are unconfigured
5. [R]emove Remove unwanted software
6. [Q]uit Quit dselect
</example>


<p>
Détaillons un peu ces six étapes:

<p>
<em>Access</em> (Accès)

<p>
<example>
COPIE D'ÉCRAN DE dselect
</example>

<p>
L'écran d'accès est visible sur la figure 5.2.

<p>
C'est le lieu où l'on dit à <prgn>dselect</prgn> où sont les
paquets. Ignorez l'ordre d'apparition à l'intérieur du menu. Il est
très important de sélectionner la bonne méthode pour
l'installation. Il se peut que vous les ayez dans un ordre différent,
ou bien que vous en ayez plus ou moins ; ne vous inquiétez pas. Dans
la suite, on décrit les différentes méthodes.

<p>
<list>
<item>multi_cd
<p>
Grande et puissante, cette méthode complexe est celle recommandée pour
installer une version récente de Debian à partir d'un jeu de cédéroms
de binaires. Chacun de ces cédéroms devraient contenir des
informations sur ses paquets ainsi que sur les paquets des cédéroms
précédents (dans le fichier <em>Package.cd</em>). Lorsque vous utilisez
cette méthode pour la première fois, assurez-vous que le cédérom n'est
pas monté. Placez ensuite le <em>dernier cédérom de binaires</em> du
jeu (les sources ne sont pas nécessaires) dans le lecteur et répondez
aux questions qui vous sont posés:

<example>
CD-ROM drive location<footnote>emplacement du lecteur de CD-ROM</footnote>
Confirmation that your are using a multi-cd set<footnote>Confirmation de l'utilisation de l'option multi-cd</footnote>
The location of the Debian distribution on the disk(s)<footnote>Emplacement de la distribution Debian sur le(s) disque(s)</footnote>
[ possibly ] the location(s) of the Packages file(s)<footnote>[ peut-être ] l'(es) emplacement(s) des paquets</footnote>.
</example>

<p>
Une fois que vous avez mis à jour la liste des paquets disponibles et
que vous avez sélectionné les paquets à installer, la méthode
<em>multi_cd</em> diverge d'une procédure normale. Il vous sera
demandé de lancer une installation pour chaque cédérom que vous
possédez, tour à tour. Malheureusement, en raison d'une limitation de
<prgn>dselect</prgn>, il n'est pas possible de changer de cédérom à
chaque étape ; la façon dont se déroule le travail pour chaque cédérom
est le suivant:

<p>
<list>
<item> Insérez le cédérom dans votre lecteur.
<item> Sélectionnez <em>Install</em> à partir du menu principal de
<prgn>dselect</prgn>.
<item> Attendez jusqu'à ce que <prgn>dpkg</prgn> en ait fini avec
l'installation à partir du cédérom. (Cela peut indiquer une
installation effectuée avec succès, ou de possibles erreurs. Ne vous
en occupez pas pour le moment).
<item> Appuyez sur <em>Entrée</em> pour retourner à l'écran principal
du menu <prgn>dselect</prgn>.
<item> Répétez le tout avec le cédérom suivant.
</list>

<p>
Il se peut qu'il soit nécessaire d'effectuer l'étape d'installation
plus d'une fois pour respecter l'ordre d'installation des
paquets. Certains paquets installés auparavant peuvent demander
l'installation d'autres paquets pour se configurer proprement.

<p>
Lancer une étape de <em>Configure</em> est recommandée pour aider à
débloquer les paquets qui le seraient à cette étape.

<item>multi_nfs, multi_mount

<p>
Ceci est proche de la méthode de <em>multi_cd</em>: elles apportent
quelques raffinements supplémentaires sur le thème de la copie en
changeant de support - par exemple, installation à partir de multi_cd
exporté via NFS sur le lecteur de cédérom d'une autre machine.

<item>apt

<p>
Une des meilleures options pour installer à partir d'un miroir local
des archives Debian ou à partir du réseau. Cette méthode utilise le
système <prgn>apt</prgn> pour effectuer l'analyse complète des
dépendances et de l'ordre. Il est donc recommandé d'installer les
paquets dans le meilleur des ordres possibles.

<p>
La configuration de cette méthode est traitée plus loin. Vous pouvez
choisir autant de sources différentes d'emplacements de paquets, en
les mélangeant avec des fichiers: <em>URLs</em> (pour les disques
locaux ou les disques montés par NFS) et <em>http:</em> ou
<em>ftp</em> pour les accès sur Internet. Attention, les options
<em>http</em> et <em>ftp</em> ne supportent pas l'authentification
locale via un proxy.

<p>
Si vous avez un serveur de proxy soit pour le http soit pour le ftp
(ou pour les deux), assurez-vous que les variables d'environnement
<prgn>http_proxy</prgn> et <prgn>ftp_proxy</prgn> soient bien
positionnés. Positionnez-les à partir du shell avant de lancer
<prgn>dselect</prgn> en utilisant les commandes suivantes:

<p>
<example>
# export http_proxy=http://gateway:3128/
# dselect
</example>
</list>

<p>
<em>Update</em> (mise à jour)

<p>
<prgn>dselect</prgn> va lire les fichiers <em>Packages</em> ou
<em>Packages.gz</em> à partir du miroir et créer une base de données
sur votre système de tous les fichiers disponibles. Cela peut prendre
un peu de temps, tant pour le téléchargement que pour l'exécution du
traitement.

<p>
<em>Select</em> (Sélection)

<p>
Asseyez-vous sur votre chapeau: c'est ici que tout se passe. Le but de
l'exercice est de sélectionner seulement le paquet que l'on désire
installer.

<p>
Appuyez sur <em>Entrée</em>. Si vous avez une machine lente, faîtes
très attention car l'écran va s'effacer et peut rester vierge pendant
environ 15 secondes. Alors, n'essayez pas de taper sur des touches
pendant ce temps-là.

<p>
La première chose qui apparaît à l'écran est la première page de
l'aide. Vous pouvez obtenir l'aide à tout moment dans l'écrans
<em>Select</em> en tapant sur « ? ». Vous pouvez dérouler l'aide par
l'intermédiaire du «.».

<p>
Avant de plonger plus en avant, notons bien ceci:

<list>

<item> Pour sortir de l'écran de sélection (<em>Select</em>) après
avoir tout sélectionné, il suffit de presser sur <em>Entrée</em>. Cela
retourne à l'écran principal s'il n'y a pas de problème de
sélection. Sinon, on vous demandera de régler le problème. Lorsque
vous êtes content avec tous les écrans proposés, appuyez sur
<em>Entrée</em> pour sortir.
<item> Les problèmes sont quelque chose de normal et sont même
attendus. Si vous sélectionnez un paquet A qui demande un paquet B
pour fonctionner, <prgn>dselect</prgn> vous avertira du problème et
tentera de vous proposer la meilleure des solutions. Si le paquet A
est en conflit avec le paquet B (c'est-à-dire qu'ils sont mutuellement
exclusifs), on vous demandera de trancher et d'en choisir un.
</list>

<p>
Regardez les deux premières lignes de l'écran de
<prgn>dselect</prgn>. Cette en-tête est un rappel de certains
raccourcis claviers dressés dans le tableau suivant:

<p>
<example>
 ------------------------------------------------------
| Touches |             Description                    |
 ------------------------------------------------------
|  +      | Sélectionne le paquet à installer          |
|  =      | Laisse le paquet en suspend                |
|  -      | Retire le paquet                           |
|  _      | Retire le paquet, ainsi que ses fichiers   |
|         | de configuration                           |
| i, I    | Affichage cyclique des informations        |
| o, O    | Affichage cyclique des options de tri      |
| v, V    | Passage en mode verbeux/sobre              |
 ------------------------------------------------------
</example>

<p>
Le tableau suivant affiche les états que <prgn>dselect</prgn> utilise
pour marquer l'état de chaque paquet et son comportement.

<p>
<example>
 -----------------------------------------------------------
|  Drapeau       |         État        | Valeurs possibles  |
|-----------------------------------------------------------
|     E          |        Erreur       |  Espace, R, I      |
|     I          | État d'installation |  Espace, *,-,U,C,I |
|     O          |   Marqueur désuet   |  *, -, =, _, n     |
|     M          |      Marqueur       |  *, -, =, _, n     |
 -----------------------------------------------------------
</example>

<p>
Plutôt que de tout décrire ici, je vous renvoie aux écrans d'aide qui
sont bien expliqués. Un exemple quand même:

<p>
Vous entrez dans <prgn>dselect</prgn> et trouver une ligne du genre:

<p>
<example>
EIOM  Pri  Section   Package    Description
**    Opt  misc      loadlin    a loader (running under DOS) for LINUX
</example>

<p>
Ceci dit que <prgn>loadlin</prgn> a été sélectionné lorsque vous avez
lancé <prgn>dselect</prgn> la dernière fois, et qu'il est toujours
sélectionné mais non installé. Pourquoi donc ? Sûrement parce que le
paquet <prgn>loadlin</prgn> n'est pas disponible physiquement. Il doit
être absent de votre miroir.

<p>
L'information que <prgn>dselect</prgn> utilise pour obtenir tous les
bons paquets installés se cache à l'intérieur des paquets
eux-mêmes. Rien en ce bas monde n'est parfait, et il peut arriver que
les dépendances d'un paquet soient erronées, ce qui veut simplement
dire que <prgn>dselect</prgn> ne sera pas en mesure de résoudre la
situation. Une solution est possible via l'utilisateur pour redonner
le contrôle: cela prend la forme des commandes Q et X qui sont
disponibles dans l'écran de sélection.

<list>
<item> Q 
<p>
 surcharge. Force <prgn>dselect</prgn> à ignorer les dépendances et à
 faire ce que vous lui imposez. Les résultats, bien sûr, sont sous
 votre entière responsabilité.  
<item> X
<p>
 Utilisez X si vous êtes complètement perdu. Cela remet les choses
 telles qu'elles étaient auparavant et sort.
</list>

Les raccourcis de l'écran de sélection de <prgn>dselect</prgn> qui
vous aide à ne pas être  perdu sont R, U et D.

<list>
<item> R
<p>
  Détruit toutes les sélections faîtes durant ce niveau. N'affecte pas
  les sélections faîtes aux niveaux précédents.
<item> U
<p>
  Si <prgn>dselect</prgn> a proposé des changements, et que vous les
  avez modifiés, U revient aux sélections de <prgn>dselect</prgn>.
<item> R
<p>
  Enlève les sélections de <prgn>dselect</prgn> en ne laissant que les
  vôtres.
</list>

<p>
Un exemple suit. Le paquet <em>boot-floppies</em> (pas un exemple de
débutant, je sais, mais il a été choisi car il possède de nombreuses
dépendances) dépend des paquets suivants:

<example>
- libc6-pi
- slang1-picn
- sysutils
- makedev
- newt0.25
- newt0.25-dev
- popt
- zlibig
- zlibig-dev
- recode
</example>

<p>
Le développeur maintenant le paquet <em>boot-floppies</em> pense que les
paquets suivants devraient aussi être installés. Ils ne sont pas, en
tout cas, indispensables:

<example>
- lynx
- debiandoc-sgml
- unzip
</example>

<p>
Lorsque vous sélectionnez <em>boot-floppies</em>, <prgn>dselect</prgn>
vous envoie dans l'écran de résolution des conflits. Vous remarquerez
que les paquets requis ont été sélectionnés.

<p>
Pressez alors sur la touche R pour remettre les choses à leur point de
départ.

<example>
EIOM Pri  Section   Package      Description
  __ Opt  admin     boot-floppie Scripts to create the Debian
  __ Opt  devel     newt0.25-dev Developer's toolkit for newt
  __ Opt  devel     slang1-dev   The S-Lang programming library
  __ Opt  devel     slang1-pic   The S-Lang programming library
</example>

<p>
Si vous décidez maintenant que vous ne voulez plus du paquet
<em>boot-floppies</em>, appuyez simplement sur <em>Entrée</em>.

<p>
Pressez alors sur la touche D remet les choses à la même place que
lorsque vous les aviez sélectionnés la première fois:

<example>
EIOM Pri  Section   Package      Description
  _* Opt  admin     boot-floppie Scripts to create the Debian
  __ Opt  devel     newt0.25-dev Developer's toolkit for newt
  __ Opt  devel     slang1-dev   The S-Lang programming library
  __ Opt  devel     slang1-pic   The S-Lang programming library
</example>

<p>
Pressez alors sur la touche U revient les sélections initiales de
<prgn>dselect</prgn>:

<example>
EIOM Pri  Section   Package      Description
  _* Opt  admin     boot-floppie Scripts to create the Debian
  _* Opt  devel     newt0.25-dev Developer's toolkit for newt
  _* Opt  devel     slang1-dev   The S-Lang programming library
  _* Opt  devel     slang1-pic   The S-Lang programming library
</example>

<p>
Je vous suggère de laisser les paramètres par défaut pour le moment:
vous aurez amplement l'occasion de les modifier plus tard.

<p>
Quoique vous décidiez, appuyez sur la touche <em>Entrée</em> pour
valider et retourner à l'écran principal. Si l'action résultante
conduit toujours à des problèmes à résoudre, vous serez à nouveau
renvoyé à un nouvel écran de résolution de conflit.

<p>
Les touches R, U et D sont très utiles dans les situations « qu'est-ce
qui se passe si ? ». Vous pouvez expérimenter à volonté et ensuite
revenir à la situation initiale. <em>Ne les regardez pas</em> comme
une vitrine où il y aurait marqué « à ne briser qu'en cas de danger ».

<p>
Après avoir fait vos sélections dans l'écran de sélection, appuyez sur
I pour obtenir une grande fenêtre, appuyez sur t pour aller au début
et utilisez les touches <em>Page Up</em> et <em>Page
Down</em><footnote>Écran haut et bas sur les claviers français: ce
sont les touches de droite du pavé situé au-dessus des flèches de
déplacement.</footnote> pour vous déplacer rapidement parmi les
sélections. Vous pouvez ainsi vérifier le résultat de votre travail et
détecter d'éventuelles erreurs. Certaines personnes ont
déselectionné des groupes entiers de paquets par erreur et ne s'en
sont rendu compte que trop tard. <prgn>dselect</prgn> est un outil
très puissant: ne le sous-utilisez pas...

<p>
Vous devriez avoir la situation suivante:

<example>
 -----------------------------------------------------
|  Package category    |          Status              |
 -----------------------------------------------------
|    Recquired         |       all selected           |
|    Important         |       all selected           |
|    Standard          |      mostly selected         |
|    Optional          |     mostly deselected        |
|       Extra          |     mostly deselected        |
 -----------------------------------------------------
</example>

<p>
Heureux ? Appuyez sur la touche <em>Entrée</em> pour sortir du
processus de sélection. Vous pouvez y revenir et à nouveau
sélectionnez si vous le désirez.

<p>
<em>Install</em> (Installation)

<p>
<prgn>dselect</prgn> travaille sur la totalité des paquets et installe
ceux sélectionnés. Il vous pose des questions pour appliquer vos
décisions. Il est souvent pratique de passer sur un autre shell pour
comparer une ancienne configuration avec une nouvelle. Si l'ancien
fichier est <em>conf.modules</em>, le nouveau sera
<em>conf.modules.dpkg-dist</em>.

<p>
Le défilement à l'écran se passe parfois très rapidement sur les
machines puissantes. Vous pouvez toujours le stopper et le redémarrer
à l'aide des combinaisons respectives de touches <em>Ctrl-s</em> et
<em>Ctrl-q</em>. À la fin de la tâche, vous aurez une liste des
paquets non installés.

<p>
Il peut arriver qu'un paquet ne soit pas installé car il dépend d'un
autre qui est décrit comme à installer mais qui ne l'est pas
encore. La solution consiste à relancer <em>Install</em> une nouvelle
fois. Il a été reporté des cas où il a été nécessaire de le relancer
quatre fois avant que tout ne se mette en place correctement. Cela
varie beaucoup suivant votre méthode d'acquisition.

<p>
<em>Configure</em> (Configuration)

<p>
La plupart des paquets sont configurés à l'étape précédente mais toute
chose restée en suspens peut être achevée ici.

<p>
<em>Remove</em> (Suppression)

<p>
Suppression des paquets installés que l'on désire retirer.

<p>
<em>Quit</em> (Quitter)

<p>
Je suggère de lancer <prgn>/etc/cron.daily/find</prgn> à ce moment car
vous avez de nombreux nouveaux fichiers sur votre système. Ensuite,
vous pourrez utiliser <prgn>locate</prgn> pour obtenir l'emplacement
de n'importe quel fichier.
</sect1>

<sect1> Quelques remarques pour conclure

<p>
Lorsque le processus d'installation lance <prgn>dselect</prgn> pour
vous, vous devez être impatient de lancer Debian aussitôt que
possible. Hé bien, préparez-vous à prendre une heure - ou plus - pour
apprendre à vous en servir et à l'utiliser judicieusement. Lorsque
vous entrez pour la première fois dans l'écran de sélection, n'en
faîtes <em>aucune</em> - appuyez simplement sur la touche
<em>Entrée</em> - et observez les problèmes de dépendances. Essayez de
les résoudre. Si vous vous retrouvez une nouvelle fois dans l'écran
principal, lancer <em>Select</em> une nouvelle fois.

<p>
Vous pouvez vous faire une idée de la taille d'un paquet en appuyant
deux fois sur i et en regardant le champ <em>Size</em> (Taille). Ceci
est la taille du paquet avec compression donc la décompression du
paquet risque d'être nettement plus importante (voir le champ
<em>Installed-Size</em> (Taille après installation) qui est en
kilo-octets, pour la déterminer).

<p>
Installer un nouveau système Debian est une chose complexe mais
<prgn>dselect</prgn> peut vous aidez à rendre la chose la plus aisée
possible. Prenez donc bien le temps d'apprendre à vous en servir. Lisez
les écrans d'aide et expérimentez les touches i, I, o et O. Utilisez
la touche R. Ce sera tout pour ici mais cela devrait être suffisant
pour vous en servir avec efficacité.
</sect1>
</sect>

<sect> Glossaire

<p>
Les termes suivants sont largement utilisés dans ce livre et de
façon générale lorsque l'on parle de Debian.

<p>
<em>Paquet</em>

<p>
C'est un fichier contenant tout le nécessaire à l'installation, à la
désinstallation et à l'utilisation d'un programme particulier. Le
logiciel qui gère les paquets est
<prgn>dpkg</prgn>. <prgn>dselect</prgn> est une interface à
<prgn>dpkg</prgn>. Les utilisateurs expérimentés utilisent souvent
<prgn>dpkg</prgn> pour installer ou retirer un paquet.

<p>
<em>Nom de paquet</em>

<p>
Tous les noms de paquets sont de la forme
<em>xxxxxxxxxxx.deb</em>. Voici un exemple de noms de paquets simples:

<example>
- efax_08a-1.deb
- lrzsz_0.12b-1.deb
- mgetty_0.99.2-6.deb
- minicom_1.75-1.deb
- term_2.3.5-5.deb
- uucp_1.06.1-2.deb
- uutraf_1.1-1.deb
- xringd_1.10-2.deb
- xtel_3.1-2.deb
</example>


</sect>

 </chapt>
<chapt> Se loguer

<p>
Votre système est maintenant installé ! Vous pouvez vous congratuler
du bon travail effectué ! Il est temps maintenant de lancer le système
pour l'utiliser. Dans ce chapitre, nous allons vous faire découvrir
les lignes de commande Debian, quelques principes de sécurité et
comment sortir du système. Dans les chapitres suivants, nous
détaillerons plus ces sujets et nous vous ferons découvrir l'interface
graphique de Debian, X11.

<sect> Les premiers pas

<p>
Après avoir quitter <prgn>dselect</prgn>, le <em>login</em> suivi du
prompteur se présentent à vous. Vous pouvez maintenant vous
loguer<footnote>J'ai délibérément francisé le terme anglais <em>to log
in</em> tellement ce terme est devenu un standard en français
</footnote> en utilisant le <em>login</em> et le mot de passe que vous
avez choisi. Votre système est maintenant prêt à être
utilisé. Examinons ce que veut dire se loguer et comment cette
procédure fonctionne.

<p>
Pour utiliser Debian, vous devez vous identifier personnellement au
système. Cela lui permettra de savoir qui vous êtes, quels sont vos
droits et quelles sont vos préférences.

<p>
Pour en arriver là, vous avez un <em>nom d'utilisateur</em> ou un
<em>login</em><footnote>Encore une fois, le terme anglais est
tellement usité qu'il vaut mieux l'apprendre et
l'utiliser</footnote>. Si vous avez installé Debian vous-même, il vous
a été demandé de fournir un tel nom durant l'installation. Si vous
vous connectez à un système administré par quelqu'un d'autre, vous
aurez à lui demander de vous fournir un compte sur le système ainsi
que son nom.

<p>
Vous avez aussi un mot de passe et ainsi personne ne peut prétendre
s'identifier à votre place. Si vous n'avez pas de mot de passe, tout
le monde peut se connecter à votre place sur votre ordinateur depuis
Internet et faire des tas de mauvaises choses. Si vous vous préoccupez
un tant soit peu de sécurité, vous devez avoir un mot de passe.

<p>
De nombreuses personnes préfèrent croire que les autres ne feront rien
de méchant sur leur compte. Il est raisonnable de croire que votre
environnement de travail n'encourage pas la paranoïa. C'est une
attitude parfaitement raisonnable. Cela dépend de vos priorités
personnelles et de votre environnement. Il est certain qu'un système
familial n'a pas les mêmes besoins en sécurité qu'une installation
militaire. Debian vous permet aussi bien d'être sécurisé
qu'insécurisé. Cela reste à votre convenance.

<p>
Lorsque vous démarrez Debian, vous apercevez un prompteur
(<em>prompt</em>): c'est l'ordinateur qui se met en attente
d'informations. Dans ce cas, le prompteur est <prgn>login:</prgn>.

<p>
Vous devez taper votre nom d'utilisateur et, lorsque l'on vous le
demande, votre mot de passe. Le mot de passe n'apparaît pas à l'écran
lors de sa frappe. Appuyez sur la touche <em>Entrée</em> après avoir
entré le nom d'utilisateur et après le mot de passe. Si vous trompez
lors de la frappe de votre nom d'utilisateur ou lors de celle du mot
de passe, vous aurez à recommencer.

<p>
Si vous effectuez l'opération correctement, vous verrez un message
rapide et ensuite un $ suivi d'un prompteur. Le $ est écrit par un
programme spécial appelé le <em>shell</em><footnote>ou
<em>interpréteur de commandes</em> en français mais le terme
<em>shell</em> est aussi utilisé que <em>log</em> ou
<em>login</em></footnote>. Il est appelé le <em>prompteur du
shell</em>. C'est l'endroit où vous envoyez les commandes au système.

<p>
Essayez d'entrer la commande <prgn>whoami</prgn> maintenant. Il y a un
<em>curseur</em> à la droite du prompteur du shell. Votre curseur est
un petit tiret ou rectangle qui indique où l'on va taper. Il doit se
déplacer au cours de la frappe. Finissez toujours une commande shell
par la touche <em>Entrée</em>.

<p>
<prgn>whoami</prgn><footnote>littéralement <em>Qui
suis-je</em></footnote> vous renvoie votre nom d'utilisateur. Vous
obtenez ensuite un nouveau prompteur de shell.

<p>
Dans le reste du livre, lorsque nous parlons d'entrer une commande,
vous aurez à la taper après le prompteur du shell puis la valider avec
la touche <em>Entrée</em>.

<p>
Lorsque vous avez fini de travailler, il se peut que vous désiriez
quitter votre système. Pour sortir du shell, entrez la commande
<prgn>exit</prgn>. Gardez bien à l'esprit que si vous restez logué,
quelqu'un peut venir et utiliser votre compte. Par chance, vous pouvez
faire confiance en vos collègues de travail ou aux personnes de chez
vous; mais si vous ne pouvez accorder votre confiance dans votre
entourage, vous devrez être certain de vous être délogué avant votre
départ.
</sect>

<sect> Historique des commandes et édition de la ligne de commande

<p>
Tout ce que vous tapez après le prompteur du shell et avant de valider
par <em>Entrée</em> est appelé une <em>ligne de commande</em>. C'est
une ligne de texte qui demande à l'ordinateur de faire quelque
chose. Le shell par défaut de Debian offre de nombreuses
fonctionnalités pour rendre plus aisée l'entrée de la ligne de
commande.

<p>
Vous pouvez revenir aux commandes précédentes pour les lancer à
nouveau ou vous pouvez les modifier avec facilité et ensuite les
relancer. Essayez ceci: entrez n'importe quelle commande, comme
<prgn>whoami</prgn>. Ensuite, appuyez sur la flèche de direction
verticale vers le haut. La commande <prgn>whoami</prgn> va
réapparaître après le prompteur. Vous pouvez alors appuyer sur
<em>Entrée</em> pour lancer une seconde fois la commande
<prgn>whoami</prgn>.

<p>
Si vous avez entré de nombreuses commandes, vous pouvez appuyer sur la
flèche plusieurs fois pour naviguer au travers des différentes
commandes. Cette fonctionnalité est très pratique si vous répétez la
même chose plusieurs fois de suite, ou si vous tapez mal une commande
et que vous la rappeliez pour la corriger. Vous pouvez aussi utiliser
la flèche verticale vers le bas pour circuler dans l'autre sens, vers
les commandes les plus récentes. Lorsqu'il n'y a plus de commande à
afficher, l'ordinateur envoie alors un signal sonore.

<p>
Vous pouvez aussi vous déplacer sur la ligne de commande pour
effectuer des transformations. La façon la plus simple est d'utiliser
les flèches de déplacements horizontaux gauche et droite. Essayez de
taper <prgn>whoami</prgn> à la place de <prgn>whoami</prgn>. Utilisez
alors la flèche de déplacement horizontal vers la gauche pour revenir
en arrière vers le s. Vous pouvez effacer le s à l'aide de la touche
<em>backspace</em><footnote>touche située au-dessus de la touche
<em>Entrée</em> et comportant une flèche horizontal en direction
arrière du défilement normal de l'écran, d'où son nom (<em>back</em>
arrière et <em>space</em> espace)</footnote> ou <em>Suppr</em>.

<p>
Il y a bien d'autres fonctionnalités avancées mais il n'est pas
nécessaire de les mémoriser maintenant. Essayez <em>Ctrl-a</em> pour
vous retrouver directement au début de la ligne de
commande. <em>Ctrl-k</em> (le k est pour <em>kill</em>, tuer en
anglais) détruira tous les caractères situés à droite jusqu'à la fin
de la ligne; essayez-la à partir du milieu d'une ligne de
commande. <em>Ctrl-y</em> renvoie la dernière chose que vous avez
détruite en l'insérant à la position courante du curseur (y est pour
<em>yank</em> en anglais). <em>Ctrl-e</em> déplace le curseur jusqu'à
la fin de la ligne de commande.

<p>
Allez de l'avant et jouez avec l'édition de la ligne de commandes pour
commencer à la maîtriser. Expérimentez.
</sect>

<sect> Travailler en tant que Root

<p>
Puisque Debian est un système multi-utilisateurs, il est nécessaire
d'en désigner un de particulier ou un programme pour être capable de
tout faire sur le système. Le noyau n'autorise pas l'utilisateur
normal à changer des fichiers importants du système. Cela signifie
que les choses restent dans l'état où elles sont, à l'abris des
accidents, des virus et même des tours de magie. À la différence de
certains autres systèmes d'exploitation, Debian est à l'abris de ce
genre de tracas. Il n'est pas nécessaire d'utiliser un programme
d'anti-virus.

<p>
Parfois, il est quand même nécessaire de changer des fichiers
importants. Par exemple, vous pouvez avoir envie d'installer un
nouveau logiciel ou bien de configurer votre connexion réseau. Pour le
faire, il vous faut des pouvoirs plus étendus que ceux d'un
utilisateur normal. Vous devez devenir l'utilisateur <em>root</em>
(parfois appelé aussi le <em>super-utilisateur</em>).

<p>
Pour devenir root, il vous suffit de vous loguer avec le nom
d'utilisateur <em>root</em> et le mot de passe de root. Ceci a été
fait durant l'installation: voir la section 5.15 pour plus de détails.

<p>
Dans de nombreux sites, seul l'administrateur système possède le mot
de passe de root et seul l'administrateur système peut faire les
tâches dévolues à root. Si vous utilisez votre propre ordinateur
personnel, <em>vous</em> êtes l'administrateur système, bien-sûr. Si
vous n'avez pas les privilèges du super-utilisateur, il vous sera
nécessaire de passer la main à votre administrateur système pour les
tâches qui requièrent les privilèges de root.

<p>
Parfois, vous aurez accès au mot de passe de root, souvent dans des
organisations ou sur des serveurs d'écoles, car l'administrateur
système vous fait confiance dans sa juste utilisation. Dans ce cas, il
vous sera possible d'aider l'administrateur et de personnaliser le
système pour vos besoins. Mais vous devrez toujours agir de façon
responsable, en respectant tout le temps les autres utilisateurs.

<p>
Si vous possédez le mot de passe de root, essayez de vous loguer en
tant que root maintenant. Entrer la commande <prgn>whoami</prgn> pour
vérifier votre identité. Et ensuite, <em>déloguez-vous
immédiatement</em>. Lorsque vous êtes root, le noyau ne vous protège
pas de vous-même car root a les permissions de tout faire sur tout le
système. N'expérimentez pas en tant que root. En fait, ne faîtes rien
sous root qui ne soit absolument nécessaire. Ce n'est pas tant un
problème de sécurité qu'un problème de stabilité. Votre système s'en
portera d'autant mieux qu'il est protégé de vos erreurs.

<p>
Il se peut que vous trouviez la commande <prgn>su</prgn> plus pratique
pour se loguer en tant que root. <prgn>su</prgn> vous permet de
prendre l'identité d'un autre utilisateur, généralement root à moins
qu'elle ne soit suivie du nom de quelqu'un d'autre (Vous pouvez
essayer de vous en souvenir en disant que <prgn>su</prgn> signifie
<em>Super User</em> bien que certains disent que c'est pour <em>Set
UserID</em> (positionne l'ID de l'utilisateur)).

<p>
Voici quelque chose à essayer. Loguez-vous en tant que simple
utilisateur, c'est-à-dire, en n'étant pas root. Après, votre session
devrait ressembler à quelque chose comme cela:

<p>
<example>
$ whoami                  Vérifie votre nom d'utilisateur
username                  Renvoie votre nom d'utilisateur
$ su                      Demande au système les droits super-utilisateurs
Password:                 Taper votre mot de passe root ici
machine:~# whoami
root                      Vous êtes maintenant root
machine:~# exit           Sort de votre shell root
$ exit                    Sort de votre shell "normal"
</example>

<p>
Lorsque vous faîtes des tâches d'administration système, vous devriez
les faire autant que possible en tant que simple utilisateur. Ensuite,
utilisez <prgn>su</prgn> pour la partie qui requiert les privilèges
de root. Pour le faire, taper <prgn>su user</prgn> où
<prgn>user</prgn> est l'utilisateur que vous voulez devenir. Vous
devrez connaître le mot de passe de l'utilisateur en question,
bien-sûr, à moins que vous ne soyez root à ce moment là ou bien que
l'utilisateur n'ait pas de mot de passe.
</sect>

<sect> Consoles virtuelles

<p>
Le noyau Linux supporte les consoles virtuelles. Ceci permet de faire
de votre simple écran et clavier un système de type terminaux
multiples connectés au même système. Heureusement, l'utilisation des
consoles virtuelles est triviale sous Debian: il y a des touches
dédiées pour aller d'une console à l'autre rapidement. Pour l'essayer,
loguez dans votre système puis pressez sur <em>Alt-F2</em> (appuyez
simultanément sur la touche <em>Alt</em> et sur <em>F2</em> qui est la
touche de fonction numéro deux).

<p>
Vous devriez vous retrouver avec une demande de login. Ne paniquez
pas. Vous êtes maintenant sur la console virtuelle (<em>VC</em> pour
<em>virtual console</em> en anglais) numéro deux ! Loguez-vous et
faîtes quelque chose - quelques commandes <prgn>whoami</prgn> ou
n'importe quoi d'autre - pour vous assurez qu'il s'agit bien d'un
nouveau shell. Maintenant vous pouvez retourner à la console numéro un
en pressant <em>Alt-F1</em>. Ou bien vous pouvez aussi aller sur la
console numéro trois avec <em>Alt-F3</em>.

<p>
Debian est fourni avec six consoles actives par défaut, qui sont
accessibles avec la combinaison de la touche <em>Alt</em> et des
touches de fonctions <em>F1</em> jusqu'à <em>F6</em>. (Techniquement,
il y a plus de six consoles actives mais seules six sont accessibles
pour vous loguer. Les autres sont réservées pour le système X Window
ou d'autres tâches.)

<p>
Si vous utilisez le système X Window, il se lance généralement sur la
première console virtuelle non utilisable - probablement la
sept. Dès-lors, pour passer de la console virtuelle sous X à une des
six autres consoles, vous devez ajouter la touche <em>Ctrl</em> à la
séquence de touches. Ainsi, il faut faire <em>Ctrl-Alt-F1</em> pour
aller à la console virtuelle numéro un. Mais vous pouvez aller d'une
console texte vers une console X en n'utilisant que la touche
<em>Alt</em>. Si vous ne quitter jamais X, vous n'avez pas à vous
inquiéter à ce sujet, X passera automatiquement sur sa console
virtuelle au démarrage.

<p>
Une fois que vous les aurez maîtrisées, les consoles virtuelles
deviendront certainement un outil indispensable pour faire plusieurs
choses en même temps (Le système X Window offre la même
fonctionnalité, au détail près qu'il s'agit de fenêtres multiples
plutôt que de consoles). Vous pouvez lancer différents programmes dans
chaque console virtuelle ou vous loguer en root dans une et en
vous-même dans une autre. Ou bien chacun dans la famille n'utilise que
sa console virtuelle. Ceci est particulièrement pratique si vous
utilisez X car dans ce cas, vous pouvez lancer plusieurs sessions X en
même temps dans différentes consoles.
</sect>

<sect> Arrêter le système

<p>
<em>N'éteignez pas simplement l'ordinateur ! Vous risquez de perdre
des données de valeurs !</em>

<p>
Si vous êtes le seul utilisateur de la machine, vous pouvez avoir
envie de l'éteindre une fois votre travail terminé.

<p>
Pour éviter de fatiguer certains composants, il est recommandé de
n'éteindre sa machine qu'une fois par jour, lorsque tout le travail
est terminé. L'allumage et l'arrêt des ordinateurs sont les deux
causes principales d'usure et de fatigue des composants internes de
l'ordinateur. Allumer et fermer votre ordinateur une fois par jour est
certainement le meilleur compromis entre votre facture d'électricité
et la durée de vie de votre machine.

<p>
C'est une mauvaise chose que d'éteindre l'ordinateur en appuyant
simplement sur le bouton d'alimentation du courant lorsque vous avez
fini de travailler. C'est aussi une mauvaise idée que de rebooter la
machine (avec le bouton <em>Reset</em>) sans avoir pris auparavant
quelques précautions. Le noyau Linux, pour augmenter ses performances,
utilise un <em>cache disque</em>. Cela signifie qu'il garde
temporairement en mémoire certaines informations stockées sur le
disque. Puisque la mémoire est des milliers de fois plus rapide qu'un
disque dur, certaines opérations sur les fichiers sont ainsi beaucoup
plus rapides. Périodiquement, ces informations en mémoire sont
retranscrites sur le disque. Cette opération est appelée
<em>syncing</em>. En vue d'éteindre ou de rebooter votre machine, il
est nécessaire de lui dire de tout nettoyer en mémoire et de le placer
sur l'unité de stockage permanent.


<p>
Pour rebooter, tapez simplement <prgn>reboot</prgn> ou appuyez sur
<em>Alt-Ctrl-Suppr</em>.

<p>
Pour éteindre l'ordinateur il vous faut vous loguer en tant que
root. Vous n'avez alors qu'à taper la commande <prgn>shutdown -h
now</prgn>. Le système va alors dérouler la procédure d'extinction, y
compris la commande <prgn>sync</prgn> qui nettoie le cache disque
comme décrit précédemment. Lorsque vous apercevez <em>System
halted</em>, il est possible d'éteindre sans danger l'ordinateur. Si
vous avez un BIOS qui supporte l'APM (<em>Advanced Power
Management</em>) et un noyau aussi, l'ordinateur peut se couper tout
seul et ainsi vous épargner des problèmes. APM est très commun pour
les ordinateurs portables et on le trouve aussi parfois dans certaines
cartes mères d'ordinateurs de bureau.

</sect>

</chapt>
<chapt> Les bases

<p>
Il est maintenant temps d'explorer le système plus en détail. Vous
avez vu comment se loguer et éteindre le système. Dans ce chapitre,
nous allons explorer la ligne de commandes sous Linux, comment Linux
gère fichiers et répertoires et quelques règles de base pour vous
identifier des autres.

<sect> La ligne de commandes et les pages de <prgn>man</prgn>

<p>
Nous avons déjà discuté de la ligne de commandes - qui sont,
rappelons-le, les commandes que vous tapez après le prompteur du
shell. Cette partie décrit la structure de lignes de commandes
beaucoup plus compliquées.

<p>
Une ligne de commandes minimale contient juste le nom d'une commande,
comme <prgn>whoami</prgn>. Mais bien d'autres choses sont
possibles. Par exemple, vous pouvez taper <prgn>man
whoami</prgn>. Cette commande appelle l'aide en ligne de la commande
<prgn>whoami</prgn> (Vous devrez vous déplacer à l'aide de la touche
<em>espace</em> page par page et taper sur <em>q</em> pour
sortir). Une commande plus compliquée est <prgn>man -k
PostScript</prgn>. Cette ligne de commandes se compose de trois
parties. Elle commence par le nom de commande
<prgn>man</prgn>. Ensuite, on trouve une <em>option</em> ou
<em>indicateur</em>, <prgn>-k</prgn>, suivi d'un <em>argument</em>,
<prgn>PostScript</prgn>. Certains disent que tout sauf le nom de la
commande est <em>paramètre</em> de la commande. Ainsi, les options et
les arguments sont tous deux des paramètres.

<p>
Les options changent le comportement d'une commande, en activant une
fonctionnalité particulière.  Généralement, on trouve un « - » les
précédant. Les utilitaires GNU ont aussi une « forme longue » pour les
options; la forme longue de <prgn>-k</prgn> est
<prgn>--apropos</prgn>. Vous pouvez entrer <prgn>man -h</prgn> ou
<prgn>man --help</prgn> pour obtenir la liste complète des options de
la commande <prgn>man</prgn>. Chaque commande a sa propre liste
d'options, bien qu'elle partage généralement les options
<prgn>--help</prgn> et <prgn>--version</prgn>. Certaines commandes,
comme <prgn>tar</prgn>, ne demande pas de « - » devant leurs options
pour des raisons historiques.

<p>
Tout ce qui n'est pas une option et qui n'est pas le nom d'une
commande est un <em>argument</em> (et dans le cas présent,
<prgn>PostScript</prgn>). Les arguments ont des tas de finalités ;
dans la plupart des cas, ce sont les noms de fichiers dont la commande
doit s'occuper.  Dans ce cas, <prgn>PostScript</prgn> est le mot que
l'on fait chercher à la commande <prgn>man</prgn>. Dans le cas de
<prgn>man whoami</prgn>, l'argument est le nom de la commande dont
vous recherchez des informations.

<p>
Voici un résumé de la ligne de commande <prgn>man -k PostScript</prgn>

<p>
<list>
<item> <prgn>man</prgn>
<p>
Le nom de la commande demande à l'ordinateur d'aller chercher les
pages du manuel. Ceci est une documentation des commandes. Par
exemple, <prgn>man whoami</prgn> ira vous chercher la documentation de
la commande <prgn>whoami</prgn>.
<item><prgn>-k</prgn>
<p>
L'option, change le comportement de la commande
<prgn>man</prgn>. Normalement, <prgn>man</prgn> s'attend à un nom de
commande, tel <prgn>whoami</prgn>, comme argument et va chercher la
documentation de cette commande. Mais avec l'option <prgn>-k</prgn> ou
<prgn>--apropos</prgn>, il s'attend à ce que l'option soit un
mot-clé. Il sort alors la liste de toutes les pages de manuel le
comportant.
<item><prgn>PostScript</prgn>
<p>
est l'argument; en raison de la présence de l'option <prgn>-k</prgn>,
c'est le mot-clé à rechercher.
</list>

<p>
Allez-y et tapez la commande <prgn>man -k PostScript</prgn> et vous
verrez apparaître une liste de pages de manuel de votre système qui
ont un rapport avec le postscript. Si vous n'avez pas installé de
nombreux logiciels, il se peut que vous voyiez apparaître à la place :
<prgn>PostScript: nothing appropriate</prgn> (<prgn>PostScript: rien
de trouvé</prgn>).
</sect>

<sect> Description de la ligne de commande

<p>
Remarque: vous pouvez sauter cette partie si vous voulez avancer
rapidement.

<p>
Il existe une façon concise et traditionnelle de décrire la
<em>syntaxe</em> d'une commande. La <em>syntaxe</em> veut dire la
façon correcte de combiner les options variées ainsi que les
arguments. Par exemple, si vous tapez <prgn>man man</prgn> pour
obtenir la page de manuel de <prgn>man</prgn>, vous apercevrez un
certain nombre de descriptions de syntaxe débutant par le nom de
commande <prgn>man</prgn>. Une d'entre elle devrait ressembler à ceci:

<p>
<prgn>man -k [-M path] keyword ...</prgn>

<p>
Tout ce qui se trouve entre crochet ([ ]) est optionnel. Dans ce cas,
il n'est pas nécessaire d'utiliser l'option <prgn>-M</prgn> mais si
vous le faîtes, il est alors nécessaire d'utiliser un argument de type
<prgn>path</prgn><footnote>C'est-à-dire le chemin d'accès en bon
français.</footnote>. Vous devez utiliser l'option <prgn>-k</prgn> et
l'argument <prgn>keyword</prgn> (mot-clé). Les <prgn>...</prgn>
signifient qu'il peut y avoir encore beaucoup de choses à la suite,
notamment plusieurs mots clés.

<p>
Regardons d'un peu plus près les descriptions complexes de la page de
manuel de <prgn>man</prgn>:

<example>
man [-c|-w|-tZT device] [-adhu7V]
[-m system[,...]] [-L locale] [-p string]
[-M path] [=P pager] [-r prompt] [-S list]
[-e extension] [[section] page ...] ...
</example>

<p>
Il n'est pas nécessaire d'aller plus en avant (et ne vous inquiétez
pas quant à sa signification), mais attirez votre attention sur
l'organisation de la description.

<p>
Premièrement, ce rassemblement en grappe d'options veut généralement
dire que vous pouvez en utiliser une ou plusieurs dans différentes
combinaisons. Ainsi, <prgn>-adhu7V</prgn> veut tout simplement dire
que vous pouvez aussi n'utiliser que <prgn>-h</prgn>. Bien sûr, vous
pouvez utiliser toutes les combinaisons. Cette description ne rend pas
forcément les choses très claires. Par exemple, <prgn>-h</prgn> est
incompatible avec les autres options mais vous pouvez faire <prgn>man
-du</prgn>. Malheureusement, cette description de format ne rend pas
cette approche très claire.

<p>
Ensuite, le symbole | signifie « ou ». Ainsi, vous pouvez utiliser
l'option <prgn>-c</prgn>, l'option <prgn>-w</prgn> <em>ou</em>
l'option <prgn>-tZT</prgn>, suivi d'un argument <prgn>device</prgn>.

<p>
Enfin, remarquez bien que vous devez respecter les crochets car ils
indiquent les unités optionnelles. Ainsi, si vous avez une
<prgn>section</prgn>, vous devez aussi avoir une <prgn>page</prgn>
parce que <prgn>page</prgn> n'est pas optionnelle à l'intérieur du
groupe <prgn>[[section] page]</prgn>.

<p>
Il n'est pas nécessaire de mémoriser tout cela. Il suffit juste de
revenir à cette partie pour lire la documentation.
</sect>

<sect> Fichiers et répertoires

<p>
Les <em>fichiers</em> sont une facilité pour stocker et organiser
l'information, analogue aux documents papier. Ils sont organisés en
<em>répertoires</em> qui sont appelés <em>dossiers</em> sur certains
autres systèmes. Regardons d'un peu plus près l'organisation des
fichiers sur un système Debian:

<p>
<list>
<item> /
<p>
Un simple / représente la répertoire racine. Tous les autres fichiers
et répertoires sont contenus dans le répertoire racine. Si vous venez
du monde DOS ou Windows, / est similaire à ce que le C: signifie pour
le DOS qui est la racine du système de fichiers. Une différence
importante entre DOS et Linux est que DOS garde toujours C: (pour le
premier disque dur), A: (premier lecteur de disquettes) et D: (soit le
lecteur de cédérom soit le second disque dur) alors que Linux organise
tous ses fichiers autour de la même racine /.  <item>
<prgn>/home/janeq</prgn>
<p>
C'est le répertoire personnel de l'utilisateur <em>janeq</em>. En
lisant de gauche à droite, pour aller dans ce répertoire, on commence
dans le répertoire racine, puis dans le répertoire <prgn>home</prgn>
et enfin dans celui de <prgn>janeq</prgn>.
<item> <prgn>/etc/X11/XF86Config</prgn>
<p>
C'est le fichier de configuration du système X Window. Il réside dans
le sous-répertoire <prgn>X11</prgn> du répertoire
<prgn>/etc</prgn>. <prgn>/etc</prgn> est lui-même un sous-répertoire du
répertoire racine /.
</list>

<p>
<em>Choses importantes à retenir</em>

<p>
<list>
<item>
  Les noms de fichiers sont sensibles à la casse utilisée. Cela veut
  dire que MONFICHIER et MonFichier sont différents.
<item>
  Le répertoire racine (<em>root</em> en anglais) se réfère uniquement
  à /. Ne confondez pas avec le root de l'utilisateur root,
  l'utilisateur du système avec les « supers pouvoirs ».  <item>Chaque
  répertoire a un nom, qui peut contenir n'importe quels lettres ou
  symboles <em> à l'exception de </em> /. Le répertoire racine est une
  exception; son nom est / (prononcé «&nbsp;slash&nbsp;» ou
  «&nbsp;répertoire racine&nbsp;» ou «&nbsp;répertoire root&nbsp;») et
  il ne peut être renommé.
<item>
  Bien que vous puissiez utiliser n'importe quels lettres ou symboles
  pour un nom de fichier, en pratique c'est une assez mauvaise
  idée. Il est souhaîtable d'éviter les caractères qui ont souvent une
  signification particulière dans les lignes de commandes comme
  <prgn>{ } ( ) [ ] ' ` " \ / > < | ; ! # & ^ * %</prgn>
<item>
  Évitez d'ajouter des espaces dans les noms de fichiers. Si vous
  désirez séparer les mots dans un nom, les meilleurs choix   sont
  la période, l'hyphénation ou le tiret souligné « _ ». Vous pouvez
  aussi mettre en majuscule le début de chaque mot comme
  dans <prgn>CommeCeci</prgn>.
<item>
  Chaque fichier et répertoire sont désignés par un <em>nom de fichier
  pleinement qualifié</em>, un <em>nom de fichier absolu</em> ou un
  <em>chemin</em> qui donne la séquence des répertoires que l'on doit
  traverser pour atteindre le fichier. Les trois termes sont
  synonymes. Tous les noms de fichiers absolus commencent par le
  répertoire racine / et il y a un / devant chaque répertoire ou
  fichier du nom de fichier. Le premier / est le nom du répertoire
  mais les autres sont de simples séparateurs pour distinguer les
  parties du nom de fichier.
<item>
  Les noms utilisés portent parfois à confusion. Prenons l'exemple
  suivant: 
<example>
/usr/share/keytables/us.map.gz
</example>
  C'est un nom de fichier pleinement qualifié. Pourtant, certaines
  personnes le désignent comme un <em>chemin</em>. D'autres personnes
  s'en servent pour désigner le fichier <prgn>us.map.gz</prgn> comme
  un seul nom de fichier.
<item>
  Il y a aussi une autre utilisation du mot
  <em>chemin</em><footnote><em>path</em> en anglais. À connaître aussi
  absolument.</footnote>. Mais le contexte est toujours suffisamment
  clair pour faire la distinction.
<item>
  Les répertoires sont rangés sous forme d'arbre. Tous les noms de
  fichiers absolus commencent avec le répertoire racine. Le répertoire
  racine possède un certain nombre de branches, comme
  <prgn>/etc</prgn> et <prgn>/usr</prgn>. Ces sous-répertoires se
  subdivisent eux-mêmes en branches en de nombreux sous-répertoires,
  comme <prgn>/etc/init.d</prgn> et
  <prgn>/usr/local</prgn>. L'ensemble est appelé <em>l'arbre des
  répertoires</em>.
<item>
  Vous pouvez faire l'analogie avec un nom de fichier absolu et la
  route partante de la base de l'arbre (/) à la fin d'une branche (le
  fichier). Vous entendrez aussi parler certaines personnes de l'arbre
  des répertoires comme d'un <em> arbre familial</em>. Certains
  répertoires ont des « parents » et un chemin montre l'arbre
  généalogique complet.
<item>
  Il existe aussi des chemins relatifs qui commencent ailleurs que
  dans le répertoire racine. On y reviendra plus tard.
<item>
  Aucun répertoire ne correspond à un périphérique physique comme
  votre disque dur. Ceci diffère profondément du DOS et de Windows
  pour qui tout chemin commence par un nom de périphérique comme
  C:\. L'arbre des répertoires est une abstraction du périphérique
  matériel et vous pouvez donc l'utiliser sans savoir ce qu'il y a
  dessous. Tous vos fichiers peuvent être contenus dans un disque - ou
  vous pouvez très bien avoir vingt disques, certains connectés sur
  des ordinateurs différents répartis n'importe où sur le réseau. Vous
  ne pouvez deviner en jetant juste un coup d'oeil sur l'arbre des
  répertoires sur quel(s) périphérique(s) matériel(s) se trouvent vos
  fichiers.
</list>

<p>
Ne vous inquiétez si tout ceci n'est pas complètement clair pour vous:
il y a de nombreux exemple à venir.

<sect1> Utilisation des fichiers: un tutoriel

<p>
Pour utiliser votre système, vous devrez connaître comment créer,
déplacer, renommer et détruire fichiers et répertoires. Cette partie a
pour but de montrer comment le faire avec les commandes standard de
Debian.

<p>
La meilleure méthode d'apprentissage est encore d'essayer. Tant que
vous n'êtes pas root (et vous n'avez pas maintenant à créer
d'importants fichiers personnels), vous ne pouvez faire de catastrophe
irrémédiable. Lancez-vous - tapez chacune de ces commandes après le
prompteur et appuyer ensuite sur la touche <em>entrée</em>:

<p>
<example>
pwd
</example>

<p>
Le répertoire en cours est toujours considéré comme le <em>répertoire
courant de travail</em> pour le shell que vous utilisez. Vous pouvez
toujours le visualiser à l'aide de la commande <prgn>pwd</prgn> qui
signifie <em>Print Working Directory</em> (affiche le répertoire de
travail). <prgn>pwd</prgn> affiche donc le nom du répertoire dans
lequel vous travaillez - et probablement <prgn>/home/votrenom</prgn>.

<p>
<example>
ls
</example>

<p>
<prgn>ls</prgn> signifie <em>list</em> (affiche) comme pour <em>list
files</em> (affiche les fichiers). Lorsque vous tapez la commande
<prgn>ls</prgn>, le système renvoie une liste de tous les fichiers de
votre répertoire courant. Si vous venez d'installer Debian, votre
répertoire de travail est certainement vide et <prgn>ls</prgn> ne
renvoie rien en sortie car il n'y a pas de fichier à afficher.

<p>
<example>
cd /
</example>

<p>
<prgn>cd</prgn> signifie <em>change directory</em> (change de
répertoire). Dans ce cas, on lui a demandé de changer pour le
répertoire racine.

<p>
<example>
pwd
</example>

<p>
Ceci pour vérifier que vous êtes bien dans le répertoire racine.

<p>
<example>
ls
</example>

Pour jeter un coup d'oeil au contenu de /.

<p>
<example>
cd
</example>

<p>
Taper <prgn>cd</prgn> sans argument sélectionne votre répertoire
personnel - <prgn>/home/votrenom</prgn> - comme répertoire
courant. Essayez <prgn>pwd</prgn> pour vérifier.

<p>
Avant de continuer, il vous faut savoir qu'il y a vraiment deux sortes
de fichiers. Certains d'entre eux commencent par /, le répertoire
racine, comme <prgn>/etc/profile</prgn>. Ils sont appelés <em>noms de
fichiers absolus</em> car ils se réfèrent au même fichier quelque soit
le répertoire courant. L'autre sorte de fichiers sont les <em>fichiers
relatifs</em>.

<p>
Seuls deux répertoires ne sont utilisés qu'avec des noms de fichiers
relatifs: «&nbsp;.&nbsp;» et «&nbsp;..&nbsp;». Le répertoire . se
réfère au répertoire courant et .. au répertoire parent. Ce sont des
raccourcis. Ils existent dans <em>tous</em> les répertoires. Même le
répertoire racine à un répertoire parent - c'est son propre parent !

<p>
Ainsi, tous les fichiers comprenant . ou .. sont <em>relatifs</em> car
leur expression dépend du répertoire courant. Si je suis dans
<prgn>/usr/bin</prgn> et que je tape <prgn>../etc</prgn>, je me réfère
à <prgn>/usr/etc</prgn>. Si je suis dans <prgn>/var</prgn> et que je
tape <prgn>../etc</prgn>, je me réfère à <prgn>/etc</prgn>. Remarquez
bien que le nom de fichier sans le répertoire racine possède
implicitement à son commencement ./ . Ainsi, vous pouvez taper
indifféremment <prgn>/local/bin</prgn> ou bien
<prgn>./local/bin</prgn>, ce qui signifie exactement la même chose.

<p>
Un dernier petit truc: le <em>tilda</em> ~ est équivalent à votre
répertoire personnel. Ainsi, taper <prgn>cd ~</prgn> revient au même
que taper <prgn>cd</prgn> sans argument. Vous pouvez donc taper
<prgn>cd ~/divers/monsousrepertoire</prgn> à la place de <prgn>cd
/home/votrenom/divers/monsousrepertoire</prgn>. De façon analogue,
<prgn>~myuser</prgn> est l'équivalent du répertoire personnel de
l'utilisateur <em>myuser</em> qui est probablement quelque chose comme
<prgn>/home/myuser</prgn>; ainsi, <prgn>~myuser/docs/debian.ps</prgn>
est équivalent à <prgn>/home/myuser/doc/debian.ps</prgn>.

<p>
Il y a encore quelques commandes à essayer maintenant que vous
maîtrisez les chemins relatifs. Tapez <prgn>cd</prgn> pour revenir
dans votre répertoire personnel.

<p>
<example>
mkdir divers
</example>

<p>
Cela fabrique dans votre répertoire personnel un répertoire nommé
<prgn>divers</prgn>. Vous allez utiliser ce répertoire pour essayer
quelques autres commandes. Vous pouvez essayer <prgn>ls</prgn> pour
vérifier que votre nouveau répertoire existe bien.

<p>
<example>
cd divers
</example>

<p>
Ceci change le répertoire vers <prgn>divers</prgn>.

<p>
<example>
mkdir monsousrepertoire
</example>

<p>
Ceci crée un sous-répertoire de <prgn>divers</prgn>.

<p>
<example>
cp /etc/profile .
</example>

<p>
<prgn>cp</prgn> est un raccourci pour <em>copy</em>
(copier). <prgn>/etc/profile</prgn> est juste un fichier quelconque de
votre système. Ne vous souciez pas de ce qu'il fait pour le
moment. Nous l'avons recopié dans . (rappelez-vous que . signifie
simplement « le répertoire dans lequel je me trouve maintenant »
c'est-à-dire le répertoire courant de travail). Donc, ceci crée une
copie de <prgn>/etc/profile</prgn> et la place dans votre répertoire
<prgn>divers</prgn>. Essayez de taper <prgn>ls</prgn> pour vérifier
qu'il y a bien un fichier appelé <prgn>profile</prgn> dans votre
répertoire courant de travail au même niveau que le répertoire
<prgn>monsousrepertoire</prgn>.

<p>
<example>
more profile
</example>

<p>
Ceci vous permet de visualiser le contenu du fichier
<prgn>profile</prgn>. <prgn>more</prgn> est utilisé pour visualiser le
contenu des fichiers textes. Il est appelé <prgn>more</prgn> car il ne
montre qu'une page d'écran du fichier à la fois et il faut appuyer sur
la barre d'espace pour visualiser la suite. <prgn>more</prgn> sortira
de lui-même lorsqu'il aura atteint la fin du fichier ou lorsque vous
aurez taper sur q (<em>quit</em> pour quitter).

<p>
<example>
more /etc/profile
</example>

<p>
va s'assurer que la copie est bien conforme à l'original.

<p>
<example>
mv profile monsousrepertoire
</example>

<p>
<prgn>mv</prgn> signifie <em>move</em> (déplacer). Vous avez déplacé
le fichier <prgn>profile</prgn> du répertoire courant dans le
sous-répertoire <prgn>monsousrepertoire</prgn> que vous avez créé
précédemment.

<p>
<example>
ls
</example>

<p>
vérifie qu'il n'existe plus de fichier <prgn>profile</prgn> dans le
répertoire courant.

<p>
<example>
ls monsousrepertoire
</example>

<p>
s'assure que <prgn>profile</prgn> a bien été déplacé dans le
répertoire <prgn>monsousrepertoire</prgn>.

<p>
<example>
cd monsousrepertoire
</example>

<p>
Ceci change de répertoire vers le répertoire
<prgn>monsousrepertoire</prgn>.

<p>
<example>
mv profile myprofile
</example>

<p>
Remarquez bien que contrairement à de nombreux autres systèmes, il n'y
a pas de différence entre renommer un fichier et le déplacer. Ainsi,
on ne trouve pas de commande <prgn>rename</prgn> (renomme). Signalons
aussi que le second argument peut aussi bien être un répertoire pour
déplacer le fichier dedans qu'un nom de fichier pour le
renommage. <prgn>cp</prgn> fonctionne de la même façon.

<p>
Comme d'habitude, vous pouvez taper <prgn>ls</prgn> pour regarder le
résultat.

<p>
<example>
mv myprofile ..
</example>

<p>
De la même façon que . signifie « le répertoire où je suis maintenant
», .. signifie « le parent du répertoire courant ». Et dans le cas
présent, le répertoire <prgn>divers</prgn> créé précédemment. Utilisez
<prgn>ls</prgn> pour vérifier où se trouve <prgn>myprofile</prgn>
maintenant.

<p>
<example>
cd ..
</example>

<p>
Change de répertoire vers le répertoire parent, c'est-à-dire ici
<prgn>divers</prgn> où vous venez de déplacer <prgn>myprofile</prgn>.

<p>
<example>
rm myprofile
</example>

<p>
<prgn>rm</prgn> signifie <em>remove</em> (effacer) donc cela efface le
fichier <prgn>myprofile</prgn>. Faîtes très attention ! Détruire un
fichier sur un système GNU-Linux est <em>définitif</em> car il n'y a
pas de fonction inverse. Si vous effacez un fichier, c'est fini <em> à
jamais</em>... Prenez bien vos précautions.... On répète: détruire un
fichier sur un système GNU-Linux est <em>définitif</em> car il n'y a
pas de fonction inverse. Si vous effacez un fichier, c'est fini <em> à
jamais</em>... Prenez bien vos précautions<footnote>Relisez-le encore
une fois: détruire un fichier sur un système GNU-Linux est
<em>définitif</em> car il n'y a pas de fonction inverse. Si vous
effacez un fichier, c'est fini <em> à jamais</em>... Prenez bien vos
précautions....</footnote>....

<p>
<example>
rmdir monsousrepertoire
</example>

<p>
<prgn>rmdir</prgn> est la même chose que <prgn>rm</prgn> mais pour les
répertoires. Remarquez que <prgn>rmdir</prgn> ne fonctionne qu'avec
des répertoires vides. Si le répertoire contient des fichiers, vous
devez les détruire en premier ou bien utiliser <prgn>rm -r</prgn> à la
place de <prgn>rmdir</prgn>.

<p>
<example>
cd ..
</example>

<p>
Ceci vous permet de sortir du répertoire courant et de vous déplacer
dans le répertoire parent. Maintenant vous pouvez taper la séquence
suivante:

<p>
<example>
rmdir divers
</example>

<p>
Ceci détruira les derniers restes de notre essai.

<p>
Nous savons maintenant comment créer, copier, déplacer, renommer et
détruire fichiers et répertoires. Nous avons aussi appris quelques
raccourcis comme taper simplement <prgn>cd</prgn> pour revenir dans
son répertoire personnel et comment . et .. désignent respectivement
le répertoire courant et le répertoire parent. Vous devez aussi
retenir les concepts de répertoire racine, ou /, et de l'alias ~ pour
votre répertoire personnel.
</sect1>

<sect1> Fichiers cachés et <prgn>ls -a</prgn>

<p>
Lorsque vous tapez <prgn>ls</prgn> les fichiers commençant par un . ne
sont pas affichés. Traditionnellement, ces fichiers contiennent des
informations de configurations, de préférences et toutes sortes de
choses du même acabit. Ils vous sont cachés dans votre travail
quotidien. Des exemples simples de fichiers cachés sont
<prgn>~/.emacs, ~/.newsrc, ~/.bashrc, ~/.xsession</prgn> et
<prgn>~/.fvwmrc</prgn>. Ils sont respectivement utilisés par
<em>Emacs</em>, le lecteur de niouses, le shell <em>Bash</em>, le
système <em>X-Window</em> et le gestionnaire de fenêtres
<em>fvwm</em>. Il est conventionnel d'ajouter un <prgn>rc</prgn> final
aux fichiers cachés mais certains programmes ne le font pas. Il y a
aussi des répertoires cachés, comme <prgn>~/.gimp</prgn> ou
<prgn>~/.netscape</prgn> qui rassemblent les préférences pour <em>The
Gimp</em> et <em>Netscape</em>.

<p>
Parfois, un fichier créera automatiquement un fichier caché ; par
exemple, <em>Netscape</em> vous permets d'éditer dans une fenêtre
graphique vos préférences et de sauvegarder vos choix. D'autres fois,
vous devrez les créer vous-même à l'aide d'un éditeur de texte. C'est
la façon traditionnelle de faire mais vous avez à apprendre le format
particulier de chaque fichier, ce qui est un inconvénient au début
mais vous donne par la suite beaucoup de puissance.
</sect1>
</sect>

<sect> Processus

<p>
Nous avons déjà souligné le fait que GNU-Linux est un système
multi-tâches. Il peut traiter plusieurs choses simultanément. Chacune
de ces tâches est appelé <em>processus</em> (<em>process</em> en
anglais). La meilleure façon de comprendre ce qui précède est de taper
<prgn>top</prgn> après le prompteur du shell. Vous obtiendrez une
liste des processus triés suivant le temps que votre ordinateur met à
les traiter. Leur ordre change continuellement devant vos yeux. En
haut de l'écran, vous devez apercevoir quelques informations sur le
système: combien il y a d'utilisateurs connectés, combien il y a de
processus, combien de mémoire vous avez et combien vous en utilisez
réellement.

<p>
Dans la colonne à l'extrème gauche, vous apercevrez les utilisateurs
propriétaires de chaque processus. À l'extrème droite, vous trouverez
la liste des commandes évoquées. Vous avez certainement remarqué que
<prgn>top</prgn> lui-même, lancé par vous, est presqu'en haut de la
liste (car à chaque fois que <prgn>top</prgn> vérifie l'usage du
microprocesseur (CPU), il l'active lui-même et utilise le CPU pour
faire la vérification).

<p>
Remarquez que toutes les commandes se terminant pas « d » - comme
<prgn>kflushd</prgn> ou <prgn>inetd</prgn> - sont des
<em>daemons</em>.

<p>
Les <em>daemons</em><footnote><em>Daemons</em> en anglais se traduit
par démons mais j'ai préféré garder le terme anglo-saxon car ce n'est
pas un nom mais un acronyme.</footnote> signifient à l'origine
<em>Disk And Extensions MOnitor</em> (surveillance des disques et des
extensions). Un daemon est un processus non interactif ce qui veut
dire qu'il est lancé par le système et que l'utilisateur n'a pas à
s'en occuper. Les daemons servent à fournir des services comme la
connexion Internet, l'impression ou le courrier électronique.

<p>
Maintenant, appuyez sur <prgn>u</prgn> et entrez votre nom
d'utilisateur. La commande <prgn>u</prgn> sert à afficher les seules
processus appartenant à un utilisateur; cela permet d'ignorer tous les
daemons et tous les processus appartenant à d'autres
utilisateurs. Vous devez voir <prgn>bash</prgn>, le nom de votre
shell. Vous aurez toujours le nom de votre shell.

<p>
La colonne numéro deux vous renvoie le PID pour <em>Process
IDentication</em> (identificateur de processus). On assigne à chaque
signal un unique PID. Vous pouvez utiliser les PID pour contrôler
individuellement les processus (on approfondira le sujet
ultérieurement). Un truc utile est la commande <prgn>?</prgn> qui vous
renvoie une liste des commandes disponibles sous <prgn>top</prgn>.

<p>
Il se peut que vous vous posiez la question de la différence entre un
processus et un programme. En pratique, on utilise indifféremment l'un
pour l'autre. Techniquement parlant, un <em>programme</em> est le jeu
d'instruction écrit par un programmeur et gardé sur le disque. Le
<em>processus</em> est l'instanciation en mémoire de ce programme sous
Linux. Mais il n'est pas primordial de faire une réelle différence.

<p>
Beaucoup de vos interventions avec un ordinateur vont consister à
contrôler les processus. Vous allez devoir les faire partir, les
arrêter et les observer. Votre outil privilégié pour cela est le
shell.
</sect>

<sect> Le shell

<p>
Le <em>shell</em>, ou <em>interpréteur de commandes</em>, vous permet
d'interagir avec votre ordinateur. Il est appelé <em>shell</em>
(coquillage) car il vous fournit un environnement de travail, comme
une sorte de petite maison électronique pour vos travaux informatiques
(pensez à l'abri de l'ermite).

<p>
La fonction la plus simple du shell est de lancer les autres
programmes. Vous tapez le nom du programme que vous voulez lancer,
avec à la suite les arguments que vous voulez et le shell demandera au
système de lancer le programme pour vous.

<p>
Bien sûr, les systèmes graphiques avec fenêtres fournissent le même
type de services. Techniquement, Windows 95 fournit un shell graphique
et le système X Window fournit un autre type de shell graphique. Mais
le terme <em>shell</em> est communément employé en sous-entendant
<em>shell pour lignes de commandes</em>.

<p>
Cela va sans le dire mais les hackers travaillant sur un shell ne se
contentent pas de lancer simplement des commandes. Votre shell regorge
d'astuces cachées et de fonctionnalités puissantes si vous désirez
vous en servir.

<p>
Il y a de très nombreux shells  différents disponibles. La plupart
d'entre eux sont basés soit sur le <em>Bourne Shell</em> soit sur le
<em>C shell</em>, deux des plus vieux shells. Le nom originel du
Bourne Shell est <prgn>sh</prgn> et celui du C shell,
<prgn>csh</prgn>. Les différentes variantes du Bourne Shell sont le
<em>Bourne Again Shell</em> du projet GNU (<prgn>bash</prgn>, le shell
par défaut de Debian), le <em>Korn Shell</em> (<prgn>ksh</prgn>) et le
<em>Z shell</em> (<prgn>zsh</prgn>). Il y a aussi <prgn>ash</prgn>,
une implémentation traditionnelle du Bourne shell. La plus connue des
variantes du C shell est <prgn>tcsh</prgn> (le <prgn>t</prgn> est un
tribu payé aux systèmes d'exploitation <em>TENEX and TOPS-20</em> qui
ont inspiré quelques parties de <prgn>tcsh</prgn> en sus de
<prgn>csh</prgn>).

<p>
<prgn>bash</prgn> est certainement le meilleur choix  pour un nouvel
utilisateur. C'est le shell par défaut et il comprend des tas de
fonctionnalités que vous allez apprécier. Mais chaque shell possède
ses avantages. Si vous voulez expérimenter, installez les différents
paquets de shell et changez votre shell avec la commande
<prgn>chsh</prgn>. Tapez simplement <prgn>chsh</prgn>, fournissez
votre mot de passe et lorsque demandé, choisissez votre nouveau
shell. Lorsque vous vous reloguerez de nouveau, vous utiliserez le
nouveau shell.
</sect>

<sect> Gérer les processus avec <prgn>bash</prgn>

<p>
Debian est un système multi-tâches donc vous avez besoin d'un moyen de
faire plus d'une chose à la fois. Les environnements graphiques, comme
X, fournissent un élément naturel pour le faire: ils autorisent
plusieurs fenêtres simultanément. Naturellement, <prgn>bash</prgn>, et
tous les autres shells, fournissent des facilités similaires.

<p>
Récemment, vous avez utilisé <prgn>top</prgn> pour jeter un coup
d'oeil sur tous les processus de votre système. Votre shell vous
propose des façons aisées de suivre les commandes que vous avez
lancées à partir de ce shell. Chaque ligne de commande lance un
<em>job</em> (aussi appelé un <em>groupe de processus</em>) qui sera
suivi par le shell. Un job peut être simplement un processus ou bien
un ensemble de processus tubés (plus sur les tubes un peu plus tard).

<p>
Entrer une ligne de commande lance un job. Essayez de taper <prgn>man
cp</prgn> et la page de manuel de <prgn>cp</prgn> va apparaître à
l'écran. Le shell va tourner en arrière-plan et revenir en avant-plan
une fois la lecture de la page terminée (ou vous pouvez taper sur q
pour éviter d'avoir à dérouler toute la page pour sortir).

<p>
Mais admettons que vous désiriez faire quelque chose d'autre pendant
la lecture du manuel. Pas de problème. Appuyez sur <em>Ctrl-z</em>
pour suspendre la lecture du manuel (mis en arrière-plan du job
courant) et ainsi remettre en avant-plan le shell. Lorsque vous
suspendez un job, <prgn>bash</prgn> vous donne immédiatement quelques
informations à son sujet et ensuite il renvoie un prompteur. Vous
devriez apercevoir quelque chose comme cela à l'écran:

<p>
<example>
NAME  cp  - copy files SYNOPSIS cp [options] source
--More--
[1]+ Stopped man cp
$
</example>

<p>
Observez bien les deux dernières lignes. Les deux dernières comportent
l'information sur le job et vous avez le prompteur du shell.

<p>
<prgn>bash</prgn> assigne à chaque ligne de commande un <em>numéro de
job</em> donné par le shell. Cela vous permet de vous référer
facilement à un processus. Dans ce cas, <prgn>man cp</prgn> porte le
numéro 1, indiqué par <prgn>[1]</prgn>. Le signe <prgn>+</prgn> veut
dire que c'est le dernier job à avoir été mis en
arrière-plan. <prgn>bash</prgn> vous renvoie aussi l'état courant du
job - <prgn>Stopped</prgn> - ainsi que la ligne de commande.

<p>
Il y a de nombreuses choses à faire avec les jobs. Avec <prgn>man
cp</prgn> toujours suspendu, essayez la commande suivante:

<p>
<example>
man ls
</example>

<p>
Cela crée un nouveau job.

<p>
<example>
Ctrl-z
</example>

<p>
Cela le suspend; vous devriez voir les informations du job.

<p>
<example>
man mv
</example>

<p>
Lance un nouveau job.

<p>
<example>
Ctrl-z
</example>

<p>
Le suspend aussi.

<p>
<example>
jobs
</example>

<p>
Demande au <prgn>bash</prgn> d'afficher l'état de tous les jobs en
cours. Le résultats devraient ressembler à :

<p>
<example>
{$} jobs
[1] Stopped man cp
[2]- Stopped man ls
[3]+ Stopped man mv
{$}
</example>

<p>
Remarquez bien que les - et + qualifient respectivement
l'avant-dernier et le dernier job en arrière-plan.

<p>
<example>
fg
</example>

<p>
Cela place le dernier job en arrière-plan (<prgn>man mv</prgn>, celui
avec le +) de nouveau en avant-plan. Si vous pressez la barre
d'espace, la page de manuel va se dérouler.

<p>
<example>
Ctrl-z
</example>

<p>
Suspend à nouveau <prgn>man mv</prgn>.

<p>
<example>
fg %1
</example>

<p>
Vous pouvez vous référer à n'importe quel job en utilisant % suivi de
son numéro. Si vous utilisez <prgn>fg</prgn> sans lui spécifier de
job, c'est le dernier actif qui sera réveillé.

<p>
<example>
Ctrl-z
</example>

<p>
Suspend à nouveau <prgn>man cp</prgn>.

<p>
<example>
kill %1
</example>

<p>
Détruit le job numéro 1. <prgn>bash</prgn> fait un rapport
d'information du job qui devrait ressembler à:

<p>
<example>
$ kill %1
[1] - Terminated man cp
$
</example>

<p>
<prgn>bash</prgn> se contente de demander au job de se terminer et
parfois ce dernier ne veut pas. Dans ce cas, vous devez ajouter
l'option <prgn>-KILL</prgn><footnote>. De nombreuses personnes
utilisent le signal -9 plutôt que le nom du signal. Dans tous les cas,
c'est techniquement moins portable que d'utiliser le nom du
signal</footnote> pour arrêter la demande de destruction et commencer
la destruction. Par exemple:

<p>
<example>
$ kill -KILL %1
[1]- Killed man mv
$
</example>

<p>
L'option <prgn>-KILL</prgn> force une destruction inconditionnelle du
job.

<p>
En des termes plus techniques, <prgn>kill</prgn> se contente d'envoyer
un signal. Par défaut, il envoie un signal de terminaison
(<prgn>TERM</prgn> ou <prgn>signal 15</prgn>) mais vous pouvez très
bien spécifier un signal et l'option <prgn>-KILL</prgn> (<prgn>signal
9</prgn>) est le signal qui force la terminaison. La commande
<prgn>kill</prgn> n'est pas forcément appropriée pour l'envoi de
signaux ; par exemple, envoyer le signal <prgn>TSTP</prgn>
(<prgn>terminal stop</prgn>) suspend le processus et permet de le
récupérer plus tard.

<p>
<example>
top
</example>

<p>
Cela nous renvoie à l'écran la sortie de <prgn>top</prgn>. Envoyez la
commande <prgn>u</prgn> dans <prgn>top</prgn> pour ne visualiser que
vos processus. Regardez dans la colonne de droite les commandes
<prgn>man ls</prgn> et <prgn>man mv</prgn>. <prgn>man cp</prgn> n'est
plus là puisque vous l'avez tuée.  <prgn>top</prgn> vous montre les
processus vous appartenant ; remarquez bien que le PID à gauche de
l'écran ne correspond pas au numéro de job.

<p>
Il se peut que vous ne voyez pas vos processus car trop bas pour
apparaître à l'écran. Si vous utilisez X (voir chapitre 11), vous
pouvez redimensionner votre <prgn>xterm</prgn> pour résoudre le
problème.

<p>
Même ces simples jobs sont en réalité des processus multiples,
incluant le processus <prgn>man</prgn> et le visualiseur
<prgn>more</prgn> qui vous permet de faire défiler les pages une par
une. Vous devez apercevoir les processus <prgn>more</prgn> dans
<prgn>top</prgn>.

<p>
Vous vous demandez peut-être comment nettoyer les deux jobs
restant. Vous pouvez soit les tuer (avec la commande
<prgn>kill</prgn>) ou bien les remettre en avant-plan (avec
<prgn>fg</prgn>) puis les quitter. Rappelez-vous que la commande
<prgn>jobs</prgn> vous renvoie la liste des jobs en cours et leur
état.

<p>
Une touche finale: la documentation de <prgn>bash</prgn> est plutôt
bonne mais il vaut mieux aller la chercher dans le système d'aide
<prgn>info</prgn> que dans les pages de manuel. Pour la lire, tapez
<prgn>info bash</prgn>. Voir la partie 16.2 pour les instructions
pour se servir de la commande <prgn>info</prgn>. <prgn>bash</prgn>
contient aussi une très bonne documentation en ligne accessible via la
commande <prgn>help</prgn>. <prgn>help</prgn> renvoie une liste de
sujets disponibles. On peut accéder directement à l'information en
tapant <prgn>help sujet en question</prgn>. Essayez <prgn>help
cd</prgn> par exemple. Cela vous fournira des détails sur les
arguments <prgn>-L</prgn> et <prgn>-P</prgn> reconnus par
<prgn>cd</prgn>.
</sect>

<sect> Quelques fonctionnalités de <prgn>bash</prgn>

<p>
Cette partie mentionne rapidement quelques fonctionnalités couramment
utilisées sous <prgn>bash</prgn>. Pour une discussion plus complète,
reportez-vous au chapitre 8.

<sect1> Le complètement par tabulation

<p>
Le shell <prgn>bash</prgn> est capable de deviner quel fichier ou
commande vous êtes en train de taper et les compléter automatiquement
pour vous. Il suffit simplement de taper le début de la commande ou du
fichier et d'appuyer sur la touche de tabulation. Si <prgn>bash</prgn>
trouve un complètement unique, il finira le mot et ajoutera un espace
à la fin. S'il trouve de multiples complètements<footnote>On trouve
parfois <em>complétion</em> qui n'est qu'un barbarisme engendré à
partir du terme anglais <em>completion</em>.</footnote>, il propose
l'ensemble de ses choix possibles en émettant un signal sonore. Vous
pouvez alors entrer le nombre de lettres suffisantes pour le rendre
unique et appuyez sur la touche de tabulation à nouveau. S'il n'existe
pas de complètement, <prgn>bash</prgn> émet simplement un signal
sonore.
</sect1>
</sect>

<sect> Protéger votre identité

<p>
Les systèmes de type Unix sont multi-utilisateurs et vous avez donc
votre propre identité comme utilisateur sur le système. Tapez
<prgn>finger votrenomdutilisateur</prgn> pour voir les informations
qui sont publiquement disponibles. Pour changer le nom et le shell
affichés ici, vous pouvez utiliser la commande <prgn>chfn</prgn> et
<prgn>chsh</prgn>. Seul root peut vous changer votre login et votre
répertoire d'attache. Vous devez avoir vu <em>No plan</em>. Un
<em>plan</em> est une simple information que vous voulez rendre
publique. Pour créer un plan, vous placer toute l'information que vous
voulez montrer aux autres dans un fichier appelé
<prgn>.plan</prgn>. Pour le faire, vous devrez vous servir d'un
éditeur de texte (voir chapitre 10.2). Ensuite, utilisez à nouveau
<prgn>finger</prgn> pour observer le résultat. Les autres peuvent
utiliser finger sur vous pour voir votre <em>plan</em> ou vérifier si
vous avez reçu ou lu votre courrier électronique.

<p>
Remarquez bien que l'information de <prgn>finger</prgn> est disponible
à travers tout l'Internet par défaut. Si vous ne le voulez pas, lisez
la documentation de <prgn>inetd</prgn> et le fichier
<prgn>/etc/services</prgn>. Éventuellement, la page de manuel peut
décrire la mise en oeuvre mais il n'est pas évident que cela puisse
réellement vous aider.
</sect>

 </chapt>
<chapt> Utiliser le shell

<p>
En lisant les chapitres précédents, vous avez déjà interagit avec le
shell. Le shell est le programme qui reçoit vos commandes et qui les
exécute. Dans ce chapitre, nous allons explorer le shell plus en
avant, avec une mention spéciale pour le personnaliser afin de lui
faire faire le travail que vous voulez qu'il fasse.

<sect> Les variables d'environnement

<p>
Chaque processus a un <em>environnement</em> associé. Un environnement
est ensembles de <em>variables d'environnement</em>. Une variable est
une valeur modifiable avec un nom déterminé. Par exemple, le nom
<em>EMAIL</em> peut se référer à la valeur
<prgn>joe@nowwhere.com</prgn>. Sa valeur peut changer ; <em>EMAIL</em>
peut aussi se référer à <prgn>jane@somewhere.com</prgn>.

<p>
Puisque le shell n'est qu'un processus parmi d'autres, il possède
aussi son environnement. Vous pouvez visualiser votre environnement en
entrant la commande <prgn>printenv</prgn>. La figure suivante donne un
exemple de résultat de sortie de cette commande. Sur votre système, la
sortie sera différente bien que similaire.

<p>
<example>
PAGER=less
HOSTNAME=icon
MAILCHECK=60
PS1=$
USER=username
MACHTYPE=i486-pc-linux-gnu
EDITOR=emacs
DISPLAY=:0.0
LOGNAME=username
SHELL=/bin/bash
OSTYPE=linux-gnu
HISTSIZE=150
TERM=xterm-debian
TEXEDIT=jed
PATH=/usr/sbin:/usr/sbin/:/usr/local/bin/:
/usr/bin/:/bin/:/usr/bin/X11/:/usr/games
_=/usr/bin/printenv
</example>

<p>
Les variables d'environnement sont une façon de configurer le
système. Par exemple, la variable <em>EDITOR</em> vous permet de
sélectionner votre éditeur préféré pour poster des <em>news</em>,
écrire du courrier électronique et ainsi de suite.

<p>
Régler ses variables d'environnement est quelque chose de triviale. En
pratique, commençons par personnaliser votre prompteur de shell ainsi
que votre visualiseur de texte avec les variables
d'environnement. Tout d'abord, commençons par un peu
d'informations basiques.

<p>
<example>
man less
</example>

<p>
Cette commande vous permet d'accéder au manuel en ligne de la commande
<prgn>less</prgn>. Pour éviter de dérouler tout le texte d'un seul
coup à l'écran, <prgn>man</prgn> invoque un <em>pageur</em> qui vous
déroule le texte page par page, à chaque fois que vous appuyez sur la
touche <em>espace</em>. Par défaut, le pageur utilisé est
<prgn>more</prgn>.

<p>
Continuons et regardons un peu la page de manuel de <prgn>less</prgn>,
qui est un pageur très puissant. Affichez la page suivante en appuyant
sur espace et q pour quitter. <prgn>more</prgn> quitte aussi
automatiquement la page en arrivant à la fin.

<p>
<example>
export PAGER=less
</example>

<p>
Après avoir lu les avantages de <prgn>less</prgn>, il se peut que vous
vouliez l'utiliser pour lire les pages de manuel. Pour ce faire, vous
devez positionner la variable d'environnement <em>PAGER</em>.

<p>
La commande pour ajuster une variable d'environnement dans
<prgn>bash</prgn> a toujours le format suivant:

<p>
<example>
export NOM=valeur
</example>

<p>
<prgn>export</prgn> signifie déplacer la variable du shell dans votre
environnement. Cela veut dire que les programmes autres que le shell
(par exemple, un visualiseur de textes) seront capables d'y accéder.

<p>
<example>
echo $PAGER
</example>

<p>
C'est la façon la plus aisée d'accéder au contenu de la
variable. <em>$PAGER</em> demande en fait au shell d'insérer la valeur
de <em>PAGER</em> <em>avant</em> d'invoquer la
commande. <prgn>echo</prgn> renvoie simplement l'argument: dans ce
cas, cela renvoie simplement la valeur du contenu de <em>PAGER</em>,
c'est-à-dire <prgn>less</prgn>.

<p>
<example>
man more
</example>

<p>
renvoie maintenant la page de manuel de <prgn>more</prgn>. Mais
maintenant, <prgn>man</prgn> utilise <prgn>less</prgn> comme pageur.

<p>
<prgn>less</prgn> a beaucoup plus de fonctionnalités que
<prgn>more</prgn>. Par exemple, vous pouvez paginer en arrière à
l'aide de la touche <prgn>b</prgn>. Vous pouvez aussi vous déplacer en
avant et en arrière à l'aide des flèches de
direction. <prgn>less</prgn> ne sort pas lorsque vous avez atteint le
bas du fichier de la page de manuel: il attend que vous appuyez sur la
touche <prgn>q</prgn>.

<p>
Vous pouvez essayer quelques spécificités de la commande
<prgn>less</prgn>, comme <prgn>b</prgn>, pour vérifier qu'elles ne
fonctionnent pas avec <prgn>more</prgn>.

<p>
<example>
unset PAGER
</example>

<p>
Si vous ne désirez pas spécifier un pageur, vous pouvez appliquer la
commande <prgn>unset</prgn> à la variable. <prgn>man</prgn> utilisera
alors <prgn>more</prgn> par défaut, comme il le faisait avant que vous
ne changiez la variable.

<p>
<example>
echo $PAGER
</example>

<p>
Comme la variable <em>PAGER</em> a été détruite, <prgn>echo</prgn> ne
renverra rien.

<p>
<example>
PS1=bonjour:
</example>

<p>
Pour s'amuser, tentons de modifier le prompteur. $ devrait maintenant
être modifié. Voici les étapes en détails:

<p>
<example>
$ echo $PS1
$
$PS1=bonjour:
bonjour:echo Mon prompteur est $PS1
Mon prompteur est bonjour: 
bonjour:
</example>

<p>
<prgn>export</prgn> n'est pas nécessaire car vous ne modifier que le
comportement de votre propre shell. Il n'y a pas de raison d'exporter
dans l'environnement de tous les programmes pour faire le
test. Techniquement parlant, <em>PS1</em> est plutôt une <em>variable
de shell</em> qu'une variable d'environnement.

<p>
Si vous le voulez, vous pouvez exporter la variable de shell, la
transformant ainsi en variable d'environnement. Si vous agissez de la
sorte, les programmes lancés à partir du shell pourront la voir.
</sect>

<sect> Où les commandes résident: la variable <em>PATH</em>

<p>
Lorsque vous tapez une commande dans votre shell, ce dernier doit
trouver le programme correspondant sur votre disque avant de
l'exécuter. Si le shell devait examiner l'ensemble du disque dur, cela
serait extrêmement lent. À la place, il se contente d'aller chercher
dans un ensemble de répertoires contenu dans la variable
d'environnement <em>PATH</em>. Cette liste de répertoires est le
<em>chemin d'accès</em> du shell. Lorsque vous entrez une commande, le
shell va chercher dans chacun des répertoires de ce chemin pour
trouver la commande que vous lui avez demandé de lancer.

<p>
Il se peut que vous ayez à changer la variable <em>PATH</em> si vous
installez vous-même des programmes à des endroits non
conventionnels. La valeur du <em>PATH</em> est une liste de
répertoires séparés par des «&nbsp;:&nbsp;».

<p>
<example>
/usr/local/bin:/usr/bin/:/bin:/usr/bin/X11:/usr/games
</example>

<p>
Cette valeur est définie dans le fichier <prgn>/etc/profile</prgn> et
applicable à tous les utilisateurs. Il est très facile de modifier
cette valeur, comme d'ailleurs l'ensemble des variables
d'environnement. Si vous tapez la commande <prgn>ls</prgn>, le shell
va d'abord la chercher dans <prgn>/usr/local/bin</prgn>;
<prgn>ls</prgn> ne s'y trouve pas donc il va continuer et la chercher
dans <prgn>/usr/bin/</prgn> ; comme cela échoue encore, il vérifie
<prgn>/bin</prgn>. Il la trouve enfin et stoppe sa recherche pour
exécuter le programme <prgn>/bin/ls</prgn>. Si la commande
<prgn>/usr/bin/X11/ls</prgn> existe (ce n'est pas le cas mais c'est pour
l'exemple), elle serait tout simplement ignorée.

<p>
Vous pouvez voir quel <prgn>ls</prgn> le shell va utiliser grâce à la
commande <prgn>type</prgn>. <prgn>type ls</prgn> va vous renvoyer
<prgn>/bin/ls</prgn>. Essayez-la vous-même.

<p>
<example>
$ type type
type is a shell builtin<footnote>type est une fonction interne du shell</footnote>
</example>

<p>
<prgn>type</prgn> n'est pas vraiment un programme: c'est une
fonctionnalité du shell mais vous pouvez l'utiliser comme un programme
extérieur.

<p>
Il y a de nombreuses commandes de la même sorte. Tapez <prgn>man
builtins</prgn> pour visualiser la page les décrivant. De façon
générale, il n'est pas nécessaire de savoir si une commande est une
fonctionnalité interne ou bien un programme extérieur. Mais il faut
garder à l'esprit qu'une fonctionnalité interne ne sera pas visible
via un <prgn>ps</prgn> ou un <prgn>top</prgn> car il ne s'agit pas
d'un processus séparé: c'est une partie intégrante du shell.
</sect>

<sect> Fichiers de configuration

<p>
De nombreuses applications sous Linux vous permettent de modifier leur
comportement à certains moment en transformant les fichiers contenant
leurs informations de configuration. Ces fichiers de configuration
peuvent contenir des informations de lancement, des réglages de
configuration ou bien des ajustements pour la sortie. En général, un
nom de fichier de configuration est basé sur le nom de l'application
qu'il est sensé modifier. Cette convention de nom permet de déterminer
rapidement à quelle application appartient quel fichier de
configuration pour les réglages.

<sect1> Configuration système contre configuration personnelle

<p>
Il est important de se rappeler qu'il y a deux façons différentes de
configurer sur un système Debian. La <em>configuration système</em>
affecte tous les utilisateurs. Ces configurations se trouve dans le
répertoire <prgn>/etc</prgn> et donc il est généralement nécessaire
d'être root pour modifier ces fichiers. Vous pouvez avoir besoin de
configurer la façon dont se connecte le système à Internet par
exemple, ou bien configurer les butineurs HTML pour leur faire
afficher la page de la société en se lançant. Si vous désirez
effectuer le changement pour tous les utilisateurs à la fois, vous
devez faire les transformations dans <prgn>/etc</prgn>. Des fichiers
de configuration simples de <prgn>/etc</prgn> sont
<prgn>/etc/X11/XF86Config, /etc/lynx.cfg</prgn> et
<prgn>/etc/ppp/options</prgn>. En fait, presque tous les fichiers de
<prgn>/etc</prgn> sont des fichiers de configuration.

<p>
La <em>configuration personnelle</em> n'affecte qu'un simple
utilisateur. Les fichiers cachés sont utilisés à cette fin. Par
exemple, le fichier <prgn>~/.newrc</prgn> contient une liste
d'articles sur USENET (groupes de discussions) que vous avez lus et à
quels groupes vous avez souscrit. Cela permet à des lecteurs de news
comme <prgn>trn</prgn> ou <prgn>GNUS</prgn> de n'afficher que les
articles non lus dans les groupes qui vous intéressent. Cette
information est bien-sûr propre à chaque utilisateur du système et
ainsi chacun possède son propre <prgn>.newrc</prgn> dans son
répertoire de travail personnel.
</sect1>
</sect>

<sect> Aliases

<p>
Si vous utilisez la même commande de nombreuses fois, il se peut que
vous vous fatiguiez à la taper. <prgn>bash</prgn> vous permet d'écrire
un raccourci - on dit <em>alias</em> - de votre commande.

<p>
Admettons que vous désiriez toujours utiliser les options
<prgn>--almost-all</prgn> et <prgn>--color=auto</prgn> de
<prgn>ls</prgn>. Faîtes un alias:

<p>
<example>
alias myls='ls --almost-all --color=auto'
</example>

<p>
Maintenant, il vous suffit de taper <prgn>myls</prgn> à la place de la
commande complète. Pour voir ce qu'est réellement <prgn>myls</prgn>,
il suffit de taper <prgn>type myls</prgn>. Pour voir la liste complète
des <em>aliases</em> que vous avez défini, taper simplement
<prgn>alias</prgn> tout seul comme commande.
</sect>

<sect> Contrôler les entrées et les sorties

<p>
Au fur et à mesure de vos expériences avec Linux, vous allez
comprendre combien manipuler les entrées et sorties des applications
est un concept très puissant. Cette partie décrit quelques points de
ce que peut vous apportez la redirection des entrées-sorties.

<sect1> <prgn>stdin</prgn>, <prgn>stdout</prgn>, tubes et redirection

<p>
Chaque processus a au moins trois connexions avec le monde
extérieur. L'<em>entrée standard</em> est une des sources des données
du processus. La <em>sortie standard</em> est un des endroits où le
processus envoie ses données et l'<em>erreur standard</em> est
l'endroit où le processus envoie ses messages d'erreurs (on les
abrège généralement par <prgn>stdin</prgn>, <prgn>stdout</prgn> et
<prgn>stderr</prgn>).

<p>
Les mots «&nbsp;source&nbsp;» et «&nbsp;endroit&nbsp;» sont
intentionnellement vagues. Ces lieux d'entrées-sorties standards
peuvent changer avec les utilisateurs. Cela peut être l'écran, le
clavier, un fichier et même une connexion réseau. Vous pouvez
spécifier les endroits à utiliser.

<p>
Lorsque vous lancez un programme à partir du shell, l'entrée standard
est généralement le clavier et la sortie standard, ainsi que les
erreurs, s'affichent sur votre écran. Vous pouvez bien sûr demander à
votre shell de modifier ce comportement.

<p>
Par exemple, la commande <prgn>echo</prgn> envoie son entrée standard
sur sa sortie standard, normalement à l'écran. Mais vous pouvez
décider de l'envoyer plutôt dans un fichier à l'aide de
<em>l'opérateur de redirection de sortie</em>, &gt . Par exemple, pour
écrire le mot «&nbsp;Bonjour&nbsp;» dans le fichier
<prgn>monfichier</prgn>, utilisez la commande suivante:

<p>
<example>
echo Bonjour &gt monfichier
</example>

<p>
Utilisez ensuite <prgn>cat</prgn> ou bien votre pageur
(<prgn>more</prgn> ou <prgn>less</prgn>) pour visualiser le contenu du
fichier <prgn>monfichier</prgn>.

<p>
<example>
$ echo Bonjour &gt monfichier
$ cat monfichier
Bonjour
$
</example>


<p>
Vous pouvez changer l'entrée standard d'une commande avec
<em>l'opérateur de redirection d'entrée</em>, &lt . Par exemple,
<prgn>cat &lt monfichier</prgn>. En pratique, ce n'est pas
commode. Pour simplifier, <prgn>cat</prgn> accepte un fichier pour
argument. Ainsi, vous pouvez vous contenter de taper <prgn>cat
monfichier</prgn> et l'effet sera identique.

<p>
Si l'on approfondit un peu, la commande <prgn>cat &lt
monfichier</prgn> signifie que le shell ouvre le fichier
<prgn>monfichier</prgn> et envoie son contenu dans l'entrée standard
de <prgn>cat</prgn>. <prgn>cat monfichier</prgn>, sans l'opérateur de
redirection, signifie que la commande <prgn>cat</prgn> reçoit un
argument unique (<prgn>monfichier</prgn>), l'ouvre d'elle-même et
ensuite l'affiche à l'écran.

<p>
Il y a bien-sûr une raison pour cette double fonctionnalité. Par
exemple, il est possible de connecter la sortie standard d'une
commande sur l'entrée standard d'une autre commande. Cela s'appelle un
<em>tube</em> (<em>pipeline</em> en anglais). Cela utilise
l'<em>opérateur tube</em><footnote>Cela dépend de votre clavier: cela
peut apparaître comme une barre verticale ou une barre verticale en
deux parties mais cela doit toujours se trouver au-dessus du contre
<em>slash</em> (NDT: pour les claviers <em>qwerty</em>
uniquement... tapez <prgn>Alt Gr 6</prgn> pour les
<em>azerty)</em></footnote>, | .

<p>
Peut-être désirez-vous voir la <em>GNU General Public License</em> à
l'envers ? Pour le faire, utilisez la commande <prgn>tac</prgn> (c'est
un <prgn>cat</prgn> mais inversé). Essayez:

<p>
<example>
tac /usr/doc/copyright/GPL
</example>

<p>
Malheureusement, cela défile beaucoup trop rapidement pour être
lisible. Donc vous ne voulez avoir que quelques paragraphes: la
solution est un tube:

<p>
<example>
tac /usr/doc/copyright/GPL | less
</example>

<p>
Cela prend donc la sortie standard de <prgn>tac</prgn>, qui est la GPL
lue à l'envers, et l'envoie dans l'entrée standard de
<prgn>less</prgn>.

<p>
Vous pouvez enchaîner ainsi autant de commandes que vous le
désirez. S'il vous prend une envie inexpliquable de transformer tous
les G en Q, il vous suffit d'utiliser la commande <prgn>tr G Q</prgn>
comme ceci:

<p>
<example>
tac /usr/doc/copyright/GPL | tr G Q | less
</example>

<p>
Vous pouvez obtenir le même résultat en utilisant des fichiers
temporaires et des redirections, par exemple:

<p>
<example>
tac /usr/doc/copyright/GPL > tmpfile
tr G Q < tmpfile > tmpfile2
less < tmpfile2
rm tmpfile tmpfile2
</example>

<p>
Il est clair qu'un tube est bien plus pratique.
</sect1>
</sect>

<sect> Expansion de nom de fichier

<p>
Vous désirez souvent utiliser une commande sur tout un groupe de
fichiers. Des caractères spéciaux (<em>wildcards</em>) sont utilisés
pour créer des <em>termes génériques d'expansion de nom de
fichiers</em>. Une série de lettres et des caractères spéciaux
permettent ainsi de lister des fichiers. Par exemple, le motif
<prgn>/etc/*</prgn> remplace la liste de tous<footnote>Actuellement,
les fichiers commençant par un point ne sont pas inclus dans
l'expansion de *</footnote> les fichiers de <prgn>/etc</prgn>.

<p>
* est un motif qui remplace n'importe quelle série de caractères et
 ainsi l'expression <prgn>/etc/*</prgn> fournira la liste de tous les
 fichiers commençant par <prgn>/etc/</prgn>.

<p>
Cette liste de fichiers est très utile comme un jeu d'arguments pour une
commande. Par exemple, le répertoire <prgn>/etc</prgn> contient une
série de sous-répertoires appelés <prgn>rc0.d, rc1.d</prgn>,
etc... Normalement, pour visualiser le contenu de ces répertoires,
vous devriez taper les commandes suivantes:

<p>
<example>
ls /etc/rc0.d /etc/rc1.d /etc/rc2.d /etc/rc3.d
ls /etc/rc4.d /etc/rc5.d /etc/rc6.d /ect/rcS.d
</example>

<p>
C'est particulièrement lourd et pénible. À la place, il suffit
d'utiliser le caractère spécial «&nbsp;?&nbsp;» comme suit:

<p>
<example>
ls /etc/rc?.d
</example>

<p>
<prgn>/etc/rc?.d</prgn> renvoie alors une liste de nom de fichiers,
commençant par <prgn>rc</prgn>, suivant d'un caractère et se terminant
pas <prgn>.d</prgn>.

<p>Les caractères spéciaux disponibles sont les suivants:

<p>
<list>
<item> *
<p>
  Correspond à n'importe quel groupe de 0 ou plus de caractères.
<item> ?
<p>
  Correspond à un caractère quelconque mais unique.
<item> <prgn>[...]</prgn>
<p>
  Si vous entourez des caractères de crochets, le résultat est une
  correspondance avec ces caractères. Par exemple, <prgn>[abc]</prgn>
  correspond soit à un <prgn>a</prgn>, soit à un <prgn>b</prgn> ou
  soit à un <prgn>c</prgn>. Si vous ajouter un ^ après le premier
  crochet, on retourne le sens. Ainsi, <prgn>[^abc]</prgn> correspond
  à tous les caractères qui ne sont pas un <prgn>a</prgn>, un
  <prgn>b</prgn> ou un <prgn>c</prgn>. Vous pouvez aussi inclure un
  intervalle comme <prgn>[a-j]</prgn> qui correspond à tout entre
  <prgn>a</prgn> et <prgn>j</prgn>. La correspondance est sensible à
  la casse des caractères donc si vous voulez inclure toutes les
  lettres, vous devz utilisez <prgn>[a-zA-Z]</prgn>.
</list>

<p>
Les motifs d'expansion sont très simples, à partir du moment où vous
les voyez dans des exemples concrets:

<p>
<list>
<item> <prgn>*.txt</prgn>
<p>
  Cela vous fournit la liste de tous les fichiers finissant pas
  <prgn>.txt</prgn> puisque * correspond à tout.
<item> <prgn>*.[hc]</prgn>
<p>
  Cela vous fournit une liste de fichier se terminant soit par
  <prgn>.h</prgn> soit par <prgn>.c</prgn>.
<item> <prgn>a??</prgn>
<p>
  Cela vous fournit la liste de tous les fichiers de trois lettres
  commençant par un <prgn>a</prgn>.
<item><prgn>[^a]??</prgn>
<p>
  Cela vous fournit la liste de tous les fichiers de trois lettres ne
  commençant pas par la lettre <prgn>a</prgn>.
<item> <prgn>a*</prgn>
<p>
  Cela vous fournit l'ensemble des fichiers commençant par
  <prgn>a</prgn> sans tenir compte de leur nombre de lettres.
</list>

</sect>

</chapt>
<chapt> Un peu plus sur les fichiers

<p>
Dans la partie 7.2, nous avons montré comment déplacer et renommer
des fichiers avec <prgn>mv</prgn>, comment les copier avec
<prgn>cp</prgn>, comment les détruire avec <prgn>rm</prgn>, comment
détruire des répertoires avec <prgn>rmdir</prgn> et comment en créer
avec <prgn>mkdir</prgn>. Ce chapitre va couvrir des aspects un peu
plus avancés du traitement de fichiers.

<sect> Permissions

<p>
 Les systèmes Unix et GNU sont paramétrables pour pouvoir autoriser de
 nombreuses personnes à utiliser la même machine tout en conservant
 secrets certains fichiers ou en empêchant certaines personnes de
 modifier certains fichiers. Vous pouvez le vérifier par
 vous-même. Loguez-vous en tant que vous-même, c'est-à-dire <em>PAS en
 root</em>.

<p>
<example>
whoami
</example>

<p>
Ceci pour vérifier que vous n'êtes pas root. Ensuite, entrer la
commande suivante:

<p>
<example>
rm /etc/resolv.conf
</example>

<p>
L'ordinateur devrait vous répondre <prgn>Permission denied</prgn>
<footnote><prgn>Permission
refusée</prgn></footnote>. <prgn>/etc/resol.conf</prgn> est un des
fichiers essentiels de configuration du système. Vous n'êtes pas
autorisé à le modifier ou l'effacer si vous n'êtes pas root. Cela
préserve le système d'une maladresse accidentelle. Si l'ordinateur est
dans un organisme public, comme dans un bureau ou une école, cela le
préserve des utilisateurs travaillant dessus.

<p>
Maintenant, tapez <prgn>ls -l /etc/resolv.conf</prgn>.

<p>
Cela devrait vous renvoyer quelque chose comme cela:

<p>
<example>
-rw-r--r-- 1 root root 119 Feb 23 1997 /etc/resolv.conf
</example>

<p>
L'option <prgn>-l</prgn> de <prgn>ls</prgn> lui demande d'ajouter des
informations additionnelles. Les informations sur la partie droite
sont faciles à interpréter. La taille du fichier fait 119 octets. La
date de dernière modification est le 23 février 1997 et le nom du
fichier est <prgn>/etc/resolv.conf</prgn>. Sur la partie gauche de
l'écran, les choses sont un tout petit peu plus compliquées.

<p>
Tout d'abord, une brève explication technique: <prgn>-rw-r--r--</prgn>
est le <em>mode</em> du fichier, le <prgn>1</prgn> correspond au
nombre de liens physiques vers ce fichier (ou le nombre de fichiers
dans le répertoire) et les deux <prgn>root</prgn> sont les
propriétaires respectifs du fichier et du groupe auquel appartient le
fichier.

<p>
Tout ceci est du charabia. Étudions les choses plus calmement.

<sect1> Les droits de propriété d'un fichier

<p>
Tous les fichiers ont deux <em>propriétaires</em>: un utilisateur et
un groupe. Le cas précédent peut porter à confusion car il y a un
groupe nommé <em>root</em> et en même temps un utilisateur nommé
<em>root</em>. Les groupes sont juste un rassemblement d'utilisateurs
à qui on donne collectivement le droit d'accéder à une partie du
système. Un bon exemple est le groupe <em>games</em>. Vous pouvez
créer un groupe <em>games</em> sur votre ordinateur et le paramétrer
de façon à ce que seuls les gens appartenant à ce groupe aient
l'autorisation de jouer sur la machine.

<p>
Il y a des exemples plus pratiques: considérons le cas de la
configuration d'une machine pour une école. Il y a certains fichiers
dont vous voulez restreindre l'accès aux professeurs seulement, et pas
aux élèves. Vous créez donc un groupe dans lequel vous rassemblez tous
les professeurs. Ensuite, vous pouvez indiquer au système que certains
fichiers appartiennent au groupe <em>professeurs</em> et que personne
d'autre n'y a accès.

<p>
Explorons les groupes du système. En premier lieu, vous pouvez
utiliser la commande <prgn>groups</prgn> du shell. Cela vous fournit
une liste de groupes auxquels vous appartenez:

<p>
<example>
$ groups 
system-wide configuration!permissions!file
ownershipusername dialout: cdrom floppy audio
</example>

<p>
Vous semblez donc n'appartenir qu'à un groupe, qui est identique à
votre nom d'utilisateur. Dans tous les cas, root peut vous ajouter
dans d'autres groupes. L'exemple suivant montre une personne membre de
cinq groupes:

<p>
<example>
less /etc/group
</example>

<p>
Ce fichier contient la liste des groupes disponibles sur votre
système. Remarquez bien le groupe root (le seul membre de ce groupe
est l'utilisateur root) et le groupe qui correspond à votre nom
d'utilisateur. Il y a aussi des groupes comme <em>dialout</em> (les
utilisateurs autorisés à lancer le modem) et <em>floppy</em> (les
utilisateurs qui ont accès au lecteur de disquette). Il est probable
que votre système ne soit pas configuré pour avoir l'usage de ces
groupes. Il est préférable que seul root ait accès au lecteur de
disquettes ou au modem pour le moment. Pour les détails en ce qui
concernent ce fichier, reportez-vous au <prgn>man group</prgn>.

<p>
<example>
ls -l /home
</example>

<p>
Cette commande vous montre que tous les répertoires utilisateurs sont
la propriété de leur utilisateur et de leur groupe personnel.

<p>
<em> Si vous venez d'installer Debian, vous êtes peut-être le seul
utilisateur. Vous pouvez ajouter d'autres utilisateur à l'aide de la
commande <prgn>adduser</prgn>.</em>
</sect1>

<sect1> Mode

<p>
En plus d'être la propriété d'un seul utilisateur et d'un seul groupe,
chaque fichier et répertoire possède aussi un mode qui détermine qui a
le droit de lire, d'écrire et d'exécuter un fichier (et de le lancer
s'il s'agit d'un programme). Il y a d'autre petites fonctionnalités
apportées par le mode mais ce sont des réglages avancées et nous les
laisserons de côté pour le moment.

<p>
Un mode ressemble à cette sortie de <prgn>ls</prgn>:
<prgn>-rw-r--r--</prgn>. À partir de maintenant, nous allons découvrir
neuf ensembles: celui qui contrôle les permissions de
<em>lecture</em>, d'<em>écriture</em> et d'<em>exécution</em> pour le
propriétaire du fichier, pour le groupe auquel se rattache le fichier
et pour les autres personnes (<em>others</em>) (tous ceux du système,
quelque fois appelé le <em>monde</em>).

<p>
Dans la ligne mode, le premier «&nbsp;élément&nbsp;» donne le type de
fichier. Le - signifie que c'est un fichier normal (<em>regular
file</em>). Si nous avions eu <prgn>d</prgn>, cela aurait été un
répertoire<footnote><prgn>d</prgn> pour <em>directory</em> en
anglais</footnote>. Il y a aussi quelques autres possibilités mais qui
sont trop complexes pour le cadre de cette partie. Pour plus détails,
allez voir la partie 15.2.2.

<p>
Les neuf éléments restant sont utilisés pour définir le mode du
fichier. Les neuf bits basics (<em><prgn>r</prgn>ead,
<prgn>w</prgn>rite</em> et <em>e<prgn>x</prgn>ecute</em> pour
l'utilisateur, le groupe et les autres) sont définis en trois blocs de
<prgn>rxw</prgn>.

<p>
Si toutes les permissions sont activées et qu'il s'agit d'un fichier
normal, le mode va ressembler à ceci:

<example>
-rxwrxwrxw
</example>

<p>
Si c'était un répertoire avec toutes les permissions désactivées pour
le monde et activées pour tous les utilisateurs et le groupe, cela
ressemblerait à:

<example>
drxwrxw---
</example>

<p>
Le tableau suivant indique la signification des permission de lecture,
écriture et exécution pour les fichiers et les répertoires:

<p>
<example>
 ---------------------------------------------------------------
|   Code    |  Nom    | Ce que cela permet | Ce que cela permet |
|           |         | aux fichiers       | aux répertoires    |
 ---------------------------------------------------------------
|     r     | lecture |  Examen du contenu |   Liste le contenu |
|           |         |     du fichier     |    du répertoire   |
 ---------------------------------------------------------------
|           |         |    Modification    |Ajout ou destruction|
|     w     | écriture|     du fichier     | de fichiers dans le|
|           |         |                    |    répertoire      |
 ---------------------------------------------------------------
|     x     |exécution| lancer en tant que |Accéder aux fichiers|
|           |         |   commande         | du répertoire      |
 ---------------------------------------------------------------
</example>

<p>
Les modes du répertoire peuvent porter un peu à confusion donc voici
une série d'exemples des effets de combinaisons diverses.

<p>
<example>
r--
</example>

<p>
L'utilisateur, le groupe et les autres avec ces permissions peuvent
afficher le contenu du répertoire mais ne peuvent rien faire
d'autre. Les fichiers contenus dans ce répertoire ne peuvent être lus,
modifiés ou manipulés de quelle que façon que ce soit. La seule action
autorisée consiste à lire le répertoire en lui-même ce qui revient à
afficher ce qu'il contient et donc la liste des fichiers.

<p>
<example>
rw-
</example>

<p>
La permission d'écriture n'a pas d'effet en l'absence de celle
d'exécution donc ce mode se comporte exactement comme le mode
précédent.

<p>
<example>
r-x
</example>
<p>

<p>
Ce mode permet aux fichiers présents dans le répertoire d'être
visibles et permet aussi d'accéder à ces fichiers. Dans tous les cas,
les fichiers ne peuvent être créés ou détruits. <em>Accéder</em>
signifie que vous pouvez voir, changer et exécuter les fichiers
suivant leurs permissions respectives.

<p>
<example>
--x
</example>

<p>
Les fichiers de ce répertoire sont accessibles mais le contenu du
répertoire ne l'est pas. Il vous faut donc connaître à l'avance le nom
du fichier que vous recherchez (à moins d'avoir des talents de
devin). Les fichiers ne peuvent être ni créés ni détruits.

<p>
<example>
rwx
</example>

<p>
Vous pouvez faire tout ce que vous voulez avec les fichiers de ce
répertoire tant que vous respectez leurs permissions respectives.

<p>
Les permissions d'écriture d'un répertoire détermine si vous pouvez
détruire des fichiers dans ce répertoire. Un fichier en lecture seule
pourra être effacé si vous avez les permissions d'écriture dans le
répertoire le contenant. Vous ne pouvez détruire un fichier d'un
répertoire en lecture seule même si vous avez les droits d'écriture
sur le fichier.

<p>
Cela signifie que si vous êtes le propriétaire d'un répertoire, vous
pouvez toujours détruire un de ses fichiers, y compris si ce fichier
appartient à root.

<p>
La permission d'exécution d'un répertoire détermine la possibilité
d'avoir accès aux fichiers - si bien sûr leurs permissions respectives
l'autorisent. Si vous avez le droit d'exécution d'un répertoire, les
droits d'exécution de ses fichiers devraient suivre. Sinon, les
permissions des fichiers ne servent à rien: vous y avez accès dans
tous les cas.
</sect1>

<sect1> Les permissions en pratique

<p>
Cette partie contient une série d'exemples pour montrer comment
utiliser les permissions. Pour changer les permissions, on utilise la
commande <prgn>chmod</prgn>.

<p>
<example>
cd ; touch monfichier
</example>

<p>
Il y a une série de nouveaux trucs ici. En premier, vous pouvez
utiliser <prgn>;</prgn> pour mettre deux commandes sur la même
ligne. Vous pouvez entrer la commande précédente comme suit:

<p>
<example>
$ cd
$ touch monfichier
</example>

<p>
ce qui revient au même que

<p>
<example>
$ cd; touch monfichier
</example>

<p>
Les deux méthodes conduisent au même résultat.

<p>
Rappelez-vous que <prgn>cd</prgn> employé seul vous renvoie dans votre
répertoire personnel. <prgn>touch</prgn> est normalement utilisé pour
modifier la date de création d'un fichier à la date courante. Mais
cela a une autre fonctionnalité intéressante. Si le fichier n'existe
pas, <prgn>touch</prgn> le crée. Ainsi, vous êtes en train de créer un
fichier pour pouvoir faire des expérimentations dessus. Utilisez
<prgn>ls -l</prgn> pour observer que le fichier a bien été créé et
remarquez son mode de permission:

<p>
<example>
$ ls -l
-rw-r--r-- 1 user user 0 Nov 18 22:04 monfichier
</example>

<p>
Bien-sûr, la date et le nom du groupe et de l'utilisateur seront
différents chez vous. La taille du fichier est <prgn>0</prgn> car
<prgn>touch</prgn> a créé un fichier vide. <prgn>-rw-r--r--</prgn> est
le mode de permission par défaut sous Debian.

<p>
<example>
chmod u+x monfichier
</example>

<p>
Cette commande <em>ajoute</em> (<prgn>+</prgn>) des permissions
d'<em>exécution</em> (<prgn>x</prgn>) pour l'<em>utilisateur</em>
(<prgn>u</prgn>) à qui appartient le fichier. Utilisez <prgn>ls
-l</prgn> pour en voir les effets.

<p>
<example>
chmod go-r monfichier
</example>

<p>
Maintenant, vous <em>ôtez</em> (<prgn>-</prgn>) les permissions de
<em>lecture</em> (<prgn>r</prgn>) au <em>groupe</em> (<prgn>g</prgn>)
à qui appartient le fichier et à tous les <em>autres</em>
(<prgn>o</prgn>). À nouveau, utilisez <prgn>ls -l</prgn> pour voir les
modifications.

<p>
<example>
chmod ugo=rx monfichier
</example>

<p>
Ici, vous positionnez (<prgn>=</prgn>) les permissions de lecture et
d'exécution pour l'utilisateur, le groupe et les autres. Cela
positionne les permissions exactement comme vous l'avez spécifié et
enlève les autres permissions. Ainsi, seules les permissions
<prgn>rx</prgn> seront activées, et toutes les permissions
<prgn>w</prgn> seront retirées. À partir de maintenant, personne ne
peut modifier le fichier.

<p>
<example>
chmod a-x monfichier
</example>

<p>
est un raccourci<footnote><prgn>a</prgn> est pour <em>all</em> (tous)
en anglais.</footnote> pour <prgn>ugo</prgn>. Ainsi, seules les
permissions d'exécution vont être retirées.

<p>
<example>
rm monfichier
</example>

Avec cette commande, nous allons tenter de détruire le fichier mais
sans les droits d'écriture. <prgn>rm</prgn> va alors s'assurer de
votre certitude en affichant le message suivant<footnote><prgn>rm:
détruire le fichier protégé en écriture
`monfichier'?</prgn></footnote>:

<p>
<example>
rm: remove 'monfichier', overriding mode 0444 ?
</example>

<p>
Vous devrez répondre en tapant <prgn>y</prgn> et ensuite en appuyant
sur <prgn>Entrée</prgn>. Ceci est une fonctionnalité de
<prgn>rm</prgn> et non une conséquence des permissions. L'autorisation
de détruire un fichier vient des droits sur le répertoire et vous avez
les droits sur ce répertoire. Dans ce cas, <prgn>rm</prgn> essaie
d'être le plus convivial possible en se figurant que si vous ne
vouliez pas changer les permissions (et <em>a fortiori</em> enlever
les droits d'écriture), vous ne vouliez pas plus le détruire et ainsi
il vous demande de faire le choix.

<p>
Qu'est-ce donc cette affaire <prgn>0444</prgn> dans la question de
<prgn>rm</prgn> ? Les modes de permission sont en fait un nombre de 12
bits comme celui-ci: <prgn>000100100100</prgn>. <prgn>0444</prgn> est
représentation octal (i-e en base 8) qui est la base conventionnelle
pour écrire un mode. Ainsi, vous pouvez écrire <prgn>chmod 444
monfichier</prgn> à la place de <prgn>chmod ugo=r monfichier</prgn>.
</sect1>
</sect>

<sect> Présentation des fichiers et de leurs emplacements

<p>
Maintenant que vous êtes capable de naviguer au gré des répertoires,
allons faire un tour auprès des fichiers et des répertoires que vous
avez créés en installant Debian. Si vous êtes curieux, faîtes un
<prgn>cd</prgn> dans chacun d'entre eux et tapez <prgn>ls</prgn> pour
voir leur contenu. Si le résultat ne tient pas dans l'écran, essayez
<prgn>ls | less</prgn> où | est le caractère <em>tube</em> que l'on
trouve généralement au même emplacement que la touche <em>retour
arrière</em><footnote>NDT: du moins chez nos voisins anglo-saxons. Les
francophones, avec des claviers <em>azerty</em>, le trouverons à la
touche 6 en faisant <em>Alt Gr - 6</em>.</footnote>.

<p>
<list>
<item> <prgn>/</prgn>
<p>
  Comme on l'a déjà mentionné, il s'agit du répertoire racine qui
  contient tous les autres répertoires.
<item> <prgn>/root</prgn>
<p>
  Attention, ne confondez pas <prgn>/</prgn> avec <prgn>/root</prgn> ! 
  <prgn>/root</prgn> est le répertoire personnel de l'utilisateur root
  (super-utilisateur). C'est un répertoire appelé <prgn>/root</prgn>
  mais ce n'est pas le répertoire racine (NDT: <em>root directory</em>
  en anglais d'où la confusion chez nos voisins anglophones).
<item><prgn>/home</prgn>
<p>
  C'est l'endroit où l'on place le répertoire personnel de tous les
  utilisateurs normaux - c'est-à-dire tous sauf le root. Chaque
  répertoire personnel est appelé du nom de l'utilisateur; par exemple
  <prgn>/home/jane</prgn>. Si vous utilisez un système de taille
  conséquente, comme pour une école ou une entreprise, votre
  administrateur système a peut-être créé des répertoires
  supplémentaires pour contenir les répertoires personnels:
  <prgn>/home1</prgn> et <prgn>/home2</prgn> par exemple. Dans
  d'autres systèmes, on peut apercevoir un niveau supplémentaire de
  sous-répertoire : 
<example>
  /home/eleves/nomdutilisateur, 
  /home/equipe/nomdutilisateur, etc...
</example>
</list>

<p>
Votre répertoire personnel est l'endroit où vous placez vos travaux
personnels, votre courrier électronique et tous les autres documents,
ainsi que vos fichiers de configurations personnelles. C'est votre «
chez vous&nbsp;» dans le système...

<p>
<list>
<item> <prgn>/bin</prgn>
<p>
  Ce répertoire contient les «&nbsp;binaires&nbsp;» et les fichiers
  exécutables indispensables au fonctionnement du système. Des
  exemples sont le shell (<prgn>bash</prgn>) et les commandes
  relatives aux fichiers comme <prgn>cp</prgn>.  <item>
  <prgn>/sbin</prgn>
<p>
  Ce répertoire contient les «&nbsp;binaires systèmes&nbsp;». Ce sont
  les utilitaires que l'utilisateur root ou l'administrateur système
  auront à utiliser. Vous n'aurez probablement jamais à y avoir accès
  dans votre travail quotidien.  <item> <prgn>/usr</prgn>
<p>
  Ce répertoire contient beaucoup de fichiers susceptibles de vous
  intéresser. Il a de nombreux sous-répertoires. <prgn>/usr/bin</prgn>
  et <prgn>/usr/sbin</prgn> sont très proches de <prgn>/bin</prgn> et
  <prgn>/sbin</prgn> à l'exception près que les fichiers y figurant ne
  sont pas considérés comme «&nbsp;vitaux pour le système&nbsp;».
<p>
  Bien que non essentiel au bon fonctionnement de l'ordinateur,
  <prgn>/usr</prgn> contient bien des applications très utiles pour
  travailler. Ainsi, dans <prgn>/usr</prgn>, vous trouverez les
  répertoires <prgn>/usr/man</prgn>, <prgn>/usr/doc</prgn> et
  <prgn>/usr/info</prgn>. Ils contiennent respectivement les pages de
  manuel, la documentation et les pages info. Et n'oubliez pas non
  plus <prgn>/usr/games</prgn> !
<item> <prgn>/usr/local</prgn>
<p>
  Le système Debian n'installe rien dans ce répertoire. Vous devrez
  l'utiliser pour installer des logiciels que vous compilerez vous
  même ou tout logiciel non contenu dans un paquet Debian. Vous pouvez
  aussi l'installer dans votre répertoire personnel si vous êtes le
  seul à l'utiliser.
<item> <prgn>/etc</prgn>
<p>
  Ce répertoire contient l'ensemble des fichiers de configuration du
  système. Lorsque vous désirez changer quelque chose au système qui
  impacte tous les utilisateurs de votre ordinateur - comme votre
  connexion Internet ou bien un changement de carte vidéo - vous aurez
  probablement à vous loguer en root et à modifier un fichier dans
  <prgn>/etc</prgn>.
<item><prgn>/tmp</prgn>
<p>
  Vous trouverez ici les fichiers temporaires de votre système, la
  plupart d'entre eux créés par le système. Ce répertoire est
  généralement nettoyé régulièrement ou à chaque <em>boot</em> du
  système. Vous pouvez créer des fichiers ici mais gardez à l'esprit
  qu'ils peuvent être détruits automatiquement.
<item> <prgn>/var</prgn>
<p>
  Ce répertoire contient les fichiers «&nbsp;variables&nbsp;» que le
  système change automatiquement. Par exemple, les courriels entrants
  sont stockés ici. Le système garde une trace de ses actions ici. Il
  y a un grand nombre d'autres fichiers engendrés automatiquement
  ici. Vous pouvez prêter attention au contenu du répertoire de
  <prgn>/var/log</prgn> où vous pourrez trouver des messages d'erreurs
  qui peuvent vous aider à comprendre ce qui ne va pas dans votre
  système en cas de défaillance.
</list>

<p>
Il y a évidemment bien d'autres répertoires dans votre système, bien
trop d'ailleurs pour que l'on puisse tous les décrire ici.

<p>
Pour changer quelque chose, vous aurez certainement à vous contenter
de votre répertoire personnel et de <prgn>/etc</prgn>. Sur un système
Debian, il y a rarement une occasion de changer quelque chose d'autre
car tout est automatiquement installé pour vous.

<p>
<prgn>/etc</prgn> est utilisé pour configurer le système comme un
tout. Vous n'utiliserez votre propre répertoire personnel que pour
configurer votre propre environnement et stocker vos propres
données. L'idée de base est de vous confiner dans
<prgn>/home/votrenom</prgn> pour le travail quotidien et ainsi, vous
ne pourrez rien casser ailleurs. À l'occasion, vous vous loguerez en
tant que root pour paramétrer quelque chose mais seulement si c'est
absolument nécessaire. Bien-sûr, si vous utilisez Debian à l'école ou
bien en entreprise et que quelqu'un d'autre est l'administrateur
système, vous n'aurez pas accès au compte root et vous ne pourrez
changer des choses que dans votre compte personnel (ou dans les
comptes où vous avez accès). Ceci limite ce que vous pouvez faire avec
le système.
</sect>

<sect> La compression de fichier avec <prgn>gzip</prgn>

<p>
Il est souvent bien pratique de réduire la taille d'un fichier -
disons, pour le télécharger plus rapidement, ou bien pour gagner de la
place sur votre disque dur. Le programme affecté à cette tâche est
<prgn>gzip</prgn> (GNU zip). Voici comment il fonctionne:

<p>
<example>
$ cd; cp /etc/profile ./monfichier
</example>

<p>
Cela vous renvoie dans votre répertoire personnel et copie un fichier
arbitrairement choisi (<prgn>/etc/profile</prgn>) dans votre
répertoire courant en le renommant <prgn>monfichier</prgn>.

<p>
<example>
$ ls -l
</example>

<p>
Affiche le contenu du répertoire courant. Remarquez bien la taille de
<prgn>monfichier</prgn>.

<p>
<example>
$ gzip monfichier
</example>

<p>
Ceci comprime <prgn>monfichier</prgn>.

<p>
<example>
$ ls -l
</example>

<p>
Observez le résultat de cette commande: <prgn>monfichier</prgn>
s'appelle maintenant <prgn>monfichier.gz</prgn>. Il est aussi beaucoup
plus petit.

<p>
<example>
$ gunzip monfichier.gz; ls -l
</example>

<p>
Ceci décomprime le fichier. Remarquez bien que <prgn>monfichier</prgn>
est retourné dans son état d'origine. Et remarquez aussi que pour
décomprimer, il faut utiliser <prgn>gunzip</prgn> et non
<prgn>gzip</prgn>.

<p>
<example>
$ rm monfichier
</example>

<p>
Utilisez cette commande pour effacer le fichier puisqu'on ne l'avait créé
juste que pour expérimenter.
</sect>

<sect> Rechercher des fichiers

<p>
Il y a deux utilitaires pour rechercher un fichier: <prgn>find</prgn>
et <prgn>locate</prgn>. <prgn>find</prgn> recherche vraiment les
fichiers dans leur état présent. <prgn>locate</prgn> recherche dans un
index engendré automatiquement par le système chaque matin à 6h42
(c'est un <prgn>cron</prgn> dont on trouvera une explication un peu
plus loin dans le livre). <prgn>locate</prgn> ne sera jamais capable
de trouver un fichier créé après la génération de l'index. Bien-sûr,
puisque <prgn>locate</prgn> recherche dans un index, il est beaucoup
plus rapide - un peu comme rechercher dans l'index d'un livre plutôt
qu'effeuiller chaque page.

<p>
Pour comparer les deux façons de faire une recherche, on va supposer
que l'on ne se rappelle plus où est le fichier de configuration
<prgn>XF86Config</prgn> du serveur X.

<p>
<example>
$ locate XF86Config
</example>

<p>
Cela devrait être très rapide. Vous allez obtenir une liste de noms de
fichier <em>contenant</em> <prgn>XF86Config</prgn>, quelque chose
comme:

<p>
<example>
/etc/X11/XF86Config
/usr/X11R6/lib/X11/XF86Config
/usr/X11R6/lib/X11/XF86Config.eg
/usr/X11R6/man/man5/XF86Config.5x.gz
</example>

<p>
Maintenant, essayez la commande <prgn>find</prgn>:

<p>
<example>
$ find / -name XF86Config
</example>

<p>
Vous allez entendre une activité intense du disque dur, et cela va
prendre un temps assez long. Le résultat devrait ressembler à:

<p>
<example>
/ect/X11/XF86Config
/usr/X11R6:lib/X11/XF86Config
find: /var/spool/cron/atjobs: Permission denied
find: /var/spool/cron/atspool: Permission denied
find: /var/lib/xdm/authdir: Permission denied
</example>

<p>
Remarquez que <prgn>find</prgn> n'a trouvé que les fichiers appelés
<em>exactement</em> <prgn>XF86Config</prgn> et non pas ceux contenant
cette chaîne de caractères. <prgn>find</prgn> a aussi essayé de
rechercher dans tous les répertoires du système - y compris ceux dont
vous n'avez pas les droits d'accès. C'est la raison pour laquelle vous
avez les messages <prgn>Permission denied</prgn> (<prgn>Permission non
accordée</prgn>).

<p>
Leur syntaxe aussi est différente. Avec <prgn>find</prgn>, vous devez
choisir à partir de quel répertoire effectuer la recherche alors que
<prgn>locate</prgn> choisit automatiquement le répertoire racine. Et
vous devez spécifiez votre recherche en utilisant l'option
<prgn>-name</prgn>. Vous pouvez aussi rechercher des fichiers avec des
tas d'autres critères, comme les dates de modification ou les
propriétaires. Pour utiliser <prgn>find</prgn> dans une recherche de
fichiers dont le nom contient <prgn>XF86Config</prgn>, il vous faut
utiliser un motif de recherche:

<p>
<example>
$ find / -name '*XF86Config*'
</example>

<p>
Comme la plupart des outils en lignes de commandes, <prgn>find</prgn>
accepte des motifs comme arguments.

<p>
De façon générale, <prgn>find</prgn> est un outil beaucoup plus
puissant et <prgn>locate</prgn> est un outil très rapide pour des
recherches journalières. L'intégralité des recherches possible
prendrait un temps fou à expliquer. Pour plus de détails, tapez
<prgn>info find</prgn> qui vous conduira au travers des méandres des
subtilités de <prgn>find</prgn> et <prgn>locate</prgn>.
</sect>

<sect> Déterminer le contenu d'un fichier

<p>
Debian vous offre un utilitaire capable de deviner le contenu d'un
fichier à votre place. Bien que cela ne soit pas à 100% sûr, vous
pouvez utiliser cette commande pour explorer votre système.

<p>
<example>
$ file /bin/cp
</example>

<p>
Vous devriez avoir quelque chose comme ceci:

<p>
<example>
/bin/cp: ELF 32-bit LSB executable, Intel 80386, version 1, dynamically linked (uses shared libs), stripped
</example>

<p>
Si l'on retire les parties techniques, on peut dire que c'est un
fichier exécutable pour machine Intel.

<p>
<example>
$ file /etc/init.d/boot
</example>

<p>
La commande précédente vous donne la réponse suivante:

<p>
<example>
/etc/init.d/boot: Bourne shell script text
</example>

<p>
ce qui veut dire que c'est un fichier texte contenant un script écrit
en Bourne shell.
</sect>

<sect> Utiliser un gestionnaire de fichier

<p>
Plutôt que manipuler les fichiers à la main, vous pouvez utilisez un
<em>gestionnaire de fichiers</em>. Si vous manipulez de nombreux
fichiers à la fois, un gestionnaire de fichiers peut rendre votre
travail plus efficace.  Il y a des gestionnaires de fichiers orienté
texte, comme <prgn>GNU Midnight Commander (mc)</prgn> et un grand
nombre de gestionnaires de fichiers pour X Window (par exemple
<prgn>gmc</prgn> qui est la version X Window de <prgn>GNU Midnigt
Commander</prgn>).

<p>
Décrire chacun d'entre est hors du propos de ce livre mais vous pouvez
les essayer si la ligne de commande ne vous sied pas.
</sect>

</chapt>
<chapt> Travailler avec des fichiers textes

<p>
Les fichiers textes sont prédominants sur un système GNU-Linux. Ils se
trouvent absolument partout, des fichiers de documentations aux
fichiers de configuration. Par chance, il est très facile de les
manipuler.

<sect> Lire des fichiers textes

<p>
Un fichier texte est simplement un fichier qui ne contient que des
caractères interprêtables par un être humain. Il n'y a rien à dire de
spécial de plus à son sujet. L'autre type de fichier est le fichier
binaire qui est destiné à être interprêté par l'ordinateur.

<p>
Vous pouvez visualiser n'importe quel type de fichiers avec le pagineur 
<prgn>less</prgn> si vous l'avez installé (installez-le si vous ne
l'avez pas, c'est très simple). Tapez <prgn>less /etc/profile</prgn>
pour lire un exemple de fichier texte. Remarquez bien que vous
pouvez lire des caractères mêmes si leur signification reste
obscure. Tapez <prgn>less /bin/ls</prgn> pour visualiser un fichier
binaire. Comme vous pouvez vous en apercevoir, le programme
<prgn>ls</prgn> n'est pas lisible par un être humain.

<p>
Parfois, vous trouverez des fichiers finissant par <prgn>.gz</prgn>
. Ces fichiers sont lisibles avec <prgn>zless</prgn>. Vous pouvez
l'utiliser comme ceci:

<p>
<example>
zless /usr/doc/ae/changelog.Debian.gz
</example>

<p>
<em> <prgn>zless</prgn> est idéal pour lire la documentation qui est la
plupart du temps comprimée au format <prgn>.gz</prgn></em> .

<p>
La différence entre les deux sortes de fichiers est purement en
rapport avec ce qu'ils contiennent à la différence de certains autres
systèmes (comme le DOS ou MacOS) qui les traitent de façon différente.

<p>
Les fichiers textes peuvent contenir des scripts shell, de la
documentation, des notices de <em>copyrights</em> ou tout autre texte
lisible par un être humain.

<p>
Incidemment, ceci illustre la différence entre le <em>code source</em>
et les <em>binaires exécutables</em>. <prgn>/bin/ls</prgn> est un
fichier binaire exécutable que vous pouvez télécharger sur votre
Debian mais vous pouvez aussi télécharger un fichier texte qui
explique à l'ordinateur comment créer <prgn>/bin/ls</prgn>. Le fichier
texte est alors le code source. Comparer la nature de
<prgn>/bin/ls</prgn> et <prgn>/etc/profile</prgn> illustre combien le
code source est important pour quelqu'un qui veut comprendre ou
modifier une partie d'un logiciel. Les logiciels libres vous
fournissent, à vous ou bien à vos consultants, tout le code source de
chaque application.
</sect>

<sect> Les éditeurs de textes

<p>
Un <em>éditeur de textes</em> est le programme utilisé pour créer ou
changer le contenu d'un fichier texte. La plupart des systèmes
d'exploitation possède leur éditeur de textes: DOS a
<prgn>edit</prgn>, Windows a <prgn>Notepad</prgn> et MacOS a
<prgn>SimplyText</prgn>.

<p>
Debian fournit une grande quantité d'éditeurs de
textes. <prgn>vi</prgn> et <prgn>Emacs</prgn> en sont les deux grands
classiques et ce sont probablement les plus puissants et les plus
utilisés. <prgn>vi</prgn> et <prgn>Emacs</prgn> sont tous les deux
complexes et requièrent un certain apprentissage, mais ils peuvent
éditer du texte avec une efficacité extraordinaire. <prgn>Emacs</prgn>
tourne à la fois en mode console et sous X Window; <prgn>vi</prgn>
tourne normalement seulement en mode console mais la variante
<prgn>vim</prgn> possède une option <prgn>-g</prgn> qui lui permet de
tourner sous X.

<p>
Il existe des éditeurs de textes plus simples comme
<prgn>nedit</prgn>, <prgn>ae</prgn>, <prgn>jed</prgn> et
<prgn>xcoral</prgn>. <prgn>nedit</prgn> et <prgn>xcoral</prgn>
fournissent une interface basée sur le système X Window très
conviviale et facile à utiliser. Il existe aussi de multiples variantes
de <prgn>vi</prgn>. Vous pouvez aussi trouver une variante de
<prgn>Emacs</prgn> appelée <prgn>XEmacs</prgn>.

<p>
Ce livre n'aborde pas l'utilisation d'un éditeur en détail, bien que
nous allons rapidement faire une introduction à <prgn>ae</prgn> qui
est petit, rapide et peut être trouvé sur les disquettes de secours de
Debian. Il est donc recommandé de savoir s'en servir au cas
où... Lorsque vous désirerez faire de l'édition de texte de façon plus
sérieuse, voyez du côté de <prgn>vim</prgn> ou de <prgn>GNU
Emacs</prgn>. <prgn>Emacs</prgn> fournit un excellente présentation
interactif<footnote>mais en anglais...</footnote> de ses capacités;
pour le lire, lancer <prgn>Emacs</prgn> avec la commande
<prgn>emacs</prgn> et taper <prgn>F1 t</prgn>. <prgn>Emacs</prgn> est
un très bon choix pour les nouveaux utilisateurs intéressés par un
éditeur tout usage ou pour la programmation.
</sect>

<sect> Utiliser <prgn>ae</prgn>

<p>
Vous pouvez lancer <prgn>ae</prgn> en lui donnant le nom d'un fichier
à éditer, comme cela:

<p>
<example>
$ ae fichier.txt
</example>

<p>
Cela va vous faire entrer dans l'écran d'édition. La partie supérieure
vous propose une aide sommaire; la partie inférieure montre le nom du
fichier que vous éditez. Se déplacer dans cet éditeur est simple: il
suffit d'utiliser les flèche de déplacement. Vous pouvez sauver le
fichier en tapant <prgn>C-x C-s</prgn> et ensuite sortir en tapant
<prgn>C-x C-c</prgn>. Lorsque vous serez à l'aise, vous pourrez
supprimer l'aide en tapant <prgn>C-x C-h</prgn>. C'est tout ! Gardez à
l'esprit que cet éditeur ne vous permet que de l'édition très
basique. Pour programmer, ou bien pour des travaux d'édition plus
avancés, vous chercherez un autre éditeur de textes comme il a été dit
précédemment.
</sect>

</chapt><chapt> Le système X Window

<p>
Le but de ce chapitre est de décrire l'interface graphique utilisateur
du système X Window. Cela suppose que vous avez réussi à configurer X
comme décrit dans le manuel d'installation (même si le manuel
d'installation n'est pas encore écrit; vous aurez besoin d'utiliser le
XFree86 HOWTO, le contenu de <prgn>/usr/doc/X11</prgn> et ce
chapitre). Une fois X installé, vous pouvez entrer dans
l'environnement X soit en tapant  <prgn>startx</prgn> soit via
<prgn>xdm</prgn>: cela dépend de vos choix pendant la configuration.

<sect> Introduction à X

<p>
Une <prgn>GUI</prgn> (<em>Graphical User Interface</em>, une interface
graphique utilisateur) fait partie des systèmes Windows et de
MacOS. Il est pratiquement impossible d'écrire une application pour
ces systèmes sans utiliser ces GUI et les systèmes ne peuvent être
utilisés à l'aide de lignes de commandes. GNU-Linux est plus modulaire
car il est composé de petits composants indépendants que l'on peut ou
non utiliser suivant ses besoins ou ses préférences. Un des ces
composants est le système X Window, que l'on appelle simplement X.

<p>
Ce composant est aussi appelé parfois X11. Remarquez bien que
l'appellation «&nbsp;X Windows&nbsp;» est incorrecte.

<p>
X en lui-même est une manière pour les programmes de discuter avec
la souris et la carte vidéo sans savoir quel type de matériel il y a
au bout. En fait, c'est une <em>abstraction</em> du matériel
graphique. Les applications des utilisateurs parlent au serveur X dans
le langage du serveur X, le serveur X le traduisant alors dans le
langage de votre matériel. Cela signifie que votre programme n'a qu'à
être écrit une fois et qu'ensuite il tournera sur tous les
ordinateurs.

<p>
Dans le jargon de X, le programme qui parle au matériel est connu sous
le vocable <em>serveur X</em>. Les applications qui demandent au
serveur X d'afficher une fenêtre sur l'écran sont appelés <em>clients
X</em>. Le serveur X inclut un pilote pour la carte vidéo et donc vous
devez avoir un serveur X qui reconnaît votre carte vidéo.

<p>
Le serveur X ne fournit aucune fonctionnalité que l'on peut attendre
d'une <em>GUI</em>, comme redimensionner une fenêtre ou bien les réarranger. Un
client X spécial, appelé le <em>gestionnaire de fenêtres</em>, dessine
les bords des fenêtres et les barres de titre, redimensionne et
réarrange les fenêtres et fournit des facilités pour lancer d'autres
clients X via un menu. Des gestionnaires de fenêtres spécifiques
peuvent avoir d'autres fonctionnalités.

<p>
Les gestionnaires de fenêtres présents dans un système Debian sont
<prgn>fvwm</prgn>, <prgn>fvwm2</prgn>, <prgn>icewm</prgn>,
<prgn>afterstep</prgn>, <prgn>olvwm</prgn>, <prgn>wmaker</prgn>,
<prgn>twm</prgn> et <prgn>enlightenment</prgn>. Vous devrez
probablement tous les essayer avant de ne garder que votre favori.

<p>
Ni le serveur X, ni le gestionnaire de fenêtres ne fournissent de
<em>gestionnaire de fichiers</em>, c'est-à-dire qu'il n'existe pas de
fenêtres contenant les icônes de vos fichiers et répertoires. Vous
pouvez lancer un gestionnaire de fichiers en tant qu'application
séparée, et il y en a de nombreux de disponibles. Le projet de bureau
GNOME se développe autour  d'un gestionnaire de fichiers basé sur des
icônes et sur d'autres fonctionnalités basées sur des
<em>GUI</em>. Allez voir la page
GNOME<footnote>http://www.gnome.org/</footnote> pour obtenir les
dernières nouvelles.

<p>
La dernière fonctionnalité de X est sa <em>transparence au
réseau</em>: cela signifie que les clients X ne s'occupent pas de
savoir s'ils discutent avec un serveur X tournant sur la même machine
qu'eux ou sur un serveur X fonctionnant quelque part sur le réseau. De
façon pratique, cela veut dire que vous pouvez faire tourner à
distance votre programme sur une autre machine très puissante et
sortir l'affichage sur votre machine.
</sect>

<sect> Lancer l'environnement X

<p>
Il y a deux façons de lancer X. La première est de le lancer
manuellement aussitôt que vous en avez besoin. Pour ce faire,
Loguez-vous dans une console et tapez <prgn>startx</prgn>. Cela lance
X et vous met automatiquement sur sa console virtuelle.

<p>
La seconde façon (et recommandée) de lancer X est d'utiliser
<prgn>xdm</prgn> (<em>X display manager</em>, le gestionnaire
d'affichage graphique). Basiquement, <prgn>xdm</prgn> vous propose un
joli prompteur graphique de login sur la console virtuelle de X
(probablement la 7) et vous pouvez vous loguer à partir de là.

<p>
Par défaut, n'importe quelle méthode lancera aussi une
<prgn>xterm</prgn> qui est une petite fenêtre contenant un prompteur
de shell. À partir de ce prompteur, vous pouvez taper n'importe
quelles commandes comme vous le faisiez sur une console texte. Vous
pouvez ainsi refaire tous les exemples du livre en utilisant
l'<prgn>xterm</prgn>. La seule différence entre une <prgn>xterm</prgn>
et la console texte est qu'il n'est pas nécessaire de se loguer dans
l'<prgn>xterm</prgn> puisque vous l'êtes déjà sous X.

<p>
Il y a d'autre part beaucoup de choses que vous ne pouvez faire que
sous X et dont on va parler dans ce chapitre.

<p>
<em>Attention: la fenêtre par défaut de l'<prgn>xterm</prgn> a une
toute petite fonte. Si vous avez un tout petit moniteur ou une
définition élevée ou bien encore de mauvais yeux, il se peut que vous
vouliez changer cet état de fait. Pour ce faire, effectuez les
étapes suivantes:</em>

<p>
<list>
<item>
  Déplacez le curseur de la souris au centre de la fenêtre
  <prgn>xterm</prgn>.
<item>
  Appuyez sur la touche <em>Control</em> et le bouton droit de la
  souris simultanément. Vous devriez voir apparaître un menu de
  fontes.
<item>
  Pointez sur la fonte que vous voulez et relâchez le bouton de la
  souris.
</list>
</sect>

<sect> Les opérations élémentaires sous X

<p>
Il y a certaines opérations très communes sous X avec lesquelles il va
falloir vous familiariser. Cette partie décrit quelques opérations
élémentaires que vous pouvez trouver très pratiques.

<sect1> La souris

<p>
La souris sous X fonctionne presque de la même façon que sous les autres
systèmes d'exploitation à l'exception du fait qu'elle possède trois
boutons. Si votre souris n'en possède que deux, vous pouvez simuler le
troisième bouton du milieu en appuyant sur les deux boutons
simultanément. Ce n'est pas très pratique; donc investir dans une
souris trois boutons bon marché n'est pas une mauvaise idée. Il y en a
de disponible chez tous les détaillants informatiques.

<p>
Les boutons sont numérotés de gauche à droite, en supposant que vous
placiez votre souris dans votre main droite. Le premier bouton est
alors sur la gauche, le deuxième au milieu et le troisième sur la
droite. Vous pouvez rencontrer soit la numérotation soit les positions
dans la documentation.

<p>
X possède une fonctionnalité interne simple de copier-coller. Pour
sélectionner le texte à copier, vous devez à cliquer puis à déplacer la
souris avec le bouton gauche. Cela devrait sélectionner le texte à
copier, en supposant bien sûr que l'application en question supporte
le copier-coller. Pour restituer le texte, vous n'avez qu'à cliquer
avec le bouton du milieu dans une autre application X. Par exemple,
vous recevez un courriel contenant une URL. Vous pouvez la
sélectionner avec le bouton gauche et ensuite cliquer dans le champ
<em>ad hoc</em> de votre butineur avec le bouton du milieu pour la
recopier.
</sect1>

<sect1> Les clients X

<p>
Les programmes communiquant avec le serveur X sont appelés des <em>clients
X</em>. La plupart de ces programmes lui demandent d'afficher une fenêtre à
l'écran.

<p>
Vous pouvez lancer un client X de la même façon que vous lancez un
autre programme Debian. Tapez simplement le nom du programme en ligne
de commandes. Essayez de taper <prgn>xterm</prgn> dans la fenêtre
<prgn>xterm</prgn> déjà existante et vous aurez une nouvelle fenêtre
<prgn>xterm</prgn> qui apparaîtra à l'écran.

<p>
Vous devez vous apercevoir que la première <prgn>xterm</prgn> est
bloquée car le shell attend que la seconde <prgn>xterm</prgn> se
finisse. Pour éviter ce problème, vous devez lancer le client X en
arrière-plan, en utilisant le & après le nom de la commande, comme
ceci: <prgn>xterm &</prgn>. Si vous oubliez, vous pouvez lancer un
processus déjà existant en arrière-plan: commencez par le suspendre
avec <em>Ctrl-z</em> et ensuite placez-le en arrière-plan avec la
commande <prgn>bg</prgn>.

<p>
Si vous utilisez régulièrement un programme, votre gestionnaire de
fenêtres doit vous fournir un moyen plus pratique de le lancer via un
menu graphique.
</sect1>
<sect1> Problèmes

<p>
Parfois, lorsque vous lancez un client X à partir d'un menu graphique,
vous n'arrivez pas à voir les messages d'erreurs en cas d'échec. Vous
pouvez les trouver dans le fichier <prgn>~/.xsession-errors</prgn>.
</sect1>

<sect1> Quitter l'environnement X

<p>
Pour sortir de X, il est nécessaire d'utiliser un
menu. Malheureusement pour les débutants, cela change avec chaque
gestionnaire de fenêtres et pour la plupart d'entre eux, cela peut
être fait de nombreuses façons différentes. S'il existe un menu
évident, rechercher une entrée du style <em>Exit</em> (quitter) ou
bien <em>Close the Window Manager</em> (Fermer le gestionnaire de
fenêtres). Si vous n'apercevez aucun menu, essayez de cliquer avec
chacun des boutons sur l'arrière-plan de l'écran. Si tout cela a
échoué, vous pouvez toujours tuer le serveur X en pressant sur la
combinaison <em>Ctrl-Alt-Backspace</em>. Bien entendu, tuer le serveur
vous fait perdre toutes les données non sauvegardées des applications
encore ouvertes.
</sect1>

<sect1> Personnaliser le lancement de X

<p>
Lorsque vous lancez X, Debian exécute quelques scripts shell qui
lancent votre gestionnaire de fenêtres et d'autres clients X. Par
défaut, il y a un gestionnaire de fenêtres, un <prgn>xconsole</prgn>
et une <prgn>xterm</prgn>.

<p>
Pour personnaliser votre lancement de X, le fichier
<prgn>/etc/X11/config</prgn> doit contenir la ligne
<prgn>allow-user-xsession</prgn>. Si ce n'est pas le cas, loguez-vous
en root et ajoutez la maintenant. Ensuite reloguez en tant que
vous-même et continuez cette présentation.

<p>
Vous pouvez voir ce que fait Debian au lancement de X dans le fichier
<prgn>/etc/X11/Xsession</prgn>. Remarquez bien que vous pouvez changer
le comportement de <prgn>/ect/X11/Xsession</prgn> en modifiant le
fichier <prgn>/ect/X11/config</prgn> qui spécifie les caractéristiques
du système par défaut.

<p>
Pour lancer les clients de votre choix au démarrage de X, vous devez
créer un fichier script exécutable appelé <prgn>.xsession</prgn> dans
votre répertoire personnel.

<p>
<example>
$ touch ~/.xession
</example>

<p>
pour le créer et

<p>
<example>
$ chmod u+x ~/.xsession
</example>

<p>
pour le rendre exécutable.

<p>
Une fois que <prgn>.xession</prgn> est créé, il est nécessaire de
le modifier pour pouvoir faire quelque chose d'utile avec votre éditeur
de textes favori. Vous pouvez faire ce que vous voulez dans ce
script. Dans tous les cas, lorsque les processus du script
s'arrêteront, la session X aussi s'arrêtera.

<p>
De façon pratique, cela signifie que vous devez toujours terminer vos
scripts avec un appel à <prgn>exec</prgn>. Quelque soit le programme
que vous appelez avec <prgn>exec</prgn>, il remplacera le processus en
cours par ce programme et ainsi les commandes suivantes après la ligne
<prgn>exec</prgn> seront ignorées. Le programme que vous appellerez via
<prgn>exec</prgn> deviendra le nouveau propriétaire du processus de
script, ce qui signifie que X s'arrêtera lorsque le nouveau programme
s'arrêtera.

<p>
Mettez par exemple à la fin de votre <prgn>.xsession</prgn> une ligne
avec <prgn>exec fvwm</prgn>. Cela signifie que le gestionnaire de
fenêtres <prgn>fvwm</prgn> sera lancé au démarrage de X. Lorsque vous
quitterez votre gestionnaire de fenêtres <prgn>fvwm</prgn>, vous
quitterez aussi la session X et tous les autres clients seront
fermés. Il n'est pas absolument nécessaire de lancer un gestionnaire
de fenêtres ici; vous pouvez y écrire <prgn>exec xterm</prgn> et dans
ce cas, tapez <prgn>exit</prgn> dans cette <prgn>xterm</prgn>
particulière fermera toute la session X.

<p>
Si vous désirez lancer d'autres clients avant votre <prgn>exec</prgn>,
il sera nécessaire de les lancer en arrière-plan. Sinon,
<prgn>.xsession</prgn> s'arrêtera jusqu'à ce que chaque client
existant disparaisse, et ainsi de suite, ligne après ligne. Voyez la
partie précédente pour envoyer un processus en arrière-plan
(basiquement, vous devez ajouter un & à la fin de la ligne, comme pour
<prgn>xterm&</prgn>).

<p>
Vous pouvez tirer parti de ceci. Si vous désirez lancer des commandes
à la fin de votre session X, vous pouvez lancer votre gestionnaire de
fenêtres, ou quoi que ce soit d'autre équivalent, dans votre
<prgn>.xsession</prgn> et attendre qu'il finisse. Pour ce faire,
n'utilisez pas <prgn>exec</prgn> ni les &. Entrez simplement
<prgn>fvwm</prgn>. Ensuite, placez les commandes de votre choix après
<prgn>fvwm</prgn>.

<p>
Quelques exemples de fichiers <prgn>.xession</prgn> devraient vous
aider. Dans les exemples, remplacez <prgn>fvwm</prgn> par le
gestionnaire de fenêtres de votre choix.

<p>
Le plus simple des <prgn>.xsession</prgn> est celui qui ne fait que
lancer un gestionnaire de fenêtres:

<p>
<example>
exec fvwm
</example>

<p>
Cela lance <prgn>fvwm</prgn> et la session X s'achève lorsque l'on
quitte <prgn>fvwm</prgn>. Si vous faîtes la même chose mais sans le
<prgn>exec</prgn>, rien ne semblera différent à première vue. Mais en
arrière-plan, <prgn>.xsession</prgn> sera en attente des réactions de
<prgn>fvwm</prgn> et <prgn>.xsession</prgn> ne s'arrêtera qu'à la fin
de <prgn>fvwm</prgn>. Utilisez <prgn>exec</prgn> est plus léger car
<prgn>fvwm</prgn> remplace alors <prgn>.xsession</prgn> plutôt que
d'attendre qu'il s'arrête. Vous pouvez le vérifier à l'aide des
commandes <prgn>ps</prgn> ou <prgn>top</prgn>.

<p>
Un fichier <prgn>.xsession</prgn> plus complet lance quelques clients
X avant de lancer le gestionnaire de fenêtres. Par exemple, vous
pouvez avoir envie d'avoir des <prgn>xterm</prgn> et un
<prgn>xclock</prgn> après le démarrage de X. Pas de problème: entrez
simplement <prgn>xterm& xterm& xclock& exec fvwm</prgn>. Deux
<prgn>xterms</prgn> se lanceront au démarrage en arrière-plan, ainsi
qu'un <prgn>xclock</prgn> et ensuite le gestionnaire de fenêtres sera
lancé. Lorsque vous quittez le gestionnaire de fenêtres, vous
quitterez aussi X.

<p>
Vous pouvez essayer sans la mise en arrière-plan pour voir ce qui se
passe. Entrez la commande: <prgn>xterm xclock exec
fvwm</prgn>. <prgn>xterm</prgn> se lance, et attend que vous en
sortiez. Ensuite, <prgn>xclock</prgn> se lance. Vous devez quitter
<prgn>xclock</prgn> pour lancer <prgn>fvwm</prgn>. Les commandes sont
lancées séquentiellement car le script attend que chacune d'entre
elles se finisse avant passer à la suivante.

<p>
Vous pouvez utiliser le caractère séquentiel de cette exécution à
votre avantage. Peut-être avez-vous envie de garder chaque jour une
trace de l'heure de votre arrêt de travail :

<p>
<example>
xterm&
xclock&
fvwm
date >> ~/heures-de-sortie
</example>

<p>
Cela va mettre en arrière-plan <prgn>xterm</prgn> et
<prgn>xclock</prgn> et lancer <prgn>fvwm</prgn> et attendre qu'il
finisse. À la sortie de <prgn>fvwm</prgn>, cela exécutera la dernière
ligne, qui extrait la date courante et l'envoie dans le fichier
<prgn>~/heures-de-sortie</prgn>.

<p>
Pour finir, vous pouvez avoir un programme autre qu'un gestionnaire de
fenêtres pour déterminer la sortie du serveur X:

<p>
<example>
xclock&
fvwm&
exec xterm
</example>
 
<p>
Ce script va envoyer <prgn>xclock</prgn>et <prgn>fvwm</prgn> en
arrière-plan et se remplacer par <prgn>xterm</prgn>. Lorsque vous
quittez cette <prgn>xterm</prgn>, votre session X s'arrête.

<p>
La meilleure façon d'apprendre comment fonctionne
<prgn>.xession</prgn> est encore de l'essayer. N'oubliez pas de
le rendre rendre  exécutable: l'oublier est une erreur très classique.
</sect1>
</sect>

</chapt><chapt> Les systèmes de fichiers

<p>
Un système Debian utilise un système de fichiers pour stocker et gérer
vos données. Ce chapitre est une introduction au système de fichiers,
décrivant comment ajouter et retirer des systèmes de fichiers et
comment sauvegarder votre système.

<sect> Concepts

<p>
C'est probablement une bonne idée de faire un peu de théorie avant de
discuter de l'utilisation des disques. En particulier, vous devez
comprendre le concept de <em>système de fichiers</em>. Cela peut être
un peu déroutant à cause des significations diverses d'un système de
fichiers.

<p>
<em>Le</em> système de fichiers concerne l'arborescence entière des
répertoires qui débute par le répertoire racine «&nbsp;/&nbsp;» comme
décrit dans les chapitres précédents.

<p>
Un système de fichiers signifie généralement n'importe quelle
organisation de fichiers et répertoires sur un périphérique physique
particulier. «&nbsp;Organisation&nbsp;» signifie la structure
hiérarchique des répertoires et toute les informations sur les
fichiers que l'on veut garder: leur taille, leurs permissions,
etc... Ainsi, vous pourriez avoir un système de fichiers sur votre
disque dur et un autre sur chacune de vos disquettes.

<p>
On utilise aussi le terme «&nbsp;système de fichiers&nbsp;» pour
désigner le <em>type particulier</em> de système de fichiers. Par
exemple, MS-DOS et Windows 3.1 organisent les fichiers d'une certaine
façon: les noms de fichiers ne peuvent dépasser huit caractères par
exemple et il n'existe aucune information de permission sur les
fichiers. Linux appelle ça le système de fichier
<prgn>msdos</prgn>. Linux a aussi son propre système de fichiers
appelé <prgn>ext2</prgn> (version 2 du système de fichiers
<prgn>ext</prgn>). Vous utiliserez la plupart du temps le système de
fichiers <prgn>ext2</prgn> à moins d'accéder à des fichiers issus
d'autres systèmes d'exploitation, ou bien d'avoir des besoins
particuliers.

<p>
Tout périphérique physique que vous désirez utiliser pour garder des
fichiers doit avoir au moins un système de fichiers. Cela signifie un
système de fichiers au second sens du terme, c'est-à-dire une
hiérarchie de fichiers et de répertoires avec l'information qui va
avec. On parle là du troisième sens. Si vous avez plus d'un système de
fichiers sur un périphérique unique, chaque système de fichiers peut
avoir un type différent. Par exemple, vous pouvez avoir en même temps
une partition DOS et une partition Linux sur votre disque dur.
</sect>

<sect> <prgn>mount</prgn> et <prgn>/etc/fstab</prgn>

<p>
Cette partie décrit comment monter une disquette ou un lecteur ZIP,
parle du répertoire <prgn>/dev</prgn> et discute comment l'arbre des
répertoires peut se distribuer sur de nombreux périphériques physiques
ou des partitions.

<sect1> Monter un système de fichiers

<p>
Dans un système GNU-Linux, il n'y a pas forcément de correspondance
entre les répertoires et les périphériques physiques comme cela existe
sous Windows pour lequel chaque périphérique a son propre arbre de
répertoires commençant par une lettre (comme C:\).

<p>Au lieu de ça, chaque périphérique physique, un disque dur ou bien
une disquette, peut contenir un ou plusieurs systèmes de
fichiers. Pour rendre un système de fichiers accessible, on lui donne
un répertoire particulier dans l'autre système de fichiers. Pour
éviter des problèmes de circularité le système de fichiers racine (qui
contient le répertoire racine «&nbsp;/&nbsp;») n'est contenu dans
aucun autre système de fichiers. Vous y avez accès automatiquement
après avoir lancé Debian.

<p>
Un répertoire dans un système de fichiers qui contient un autre
système de fichiers est appelé <em>point de montage</em>. Un point de
montage est un répertoire dans un premier système de fichier (sur un
périphérique, comme votre disque dur par exemple), qui
«&nbsp;contient&nbsp;» un second système de fichiers, lequel peut être
placé ailleurs, sur un lecteur de disquette par exemple. Pour accéder
à un système de fichiers, vous devez le monter sur un point de
montage.

<p>
Ainsi, par exemple, vous pouvez monter un cédérom au point de montage
<prgn>/cdrom</prgn>. Cela signifie que si vous allez jeter un coup
d'oeil dans le répertoire <prgn>cdrom</prgn>, vous y verrez le contenu
du cédérom. Le répertoire <prgn>/cdrom</prgn> lui-même est en fait sur
votre disque dur. Pour des tas de raisons pratiques, le contenu du
cédérom devient une partie du système de fichiers racine et lorsque
vous tapez des commandes ou bien que vous utilisez des programmes,
l'emplacement réel des fichiers n'importe pas. Vous auriez pu avoir
créé un répertoire appelé <prgn>/cdrom</prgn> et mis quelques fichiers
à l'intérieur et tout ce serait passé de la même façon. Lorsque vous
avez monté un système de fichiers, il n'est plus nécessaire de prêter
la moindre attention à son emplacement physique.

<p>
Toutefois, avant de monter un système de fichiers ou d'en créer un
nouveau sur un disque qui n'en contient pas, il est nécessaire de se
référer aux périphériques eux-mêmes. Chaque périphérique a son nom et
ces noms se trouvent dans le répertoire <prgn>/dev</prgn>. Si vous tapez
<prgn>ls /dev</prgn> maintenant, vous apercevrez une longue liste de
l'ensemble des périphériques possibles (dont la liste est fournie
chapitre 4). Une liste plus détaillée peut être trouvée sur votre
système dans le fichier
<prgn>/usr/src/linux/Documentation/devices.txt</prgn>.

<p>
Vouloir monter un système de fichiers, c'est dire à Linux d'associer
un système de fichiers sur tel périphérique avec tel point de montage
particulier. Dans la procédure, il faudra aussi indiquer quel type de
système de fichiers on veut.
</sect1>

<sect1> Exemple: monter un cédérom

<p>
Comme exemple élémentaire, nous allons  monter un cédérom
comme celui que vous avez utilisé pour installer Debian. Vous avez
besoin d'être root pour faire cela donc faîtes attention: chaque fois
que vous êtes root, vous avez le pouvoir de manipuler tout le système
et pas simplement vos seuls fichiers. Ces commandes supposent d'autre
part que vous avez un cédérom dans le lecteur: vous devez donc le
mettre maintenant. Ensuite, commencez avec la commande suivante:

<p>
<example>
su
</example>

<p>
Si vous ne l'avez pas déjà fait, vous devez soit vous loguer en tant
que root soit obtenir les privilèges du super-utilisateur via la
commande <prgn>su</prgn>. Si vous utilisez <prgn>su</prgn>, ajoutez le
mot de passe de root quand on vous le demande.

<p>
<example>
ls /cdrom
</example>

<p>
Utilisez cette commande pour voir ce que contient le répertoire
<prgn>/cdrom</prgn> avant de commencer. Si vous n'avez pas de
répertoire <prgn>/cdrom</prgn>, il vous faudra le créer en utilisant
<prgn>mkdir /cdrom</prgn>.

<p>
<example>
mount
</example>

<p>
Taper simplement <prgn>mount</prgn> sans argument donne la liste des
systèmes de fichiers actuellement montés.

<p>
<example>
mount -t iso9660 CD-device /cdrom
</example>

<p>
Avec cette commande, vous devez mettre le nom de votre cédérom à la
place de <prgn>CD-device</prgn>. Si vous n'êtes pas sûr, mettez
<prgn>/dev/cdrom</prgn> car la procédure d'installation devrait avoir
créé ce lien symbolique sur le système. Si cela échoue, essayez les
différents périphériques IDE: <prgn>/dev/hdc</prgn>, etc... Vous devez
voir un message du type<footnote>mount: le périphérique bloc /dev/hdc
est protégé en écriture, montage en lecture seule</footnote>:

<example>
mount: block device /dev/hdc is write protected, mounting read-only
</example>

<p>
L'option <prgn>-t</prgn> spécifie le type de système de fichiers, dans
ce cas <prgn>iso9660</prgn>. L'argument suivant est le nom du
périphérique à monter et le dernier argument est le point de
montage. Il y a de nombreux autres arguments possibles pour
<prgn>mount</prgn>; allez voir la page de manuel pour plus de détails.

<p>
Une fois le cédérom monté, vous remarquerez que le plateau du cédérom
ne s'ouvre pas:: vous devez le démonter avant de pouvoir le démonter.

<p>
<example>
ls /cdrom
</example>

<p>
confirme maintenant que <prgn>/cdrom</prgn> contient bien ce qu'il y a
dans votre cédérom.

<p>
<example>
mount
</example>

<p>
Affiche à nouveau la liste des systèmes de fichiers ; remarquez que
votre lecteur est maintenant monté.

<p>
<example>
umount /cdrom
</example>

<p>
Ceci démonte le cédérom. Il est maintenant à nouveau possible de
sortir le cédérom de son lecteur. Attention, la commande est
<prgn>umount</prgn> sans <prgn>n</prgn> même s'il s'agit de
démonter<footnote><em>unmount</em> en anglais, d'où la remarque
</footnote> le système de fichiers.

<p>
<example>
exit
</example>

<p>
N'oubliez pas de vous déloguer du compte root. Déloguez-vous
immédiatement, juste pour être sûr.
</sect1>

<sect1> <prgn>/etc/fstab</prgn>: automatiser la procédure de montage.

<p>
Le fichier <prgn>/etc/fstab</prgn> (qui veut dire <em>file system
table</em>, table des systèmes de fichiers) contient les descriptions
des fichiers que vous montez souvent. Ces systèmes de fichiers peuvent
être montés avec des commandes réduites, comme <prgn>mount
/cdrom</prgn>. Vous pouvez aussi faire qu'ils soient montés
automatiquement au démarrage.

<p>
Jetons un coup d'oeil à ce fichier en tapant <prgn>more
/etc/fstab</prgn>. Il devrait y avoir deux ou plusieurs entrées
configurées automatiquement lors de la procédure d'installation. Cela
devrait probablement ressembler à quelque chose comme cela:

<p>
<example>
# /etc/fstab: static file system information
#
# &lt file system &gt &lt mount point &gt &lt type &gt &lt options &gt

# &lt dump &gt  &lt pass &gt
/dev/hda1 / ext2 defaults 0 1
/dev/hda3 none swap sw 0 0
proc /proc proc defaults 0 0 
/dev/hda5 /tmp ext2 defaults 0 2
/dev/hda6 /home ext2 defaults 0 2
/dev/hda7 /usr ext2 defaults 0 2
/dev/hdc /cdrom iso9660 ro, noauto 0 0
/dev/fd0 /floppy auto noauto,sync 0 0
</example>

<p>
La première colonne affiche les périphériques présents sur le
système. La seconde colonne est le point de montage, la colonne
suivante étant le type de système de fichiers. Remarquez que la
partition de <em>swap</em> (<prgn>/dev/hda3</prgn> dans l'exemple) n'a
pas de point de montage et donc il y a un <prgn>none</prgn> dans la
colonne correspondante.

<p>
Les trois dernières colonnes méritent une explication plus
approfondie.

<p>
La cinquième colonne est utilisée par l'utilitaire <prgn>dump</prgn>
pour décider quand sauvegarder le système de fichiers. Dans la plupart
des cas, vous pouvez mettre 0 ici.

<p>
La sixième colonne est utilisée par <prgn>fsck</prgn> pour décider
dans quel ordre vérifier les systèmes de fichiers au démarrage. Le
système de fichiers racine ou principal doit avoir le <prgn>1</prgn>
dans son champ, les systèmes de fichiers n'ayant besoin d'aucune
vérification (comme la partition de <em>swap</em>) doivent avoir un
<prgn>0</prgn> et tous les autres doivent avoir un <prgn>2</prgn>. Il
est vrai que la partition de <em>swap</em> ne possède pas vraiment un
système de fichiers, au sens où elle ne contient pas des fichiers et
des répertoires mais elle est utilisée par le noyau Linux comme
mémoire secondaire. Quoiqu'il en soit, pour des raisons historiques,
la partition de <em>swap</em> est toujours contenu dans le fichier
incluant les systèmes de fichiers.

<p>
La quatrième colonne contient une ou plusieurs options à utiliser
lors du montage du système de fichiers. Vous pouvez vérifier la page
de manuel de <prgn>mount</prgn> pour un résumé. Allez voir aussi le
chapitre 7.1.
</sect1>

<sect1> Supports extractibles (disquettes, lecteur Zip, etc.)

<p>
Ajoutez les lignes suivantes dans votre fichier
<prgn>/etc/fstab</prgn>:

<p>
<example>
/dev/sda1 /mnt/zip ext2 noauto,user 0 0
/dev/sda4 /mnt/dos msdos no,user 0 0
</example>

<p>
À partir de maintenant, vous êtes capable de monter une cartouche Zip
formatée en DOS avec la commande <prgn>mount /mnt/dos</prgn> et vous
pouvez monter une cartouche Zip formatée pour Linux avec la commande
<prgn>mount /mnt/zip</prgn>.

<p>
Si vous avez des disques durs SCSI sur votre système, vous devez
changer <prgn>sda</prgn> en <prgn>sdb</prgn> ou <prgn>sdc</prgn> dans
l'exemple ci-dessus.
</sect1>
</sect>

<sect> Les outils de sauvegarde

<p>
Les sauvegardes sont quelque chose de fondamental dans tous les
systèmes d'exploitation. Debian GNU-Linux fournit différents
utilitaires que vous pourrez utiliser à votre convenance. De plus,
bien que la plupart de ces utilitaires aient été créés originellement
pour des sauvegardes sur bandes, vous pourrez les utiliser pour plein
d'autres choses. Par exemple, <prgn>tar</prgn> est utilisé pour
distribuer des programmes sur Internet. Voici une liste des
utilitaires que vous pourrez trouver sur le système:

<p>
<list>
<item>
<p>
  <prgn>Taper</prgn> est un programme basé sur des menus, très
  convivial et qui peut sauvegarder sur de nombreux supports. Sa
  limitation est qu'il n'est pas capable de faire des sauvegardes
  supérieures à 4 Go.
<item>
<p>
  <prgn>dump</prgn> a été créé spécialement pour les bandes: sa force
  principale réside dans son interface pour la restauration de
  fichiers, les sauvegardes de systèmes de fichiers de bas niveau et
  la sauvegarde incrémentale. Sa limitation réside dans le fait qu'il
  n'est pas capable de sauvegarder via NFS ou d'autres systèmes de
  fichiers différents de <prgn>ext2</prgn> et quelques petits défauts
  de conception.
<item>
<p>
  <prgn>GNU tar</prgn> (raccourci de <em>Tape ARchiver</em>, archiveur
  d'enregistrements) est une implémentation de ce qui est probablement
  la façon la plus utilisée de sauvegarder quelque chose sous Linux
  aujourd'hui. Cela fournit un bon outil multi-usage et peut
  s'accomoder de l'ensemble des supports utilisés. De plus, de
  nombreux systèmes sont capables de lire un fichier <prgn>tar</prgn>
  ce qui le rend très portable. Les défauts de <prgn>tar</prgn> sont
  qu'il contient un pauvre outil de sauvegarde incrémentale en
  comparaison de <prgn>dump</prgn> et aucun écran de sélection de
  restauration automatique.
</list>

<sect1> <prgn>tar</prgn>

<p>
Parce que <prgn>tar</prgn> est vraiment très utilisé, et pas seulement
pour des tâches de sauvegardes, nous allons en parler un peu ici. Pour
plus de détails, lisez la page de manuel de <prgn>tar</prgn>, les
instructions pour lire une page de manuel sont dans la partie 7.1.

<p>
<prgn>tar</prgn> est un archiveur. Cela veut dire que <prgn>tar</prgn>
est capable de rassembler plusieurs fichiers et les combiner en un seul
grand fichier pour les écrire sur un périphérique de sauvegarde comme
une bande. Une fois que vous avez ce grand fichier, vous voulez
souvent le comprimer: l'option <prgn>-z</prgn> est alors très
bien. Ainsi, <prgn>tar</prgn> est une façon pratique de distribuer des
programmes et des données sur Internet et vous vous rendrez compte
qu'il est beaucoup utilisé à cette fin.

<p>
Voici une ligne de commande <prgn>tar</prgn> simple:

<p>
<example>
tar -zcvf monfichier.tar.gz /usr/local/bin
</example>

<p>
Regardons un peu comment se décompose la commande <prgn>tar</prgn>:

<list>
<item> <prgn>tar</prgn>
<p>
  Nom de la commande
<item> <prgn>-</prgn>
<p>
  Options de la commande <prgn>tar</prgn>
  <list>
  <item> <prgn>z</prgn>
   <p>
      demande à <prgn>tar</prgn> d'utiliser <prgn>gzip</prgn> pour
      comprimer automatiquement . Si vous utilisez cette option, il
      est bon d'ajouter l'extension <prgn>.gz</prgn> à votre fichier
      <prgn>tar</prgn>.  <item> <prgn>c</prgn>
    <p>
       demande à <prgn>tar</prgn> de créer une nouvelle archive
  <item> <prgn>v</prgn>
    <p>
       active le mode verbeux: <prgn>tar</prgn> vous explique ce qu'il
       fait pendant qu'il crée l'archive.
  <item> <prgn>f</prgn>
    <p>
       ceci indique que la chaîne suivante de la ligne de commande est
       le nom du fichier à créer ou le périphérique à utiliser. Si
       j'utilisais <prgn>/dev/st0</prgn> ici, par exemple, cela
       enverrait l'écriture de la sauvegarde sur le lecteur de bandes.
  </list>
<item> <prgn>monfichier.tar.gz</prgn>
<p>
  C'est le nom du fichier à créer.
<item> <prgn>/usr/local/bin</prgn>
<p>
  C'est le nom du fichier ou du répertoire à placer dans l'archive. Il
  est aussi possible de spécifier différents emplacements ici.
</list>

<p>
Vous trouverez de nombreux fichiers <prgn>tar.gz</prgn> (ou plus
simplement <prgn>.tgz</prgn>) sur Internet. Vous pouvez les
désarchiver avec la commande suivante:

<p>
<example>
tar -zxvf nomdufichier.tar.gz
</example>
</sect1>
</sect>

</chapt><chapt> Réseau

<p>
Un des très grands avantages de GNU-Linux sur les autres systèmes
réside dans son support réseau. Peu de systèmes peuvent rivaliser avec
les fonctionnalités présentes au sein d'un système GNU-Linux. Dans ce
chapitre, nous allons vous expliquer comment configurer vos
périphériques réseau.

<sect>  <prgn>PPP</prgn>

<p>
Cette partie est une aide pour une installation rapide de
<prgn>PPP</prgn> sur Debian. Si vous désirez aller plus loin,
tournez-vous vers l'excellent PPP-HOWTO du Projet de Documentation
Linux.  Si vous êtes curieux ou si vous avez des besoins
particuliers,le HOWTO examine ces questions en détail.


<sect1> Introduction

<p>
Si vous vous connectez à Internet via une ligne de téléphone, vous
voudrez certainement utiliser <prgn>PPP</prgn> (<em>Point-to-Point
Protocol</em>, protocole de liaison point-à-point). C'est la méthode
standard de connexion auprès des FAI (Fournisseurs d'Accès à
Internet). En plus d'utiliser <prgn>PPP</prgn> pour vous connecter
chez votre FAI, vous pourrez autoriser les connexions de l'extérieur
- ce qui vous permettra de vous connecter sur une machine à distance.
</sect1>

<sect1> Préparation

<p>
Configurer une liaison <prgn>PPP</prgn> sur un système Debian
GNU-Linux est élémentaire une fois que vous possédez toutes les
informations dont vous allez avoir besoin. Debian rend les choses très
faciles avec ses outils simples de configuration.

<p>
Avant de vous lancer, assurez-vous de bien avoir toutes les
informations de votre FAI. Cela peut inclure:

<list>
<item> Nom d'utilisateur ou login
<item> Mot de passe
<item> Votre adresse IP (<em>Internet Protocol</em>) fixe si
nécessaire (cela doit ressembler à quelque chose comme
<prgn>209.81.8.242</prgn>). Cette information n'est pas nécessaire
pour la plupart des FAI.
<item> Le masque réseau (cela doit ressembler à quelque chose comme
<prgn>255.255.255.248</prgn>). Cette information n'est pas nécessaire
pour la plupart des FAI.
<item> Les adresses IP des serveurs DNS de votre FAI
<item> Toute procédure de login particulière requis chez votre FAI
</list>

<p>
Ensuite, il va falloir examiner votre configuration matérielle: la
façon dont votre modem fonctionner avec GNU-Linux et sur quel port
série il est connecté.

<p>
Voici une règle simple pour déterminer si votre modem va fonctionner:
si c'est un «&nbsp;winmodem&nbsp;» ou bien un modem intégré, cela ne
fonctionnera pas. Ces modems sont bon marché car ils ont très peu de
fonctionnalités et ils demandent à l'ordinateur de compenser leur
incapacité. Malheureusement, cela signifie qu'ils sont complexes à
programmer et les fabricants ne donnent généralement pas leurs
spécifications aux développeurs.

<p>
Si vous avez un modem avec son propre circuit embarqué ou bien un
modem extérieur, vous ne devriez pas avoir de problème.

<p>
Sur les systèmes GNU-Linux, les ports séries sont référencés comme
<prgn>/dev/ttyS0</prgn>, <prgn>/dev/ttys1</prgn> et ainsi de
suite. Votre modem est certainement connecté soit au port 0 soit au
port 1, l'équivalent du COM1 et COM2 sous Windows. Si vous ne savez
pas où est connecté votre modem, lancez le programme
<prgn>wvdialconf</prgn> pour essayer de le détecter (voir plus
bas). Sinon, vous pouvez toujours essayer les deux et regardez lequel
fonctionne...

<p>
Si vous désirez discuter avec votre modem ou vous connecter à votre
FAI sans utiliser <prgn>PPP</prgn>, vous pouvez utiliser le programme
<prgn>minicom</prgn>. Il se peut que vous ayez besoin d'installer le
paquet <prgn>minicom</prgn> pour disposer du programme.
</sect1>

<sect1> La voie facile: <prgn>wvdial</prgn>

<p>
La façon la plus facile d'obtenir une liaison <prgn>PPP</prgn>
fonctionnelle est d'utiliser le programme <prgn>wvdial</prgn>. Il fait
des propositions raisonnables et tente de paramétrer les choses pour
vous. Si cela fonctionne, vous êtes verni. Sinon, vous aurez à faire
les choses à la main.

<p>
Assurez-vous d'avoir bien installé les paquets suivants:

<p>
<list>
<item> <prgn>ppp</prgn>
<item> <prgn>ppp-pam</prgn>
<item> <prgn>wvdial</prgn>
</list>

<p>
Lorsque vous installez <prgn>wvdial</prgn>, on vous donne l'occasion
de le configurer. Sinon, pour configurer <prgn>wvdial</prgn>, procédez
comme suit en vous loguant en root à l'aide de la commande
<prgn>su</prgn>:


<p>
<example>
touch /etc/wvdial.conf
</example>

<p>
<prgn>touch</prgn> va créer le fichier suivant s'il n'existe pas: le
programme de configuration requiert un fichier déjà existant.

<p>
<example>
wvdialconf /etc/wvdial.conf
</example>

<p>
Cela signifie que vous êtes en train de créer le fichier de
configuration <prgn>/etc/wvdial.conf</prgn>.

<p>
Répondez aux questions qui apparaissent à
l'écran. <prgn>wvdialconf</prgn> va aussi rechercher votre modem et
vous indiquer sur quel port série il se trouve. Inscrivez le résultat
quelque part pour vous en souvenir un peu plus tard.
</sect1>
</sect>

<sect> Ethernet

<p>
Une autre façon très populaire de se connecter à Internet est de
passer via un LAN (<em>Local Area Network</em>, réseau local) qui
utilise Ethernet.Cela vous donne un réseau local à haut débit en plus
de la connexion à Internet. Heureusement, vous avez déjà dû configurer
le réseau pendant l'installation et dès lors, il n'y rien d'autre à
faire. Si jamais vous désirez modifier votre configuration, voici les
fichiers intéressants:

<p>
<list>
<item> <prgn>/etc/init.d/network</prgn>
<p>
  Pour votre adresse IP, le masque réseau et la route par défaut.
<item> <prgn>/etc/hostname</prgn>
<p>
  Pour enregistrer votre nom d'hôte.
<item> <prgn>/etc/hosts</prgn>
<p>
  Pour enregistrer aussi votre nom d'hôte et votre adresse IP.
</list>
</sect>

</chapt><chapt> Installer et désinstaller des logiciels

<p>
Ce chapitre décrit les façons d'installer et de désinstaller des
paquets de logiciels. Il y a plusieurs façons de le faire. Ici, nous
n'allons parler de l'installation et de la désinstallation de
logiciels pré-empaquetés comme les paquets Debian. L'installation à
partir de sources restera à votre charge.

<sect>  À quoi sert un utilitaire de maintenance de paquet

<p>
Une application ou un programme utilitaire rassemblent généralement
plusieurs fichiers. Cela peut inclure des bibliothèques, des fichiers
de données comme des scénarios de jeux ou des icônes, des fichiers de
configurations, des pages de manuels et la documentation. Lorsque vous
installez un programme, vous voulez être sûr d'avoir tous les fichiers
dont vous avez besoin à la bonne place.

<p>
Vous devez aussi être capable de désinstaller un programme. Lorsque
vous désinstallez, vous devez être sûr que tous les fichiers associés
sont détruits. Et de plus, si les fichiers sont partagés par d'autres
programmes dans le système, vous voulez être sûr de les conserver.

<p>
Enfin, vous devez être capable de faire la mise à jour d'un
programme. Lorsque vous effectuez une mise à jour, vous désirez
détruire les fichiers obsolètes et ajouter les nouveaux, sans ne rien
casser au système existant.

<p>
Le système de gestion des paquets de Debian offre une solution à ces
problèmes. Il vous autorise à installer, désinstaller et mettre à
jours les paquets de logiciels, qui ne sont qu'un petit ensemble
contenant les fichiers du programme et les informations qui aident
l'ordinateur à gérer le paquet correctement. Les paquets Debian ont un
nom se terminant par <prgn>.deb</prgn> et ils sont disponibles sur le
site <prgn>FTP</prgn> ou bien sur votre cédérom officiel de Debian.
</sect>

<sect> <prgn>dpkg</prgn>

<p>
La manière la plus simple d'installer un simple paquet que vous venez
de télécharger est d'utiliser la commande <prgn>dpkg -i</prgn> (qui
est un raccourci pour <prgn>dpkg --install</prgn>). Admettons que vous
ayez téléchargé le paquet <prgn>icewm_0.8.12-1.deb</prgn> et que vous
désirez l'installer. Loguez-vous d'abord en tant que root et tapez
ensuite <prgn>dpkg -i icewm_0.8.12-1.deb</prgn> et <prgn>icewm</prgn>,
version 0.8.12, sera installé. Si vous avez déjà une ancienne version,
<prgn>dpkg</prgn> se chargera de la mise à jour plutôt que d'installer
deux versions en même temps.

<p>
Si vous désirez désinstaller un paquet, vous avez deux options. La
première est la plus intuitive: <prgn>dpkg -r icewm</prgn>. Cela
retirera le paquet <prgn>icewm</prgn> (<prgn>-r</prgn> est un
raccourci pour <prgn>--remove</prgn> (désinstaller)). Remarquez bien
qu'il est juste nécessaire de donner le nom <prgn>icewm</prgn> pour la
désinstallation tandis que l'installation requiert l'extension
<prgn>.deb</prgn>.

<p>
<prgn>--remove</prgn> va laisser les fichiers de configuration du
paquet dans votre système. Un fichier de configuration est défini
comme tout fichier que vous avez pu éditer pour personnaliser le
programme du système ou vos préférences. Ainsi, si vous décidez de
réinstaller un peu plus tard le programme, vous n'aurez pas à le
re-personnaliser.

<p>
Mais si vous désirez réellement nettoyer les fichiers de
configuration, <prgn>dpkg</prgn> propose une option
<prgn>--purge</prgn>. <prgn>dpkg --purge icewm</prgn> nettoiera tous
les derniers fichiers associés au paquet <prgn>icewm</prgn>.
</sect>

<sect> <prgn>dselect</prgn>

<p>
<prgn>dselect</prgn> est une très bonne interface à
<prgn>dpkg</prgn>. <prgn>dselect</prgn> offre une interface à base de
menus à <prgn>dpkg</prgn> et est capable de sélectionner
automatiquement tous les fichiers appropriés à partir d'un cédérom ou
bien d'un site FTP. Pour plus de détails sur <prgn>dselect</prgn>,
reportez-vous à la partie 4.20.
</sect>

<sect> Compiler un logiciel

<p>
De nombreux programmes sont fournis sous forme de sources, la plupart
du temps au format <prgn>tar.gz</prgn>. Premièrement, vous devez
détarer le fichier <prgn>tar.gz</prgn>; pour plus de détails sur
comment faire cette opération, reportez-vous à la partie 12.3.1. Avant
de compiler un paquet, vous aurez besoin d'installer <prgn>gcc</prgn>,
<prgn>libc6-dev</prgn> et autres assimilés
«&nbsp;<prgn>-dev</prgn>&nbsp;». Vous les trouverez pour la plupart
d'entre eux dans la section <prgn>devel</prgn> de
<prgn>dselect</prgn>.

<p>
Lorsque vous aurez installé les paquets appropriés, allez via
<prgn>cd</prgn> dans le répertoire que <prgn>tar</prgn> a créé pour
vous. À partir de ce moment-là, vous aurez à lire les instructions
d'installation. La plupart des programmes fournissent un fichier
INSTALL ou README qui vous indique comment procéder.
</sect>

</chapt><chapt> Pour en savoir plus...

<p>
À présent, vous possédez de bonnes bases pour construire votre système
GNU-Linux. Dans ce chapitre, nous allons aborder quelques notions très
utiles des fonctionnalités avancées de GNU-Linux.

<sect>  Les expressions rationnelles

<p>
Une <em>expression rationnelle</em> est une description d'un ensemble
de caractères. On utilise cette description pour éplucher un fichier à
la recherche d'un texte correspondant à cette expression
rationnelle. Les expressions rationnelles sont analogues aux motifs de
recherche du shell (voir partie 8.6) mais elles sont plus compliquées
et beaucoup plus puissantes.  elles sont à la fois plus compliquées et
plus puissantes.

<p>
Une expression rationnelle est formée de texte et de
<em>méta-caractères</em>. Un méta-caractère est simplement un
caractère avec une signification particulière. Les méta-caractères
comprennent les signes suivants:
<example>
. * [] - \ ^ $
</example>

<p>
Si une expression rationnelle ne comprend que du texte (pas de
méta-caractère), cela correspond exactement au texte. Par exemple,
l'expression rationnelle <prgn>mon expression rationnelle</prgn>
correspond exactement au texte <prgn>mon expression rationnelle</prgn>
et à rien d'autre. Les expressions rationnelles prennent
habituellement en compte la casse.

<p>
Vous pouvez utiliser la commande <prgn>egrep</prgn> pour extraire les
lignes d'un fichier qui contiennent une expression rationnelle. Sa
syntaxe est la suivante:

<p>
<example>
egrep 'regexp' nomdefichier1 ...
</example>

<p>
Les guillemets simples ne sont pas obligatoires mais cela ne mange pas
de pain de les ajouter.

<p>
Par exemple, pour trouver toutes les lignes contenant le mot GNU dans
la GPL, vous tapez:

<p>
<example>
egrep 'GNU' /usr/doc/copyright/GPL
</example>

<p>
<prgn>egrep</prgn> va vous égrener les lignes correspondantes sur la
sortie standard. Si vous voulez toutes les lignes contenant
<prgn>freedom</prgn> (liberté) suivi d'un ensemble quelconque de
caractères et suivi du mot GNU, vous pouvez taper:

<p>
<example>
egrep 'freedom.*GNU' /usr/doc/copyright/GPL
</example>

<p>
Le <prgn>.</prgn> signifie «&nbsp;n'importe quel caractère&nbsp;» et
le <prgn>*</prgn> signifie «&nbsp;zéro ou plus de la chose
précédente&nbsp;» soit dans ce cas «&nbsp;zéro ou plus de n'importe
quel caractère&nbsp;». Ainsi, <prgn>.*</prgn> correspond bien à
n'importe quel texte. <prgn>egrep</prgn> effectue un traitement ligne
par ligne donc <prgn>freedom</prgn>et <prgn>GNU</prgn> doivent se
trouver sur la même ligne.

<p>
Voici un récapitulatif des méta-caractères dans expressions
rationnelles:

<p>
<list>
<item> <prgn>.</prgn>
<p>
  Correspond à un seul caractère, à l'exception du caractère
  <em>newline</em> (retour chariot)
<item> <prgn>*</prgn>
<p>
  Correspond à zéro ou plus d'occurences de ce qui précède. Ainsi,
  l'expression <prgn>a*</prgn> correspond à zéro ou plus de
  <prgn>a</prgn> minuscule et <prgn>.*</prgn> correspond à zéro ou
  plus de caractères quelconques.
<item> <prgn>[caractères]</prgn>
<p>
  Les crochets doivent contenir un ou plusieurs
  caractères. L'expression complète correspond exactement à l'ensemble
  des caractères. Ainsi, <prgn>[abc]</prgn> correspond à un
  <prgn>a</prgn>, un <prgn>b</prgn> et un <prgn>c</prgn>. Cela ne
  correspond pas à une chaîne vide et cela ne correspond pas non plus
  à un caractère autre que ces trois-là.  <item> <prgn>^</prgn>
<p>
  Impose la correspondance en début de ligne. L'expression
  <prgn>^The</prgn> ne correspond à <prgn>The</prgn> que si elle
  apparaît en début de ligne: il ne peut y avoir d'espace, ou de
  texte, avant le <prgn>The</prgn>. Si vous désirez autoriser des
  espaces, vous pouvez autoriser 0 ou plus d'espaces avec <prgn>^
  *The</prgn>.
<item> <prgn>$</prgn>
<p>
  Impose la correspondance en fin de ligne. <prgn>fin$</prgn>
  requiert que le texte <prgn>fin</prgn> soit placé en fin de ligne
  sans espace ni texte à la fin.
<item> <prgn>[^caractères]</prgn>
<p>
  C'est la négation de la liste des caractères entre
  crochets. <prgn>[^abc]</prgn> correspond à tout caractère simple, à
  l'exception de a, b ou c.
<item> <prgn>[caractères-caractères]</prgn>
<p>
  Vous pouvez inclure un intervalle dans une liste de caractères entre
  crochets. Pour faire la correspondance avec toutes les lettres
  minuscules, utilisez <prgn>[a-z]</prgn>. Vous pouvez multiplier les
  intervalles: ainsi, pour avoir les trois premières lettres de
  l'alphabet et les trois dernières, essayez
  <prgn>[a-cx-z]</prgn>. Pour avoir toutes les lettres dans toutes les
  casses, essayez <prgn>[a-zA-Z]</prgn>. Vous pouvez mélanger les
  intervalles avec des caractères simples ou bien le méta-caractère
  <prgn>^</prgn>: <prgn>[^a-zBZ]</prgn> signifie «&nbsp;tout sauf une
  lettre minuscule, un B ou ou un Z&nbsp;».  
<item> <prgn>()</prgn>
<p>
  Vous pouvez utiliser les parenthèses pour regrouper les expressions
  rationnelles, comme dans des expressions mathématiques.
<item> <prgn>||</prgn>
<p>
  signifie «&nbsp;ou&nbsp;».  Vous pouvez vous en servir pour fournir
  une série d'expressions alternatives. On met généralement ces
  expressions entre parenthèses comme ceci: <prgn>c(ad|ab|at)</prgn>
  correspond à <prgn>cad</prgn>, <prgn>cab</prgn> ou
  <prgn>cat</prgn>. Sans les parenthèses, cela aurait correspondu à
  <prgn>cad</prgn> ou bien <prgn>ab</prgn> ou bien <prgn>at</prgn>.
  <item> <prgn>\</prgn>
<p>
  Protège tout caractère spécial. Si vous désirez trouver un
  <prgn>*</prgn>, vous devez taper <prgn>\*</prgn>. Le \ signifie
  d'ignorer le sens usuel de <prgn>*</prgn>.
</list>

<p>
Voici une série d'exemples concrets pour vous aider.

<p>
<list>
<item> <prgn>c.pe</prgn> correspond à <prgn>cope, cape, caper</prgn>
<item> <prgn>c\.pe</prgn> correspond à <prgn>c.pe, c.per</prgn>
<item> <prgn>sto*p</prgn> correspond à <prgn>stp, stop, stoop</prgn>
<item> <prgn>car.*n</prgn> correspond à <prgn>carton, cartoon, carmen</prgn>
<item> <prgn>xyz.*</prgn> correspond à <prgn>xyz</prgn> et tout ce qui
s'ensuit. Certains outils, comme <prgn>egrep</prgn>, ne font la
correspondance que jusqu'à la fin de la ligne.  
<item> <prgn>^The</prgn> correspond à <prgn>The</prgn> en début de ligne
<item> <prgn>atime$</prgn> correspond à <prgn>atime</prgn> en fin de ligne
<item> <prgn>^Only</prgn> correspond à <prgn>Only</prgn> en début de
ligne - pas d'espace, de caractère, rien. Seul <prgn>Only</prgn>
est accepté.  
<item> <prgn>b[aou]rn</prgn> correspond à <prgn>barn, born, burn</prgn>
<item> <prgn>ver[D-F]</prgn> correspond à <prgn>verD, verE, verF</prgn>
<item> <prgn>ver[^0-9]</prgn> correspond à <prgn>Ver</prgn> suivi de
tout sauf d'un chiffre.
<item> <prgn>the[ir][re]</prgn> correspond à <prgn>thier, therr,
there, theie</prgn>
<item> <prgn>[A-Za-z][A-Za-z]*</prgn> correspond à tous les mots composés
seulement de lettres et d'au moins une lettre. Cela ne peut pas
contenir des chiffres ou des espaces.
</list>
</sect>

<sect> Notions avancées sur les fichiers

<p>
Maintenant que vous avez compris les bases sur les fichiers, il est
temps d'apprendre plus de choses à leur sujet.

<sect1> La véritable nature des fichiers: les liens physiques et les
i-noeuds

<p>
Chaque fichier de votre système est représenté par un <em>i-noeud</em>
(en anglais, <em>inode</em> pour <em>Information Node</em>, prononcez
«&nbsp;aïe-node&nbsp;», noeud d'information). un i-noeud contient
toutes les informations du fichier. Cependant, l'i-noeud n'est pas
directement visible. De plus, chaque i-noeud est lié au système de
fichiers par un ou plusieurs liens physiques. Les liens physiques
contiennent le nom du fichier et le numéro d'i-noeud. L'i-noeud
contient le fichier en lui-même, c'est-à-dire, l'emplacement où
l'information est stockée sur le disque, les permissions d'accès, le
type de fichier et ainsi de suite. Le système peut trouver n'importe
quelle i-noeud s'il a son numéro.

<p>
Un simple fichier peut avoir plus d'un lien physique. Cela signifie
que tous ces fichiers multiples correspondent au même fichier
(c'est-à-dire qu'ils sont associés au même numéro d'i-noeud). Cependant,
vous ne pouvez faire de lien physique entre des systèmes de fichiers:
tous les liens physiques à un fichier particulier (i-noeud) doivent être
dans le même système de fichiers. C'est parce que chaque système de
fichiers possède sa propre table d'i-noeuds et que l'on ne peut
dupliquer des numéros d'i-noeud sur différents systèmes de fichiers.

<p>
Parce que tous les liens physiques à une certaine i-noeud se réfèrent au
<em>même fichier</em>, vous pouvez modifier le fichier en l'appelant
par un nom et voir ensuite les modifications en l'appelant par un des
autres noms. Essayez ceci:

<p>
<example>
cd; echo "Bonjour" > premierlien
</example>

<p>
Vous allez dans votre répertoire personnel et vous créez un premier
fichier appelé <prgn>premierlien</prgn> contenant le mot
«&nbsp;Bonjour&nbsp;». Ce que vous venez de faire est juste de
rediriger la sortie de <prgn>echo</prgn> (<prgn>echo</prgn> renvoie
juste ce que vous lui donnez) en la plaçant dans
<prgn>premierlien</prgn>. Allez voir le chapitre sur le shell pour de
plus amples explications.

<p>
<example>
cat premierlien
</example>

<p>
Pour vérifier le contenu de <prgn>premierlien</prgn>.

<p>
<example>
ln premierlien secondlien
</example>

<p>
Crée un lien physique: <prgn>secondlien</prgn> pointe maintenant sur
le même i-noeud que <prgn>premierlien</prgn>.

<p>
<example>
cat secondlien
</example>

<p>
Pour confirmer que <prgn>secondlien</prgn> est bien identique à
<prgn>premierlien</prgn>.

<p>
<example>
ls -l
</example>

<p>
Remarquez bien que le nombre de liens physiques affiché pour
<prgn>premierlien</prgn> et <prgn>secondlien</prgn> est 2.

<p>
<example>
echo "change" >> secondlien
</example>

C'est une nouvelle redirection du shell (ne vous souciez pas des
détails). Vous avez ajouté le mot «&nbsp;change&nbsp;» à
<prgn>secondlien</prgn>. Confirmez-le avec <prgn>cat
secondlien</prgn>.

<p>
<example>
cat premierlien
</example>

<p>
<prgn>premierlien</prgn> a aussi le mot «&nbsp;change&nbsp;» ! C'est
parce que <prgn>premierlien</prgn> et <prgn>secondlien</prgn> se
réfèrent au <em>même fichier</em>. Peu importe comment vous l'appelez
lorsque vous le modifiez.

<p>
<example>
chmod a+rwx premierlien
</example>

<p>
Cela modifie les permissions de <prgn>premierlien</prgn>. Entrez la
commande <prgn>ls -l</prgn> pour vérifier que les permissions de
<prgn>secondlien</prgn> ont aussi été modifiées. Cela signifie que les
informations de permission résident dans l'i-noeud, et non dans le lien.

<p>
<example>
rm premierlien
</example>

<p>
Cela détruit le lien. C'est une astuce de <prgn>rm</prgn>. Cela
détruit en réalité le lien et non le fichier. Maintenant, tapez
<prgn>ls -l</prgn> et remarquez que <prgn>secondlien</prgn> est
toujours là. Notez bien aussi que le nombre de liens est passé de 2 à
1.

<p>
<example>
rm secondlien
</example>

<p>
Cela détruit le second lien. Quand il ne reste plus de lien rattaché à
un fichier, Linux détruit le fichier lui-même c'est-à-dire son i-noeud.

<p>
Tous les fichiers fonctionnent ainsi, et même les fichiers spéciaux
comme les périphériques (comme <prgn>/dev/hda</prgn>).

<p>
Un répertoire n'est qu'une liste de nom de fichiers et de numéros
d'i-noeuds, c'est-à-dire une liste de liens physiques. Lorsque vous
créez un lien physique, vous ajouter seulement une association
numéro-nom à un répertoire. Lorsque vous détruisez un fichier, vous
détruisez juste un lien physique d'un répertoire.
</sect1>

<sect1> Types de fichiers

<p>
Nous avons dissimulé jusqu'à présent le fait que le noyau Linux
considère presque tout comme un fichier. Cela inclut les répertoires
et les périphériques. Ce sont juste des genres de fichiers un peu
spéciaux.

<p>
Comme vous devez vous le rappelez, le premier caractère dans <prgn>ls
-l</prgn> renvoie le type du fichier. Pour un fichier ordinaire, cela
ne renvoie que <prgn>-</prgn> tout simplement. Les autres possibilités
sont les suivantes:

<p>
<list>
<item> <prgn>d</prgn> : répertoire
<item> <prgn>l</prgn> : lien symbolique
<item> <prgn>b</prgn> : périphérique bloc
<item> <prgn>c</prgn> : périphérique caractère
<item> <prgn>p</prgn> : tube nommé
<item> <prgn>s</prgn> : socket
</list>

<p>
<em>Liens symboliques</em>

<p>
Les liens symboliques (aussi appelés <em>symlink</em> ou liens
logiciels) sont l'autre type de lien avec les liens physiques. Un lien
symbolique est un fichier spécial qui «&nbsp;pointe vers&nbsp;» un
lien physique de n'importe quel système de fichiers monté. Lorsque
vous tentez de lire le contenu d'un lien symbolique, cela vous renvoie
le contenu du fichier pointé plutôt que le contenu du lien en
lui-même. Puisque les répertoires, les périphériques et autres liens
symboliques sont des fichiers, vous pouvez pointer un lien symbolique
sur chacun de ces objets.

<p>
Pour résumé, un lien physique est un nom de fichier et son numéro
d'i-noeud. Un fichier est réellement un i-noeud: un emplacement sur un
disque, le type du fichier, les modes de permission, etc... Un lien
symbolique est un i-noeud qui contient le nom du lien physique. Un
lien symbolique appareille deux noms de fichiers ensemble tandis qu'un
lien physique appareille un nom de fichier avec un numéro d'i-noeud.

<p>
Tous les liens physiques d'un même fichier ont le même état. Cela veut
dire qu'il n'y en a pas un de privilégié. Si vous effectuez une
opération sur l'un, c'est comme la faire sur n'importe lequel d'entre
eux. C'est parce que le lien physique réfère au même i-noeud. Les
opérations sur les liens symboliques, pour leurs parts, affectent
parfois le propre i-noeud du lien (celui contenant le nom du lien
physique) et parfois affectent le lien physique sur lequel ils
pointent.

<p>
Il y a un certain nombre de différences importantes entre les liens
symboliques et les liens physiques.

<p>
Les liens symboliques peuvent traverser des systèmes de
fichiers. C'est parce qu'ils contiennent les noms complets des
fichier, en partant d'un répertoire racine et que les noms complets de
fichiers sont uniques. Puisque les liens physiques pointent vers un
numéro d'i-noeud et que les numéros d'i-noeuds sont uniques qu'à
l'intérieur d'un système de fichiers, ils deviendraient impossible de
les qualifier avec certitude si l'on ne connaissait pas le système de
fichiers.

<p>
Vous pouvez faire des liens symboliques vers des répertoires mais cela
n'est pas possible pour les liens physiques. Chaque répertoire a des
liens physiques - son référencement dans son répertoire parent, son
entrée <prgn>.</prgn> et l'entrée <prgn>..</prgn> dans chacun de ses
sous-répertoires - mais pour pouvoir ordonner le système de fichiers,
aucun autre lien physique n'est autorisé. En conséquence de quoi, le
nombre de fichiers d'un répertoire est égal au nombre de liens
physiques du répertoire moins deux (vous retirez le nom du répertoire
et le lien <prgn>.</prgn> ).

<p>
Pour comparer un lien physique et un lien symbolique: vous pouvez
uniquement faire un lien physique sur un fichier existant car il doit
exister un numéro d'i-noeud sur lequel se référer. Par contre, vous
pouvez faire un lien symbolique sur n'importe quel fichier, qu'il existe
+réellement ou pas.

<p>
Détruire un lien symbolique détruit seulement le lien. Cela n'a pas
d'impact sur le fichier anciennement pointé. Détruire le seul lien
physique d'un fichier conduit à détruire le fichier.

<p>
Essayez ceci:

<p>
<example>
cd; ln -s /tmp/moi MonTmp
</example>

<p>
Vous vous positionnez dans votre répertoire personnel. <prgn>ls</prgn>
avec l'option <prgn>-s</prgn> fabrique un lien symbolique et dans ce
cas, ce lien s'appelle <prgn>MonTmp</prgn> et pointe sur le fichier
<prgn>/tmp/moi</prgn>.

<p>
<example>
ls -l MonTmp
</example>

<p>
Vous devriez observer une sortie du genre:

<p>
<example>
lrxwrxwrxw 1 havoc havoc 7 Dec 6 12:50 MyTmp -> /tmp/me
</example>

<p>
La date ainsi que l'utilisateur et le groupe devrait être différents
pour vous. Notez le type du fichier: <prgn>l</prgn>. Cela indique un
lien symbolique. Regardez aussi les permissions. Les liens symboliques
ont toujours ces permissions. Si vous tentez de changer les
permissions d'un fichier symbolique via <prgn>chmod</prgn>, vous allez
réellement changer les permissions du fichier sur lequel il pointe.

<p>
<example>
chmod 700 MonTmp
</example>


<p>
Vous devriez obtenir un <prgn>No such file or directory</prgn> (pas
trouvé de fichier ou de répertoire portant ce nom) car le fichier
<prgn>/tmp/moi</prgn> n'existe pas. Remarquez que cela n'a pas empêché
la création du lien symbolique.

<p>
<example>
mkdir /tmp/moi
</example>

<p>
Cela crée le répertoire <prgn>/tmp/moi</prgn>.

<p>
<example>
chmod 700 MonTmp
</example>

<p>
devrait maintenant fonctionner sans problème.

<p>
<example>
touch MonTmp/monfichier
</example>

<p>
Pour créer un fichier dans <prgn>MonTmp</prgn>.

<p>
<example>
ls /tmp/moi
</example>

<p>
Le fichier a vraiment été créé dans <prgn>/tmp/moi</prgn>.

<p>
<example>
rm MonTmp
</example>

<p>
Détruit le lien symbolique. Remarquez que cela ne retire que le lien
et non ce vers quoi il pointe. Ensuite, vous devez utiliser
<prgn>rm</prgn> et non pas <prgn>rmdir</prgn>:

<p>
<example>
rm /tmp/moi/monfichier; rmdir /tmp/moi
</example>

<p>
Cela nettoie tout ce qu'il reste.

<p>
<em> Fichiers périphériques </em>

<p>
Les fichiers périphériques se réfèrent à un périphérique physique ou
virtuel de votre système, comme votre disque dur, votre carte vidéo,
votre écran et votre clavier. Un exemple de périphérique virtuel est
la console, représentée par <prgn>/dev/console</prgn>.

<p>
Il y a deux sortes de périphériques: bloc et caractère. On peut avoir
accès aux <em>périphériques caractères</em> caractère par
caractère. Rappelez-vous que la plus petite unité de données qui peut
être écrite ou bien être lue à partir du périphérique est un caractère
(octet).

<p>
On peut accéder aux <em>périphériques bloc</em> avec des unités plus
grandes appelées blocs, qui contiennent un certain nombre de
caractères. Votre disque dur est un périphérique bloc.

<p>
Vous pouvez lire ou écrire dans des fichiers périphériques comme vous
le feriez avec n'importe quelle autre sorte de fichiers, quoique le
fichier puisse contenir alors un étrange baragouin incompréhensible à
nous autres humains. Écrire n'importe quoi dans ces fichiers n'est pas
une bonne idée. Parfois si. Par exemple, vous pouvez envoyer un
fichier PostScript dans le périphérique de l'imprimante
<prgn>/dev/lp0</prgn> ou bien envoyer des commandes de modem au
fichier périphérique idoine à partir du bon port série.

<p>
Il existe un fichier particulier appelé <prgn>/dev/null</prgn>. Il
détruit tout ce qu'il reçoit. Si vous ne voulez pas quelque chose,
envoyez-le dans <prgn>/dev/null</prgn>. C'est essentiellement un
puits sans fond. Si vous tentez de lire <prgn>/dev/null/</prgn>,
vous obtiendrez un <em>end-of-file</em> (EOF, caractère de fin de
fichier) immédiatement. <prgn>/dev/zero</prgn> est similaire, à
l'exception du fait que sa lecture vous renverra le caractère
<prgn>\0</prgn> (pas le même que le chiffre 0).

<p>
<em>Tubes nommés (FIFO)</em>

<p>
Un tube nommé est un fichier qui agit comme un tube. Vous entrez
quelque chose dans le fichier et cela ressort. Ceci est appelé une
FIFO (<em>First-In-First-Out</em>, premier entré, premier sorti) car
la première chose que vous entrez est aussi la première chose que l'on
sort.

<p>
Si vous écrivez dans un tube nommé, le processus d'écriture ne
s'arrête pas tant qu'il y a quelque chose à lire dans le tube. Si vous
lisez dans un tube nommé, le processus de lecture attend qu'il y ait
quelque chose à lire avant de s'arrêter. La taille du tube est
toujours zéro. Il ne stocke pas de donnée: il lie simplement deux
processus à travers le signe «&nbsp;|&nbsp;» du shell. Dans tous les
cas, puisque le tube a un nom, les deux processus n'ont pas à
appartenir à la même ligne de commandes ou même à être lancé par le
même utilisateur.

<p>
Vous pouvez essayer ceci:

<p>
<example>
cd; mkfifo montube
</example>

<p>
Activez alors le tube:

<p>
<example>
echo "bonjour" > montube &
</example>

<p>
Cela place le processus qui essaie d'écrire «&nbsp;bonjour&nbsp;» dans
le tube en arrière-plan. Remarquez bien que le processus ne rend pas
la main: il attend que quelqu'un vienne lire dans le tube:

<p>
<example>
cat montube
</example>

<p>
À ce moment, le processus <prgn>echo</prgn> s'achève car
<prgn>cat</prgn> a lu le tube et le processus <prgn>cat</prgn> a
affiché <prgn>bonjour</prgn>.

<p>
<example>
rm montube
</example>

<p>
Vous pouvez détruire les tubes comme n'importe quel autre fichier.


<p>
<em>Les sockets</em>

<p>
Les sockets sont similaires aux tubes mais elles ne fonctionnent qu'à
travers un réseau. C'est de cette façon que votre ordinateur travaille
en réseau. Vous avez peut-être entendu parler de
«&nbsp;WinSock&nbsp;», qui sont les sockets de Windows.

<p>
Nous n'irons pas plus loin sur ce sujet car vous n'aurez pas
l'occasion de vous en servir, à moins de programmer. En tout cas, si
vous apercevez un fichier marqué avec un type <prgn>s</prgn> sur votre
ordinateur, vous saurez de quoi il s'agit.
</sect1>

<sect1> Le système de fichiers <prgn>proc</prgn>

<p>
Le noyau Linux fournit un système de fichiers particulier qui est
monté sous <prgn>/proc</prgn> dans les systèmes Debian. C'est ce que
l'on appelle un «&nbsp;pseudo-système de fichiers&nbsp;» parce qu'il
n'existe pas réellement sur vos périphériques physiques.

<p>
Le système de fichiers <prgn>proc</prgn> contient des informations sur
le système et sur les processus en cours. Certains des
«&nbsp;fichiers&nbsp;» de <prgn>proc</prgn> sont raisonnablement
compréhensibles par un être humain (essayez <prgn>cat
/proc/meminfo</prgn> et <prgn>cat /proc/cpuinfo</prgn>). Les autres
fichiers sont un amas incompréhensible de chiffres. Les utilitaires
systèmes traduisent les informations contenues dans ces chiffres et
vous les présentent de façon plus compréhensible.

<p>
Les gens paniquent souvent lorsqu'ils remarquent qu'un fichier en
particulier - <prgn>/proc/kcore</prgn> - est souvent énorme, C'est, à
un cheval près, une copie du contenu de la mémoire de votre
ordinateur. Il est utilisé pour déboguer le noyau. Il n'existe nulle
part physiquement donc ne vous préoccupez pas de sa taille.

<p>
Si vous désirez en savoir plus sur <prgn>/proc</prgn>, tapez <prgn>man
5 proc</prgn>.
</sect1>

<sect1> Copie à grande échelle

<p>
Il est parfois nécessaire de recopier un répertoire dans  un autre
emplacement. Peut-être avez-vous ajouté un nouveau disque dur et vous
désirez faire une copie de <prgn>/usr/local</prgn> dessus. Il y a
plusieurs façons de procéder:

<p>
La première est d'utiliser la commande <prgn>cp</prgn>. La commande
<prgn>cp -a</prgn> demande à <prgn>cp</prgn> de préserver le maximum
d'informations. Vous pourriez ainsi utiliser la commande suivante:

<p>
<example>
cp -a /usr/local /destination
</example>

<p>
Cependant, il existe quelques cas qui ne fonctionnent
pas<footnote>comme les fichiers morcelés et les liens physiques par
exemple</footnote>. Dès-lors, la meilleure façon de procéder lors
d'une grande copie est d'enchaîner deux commandes <prgn>tar</prgn>
consécutives, comme ceci:

<p>
<example>
tar -cSpf - /usr/local | tar -xvSpf -C /destination
</example>

<p>
La première commande <prgn>tar</prgn> archive le répertoire et
l'entube dans le second. La seconde commande déploie l'archive dans
l'emplacement spécifié avec l'option <prgn>-C</prgn>.
</sect1>
</sect>

<sect> Sécurité

<p>
Dans la partie 9.1, nous avons parlé des permissions sur les fichiers
dans Linux. C'est une façon fondamentale de sécuriser votre
système. Si vous faîtes tourner un système multi-utilisateurs ou un
serveur, il est primordial d'établir des bonnes permissions. Une bonne
règle de base consiste à configurer les fichiers avec les permissions
les plus basses autorisant leur bon usage.

<p>
Si vous faîtes tourner un serveur en réseau, il y a quelques petites
bricoles auxquelles il faut faire attention. Premièrement, vous devez
désinstaller ou arrêter les services que vous n'utilisez pas. Un bon
point de départ est le fichier <prgn>/ect/inetd.conf</prgn>. Vous
pouvez probablement désactiver quelques services. Pour la plupart des
services réseau, vous pouvez contrôler qui y a accès. Les fichiers
<prgn>/etc/host.allow</prgn> et <prgn>/etc/hosts.deny</prgn>
(documentés dans <prgn>man 5 hosts_access</prgn>) peuvent contrôler
qui a accès à quel service. Vous devez aussi être à jour des rustines
(<em>patches</em>) ou des mises-à-jour proposées par Debian. Elles
sont disponibles dans votre miroir FTP de Debian.

<p>
Les règles suivantes de bon sens doivent aussi s'appliquer:

<p>
<list>
<item> Ne révélez à personne votre mot de passe.
<item> N'envoyez jamais votre mot de passe en clair à travers Internet
en utilisant <prgn>telnet</prgn> ou <prgn>ftp</prgn>. Utilisez des
protocoles de cryptage ou évitez de vous loguer à distance.
<item> Évitez d'utiliser le compte root le plus possible
<item> N'installez pas de logiciels non sûrs et ne les installez par en
tant que  root
<item> Évitez de laisser des accès libre en écriture dans la mesure du
possible. <prgn>/tmp</prgn> est une exception à cette règle.
</list>

<p>
Bien que cela soit de peu d'utilité pour quelqu'un qui ne fait pas
tourner un serveur, cela vaut la peine de se renseigner sur les
questions de sécurité. Le mécanisme de sécurité de Debian vous protège
de la plupart des virus.
</sect>

<sect> Le développement de logiciels avec Debian

<p>
Debian est une plateforme privilégiée pour le développement de
logiciels et la programmation. Voici une liste des langages et
pseudo-langages supportés: C, C++, Objective-C, Perl, Python, m4,
Ada, Pascal, Java, awk, Tcl/Tk, SQL, assembleur, Bourne shell, csh et
bien d'autres encore. L'écriture de programmes est hors du propos de
ce livre mais voici les programmes de développement parmi les plus
populaires que l'on trouve sur Debian:

<p>
<list>
<item> <prgn>gcc</prgn>
<p>
  Le compilateur C de GNU: un compilateur moderne et optimisé de C.
<item> <prgn>g++</prgn>
<p>
  Le compilateur C++ extrait de <prgn>gcc</prgn>
<item> <prgn>cpp</prgn>
<p>
  Le pré-processeur de C de <prgn>gcc</prgn>
<item> <prgn>perl</prgn>
<p>
  L'interpréteur Perl. Perl est un super langage multi-usages.
<item> <prgn>gdb</prgn>
<p>
  Le débogueur GNU. Il est utilisé pour déboguer de nombreux langages.
<item> <prgn>gprof</prgn>
<p>
  Extraction de profile. Ce programme vous aide à optimiser votre
  programme pour augmenter ses performances.
<item> <prgn>emacs</prgn>
<p> 
  <em>GNU Emacs</em> est un éditeur et un environnement intégré de travail.
<item> <prgn>as</prgn>
<p>
 C'est l'assembleur de GNU.
</list>
</sect>

</chapt>
<chapt> Lire la documentation et obtenir de l'aide

<sect> Les sources de documentation

<p>
Sur un système Debian, vous pouvez trouver la documentation aux
emplacements suivants:

<p>
<list>
<item> Pages de manuel, que l'on peut lire avec la commande <prgn>man</prgn>
<item> Pages info, que l'on peut lire avec la commande <prgn>info</prgn>
<item> Les répertoires de <prgn>/usr/doc/paquets</prgn> où
<em>paquet</em> est le nom du paquet
Debian<footnote><prgn>zless</prgn> est très pratique pour lire les
fichiers de <prgn>/usr/doc</prgn>. Voir chapitre 10.1 pour plus de
détails.</footnote>
<item> Le répertoire <prgn>/usr/doc/HOWTO</prgn> contient les HOWTOs
du Projet Linux de Documentation, si vous avez installé les paquets
les contenant.
<item> La plupart des commandes ont une option <prgn>-h</prgn> ou
<prgn>--help</prgn>. Tapez le nom de la commande suivi d'une de ces
options pour essayer.
<item> Le Projet de Documentation de Debian
(<em>https://www.debian.org/ddp/</em>) fournit aussi quelques
manuels.
<item> La page d'assistance de Debian
(<em>https://www.debian.org/support/</em>) possède sa FAQ et quelques
autres documents. Vous pouvez aussi essayer le site oueb de Linux
(<em>http://www/linux.org</em>).
</list>

<p>
Cette déroutante profusion de sources de documentations existe pour des
tas de raisons. Par exemple, <prgn>info</prgn> est supposé remplacer
le <prgn>man</prgn> mais <prgn>man</prgn> n'a toujours pas disparu à
ce jour. Mais dans tous les cas, il est rassurant de savoir que tant
de documentations existent !

<p>
Ainsi, où chercher pour obtenir de l'aide ? Voici quelques
suggestions:

<p>
<list>
<item> Utilisez la page info ou l'option <prgn>--help</prgn> pour
avoir un résumé rapide de la syntaxe et des options de la
commande. Utilisez aussi la page de manuel si le programme n'a pas de
page info.
<item> Utilisez la page info si le programme possède une documentation
à ce format.
<item> Si cela ne donne rien, allez voir dans
<prgn>/usr/doc/nomdepaquet</prgn>
<item> Utilisez les HOWTOs pour régler une chose particulière ou
chercher une information sur un matériel particulier. Par exemple,
l'<prgn>Eternet-HOWTO</prgn> regorge d'informations sur les cartes
Ethernet et le <prgn>PPP-HOWTO</prgn> explique en détail comment
configurer une liaison <prgn>ppp</prgn>.
<item> Utilisez les manuels du Projet de Documentation Debian pour les
concepts inhérents et spécifiques à Debian.
<item> Si tout cela ne donne rien, demandez de l'aide à
quelqu'un. Voir la partie 16.4 pour cela.
</list>

<p>
Comment utiliser les pages de manuel est expliqué à la partie 7.1. C'est très
simple: appuyez sur la touche espace pour aller à la page suivante et
appuyez sur <prgn>q</prgn> pour quitter le manuel. Utiliser
<prgn>info</prgn>, visualiser les fichiers de <prgn>/usr/doc</prgn> et
demander de l'aide à quelqu'un font l'objet des parties suivantes du
chapitre.
</sect>


<sect> Utiliser <prgn>info</prgn>

<p>
<prgn>info</prgn> est le visualiseur de documentation de GNU. Certains
programmes fournissent leur documentation au format <prgn>info</prgn>
et vous pouvez utiliser <prgn>info</prgn> pour la lire. Vous pouvez
lancer le visualiseur en tapant simplement <prgn>info</prgn> ou en lui
passant un argument comme ceci:

<p>
<example>
info emacs
</example>

<p>
Vous pouvez obtenir aussi des informations sur <prgn>info</prgn>
lui-même en appelant le tutoriel interne:

<p>
<example>
info info
</example>

<p>
Maintenant, vous pouvez vous déplacer à l'aide des touches suivantes:

<p>
<list>
<item> <prgn>flèches</prgn>
<p>
  Pour déplacer le curseur au sein du document.
<item> <prgn>m RET</prgn>
<p>
  Sélectionne le choix d'un menu sous le curseur.
<item> <prgn>u</prgn>
<p>
  Pour «&nbsp;remonter&nbsp;» dans le document.
<item> <prgn>n</prgn>
<p>
  Pour aller à la page suivante.
<item> <prgn>p</prgn>
<p>
  Pour aller à la page précédente.
<item> <prgn>s</prgn>
<p>
  Pour rechercher quelque chose.
<item> <prgn>g</prgn>
<p>
  Pour aller à une page spécifique.
<item> <prgn>q</prgn>
<p>
  Quitter <prgn>info</prgn>
</list>

<p>
Vous remarquerez que la ligne supérieure de l'écran indique les pages
<em>next</em> (suivantes), <em>previous</em> (précédentes) et
<em>up</em> (supérieures) qui correspondent aux actions des touches
<prgn>n</prgn>, <prgn>p</prgn> et <prgn>u</prgn>.
</sect>

<sect> HOWTO

<p>
En plus de ses livres, le Projet de Documentation Linux a diffusé une
série de petits documents décrivant comment configurer des aspects
particuliers de GNU-Linux. Par exemple, le SCSI-HOWTO décrit les
complications de l'utilisation du SCSI - une façon standard de
communiquer avec des périphériques - sous GNU-Linux. De façon
générale, les HOWTOs ont plus de détails techniques sur des
configurations matérielles et sont souvent plus à jour que ce manuel.

<p>
Il y a des paquets Debian pour les HOWTOs. <prgn>doc-linux-text</prgn>
contient l'ensemble des HOWTOs au format texte et
<prgn>doc-linux-html</prgn> les contient (surprise!) au format html
pour naviguer. Remarquez bien que Debian fournit des traductions de
ces HOWTOs si l'anglais n'est pas votre langue maternelle. Debian a des
paquets en allemand, français, espagnol, italien, japonais, coréen,
polonais, suédois et chinois des HOWTOs. On les trouve généralement
dans les paquets <prgn>doc-linux-<em>languagecode</em></prgn> où
<em>languagecode</em> est <prgn>fr</prgn> pour le français,
<prgn>es</prgn> pour l'espagnol, etc... Si vous les avez installés,
vous les trouverez dans <prgn>/usr/doc/HOWTO</prgn>. Quoi qu'il en
soit, vous trouverez toujours les toutes dernières versions sur le
réseau sur la page du LDP:

<p>
<example>
http://metalab.unc.edu/LDP/
</example>

<sect> Aide personnalisée

<p>
L'emplacement correct<footnote>Les francophones ont leur propre liste
avec l'avantage du support de leur langue maternelle:
debian-user-french@lists.debian.org</footnote> pour demander de l'aide sur
Debian est la liste de distribution des utilisateurs de Debian à
<prgn>debian-user@lists.debian.org</prgn> (envoyer un courriel à
<prgn>debian-user@lists.debian.org</prgn>). Si vous savez vous servir
d'IRC, vous pouvez utiliser le canal <prgn>#debian</prgn> sur
<prgn>irc.debian.org</prgn>. Vous pouvez trouver de l'aide sur
GNU-Linux en général dans la hiérarchie USENET
<prgn>comp.os.linux.*.</prgn> Il est aussi possible d'embaucher des
consultants pour fournir un service d'assistance garantie. Le site
oueb de Debian (<em> https://www.debian.org</em>) fournit d'autres
informations sur beaucoup de ces ressources.

<p>
Une nouvelle fois, ne contactez pas les auteurs (et le traducteur!) de
ce livre pour obtenir de l'aide. Nous ne serons de toute façon
certainement pas capables de répondre à votre problème spécifique. Si
vous vous adressez à <prgn>debian-user</prgn>, vous recevrez quantité
de messages de qualité, et qui plus est rapidement.

<p>
Restez toujours courtois et faîtes l'effort de lire la
documentation. Rappelez-vous bien que Debian résulte d'un effort
collectif de volontaires et que les personnes vous font une faveur en
vous donnant un peu de leur temps pour vous aider. Beaucoup d'entre
eux font payer ce même service plusieurs centaines de dollars pendant
la journée.

<p>
<em> Ce qu'il faut faire pour poser des questions </em>

<p>
<list>

<item> Lire tout d'abord la documentation de base en premier. Les
trucs comme les options des commandes et ce que fait une commande en
fait partie. Cela inclut aussi les pages de manuel et la documentation
au format info.
<item> Vérifier les documents HOWTOs si votre question concerne un
réglage comme une connexion <prgn>ppp</prgn> ou <prgn>Ethernet</prgn>.
<item> Essayez d'être sûr que la réponse ne se trouve pas dans ce
livre.
<item> N'ayez pas peur de demander, après avoir fait l'effort
d'essayer de comprendre.
<item> N'ayez pas peur de demander des explications conceptuelles, des
conseils sur tous les aspects que l'on ne trouve pas dans les
documentations.
<item> Joignez toute information intéressante. Vous devez toujours
mentionner la version de Debian que vous utilisez. Vous pouvez aussi
mentionner le numéro de version de tout paquet pertinent. La commande
<prgn>dpkg -l nomdupaquet </prgn> vous le fournit. Vous pouvez aussi
signaler ce que vous avez tenté et ce qu'il est advenu. N'oubliez
d'inclure les messages d'erreur complets et exacts, s'il y en a.
<item> Ne vous excusez pas d'être un nouveau sur Linux. Il n'y a pas
de raison d'être un expert pour pouvoir utiliser GNU-Linux, pas plus
qu'il est nécessaire d'être une mécanique pour conduire une
automobile.
<item> Ne postez pas ou n'envoyez pas de courriel en HTML. Certaines
versions de Netscape ou d'Internet Explorer postent par défaut en HTML
plutôt qu'en texte. Beaucoup de gens vont carrément alors ignorer ces
courriels car de nombreux lecteurs de courriels ont des difficultés à
lire ce format. Il y a une préférence quelque part pour désactiver le
support HTML.
<item> Soyez courtois. Rappelez-vous que Debian est un effort
collectif de bénévoles et quiconque vous aide vous donne une partie de
son temps libre.
<item> Renvoyez votre question à la liste si vous n'avez pas eu de
réponse après quelques jours. Il y avait peut-être de nombreux
messages et il est passé inaperçu. Ou peut-être que personne ne
connaissait la réponse et si personne n'est capable de répondre la
fois suivante, il s'agit d'une sacrée colle. Vous pourriez peut-être
fournir plus d'informations la fois suivante.
</list>
</sect>

<sect> Extraire des informations du système

<p>
Lorsque vous diagnostiquez un problème ou lorsque vous demandez de
l'aide, vous aurez besoin d'extraire des informations de votre
système. Voici quelques façons d'y parvenir:

<p>
<list>
<item> Examinez les fichiers placés dans <prgn>/var/log</prgn>
<item> Examinez la sortie du message de la commande <prgn>dmesg</prgn>
<item> Lancez la commande <prgn>uname -a</prgn>
</list>
</sect>




</chapt>
<chapt> Problèmes

<p>
Dans Debian, comme partout ailleurs, les choses ne fonctionnent pas
toujours comme vous vous y attendez ou comme vous voulez qu'elles le
fassent. Bien que Debian ait une solide réputation d'être robuste et
stable, ses réactions à vos commandes peuvent parfois être
inattendues. Ici, nous allons tenter de lever le voile sur des
problèmes courants très fréquemment rencontrés.


<sect> Difficultés classiques

<p>
Cette partie a pour but de fournir quelques solutions aux difficultés
les plus fréquemment rencontrées à l'usage par les utilisateurs.

<sect1>  Travailler avec des noms de fichiers étranges

<p>
Vous pourrez parfois accidentellement créer un fichier dont le nom
comporte un caractère normalement absent d'un nom de fichier. Les
exemples sont l'inclusion d'espace, un trait d'union placé au début du
nom ou tout simplement des guillemets. Il se peut que l'accès, la
destruction ou le renommage de ces fichiers vous posent des
difficultés.

<p>
Voici quelques trucs pour vous aider:

<p>
<list>
<item> Essayez d'entourer le nom de fichier d'apostrophes simples, comme ceci:
<p>
<prgn>less 'Fichier avec espaces.txt'</prgn>
<item> Insérez un <prgn>./</prgn> avant le nom de fichier:
<p>
<prgn>less './-un étrange fichier.txt'</prgn>
<item> Utilisez des motifs:
<p>
<prgn>less Fichier?avec?espaces.txt</prgn>
<item> Utilisez un contre-slash devant chaque caractère inhabituel
<p>
<prgn>less Fichier\ avec\ espaces.txt</prgn>
</list>
</sect1>

<sect1> Imprimer

<p>
Une source d'ennui commune est le système d'impression sous
Debian. Traditionnellement, l'impression a toujours été un aspect
puissant mais complexe d'Unix. Cependant, Debian la rend plus
simple. La façon la plus simple est d'utiliser le paquet
<prgn>magicfilter</prgn>. <prgn>magicfilter</prgn> va vous poser une
série de questions au sujet de votre imprimante et la configurer pour
vous. Si vous avez des soucis d'impression, essayez
<prgn>magicfilter</prgn>.
</sect1>

<sect1> Les problème sous X

<p>
De nombreuses questions tournent autour de X. Voici quelques trucs si
vous avez quelques difficultés à paramétrer le système X Window.

<p>
<list>
<item>Pour les problèmes de souris, lancez <prgn>XF86Setup</prgn> et
essayez les options PS/2, Microsoft, MouseSystems et Logitech. La
plupart des souris devraient correspondre à l'une d'entre elles. Le
périphérique pour les souris est <prgn>/dev/psaux</prgn> pour celle
PS/2 et un port série comme <prgn>/dev/ttyS0</prgn> pour les souris
série.
<item> Si vous ne connaissez pas votre chipset vidéo, lancez
<prgn>SuperProbe</prgn>: cela permet souvent de le déterminer pour
vous.
<item> Si votre écran ne possède pas beaucoup de couleurs, essayez de
sélectionner une autre carte ou indiquez à X quelle quantité de
mémoire vidéo vous possédez.
<item> Si votre écran reste blanc, ou bien si vous avez un texte
illisible en lançant X, vous avez probablement sélectionné un taux de
rafraîchissement incorrect. Retournez dans <prgn>XF86Setup</prgn> ou
<prgn>xf86config</prgn> et revérifiez ces réglages.
<item> <prgn>xvidtune</prgn> peut vous aider à régler l'image si elle
est trop à droite ou trop à gauche ou bien si elle est trop haute ou
trop basse.
<item><prgn>xdpyinfo</prgn> peut vous donner des informations sur une
session X en cours.
<item><prgn>XF86Setup</prgn> peut vous régler votre profondeur de couleurs
par défaut.
<item> Vous pouvez sélectionner votre gestionnaire de fenêtres par
défaut en modifiant <prgn>/etc/X11/window-managers</prgn>.
<item> <prgn>/var/log/xdm-errors</prgn> peut contenir des informations
utiles si vous avez des problèmes en lançant <prgn>xdm</prgn>.
</list>
</sect1>
</sect>

<sect> Problème lors de la procédure de boot

<p>
Si vous avez des problèmes durant la phase de boot, comme un blocage
du noyau pendant la procédure d'amorçage, ou que le noyau ne
reconnaisse pas les périphériques que vous avez ou encore que les
lecteurs ne soient reconnus proprement, la première chose à faire est
de vérifier les paramètres de boot. On les obtient en pressant sur la
touche <prgn>F1</prgn> lors du boot sur la disquette de secours.

<p>
La plupart du temps, les problèmes se résolvent en supprimant quelques
périphériques et en bootant à nouveau. Les modems internes, les cartes
son et les périphériques <em>Plug-n-Play</em> sont souvent
problématiques.

<p>
Tecras, et quelques autres portables, et certains non portables
n'arrivent pas à vider le cache lorsqu'ils passent en A20. Ceci est
provoqué par les noyaux bzImage et non par les noyaux zImages. Si
votre ordinateur souffre de ce problème, vous verrez un message lors
du boot disant <prgn>saying A200 gating failed</prgn>. Dans ce cas, il
est nécessaire d'utiliser les images de boot «&nbsp;tecra&nbsp;».

<p>
Si vous avez toujours des problèmes, envoyez un rapport de
bogue. Envoyez un courriel à 
<example>submit@bugs.debian.org</example>
Vous DEVEZ inclure les lignes suivantes en en-tête de votre courriel:

<p>
<example>
Package: boot-floppies
Version: version
</example>

<p>
Assurez-vous que la <em>version</em> que vous fournissez est celle que
vous avez utilisé avec les disquettes de boot. Si vous ne connaissez
pas la version exacte, fournissez la date à laquelle vous avez
téléchargé les disquettes, et ajoutez à partir de quelle distribution
vous les avez obtenues: «&nbsp;stable&nbsp;» ou «&nbsp;frozen&nbsp;».

<p>
Vous devez aussi inclure les informations suivantes dans votre rapport
de bogues:

<p>
<list>
<item> <prgn>architecture</prgn>: i386
<item> <prgn>model</prgn>: votre matériel principal et le modèle
<item> <prgn>memory</prgn>: la quantité de RAM
<item> <prgn>SCSI</prgn>: les adapteurs, s'il y en a.
<item> <prgn>cd-rom</prgn>: type de cédérom et son interface (ATAPI)
<item> <prgn>network card</prgn>: votre carte réseau, si vous en avez une.
<item> <prgn>pcmcia</prgn>: le détail de vos périphériques PCMCIA
</list>

<p>
Cela dépend de la nature du bogue mais il peut être pertinent de
donner le modèle du disque dur, la capacité du disque et le modèle de
carte vidéo.

<p>
Dans le rapport de bogue, décrivez le problème et joignez les derniers
messages visibles du noyau dans le cas d'un blocage du noyau. Décrivez
les étapes qui vous ont amenées dans cet état.
</sect>

</chapt>
<chapt> Booter le système

<p>
Cette partie montre ce qui se passe lors du boot de GNU-Linux.

<p>
La façon dont vous amorcez votre système dépend de la façon dont vous
l'avez configuré à l'installation. Dans le meilleur des cas, vous
n'avez qu'à allumer votre ordinateur. Mais il se peut que vous deviez
insérer une disquette.

<p>
Linux est appelé par un programme appelé LILO (LInux LOader,
littéralement «&nbsp;chargeur de linux&nbsp;»). LILO peut aussi
charger un autre système d'exploitation et vous demander sur quel
système vous désirez booter.

<p>
La première chose qui se passe lorsque vous allumez un PC de type
Intel est l'exécution du BIOS. BIOS signifie <em>Basic Input Output
System</em> (système d'entrée-sortie simple). C'est un programme
résidant perpétuellement sur l'ordinateur et stocké en lecture seule
sur un composant. Il effectue quelques tests basiques et ensuite
recherche une disquette dans le premier lecteur de disquettes. S'il la
trouve, il recherche un secteur d'amorce (<em>boot sector</em>) et
lance le code se trouvant dessus s'il existe. S'il y a une disquette
sans secteur d'amorce, le BIOS va vous afficher un message du type:
<prgn>Non-system disk</prgn> ou <prgn>disk
error</prgn><footnote><em>Disque non-système</em> et <em>mauvaise
disquette</em></footnote>. Retirez alors la disquette et appuyez sur
une touche pour relancer la procédure de boot.

<p>
S'il n'y a pas de disquette dans le lecteur, le BIOS recherche un MBR
(<em>Master Boot Record</em>) sur le disque dur. Il lance le code
exécutable trouvé dessus qui charge le système d'exploitation. Sur des
systèmes GNU-Linux, LILO peut occuper le MBR et charger GNU-Linux.

<p>
Ainsi, si vous avez décidé d'installer LILO sur votre disque dur, vous
devriez apercevoir LILO au démarrage de votre ordinateur. À partir de
ce moment-là, vous pouvez appuyer sur la touche <em>shift</em> pour
sélectionner quel système d'exploitation charger et appuyez sur
<em>Tab</em> pour afficher la liste des options. Tapez sur une de ces
options et appuyez sur la touche <em>Entrée</em>. LILO va charger le
système demandé.

<p>
Si vous n'appuyez pas sur la touche <em>shift</em>, LILO chargera
automatiquement le système par défaut au bout de cinq secondes. Si
vous le désirez, vous pouvez changer le système par défaut, le nombre
de systèmes et le temps d'attente avant le chargement.

<p>
Si vous n'avez pas installé LILO sur votre disque dur, vous avez
probablement créé une <em>disquette de boot</em>. La disquette de boot
va avoir LILO dessus. Tout ce que vous avez à faire est d'installer la
disquette dans son lecteur et rallumer l'ordinateur; le BIOS va la
trouver avant de vérifier le MBR du disque. Pour retourner à un
système non-linux, sortez la disquette et redémarrez
l'ordinateur. Assurez-vous bien de suivre la procédure (voir 6.6) de
redémarrage correctement.

<p>
LILO charge le noyau linux à partir du disque et ensuite le laisse
agir. (le noyau est le programme central du système d'exploitation qui
contrôle tous les autres programmes). Le noyau est totalement
indépendant du BIOS ou de LILO.

<p>
Sur les plateformes non Intel, les choses se passent un peu
différemment. Mais après avoir booté, les choses sont identiques - ou
quasiment.

<p>
Linux examine le matériel sur lequel il va tourner. Il veut savoir
quel type de disque dur vous avez, si vous avez ou non un bus souris,
un réseau et quelques autres choses du même acabit. Linux ne peut se
rappeler ces choses entre chaque boot donc il doit se poser ces
questions à chaque démarrage. Heureusement, il ne <em>vous</em> pose
pas les questions mais le fait directement au matériel. Lors du boot,
le noyau Linux affiche des messages pour indiquer ce qu'il fait.

<p>
Le processus de recherche peut poser des problèmes mais s'il devait le
faire, vous auriez déjà dû rencontrer ces problèmes lors de la
première installation de GNU-Linux. Si vous avez des problèmes,
reportez-vous aux instructions d'installation ou bien posez des
questions sur les listes de distribution.

<p>
Le noyau permet simplement l'existence d'autres programmes donc une
fois que tout est ok pour lui, il doit lancer un autre programme pour
rendre les choses plus fonctionnelles. Le programme que le noyau lance
est <prgn>init</prgn>. Après que le noyau ait lancé <prgn>init</prgn>,
il ne lance jamais plus d'autres programmes. Le noyau devient alors un
gestionnaire et un fournisseur de services.

<p>
Lorsque <prgn>init</prgn> se lance, il lance un certain nombre de
scripts (des fichiers contenant des commandes) qui préparent le
système à être utilisé. Il y a des routines de maintenance et de
nombreux programmes qui font des choses comme fournir un prompteur de
login, écouter les connexions réseau et garder une trace des activités
de l'ordinateur.

</chapt>
<chapt> La Licence Publique Générale de GNU

<p>
<em>
This is an unofficial translation of the GNU General Public License into
french. It was not published by the Free Software Foundation, and does not
legally state the distribution terms for software that uses the GNU
GPL--only the original English text of the GNU GPL does that. However, we
hope that this translation will help french speakers understand the GNU GPL
better.
</em>

<p>
Ceci est une traduction non officielle de la <em>GNU General Public
License</em> en français. Elle n'a pas été publiée par la <em>Free
Software Foundation</em>, et ne détermine pas les termes de distribution
pour les logiciels qui utilisent la GNU GPL--seul le texte anglais
original de la GNU GPL en a le droit.  Cependant, nous espérons que
cette traduction aidera les francophones à mieux comprendre la GPL.

<p>
Nous autorisons la FSF à apporter toute modification qu'elle jugera
nécessaire pour rendre la traduction plus claire.

<sect>
GNU GENERAL PUBLIC LICENSE

<p>
Version 2, juin 1991

<p>
Copyright &copy 1989, 1991, Free Software Foundation Inc. 675 Mass Ave,
Cambridge, MA02139, États-Unis.

<p>
Il est permis à tout le monde de reproduire et distribuer des copies
conformes de ce document de licence, mais aucune modification ne doit y être
apportée.

<p>
Préambule

<p>
Les licences relatives à la plupart des logiciels sont destinées à
supprimer votre liberté de les partager et de les modifier. Par
contraste, la licence publique générale <em>GNU General Public
License</em> veut garantir votre liberté de partager et de modifier
les logiciels libres, pour qu'ils soient vraiment libres pour tous
leurs utilisateurs. La présente licence publique générale s'applique à
la plupart des logiciels de la <em>Free Software Foundation</em>, ainsi qu'à
tout autre programme dont les auteurs s'engagent à l'utiliser.
(Certains autres logiciels sont couverts par la Licence Publique
Générale pour Bibliothèques GNU à la place). Vous pouvez aussi
l'appliquer à vos programmes.

<p>
Quand nous parlons de logiciels libres, nous parlons de liberté, non de
gratuité. Nos licences publiques générales veulent vous garantir :

<list>
<item> que vous avez toute liberté de distribuer des copies des
logiciels libres (et de facturer ce service, si vous le souhaitez) ;
<item> que vous recevez les codes sources ou pouvez les obtenir si
vous le souhaitez ;
<item> que vous pouvez modifier les logiciels ou en utiliser des
éléments dans de nouveaux programmes libres ;
<item> et que vous savez que vous pouvez le faire.
</list>

<p>
Pour protéger vos droits, nous devons apporter des restrictions, qui vont
interdire à quiconque de vous dénier ces droits, ou de vous demander de vous
en désister. Ces restrictions se traduisent par certaines responsabilités
pour ce qui vous concerne, si vous distribuez des copies de logiciels, ou si
vous les modifiez.

<p>
Par exemple, si vous distribuez des copies d'un tel programme, gratuitement
ou contre une rémunération, vous devez transférer aux destinataires tous les
droits dont vous disposez. Vous devez vous garantir qu'eux-mêmes, par
ailleurs, reçoivent ou peuvent recevoir le code source. Et vous devez leur
montrer les présentes dispositions, de façon qu'ils connaissent leurs
droits.

<p>
Nous protégeons vos droits en deux étapes :

<enumlist>
<item> Nous assurons le droit d'auteur (<em>copyright</em>) du logiciel, et

<item>Nous vous proposons cette licence, qui vous donne l'autorisation légale
     de dupliquer, distribuer et/ou modifier le logiciel.
</enumlist>

<p>
De même, pour la protection de chacun des auteurs, et pour notre propre
protection, nous souhaitons nous assurer que tout le monde comprenne qu'il
n'y a aucune garantie portant sur ce logiciel libre. Si le logiciel est
modifié par quelqu'un d'autre puis transmis à des tiers, nous souhaitons que
les destinataires sachent que ce qu'ils possèdent n'est pas l'original, de
façon que tous problèmes introduits par d'autres ne se traduisent pas par
une répercussion négative sur la réputation de l'auteur original.

<p>
Enfin, tout programme libre est en permanence menacé par des brevets de
logiciels. Nous souhaitons éviter le danger que des sous-distributeurs d'un
programme libre obtiennent à titre individuel des licences de brevets, avec
comme conséquence qu'ils ont un droit de propriété sur le programme. Pour
éviter cette situation, nous avons fait tout ce qui est nécessaire pour que
tous brevets doivent faire l'objet d'une concession de licence qui en
permette l'utilisation libre par quiconque, ou bien qu'il ne soit pas
concédé du tout.

<p>
Nous présentons ci-dessous les closes et dispositions concernant la
duplication, la distribution et la modification.

<p>
Conditions d'exploitation portant sur la duplication, la distribution et la
modification

<enumlist>

<item> 
  Le présent contrat de licence s'applique à tout programme ou autre
  ouvrage contenant un avis, apposé par le détenteur du droit de
  propriété, disant qu'il peut être distribué au titre des
  dispositions de la présente Licence Publique Générale. Ci-après, le
  «&nbsp;Programme&nbsp;» désigne l'un quelconque de ces programmes ou
  ouvrages, et un «&nbsp;ouvrage fondé sur le programme&nbsp;» désigne
  soit le programme, soit un ouvrage qui en dérive au titre de la loi
  sur le droit d'auteur ; plus précisément, il s'agira d'un ouvrage
  contenant le programme ou une version de ce dernier, soit mot à mot,
  soit avec des modifications et/ou traduit en une autre langue
  (ci-après, le terme «&nbsp;modification&nbsp;» englobe, sans aucune
  limitation, les traductions qui en sont faites). Chaque titulaire de
  licence sera appelé «&nbsp;concessionnaire&nbsp;».
<p>
   Les activités autres que la duplication, la distribution et la
   modification ne sont pas couvertes par la présente licence ; elles
   n'entrent pas dans le cadre de cette dernière. L'exécution du
   programme n'est soumise à aucune restriction, et les résultats du
   programme ne sont couverts que si son contenu constitue un ouvrage
   fondé sur le programme (indépendamment du fait qu'il a été réalisé
   par exécution du programme). La véracité de ce qui précède dépend
   de ce que fait le programme.

<item>
   Le concessionnaire peut dupliquer et distribuer des copies mot à
   mot du code source du programme tel qu'il les reçoit, et ce sur un
   support quelconque, du moment qu'il appose, d'une manière
   parfaitement visible et appropriée, sur chaque exemplaire, un avis
   approprié de droits d'auteur (<em>Copyright</em>) et de renonciation à
   garantie ; qu'il maintient intacts tous les avis qui se rapportent
   à la présente licence et à l'absence de toute garantie ; et qu'il
   transmet à tout destinataire du programme un exemplaire de la
   présente licence en même temps que le programme.
<p>
   Le concessionnaire peut facturer l'acte physique de transfert d'un
   exemplaire, et il peut, à sa discrétion, proposer en échange d'une
   rémunération une protection en garantie.

<item>
   Le concessionnaire peut modifier son ou ses exemplaires du
   programme ou de toute portion de ce dernier, en formant ainsi un
   ouvrage fondé sur le programme, et dupliquer et distribuer ces
   modifications ou cet ouvrage selon les dispositions de la section 1
   ci-dessus, du moment que le concessionnaire satisfait aussi à
   toutes ces conditions :
<list>
<item>    Le concessionnaire doit faire en sorte que les fichiers modifiés
          portent un avis, parfaitement visible, disant que le
          concessionnaire a modifié les fichiers, avec la date de tout
          changement.

<item>    Le concessionnaire doit faire en sorte que tout ouvrage qu'il
          distribue ou publie, et qui, en totalité ou en partie, contient le
          programme ou une partie quelconque de ce dernier ou en dérive,
          soit concédé en bloc, à titre gracieux, à tous tiers au titre des
          dispositions de la présente licence.

<item>     Si le programme modifié lit normalement des instructions
          interactives lors de son exécution, le concessionnaire doit, quand
          il commence l'exécution du programme pour une telle utilisation
          interactive de la manière la plus usuelle, faire en sorte que ce
          programme imprime ou affiche une annonce, comprenant un avis
          approprié de droits d'auteur, et un avis selon lequel il n'y a
          aucune garantie (ou autrement, que le concessionnaire fournit une
          garantie), et que les utilisateurs peuvent redistribuer le
          programme au titre de ces dispositions, et disant à l'utilisateur
          comment visualiser une copie de cette licence (exception : si le
          programme par lui-même est interactif mais n'imprime normalement
          pas une telle annonce, l'ouvrage du concessionnaire se fondant sur
          le programme n'a pas besoin d'imprimer une annonce).
</list>

<item> 
  Les exigences ci-dessus s'appliquent à l'ouvrage modifié pris en
  bloc.  Si des sections identifiables de cet ouvrage ne dérivent pas
  du programme et peuvent être considérées raisonnablement comme
  représentant des ouvrages indépendants et distincts par eux-mêmes,
  alors la présente licence, et ses dispositions, ne s'appliquent pas
  à ces sections quand le concessionnaire les distribue sous forme
  d'ouvrages distincts. Mais quand le concessionnaire distribue ces
  mêmes sections en tant qu'élément d'un tout qui représente un
  ouvrage se fondant sur le programme, la distribution de ce tout doit
  se faire conformément aux dispositions de la présente licence, dont
  les autorisations, portant sur d'autres concessionnaires, s'étendent
  à la totalité dont il est question, et ainsi à chacune de ces
  parties, indépendamment de celui qu'il a écrite.
<p>
  Ainsi, cette section n'a pas pour but de revendiquer des droits ou
  de contester vos droits sur un ouvrage entièrement écrit par le
  concessionnaire ; bien plus, l'intention est d'exercer le droit de
  surveiller la distribution d'ouvrages dérivée ou collective se
  fondant sur le programme.
<p>
  De plus, un simple assemblage d'un autre ouvrage ne se fondant pas
  sur le programme, avec le programme (ou avec un ouvrage se fondant
  sur le programme) sur un volume d'un support de stockage ou
  distribution, ne fait pas entrer l'autre ouvrage dans le cadre de la
  présente licence.

<item>
   Le concessionnaire peut dupliquer et distribuer le programme (ou un
   ouvrage se fondant sur ce dernier, au titre de la Section 2), en
   code objet ou sous une forme exécutable, au titre des dispositions
   des Sections 1 et 2 ci-dessus, du moment que le concessionnaire
   effectue aussi l'une des opérations suivantes :
<list>
<item>    Lui joindre le code source complet correspondant, exploitable par
          une machine, code qui doit être distribué au titre des Sections 1
          et 2 ci-dessus sur un support couramment utilisé pour l'échange de
          logiciels ; ou bien

<item>    Lui joindre une offre écrite, dont la validité se prolonge pendant
          au moins 3 ans, de transmettre à un tiers quelconque, pour un
          montant non supérieur au coût pour le concessionnaire, de
          réalisation physique de la distribution de la source, un
          exemplaire complet, exploitable par une machine, du code source
          correspondant, qui devra être distribué au titre des dispositions
          des Sections 1 et 2 ci-dessus sur un support couramment utilisé
          pour l'échange des logiciels ; ou bien

<item>    Lui joindre les informations que le concessionnaire a reçues, pour
          proposer une distribution du code source correspondant (cette
          variante n'est autorisée que pour la distribution non commerciale,
          et seulement si le concessionnaire a reçu le programme sous forme
          exécutable ou sous forme d'un code objet, avec une telle offre,
          conformément à l'alinéa b) ci-dessus).
</list>
<p>
   Le code source d'un ouvrage représente la forme préférée de
   l'ouvrage pour y effectuer des modifications. Pour un ouvrage
   exécutable, le code source complet représente la totalité du code
   source pour tous les modules qu'il contient, plus tous fichiers de
   définitions d'interface associés, plus les informations en code
   machine pour commander la compilation et l'installation du
   programme exécutable. Cependant, à titre d'exceptions spéciales, le
   code source distribué n'a pas besoin de comprendre quoi que ce soit
   qui est normalement distribué (sous forme source ou sous forme
   binaire) avec les composants principaux (compilateur, noyau de
   système d'exploitation, etc.) du système d'exploitation sur lequel
   est exécuté le programme exécutable, à moins que le composant, par
   lui-même, soit joint au programme exécutable.
<p>
   Si la distribution de l?exécutable ou du code objet est réalisée de
   telle sorte qu'elle offre d'accéder à une copie à partir d'un lieu
   désigné, alors le fait d'offrir un accès équivalent à la
   duplication du code source à partir de ce même lieu s'entend comme
   distribution du code source, même si des tiers ne sont pas
   contraints de dupliquer la source en même temps que le code objet.

<item> 
   Le concessionnaire ne peut dupliquer, modifier, concéder en
   sous-licence ou distribuer le programme, sauf si cela est
   expressément prévu par les dispositions de la présente
   licence. Toute tentative pour autrement dupliquer, modifier,
   concéder en sous-licence ou distribuer le programme est répétée
   nulle, et met automatiquement fin aux droits du concessionnaire au
   titre de la présente licence. Cependant, les parties qui ont reçu
   des copies, ou des droits, de la part du concessionnaire au titre
   de la présente licence, ne verront pas expirer leur contrat de
   licence, tant que ces parties agissent d'une manière parfaitement
   conforme.

<item>
   Il n'est pas exigé du concessionnaire qu'il accepte la présente
   licence, car il ne l'a pas signée. Cependant, rien d'autre
   n'octroie au concessionnaire l'autorisation de modifier ou de
   distribuer le programme ou ses ouvrages dérivés. Ces actions sont
   interdites par la loi si le concessionnaire n'accepte pas la
   présente licence. En conséquence, par le fait de modifier ou de
   distribuer le programme (ou un ouvrage quelconque se fondant sur le
   programme), le concessionnaire indique qu'il accepte la présente
   licence, et qu'il a la volonté de se conformer à toutes les closes
   et dispositions concernant la duplication, la distribution ou la
   modification du programme ou d'ouvrages se fondant sur ce dernier.

<item>
   Chaque fois que le concessionnaire redistribue le programme (ou
   tout ouvrage se fondant sur le programme), le destinataire reçoit
   automatiquement une licence de l'émetteur initial de la licence,
   pour dupliquer, distribuer ou modifier le programme, sous réserve
   des présentes closes et dispositions. Le concessionnaire ne peut
   imposer aucune restriction plus poussée sur l'exercice, par le
   destinataire, des droits octroyés au titre des présentes. Le
   concessionnaire n'a pas pour responsabilité d'exiger que des tiers
   se conforment à la présente licence.

<item>
   Si, en conséquence une décision de justice ou une allégation
   d'infraction au droit des brevets, ou pour toute autre raison (qui
   n'est pas limitée à des problèmes de propriétés industrielles), des
   conditions sont imposées au concessionnaire (par autorité de
   justice, par convention ou autrement), qui entrent en contradiction
   avec les dispositions de la présente licence, elles n'exemptent pas
   le concessionnaire de respecter les dispositions de la présente
   licence.  Si le concessionnaire ne peut procéder à la distribution
   de façon à satisfaire simultanément à ces obligations au titre de
   la présente licence et à toutes autres obligations pertinentes,
   alors, en conséquence de ce qui précède, le concessionnaire peut ne
   pas procéder du tout à la distribution du programme. Par exemple,
   si une licence de brevet ne permettait pas une redistribution du
   programme, sans redevances, par tous ceux qui reçoivent des copies
   directement ou indirectement par l'intermédiaire du
   concessionnaire, alors le seul moyen par lequel le concessionnaire
   pourrait satisfaire tant à cette licence de brevet qu'à la présente
   licence, consisterait à s'abstenir complètement de distribuer le
   programme.
<p>
   Si une partie quelconque de cette section est considérée comme
   nulle ou non exécutoire dans certaines circonstances particulières,
   le reste de cette section est réputé s'appliquer, et la section
   dans son ensemble est considérée comme s'appliquant dans les autres
   circonstances.
<p>
   La présente section n'a pas pour objet de pousser le
   concessionnaire à enfreindre tous brevets ou autres revendications
   à droit de propriété, ou encore à contester la validité de une ou
   plusieurs quelconques de ces revendications ; la présente section a
   pour objet unique de protéger l'intégrité du système de
   distribution des logiciels libres, système qui est mis en oeuvre
   par les pratiques liées aux licences publiques. De nombreuses
   personnes ont apporté une forte contribution à la gamme étendue des
   logiciels distribués par ce système, en comptant sur l'application
   systématique de ce système ; c'est à l'auteur/donateur de décider
   s'il a la volonté de distribuer le logiciel par un quelconque autre
   système, et un concessionnaire ne peut imposer ce choix.
<p>
   La présente section veut rendre parfaitement claire ce que l'on
   pense être une conséquence du reste de la présente licence.

<item>
   Si la distribution et/ou l'utilisation du Programme est restreinte
   dans certains pays, sous l'effet de brevets ou d'interfaces
   présentant un droit d'auteur, le détenteur du droit d'auteur
   original, qui soumet le Programme aux dispositions de la présente
   licence, pourra ajouter une limitation expresse de distribution
   géographique excluant ces pays, de façon que la distribution ne
   soit autorisée que dans les pays ou parmi les pays qui ne sont pas
   ainsi exclus. Dans ce cas, la limitation fait partie intégrante de
   la présente licence, comme si elle était écrite dans le corps de la
   présente licence.
<p>
   La <em>Free Software Foundation</em> peut, de temps à autre,
   publier des versions révisées et/ou nouvelles du <em>General Public
   License</em>. Ces nouvelles versions seront analogues, du point de
   vue de leur esprit, à la présente version, mais pourront en
   différer dans le détail, pour résoudre de nouveaux problèmes ou de
   nouvelles situations.
<p>
   Chaque version reçoit un numéro de version qui lui est propre. Si
   le programme spécifie un numéro de version de la présente licence,
   qui s'applique à cette dernier et "à toute autre version
   ultérieure", le concessionnaire a le choix de respecter les closes
   et dispositions de cette version, ou une quelconque version
   ultérieure publiée par la <em>Free Software Foundation</em>. Si le programme
   ne spécifie pas de numéro de version de la présente licence, le
   concessionnaire pourra choisir une version quelconque publiée à
   tout moment par la <em>Free Software Foundation</em>.

<item>
   Si le concessionnaire souhaite incorporer des parties du programme
   dans d'autres programmes libres dont les conditions de distribution
   sont différentes, il devrait écrire à l'auteur pour demander son
   autorisation. Pour un logiciel soumis à droit d'auteur par la <em>Free
   Software Foundation</em>, il devra écrire à la <em>Free Software Foundation</em>
   ; nous faisons quelquefois des exceptions à cette règle. Notre
   décision va être guidée par le double objectif de protéger le
   statut libre de tous les dérivés de nos logiciels libres, et de
   favoriser le partage et la réutilisation des logiciels en général.
<p>
     ABSENCE DE GARANTIE

<item>
   COMME LA LICENCE DU PROGRAMME EST CONCÉDÉE À TITRE GRATUIT, IL N'Y
   AUCUNE GARANTIE S'APPLIQUANT AU PROGRAMME, DANS LA MESURE AUTORISÉE
   PAR LA LOI EN VIGUEUR. SAUF MENTION CONTRAIRE ÉCRITE, LES
   DÉTENTEURS DU DROIT D'AUTEUR ET/OU LES AUTRES PARTIES METTENT LE
   PROGRAMME À DISPOSITION "EN L'ÉTAT", SANS AUCUNE GARANTIE DE QUELQUE
   NATURE QUE CE SOIT, EXPRESSE OU IMPLICITE, Y COMPRIS, MAIS SANS
   LIMITATION, LES GARANTIES IMPLICITES DE COMMERCIALISATION ET DE
   L'APTITUDE À UN OBJET PARTICULIER. C'EST LE CONCESSIONNAIRE QUI
   PREND LA TOTALITÉ DU RISQUE QUANT A LA QUALITÉ ET AUX PERFORMANCES
   DU PROGRAMME. SI LE PROGRAMME SE RÉVÉLAIT DÉFECTUEUX, C'EST LE
   CONCESSIONNAIRE QUI PRENDRAIT À SA CHARGE LE COÛT DE L'ENSEMBLE DES
   OPÉRATIONS NÉCESSAIRES D'ENTRETIEN, RÉPARATION OU CORRECTION.

<item>
   EN AUCUN CAS, SAUF SI LA LOI EN VIGUEUR L'EXIGE OU SI UNE
   CONVENTION ÉCRITE EXISTE À CE SUJET, AUCUN DÉTENTEUR DE DROITS
   D'AUTEUR, OU AUCUNE PARTIE AYANT LE POUVOIR DE MODIFIER ET/OU DE
   REDISTRIBUER LE PROGRAMME CONFORMÉMENT AUX AUTORISATIONS CI-DESSUS,
   N'EST RESPONSABLE VIS-À-VIS DU CONCESSIONNAIRE POUR CE QUI EST DES
   DOMMAGES, Y COMPRIS TOUS DOMMAGES GÉNÉRAUX, SPÉCIAUX, ACCIDENTELS
   OU INDIRECTS, RÉSULTANT DE L'UTILISATION OU DU PROGRAMME OU DE
   L'IMPOSSIBILITÉ D'UTILISER LE PROGRAMME (Y COMPRIS, MAIS SANS
   LIMITATION, LA PERTE DE DONNÉES, OU LE FAIT QUE DES DONNÉES SONT
   RENDUES IMPRÉCISES, OU ENCORE LES PERTES ÉPROUVÉES PAR LE
   CONCESSIONNAIRE OU PAR DES TIERS, OU ENCORE UN MANQUEMENT DU
   PROGRAMME À FONCTIONNER AVEC TOUS AUTRES PROGRAMMES), MÊME SI CE
   DÉTENTEUR OU CETTE AUTRE PARTIE A ÉTÉ AVISÉ DE LA POSSIBILITÉ DE
   TELS DOMMAGES.
<p>
                     FIN DES CONDITIONS D'EXPLOITATION
<p>
  ------------------------------------------------------------------------
</enumlist>

</sect>


<sect>Comment appliquer ces dispositions à vos nouveaux programmes?

<p>
Si le concessionnaire développe un nouveau programme, et s'il en souhaite
l'utilisation la plus large possible dans le public, le meilleur moyen d'y
arriver est d'en faire un logiciel libre, que tout le monde pourra
redistribuer et modifier au titre des présentes dispositions.

<p>
Dans ce but, il convient de rattacher au programme les avis suivants. Le
moyen le plus sûr consiste à les rattacher au début de chaque fichier
source, pour avertir le plus efficacement possible de l'exclusion de
garantie ; et chaque fichier doit comporter au moins la ligne <em>copyright</em>,
et un pointeur indiquant où est localisée la totalité de l'avis.

<p>
Une ligne pour donner le nom du programme et une idée de ce qu'il fait.

<p>
<prgn>
Copyright &copy 19yy nom de l'auteur
</prgn>

<p>
<prgn>
Ce programme est un logiciel libre ; vous pouvez le redistribuer et/ou le
modifier conformément aux dispositions de la Licence Publique Générale GNU,
telle que publiée par la <em>Free Software Foundation</em> ; version 2 de la licence,
ou encore (à votre choix) toute version ultérieure.
</prgn>
<p>
<prgn>
Ce programme est distribué dans l'espoir qu'il sera utile, mais SANS AUCUNE
GARANTIE ; sans même la garantie implicite de COMMERCIALISATION ou
D'ADAPTATION A UN OBJET PARTICULIER. Pour plus de détail, voir la Licence
Publique Générale GNU .
</prgn>
<p>
<prgn>
Vous devez avoir reçu un exemplaire de la Licence Publique Générale GNU en
même temps que ce programme ; si ce n'est pas le cas, écrivez à la Free
Software Foundation Inc., 675 Mass Ave, Cambridge, MA 02139, États-Unis.
</prgn>
<p>
Ajoutez aussi des informations sur le moyen permettant d'entrer en contact
avec vous par courrier électronique (e-mail) et courrier normal.

<p>
Si le programme est interactif, prévoyez en sortie un court avis, tel que
celui qui est présenté ci-dessous, lors du démarrage en mode interactif.

<p>
<prgn>
Gnomovision version 69, Copyright &copy 19 yy nom de l'auteur
</prgn>
<p>
<prgn>
Gnomovision est livré absolument SANS AUCUNE GARANTIE ; pour plus de
détail, tapez «&nbsp;show w&nbsp;». Il s'agit d'un logiciel libre, et
vous avez le droit de le redistribuer dans certaines conditions ; pour
plus de détail, tapez «&nbsp;show c&nbsp;».
</prgn>

<p>
Les instructions hypothétiques «&nbsp;show w&nbsp;» et «&nbsp;show
c&nbsp;» doivent présenter les parties appropriées de la Licence
Publique Générale. Bien évidemment, les instructions que vous utilisez
peuvent porter d'autres noms que «&nbsp;show w&nbsp;» et «&nbsp;show
c&nbsp;» ; elles peuvent même correspondre à des clics de souris ou à
des éléments d'un menu, selon ce qui convient à votre programme.
<p>
Si nécessaire, vous devrez aussi demander à votre employeur (si vous
travaillez en tant que programmeur) ou à votre éventuelle école ou
université, de signer une "renonciation à droit d'auteur" concernant le
programme. En voici un échantillon (il suffit de modifier les noms) :
<p>
<prgn>
Yoyodyne, Inc., par la présente, renonce à tout intérêt de droits
d'auteur dans le programme «&nbsp;Gnomovision&nbsp;» (qui fait des
passages au niveau des compilateurs) écrit par James Hacker.
</prgn>
<p>
<prgn>
Signature de Ty Coon, 1er avril 1989
</prgn>
<p>
<prgn>
Ty Coon, President of Vice
</prgn>
<p>
La présente Licence Publique Générale n'autorise pas le concessionnaire à
incorporer son programme dans des programmes propriétaires. Si votre
programme est une bibliothèque de sous-programmes, vous pouvez considérer
comme plus intéressant d'autoriser une édition de liens des applications
propriétaires avec la bibliothèque. Si c'est ce que vous souhaitez, vous
devrez utiliser non pas la présente licence, mais la Licence Publique
Générale pour Bibliothèques GNU.
</sect>

</chapt></book>

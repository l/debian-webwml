#use wml::debian::template title="Debian GNU/Hurd&nbsp;&ndash;&nbsp;Installation" NOHEADER="yes"
#include "$(ENGLISHDIR)/ports/hurd/menu.inc"
#use wml::debian::translation-check translation="1.51" maintainer="Nicolas Bertolissio"

# traducteur précédent : Mohammed Adnène Trojette
# traducteur précédent : Thomas Marteau.
# Premier traducteur   : Jérome Abela

<h1>Installation de Debian&nbsp;GNU/Hurd</h1>

<p>
Ce document vise à fournir un jeu d'instructions facile et relativement peu
fastidieux sur la façon d'obtenir et de faire fonctionner Debian&nbsp;GNU/Hurd
avec un minimum d'efforts.
</p>

<p>
Il est basé sur le <q>Guide d'installation du Hurd</q> de Neal H. Walfield.
Merci beaucoup à Neal pour sa contribution.
</p>

<p>
Veuillez noter que quelques points de ce manuel sont peu commodes parce qu'ils
prennent beaucoup de temps et peuvent causer des problèmes. Vous préférerez
peut-être l'installation à l'aide d'<a href="hurd-cd">images de CD
préparées</a>, particulièrement si vous êtes débutant. Même s'ils sont périmés,
normalement, ils fonctionnent. Vous pouvez toujours obtenir des mises à jour
depuis les dépôts mis en ligne.
</p>

<h2>1. Vue d'ensemble</h2>

<p>
La distribution Debian&nbsp;GNU/Hurd, contrairement à des distributions
d'autres systèmes d'exploitation, n'a pas de joli programme d'installation. Un
jour il y en aura un, et vous aiderez peut-être à sa conception et à son
implantation. Toutefois, en attendant ce jour, installer Debian&nbsp;GNU/Hurd
requiert un autre système d'exploitation, plus spécifiquement un autre système
de type Unix. Des utilisateurs ont indiqué avoir réussi des installations en
utilisant aussi bien différentes versions de GNU/Linux que des BSD. Le minimum
requis sur le système d'exploitation d'amorçage est la capacité&nbsp;: de créer
des systèmes de fichiers ext2, d'y extraire une archive tar, d'installer
GNU&nbsp;Grub.
</p>

<p>
GNU est de nature similaire à n'importe quel système de type Unix&nbsp;: après
s'être identifié, un interpréteur de commandes et le système de fichiers
virtuel (VFS) Unix familier sont présentés à l'utilisateur. Malgré les
tentatives de GNU d'être conforme à POSIX, ce <q>n'est pas Unix</q> (<i>GNU is
Not Unix</i>). GNU/Hurd est basé sur plusieurs concepts Unix et les étend soit
en ajoutant de nouvelles fonctionnalités, soit en réparant ce qui a été perçu
comme des failles dans la conception originelle. La différence la plus
remarquable est l'existence des traducteurs, programmes de l'espace utilisateur
qui interagissent avec le VFS. Ces systèmes de fichiers n'ont besoin d'accéder
qu'au périphérique de stockage et au <code>point de montage</code>. Une autre
différence réside dans le fait que les processus, plutôt que d'avoir l'identité
d'un utilisateur unique donné au moment de la création, peuvent avoir des
identités disjointes du processus, c'est-à-dire qu'ils peuvent être ajoutés
avec la permission appropriée par une autorité, ou être détruits.
</p>

<p>
Être familiarisé avec l'environnement Unix (et en particulier l'espace
utilisateur GNU, que l'on trouve dans des variantes populaires telles que
GNU/Linux) est un impératif pour se sentir à l'aise avec GNU. Avoir de
l'expérience avec les outils Debian sera un atout inestimable pour la
configuration et la maintenance d'une machine sous GNU/Hurd.
</p>

<p>
Ce guide s'efforce de rendre l'installation de GNU/Hurd aussi facile que
possible. S'il s'y trouve des erreurs, ce sont probablement des erreurs de
l'auteur. Veuillez les lui rapporter, ainsi que d'autres suggestions ou
critiques&nbsp;; toutes seront acceptées avec plaisir.
</p>

<h2>2. État réel ou trouver un foyer</h2>

<p>
Si vous n'avez pas de partition disponible ni de disque dur supplémentaire,
c'est peut-être l'étape la plus longue. Dans ce cas, vous devrez repartitionner
le disque dur. Une solution est d'utiliser l'éditeur de partition de GNU,
Parted. Il permet non seulement l'édition basique de partitions, mais aussi le
redimensionnement de partitions et leur déplacement. Il se trouve à <url
"http://www.gnu.org/software/parted" />. Son manuel est assez complet et inclut
plusieurs didacticiels.
</p>

<p>
Le Hurd prend en charge plusieurs extensions au format du système de fichiers
ext2fs. Les principales d'entre elles sont les traducteurs passifs et une
quatrième série de bits de permissions pour les utilisateurs inconnus
(utilisateurs sans identité et non l'utilisateur <q>autre</q> des permissions
Unix classiques). Pour utiliser ces extensions, le propriétaire de la
partition doit être <code>hurd</code>. <code>mke2fs</code>, sauf
mention contraire spécifiée en ligne de commande, le noyau lancé sera le
propriétaire de la partition. Comme le Hurd respecte ce paramètre, il faut
faire attention à le configurer de manière appropriée, sinon le Hurd échouera
de manière subtile. Soyez conscient que même si un système de fichiers
appartient à un noyau donné, les autres peuvent quand même l'utiliser&nbsp;;
ils ne peuvent seulement pas utiliser certaines extensions.
</p>

<p>
Pour créer un système de fichiers, utilisez <code>mke2fs</code> et passez-lui
les options <samp>-b 4096 -o hurd</samp> afin de désigner le Hurd comme
propriétaire du nouveau système de fichiers. Par exemple, si la partition est
<tt>/dev/hda2</tt>&nbsp;:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
 \# mke2fs -b 4096 -o hurd /dev/hda2
</pre></td></tr></table>


<h2>3. Le chargeur d'amorçage</h2>

<p>
Le chargeur d'amorçage du système GNU est Grub (le <i>GRand Unified Boot
loader</i>), et sa tâche principale est de charger le c½ur du système GNU (Mach
et le Hurd). Tout chargeur d'amorçage qui gère le standard d'amorçage multiple
pourra cependant charger Mach et le Hurd. En ce moment (à notre connaissance),
GNU&nbsp;Grub est le seul chargeur d'amorçage qui gère ce standard.
</p>

<p>
Un mot sur Grub. Contrairement aux chargeurs d'amorçage sur x86, comme LILO,
Grub est très puissant. Il a une interface en ligne de commande, bootp, la
gestion de terminal factice et pléthore d'autres fonctionnalités. De plus, il
peut amorcer pratiquement n'importe quel noyau. Si vous avez déjà amorcé une
machine alpha ou sparc, vous comprendrez ce que Grub peut faire. Par
conséquent, n'ayez pas peur&nbsp;: Grub est mieux. Vous l'aimerez. Vous ne
changerez pas d'avis.
</p>

<p>
Pour trouver Grub, veuillez visiter <url "http://www.gnu.org/software/grub/"
/>. Vous y trouverez une archive du source et une image pour disquette. Si vous
choisissez de télécharger l'archive, il suffira d'un habituel
<code>configure</code>, <code>make</code> et <code>make install</code>. Un
fantastique manuel complet expliquant le fonctionnement de Grub est inclus.
Lisez-le. Si, au contraire, vous choisissez de télécharger l'image pour
disquette, il suffit de la transférer sur une disquette pour faire fonctionner
Grub, par exemple&nbsp;:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
 \# dd if=grub-boot-image of=/dev/fd0
</pre></td></tr></table>

<p>
Vous pourrez toujours installer Grub sur votre disque dur plus tard.
</p>


<h2>4. Installation croisée</h2>

<p>

L'étape suivante est d'obtenir un système de base. Il existe plusieurs
possibilités&nbsp;: si vous utilisez un système Debian, vous pouvez utiliser le
paquet crosshurd. Sinon, vous pouvez obtenir une archive de système de base à
jour depuis
<url "http://ftp.gnuab.org/pub/debian/base/" /> en Espagne,
<url "http://www.superunprivileged.org/debian/base/" /> au Canada et
<url "http://ftp.easynet.be/ftp/gnuab/debian/base/" /> en Belgique.
</p>

<p>
L'archive est configurée pour tout extraire vers le répertoire courant. Une
fois le système de fichiers monté, l'archive peut être extraite. En supposant
que le système de fichiers est sur <tt>/dev/hda2</tt>, que le point de montage
est <tt>/gnu</tt> et que l'archive est dans le répertoire personnel de
l'utilisateur courant, il est nécessaire de faire comme suit&nbsp;:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
 \# mount -t ext2 /dev/hda2 /gnu
 \# cd /gnu
 \# tar --same-owner -xvjpf ~/gnu.tar.bz2
</pre></td></tr></table>


<h2>5. Amorçage du GNU/Hurd</h2>

<p>
Tout est maintenant prêt pour amorcer GNU/Hurd pour la première fois. Après
avoir vérifié que le disque d'amorçage de Grub est dans le lecteur, réamorcez.
Si tout se passe bien, soit un menu Grub, soit une ligne de commande sera
affiché. Si c'est un menu qui apparaît, veuillez appuyer sur <kbd>c</kbd> pour
aller sur la ligne de commande.
</p>

<p>
D'abord, GNU&nbsp;Mach devra être chargé. Il faudra connaître le système de
fichiers et le chemin vers GNU&nbsp;Mach. Grub utilise une nomenclature de
partitions un peu différente de Linux comme du Hurd&nbsp;: IDE et SCSI
sont tous les deux nommés <tt>(hdN,M)</tt>. <code>N</code> est le numéro de
lecteur (commence à zéro) tel qu'énuméré par le BIOS. Cela étant fait,
Grub ne fait aucune distinction entre les disques IDE et SCSI. <code>M</code>
identifie la partition sur le lecteur. Il est aussi indexé à partir de zéro. Si
cela vous semble confus, relaxez-vous&nbsp;: Grub va vous aider.
</p>

<p>
Pour déterminer le système de fichiers sur lequel un fichier en particulier se
trouve, Grub fournit la commande <code>find</code>. Quand cette commande est
lancée avec un nom de fichier donné, Grub recherche sur chaque système de
fichiers le fichier spécifié et affiche l'endroit où il a été trouvé. Par
exemple, pour chercher le noyau, <tt>/boot/gnumach.gz</tt>&nbsp;:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre> 
   grub&#62; find /boot/gnumach.gz
   (hd0,0)
</pre></td></tr></table>

<p>
Grub indique ici que <tt>/boot/gnumach.gz</tt> est sur <tt>(hd0,0)</tt>.
</p>

<p>
Avant d'amorcer le noyau, une option au moins, la partition racine, doit être
indiquée sur la ligne de commande. Elle sera utilisée par le Hurd lui-même
(c'est-à-dire pas par Grub). Elle doit donc être formulée en termes que le Hurd
pourra comprendre.
</p>

<p>
GNU&nbsp;Mach énumère les disques à partir de zéro. Les lecteurs IDE sont
préfixés par <code>hd</code>, tandis que les disques SCSI sont préfixés par
<code>sd</code>. Comme sur Linux, les lecteurs sont numérotés selon leur
position sur le contrôleur. Par exemple, le maître primaire est
<code>hd0</code> et l'esclave secondaire est <code>hd3</code>. Les partitions
utilisent la convention de nommage de tranches de BSD et ajoutent un
<code>sM</code> au nom de lecteur afin d'indiquer une partition. Veuillez noter
que <code>M</code> est indexé à partir de un, et non de zéro. Le numéro de
tranche est facile à calculer&nbsp;: il suffit d'incrémenter celui qu'utilise
Grub d'une unité.
</p>

<p>
Comme le Hurd n'a pas encore été configuré, il doit être lancé en mode
<q>utilisateur unique</q>. Ajouter <samp>-s</samp> à la ligne de commande du
noyau est tout ce qu'il y a à faire.
</p>

<p>
En supposant que le premier lecteur (à savoir <tt>(hd0)</tt>) est le maître sur
le contrôleur secondaire, nous aurions&nbsp;:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
   grub&#62; kernel (hd0,0)/boot/gnumach.gz root=device:hd2s1 -s
   [Multiboot-elf, ...]
</pre></td></tr></table>

<p>
Ensuite, le serveur du système de fichiers racine et le serveur
<code>exec</code> doivent être chargés. Cela est fait par le biais des
capacités d'amorçage de module de Grub. Les ${var} sont remplies par
GNU&nbsp;Mach. Les paramètres utilisés par le Hurd indiquent le type
d'information fournie. Comme la ligne de commande ext2fs est très longue, elle
peut être rallongée par des sauts de ligne protégés à la manière d'une ligne de
commande Unix. Veillez à ce qu'il n'y ait pas d'espace après l'antislash en fin
de ligne. Veillez aussi à distinguer <kbd>{</kbd> et <kbd>}</kbd> de
<kbd>(</kbd> et <kbd>)</kbd>.
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
  grub&#62; module (hd0,0)/hurd/ext2fs.static \
   --multiboot-command-line=${kernel-command-line} \
   --host-priv-port=${host-port} \
   --device-master-port=${device-port} \
   --exec-server-task=${exec-task} -T typed ${root} \
   $(task-create) $(task-resume)
    [Multiboot-module  0x1c4000, 0x2cfe6a bytes]
  grub&#62; module (hd0,0)/lib/ld.so.1 /hurd/exec $(exec-task=task-create)
    [Multiboot-module  0x494000, 0x27afe bytes]
</pre></td></tr></table>

<p>
Une fois le Hurd lancé, le procédé peut être automatisé en ajoutant la ligne de
commande appropriée au fichier de configuration <tt>/boot/grub/menu.lst</tt> de
Grub.
</p>

<p>
GNU/Hurd peut maintenant être amorcé&nbsp;:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
grub&#62; boot
</pre></td></tr></table>

<p>
Si GNU/Hurd ne parvient pas à s'amorcer, cela peut être dû à des interruptions
partagées&nbsp;: GNU&nbsp;Mach ne se sert pas très bien de celles-ci. Vous
pouvez vérifier votre situation en regardant, par exemple, le fichier
<tt>/proc/interrupts</tt> sous GNU/Linux. Aussi, comme GNU&nbsp;Mach ne gère
pas les modules chargeables du noyau, de nombreux pilotes sont compilés dans le
noyau par défaut. S'il y a d'anciens périphériques, cela peut être un
problème&nbsp;: un périphérique pourra répondre incorrectement à une requête
faite à un périphérique qui n'a rien à voir et ainsi entraîner un arrêt
inopiné. Construire un nouveau noyau seulement avec les pilotes des
périphériques requis résoudra normalement ce problème. GNU&nbsp;Mach peut être
facilement compilé de manière croisée. Si vous utilisez Debian, installez le
paquet <tt>mig</tt> et votre <tt>gcc</tt> standard devrait fonctionner.
</p>

<p>
Si cela ne vous aide pas, veuillez demander sur la liste de diffusion
appropriée.
</p>


<h2>6. Installation native</h2>

<p>
Une fois qu'une invite d'interpréteur de commandes vous est affichée, et quand
le Hurd est en mode utilisateur unique, il est nécessaire de déterminer le type
de terminal&nbsp;:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
 \# export TERM=mach
</pre></td></tr></table>

<p>
Attention&nbsp;: <kbd>CONTROL-C</kbd> et compagnie ne marcheront pas en mode
utilisateur unique.
</p>

<p>
Nous pouvons maintenant lancer le script <code>native-install</code>. Cela
configurera les paquets et installera les traducteurs importants&nbsp;:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
 \# ./native-install
</pre></td></tr></table>

<p>
Avant la fin de l'exécution du script, celui-ci indiquera qu'il a besoin d'être
lancé une deuxième fois. Suivez ses instructions et réamorcez le système en
utilisant la commande <code>reboot</code>. À nouveau, passez en mode
utilisateur unique et lancez <code>./native-install</code>.
</p>


<h2>7. Configuration</h2>


<h3>7.1 Le réseau</h3>

<p>
Pour configurer le réseau, le traducteur pfinet doit être configuré. Cela se
fait par la commande <code>settrans</code> qui attache un traducteur à un n½ud
de système de fichiers donné. Quand les programmes accéderont au n½ud, par
exemple en envoyant un RPC, le système d'exploitation lancera de manière
transparente le serveur afin de prendre en charge la requête.
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
 \# settrans -fgap /servers/socket/2 /hurd/pfinet -i eth0 \
   -a a.b.c.d -g e.f.g.h -m i.j.k.l
</pre></td></tr></table>

<p>
Ici, <code>settrans</code> reçoit plusieurs options. Les deux premières,
<samp>fg</samp>, forcent tous les traducteurs existants à disparaître. Les deux
suivantes, <samp>ap</samp>, créent les traducteurs actifs et passifs. En
rendant un traducteur actif, nous verrons immédiatement tous les messages
d'erreur sur <tt>stderr</tt>. Ce dernier sauvegarde le traducteur et ses
paramètres dans le n½ud de façon à pouvoir le relancer plus tard de manière
transparente (c'est-à-dire en ayant des paramètres persistants même après un
réamorçage). Les options sont suivies d'un n½ud auquel le traducteur sera
attaché, puis du programme (c'est-à-dire le traducteur) à lancer et de tous les
paramètres à lui passer. L'option <samp>-i</samp> est l'interface sur laquelle
<code>pfinet</code> écoutera, <samp>-a</samp> est l'adresse IP, <samp>-g</samp>
la passerelle et <samp>-m</samp> le masque de sous-réseau.
</p>

<p>
Veillez à ajouter des serveurs de nom de domaines à votre fichier
<tt>/etc/resolv.conf</tt>&nbsp;:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
  nameserver 192.168.1.1
</pre></td></tr></table>

<p>
Pour tester la configuration, veuillez taper <code>ping -c2 gateway</code>. Le
<samp>-c</samp> est important pour limiter le nombre de pings&nbsp;;
rappelez-vous, <kbd>CONTROL-C</kbd> ne fonctionne pas en mode utilisateur
unique.
</p>

<p>
DHCP ne fonctionne pas encore sous le Hurd. C'est dû à des limitations de
pfinet&nbsp;: il est basé sur le code TCP/IP de Linux et est incapable
d'écouter sur <tt>0.0.0.0</tt>.
</p>

<p>
Il est possible d'obtenir de l'aide sur <code>settrans</code> en lui passant l'option
<samp>--help</samp>. Il en va de même concernant un traducteur donné en
l'invoquant depuis la ligne de commande avec ce même paramètre, par
exemple&nbsp;:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
 \# /hurd/pfinet --help
</pre></td></tr></table>

<p>
Comme la sortie peut être importante, pensez à la traiter à travers un visionneur
de texte tel que <code>less</code>.
</p>


<h3>7.2 Autres systèmes de fichiers</h3>

<p>
Ensuite, veuillez éditer <tt>/etc/fstab</tt> en y ajoutant tous les systèmes de
fichiers supplémentaires ainsi que l'espace d'échange. Il est <em>très
important</em> que l'espace d'échange soit utilisé&nbsp;; le Hurd sera plus
stable. Notez que le Hurd peut partager une partition d'échange de
manière transparente avec Linux, mais pourra sans problème paginer sur quelque
périphérique que ce soit, y compris une partition brute comme votre partition
home. Par défaut, <code>nano</code> est le seul éditeur de texte installé par
la distribution de base.
</p>

<p>
Voici un exemple de fichier <tt>/etc/fstab</tt>&nbsp;:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
\# &#60;file system&#62; &#60;mount point&#62;   &#60;type&#62;  &#60;options&#62;  &#60;dump&#62;  &#60;pass&#62;
/dev/hd2s1      /               ext2    rw         0       1
/dev/hd2s2      /home           ext2    rw         0       2
/dev/hd2s3      none            swap    sw         0       0
</pre></td></tr></table>

<p>
N'oubliez pas de créer tous les périphériques avec la commande
<code>MAKEDEV</code>&nbsp;:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
 \# cd /dev
 \# ./MAKEDEV hd2s1 hd2s2 hd2s3
</pre></td></tr></table>

<p>
Pour monter un système de fichiers nfs, le traducteur <code>/hurd/nfs</code> est
utilisé. Quand il n'est pas lancé par le superutilisateur, le traducteur se
connecte au serveur en utilisant un port au-dessus de&nbsp;1023. Par défaut,
GNU/Linux rejettera cela. Pour dire à GNU/Linux d'accepter les connexions
provenant d'un port non réservé, veuillez ajouter l'option
<samp>insecure</samp> à la ligne d'export. Voici un exemple de fichier
<tt>/etc/exports</tt> supposant que l'adresse IP du client est
<tt>192.168.1.2</tt>&nbsp;:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
  /home  192.168.1.2(rw,insecure)
</pre></td></tr></table>

<p>
Pour monter ceci sur une machine GNU et en supposant que l'adresse IP du
serveur nfs est <tt>192.168.1.1</tt>&nbsp;:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
\# settrans -cgap /mount/point /hurd/nfs 192.168.1.1:/home
</pre></td></tr></table>


<h3>7.3 Réamorçage</h3>

<p>
Enfin, réamorcez en mode multiutilisateur, c'est-à-dire de la même manière que
pour le mode utilisateur unique, sans l'option <samp>-s</samp> de chargement du
noyau. Pour de plus amples informations, veuillez vous référer à la
section&nbsp;5. Amorçage du GNU/Hurd.
</p>

<p>
Bon bidouillage&nbsp;!
</p>


<h2>8. Derniers mots</h2>


<h3>8.1 Le menu de Grub</h3>

<p>
Charger le noyau manuellement à chaque fois peut se révéler très fastidieux.
Veuillez adapter le fichier <tt>/boot/grub/menu.lst</tt> de manière
appropriée&nbsp;; l'amorçage sera plus rapide et plus facile.
</p>


<h3>8.2 Ajouter des périphériques</h3>

<p>
Par défaut, quelques périphériques seulement sont créés dans le répertoire
<tt>/dev</tt>. Veuillez utiliser le script <code>MAKEDEV</code> pour créer tous
les n½uds de périphériques nécessaires.
</p>


<h3>8.3 Installer plus de paquets</h3>

<p>
Il y a plusieurs manières d'ajouter des paquets. Télécharger et utiliser
<code>dpkg -i</code> fonctionne mais est très peu pratique. La méthode la plus
simple est d'utiliser <code>apt-get</code>. Veuillez éditer
<tt>/etc/apt/sources.list</tt> et ajouter l'une des entrées non publiées
suivantes&nbsp;:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
deb http://ftp.gnuab.org/debian unreleased main
deb http://www.superunprivileged.org/debian unreleased main
deb http://ftp.easynet.be/ftp/gnuab/debian unrelease main
</pre></td></tr></table>

<p>
<url "http://ftp.gnuab.org/" /> et ses miroirs contiennent des paquets qui ont
été modifiés ou des corrections qui n'ont pas encore été intégrées en amont ou
dans Debian. Et la distribution instable à partir de l'un des miroirs de Debian
(voir la liste complète <url "http://www.debian.org/mirror/list" />) contenant
cette architecture&nbsp;:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
deb http://ftp.fr.debian.org/debian unstable main
</pre></td></tr></table>

<p>
Si GNU/Mach ne reconnaît pas votre carte réseau ou si vous utilisez un modem,
le seul moyen de mettre à jour sera de télécharger les paquets, de les
transférer ensuite sur le système GNU. Le moyen le plus facile de faire ceci
est d'utiliser apt en mode déconnecté. Veuillez vous référer à
<tt>/usr/share/doc/apt-doc/offline.text.gz</tt> pour des instructions
détaillées.
</p>


<h3>8.4 La console Hurd</h3>

<p>
Outre la console Mach que vous rencontrez pendant l'installation, GNU/Hurd
possède une puissante console en espace utilisateur qui fournit des terminaux
virtuels. Actuellement, vous devez lancer la console Hurd manuellement avec la
commande suivante&nbsp;:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
 \# console -d vga -d pc_mouse --repeat=mouse -d pc_kbd --repeat=kbd -d generic_speaker -c /dev/vcs
</pre></td></tr></table>

<p>
Dans la console Hurd, vous pouvez passer d'un terminal virtuel à un autre
<i>via</i> <kbd>ALT+F1</kbd>, <kbd>ALT+F2</kbd> et ainsi de suite.
<kbd>ALT+CTRL+BACKSPACE</kbd> détache la console Hurd et vous ramène à la
console Mach, depuis laquelle vous pouvez vous rattacher à nouveau avec la
commande ci-dessus.
</p>


<h3>8.5 X.Org</h3>

<p>
X.Org a été porté, et toutes les cartes vidéo qu'il gère sans nécessiter de
module noyau devraient fonctionner.
</p>

<p>
Vous devez être dans la console Hurd et avoir configuré les répétiteurs comme
indiqué dans la section&nbsp;8.4 ci-dessus. Comme <code>/dev/kbd</code> est
codé en dur en tant que périphérique pour le clavier dans X.Org, vous devez
créer un lien symbolique&nbsp;:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
 \# cd /dev
 \# ln -s cons/kbd kbd
 \# ln -s cons/mouse mouse
</pre></td></tr></table>

<p>
Vous aurez besoin de plusieurs paquets de X. Vous pouvez commencer par
<code>x-window-system-core</code>, <code>rxvt</code> et <code>twm</code>,
<code>fvwm</code> ou <code>wmaker</code>.
</p>

<p>
Debconf peut être utilisé pour configurer X.Org&nbsp;; toutefois, il ne gère
pas le Hurd correctement et le fichier de configuration nécessitera quelques
modifications. Après la configuration, veuillez changer la section pointeur
comme suit&nbsp;:
</p>

<table><tr><td>&nbsp;</td><td class=example><pre>
Section "Pointer"
  Protocol "osmouse"
  Device "/dev/mouse"
EndSection
</pre></td></tr></table>

<p>
Les options <samp>Emulate3Buttons</samp> et <samp>ZAxisMapping</samp> doivent
toutes deux être désactivées.
</p>

<p>
Enfin, lancez <code>startx</code>.
</p>

<p>
Il y a plusieurs choses à savoir. <code>update-menu</code> n'a pas encore été
porté. C'est pourquoi il n'existe pas de jolis menus Debian. Bien qu'une
implantation avec <code>pthreads</code> existe, tous les paquets pthread n'ont
pas été portés&nbsp;: ne vous attendez pas à ce que Gnome et KDE fonctionnent.
</p>

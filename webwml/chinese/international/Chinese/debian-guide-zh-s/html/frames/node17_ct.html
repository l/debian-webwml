
<!--Converted with LaTeX2HTML 99.2beta6 (1.42)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Contents of 13 进阶话题</TITLE>
<META NAME="description" CONTENT="Contents of 13 进阶话题">
<META NAME="keywords" CONTENT="debian-tutorial-zh_CN-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=gb2312">
<META NAME="Generator" CONTENT="LaTeX2HTML v99.2beta6">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="debian-tutorial-zh_CN-html.css">

<LINK REL="previous" HREF="node16_mn.html">
<LINK REL="up" HREF="node4_mn.html">
<LINK REL="next" HREF="node18_mn.html">
</HEAD>
 
<BODY bgcolor="#ffffff" text="#000000" link="#9944EE" vlink="#0000ff" alink="#00ff00">
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html883" HREF="node17_ct.html#SECTION041310000000000000000" TARGET="contents"><SPAN CLASS="arabic">1</SPAN> 规则表达式 (Regular Expressions)</A>
<LI><A NAME="tex2html884" HREF="node17_ct.html#SECTION041320000000000000000" TARGET="contents"><SPAN CLASS="arabic">2</SPAN> 深入文件</A>
<UL>
<LI><A NAME="tex2html885" HREF="node17_ct.html#SECTION041321000000000000000" TARGET="contents"><SPAN CLASS="arabic">1</SPAN> 文件的本质：硬连接和资料结点 (Hard Links and Inodes)</A>
<LI><A NAME="tex2html886" HREF="node17_ct.html#SECTION041322000000000000000" TARGET="contents"><SPAN CLASS="arabic">2</SPAN> 文件类型</A>
<UL>
<LI><A NAME="tex2html887" HREF="node17_ct.html#SECTION041322100000000000000" TARGET="contents"><SPAN CLASS="arabic">1</SPAN> 符号连接 (Symbolic Links) </A>
<LI><A NAME="tex2html888" HREF="node17_ct.html#SECTION041322200000000000000" TARGET="contents"><SPAN CLASS="arabic">2</SPAN> 设备文件 (Device Files)</A>
<UL>
<LI><A NAME="tex2html889" HREF="node17_ct.html#SECTION041322210000000000000" TARGET="contents"><SPAN CLASS="arabic">1</SPAN> <TT>/dev/null</TT></A>
</UL>
<LI><A NAME="tex2html890" HREF="node17_ct.html#SECTION041322300000000000000" TARGET="contents"><SPAN CLASS="arabic">3</SPAN> 具名管道 (Named Pipes, FIFOs)</A>
<LI><A NAME="tex2html891" HREF="node17_ct.html#SECTION041322400000000000000" TARGET="contents"><SPAN CLASS="arabic">4</SPAN> 套接口 (Sockets)</A>
</UL>
<LI><A NAME="tex2html892" HREF="node17_ct.html#SECTION041323000000000000000" TARGET="contents"><SPAN CLASS="arabic">3</SPAN> <TT>proc</TT> 文件系统 (The <TT>proc</TT> Filesystem)</A>
<LI><A NAME="tex2html893" HREF="node17_ct.html#SECTION041324000000000000000" TARGET="contents"><SPAN CLASS="arabic">4</SPAN> 大规模复制</A>
</UL>
<LI><A NAME="tex2html894" HREF="node17_ct.html#SECTION041330000000000000000" TARGET="contents"><SPAN CLASS="arabic">3</SPAN> 系统安全</A>
<LI><A NAME="tex2html895" HREF="node17_ct.html#SECTION041340000000000000000" TARGET="contents"><SPAN CLASS="arabic">4</SPAN> Debian 上的软件开发</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION041300000000000000000">
<SPAN CLASS="arabic">13</SPAN> 进阶话题</A>
</H1>

<P>
现在你应该了一个很好的基础，可以在此基础上增强你的 GNU/Linux 技巧了。本章我们探讨一些 GNU/Linux 上的较有用的应用资料。

<P>

<H1><A NAME="SECTION041310000000000000000"></A>
<A NAME="3703"></A><A NAME="3704"></A><A NAME="3705"></A><A NAME="3706"></A><A NAME="3707"></A>
<BR>
<SPAN CLASS="arabic">1</SPAN> 规则表达式 (Regular Expressions)
</H1>规则表达式是一组字符集合的描述。这个描述可以用来搜索一篇文章，寻找一段<SPAN  CLASS="textit">符合</SPAN>我们用规则表达式描述的文字。规则表达式类似于 shell 的通配符 (shell wildcards) （见第 <A HREF="node10_ct.html#expansion">6.6</A> 页第<A HREF="node10_ct.html#expansion">6.6</A> 节），但是它更复杂，功能也更强大。

<P>
一段规则表达式是由文字和
<SPAN  CLASS="textit">变字符</SPAN> (<SPAN  CLASS="textit">metacharacters</SPAN>) 组成的。一个变字符就是一个字符但是有特殊的意思。变字符包括：<TT>.&nbsp;*&nbsp;[]&nbsp;-&nbsp;&#92;^&nbsp;$</TT>。

<P>
如果一段规则表达式只含有文字（没有变字符），那它就相对应那些文字。例如规则表达式 ``<TT>my regular expression</TT>'' 就匹对``<TT>my regular expression</TT>''，仅此而已。规则表达式一般是大小写敏感的。

<P>
你可以用命令 <TT>egrep</TT> 显示一个文件中所有匹对一个规则表达式的行。语法是：

<P>

<DL COMPACT>
<DT>
<DD>egrep&nbsp;'regexp'&nbsp;filename1&nbsp;...
</DD>
</DL>其中的单引号不是所有情况下都需要的，但最好加上。

<P>
例如，要找到 GPL 里所有含有 GNU 这个单词的行，键入：

<P>

<DL COMPACT>
<DT>
<DD>egrep&nbsp;'GNU'&nbsp;/usr/doc/copyright/GPL
</DD>
</DL><TT>egrep</TT> 会把那些行印在标准输出的。
<A NAME="3726"></A><A NAME="3727"></A><A NAME="3728"></A><A NAME="3729"></A><A NAME="3730"></A>
如果你想要所有含有 <TT>freedom</TT> 后跟一些其它的字然后再跟 <TT>GNU</TT> 的行，可以用命令：

<P>

<DL COMPACT>
<DT>
<DD><A NAME="3734"></A><A NAME="3735"></A><A NAME="3736"></A><A NAME="3737"></A><A NAME="3738"></A><A NAME="3739"></A><A NAME="3740"></A><A NAME="3741"></A><A NAME="3742"></A>egrep&nbsp;'freedom.*GNU'&nbsp;/usr/doc/copyright/GPL
</DD>
</DL>这儿的 <TT>.</TT> 是指“所有字符”，而 <TT>*</TT> 指“0 或以上个前面的那个东西”，合起来就是“零或一个任意的字符”，因此 <TT>.*</TT> 基本上对应几乎所有的文字。<TT>egrep</TT> 对匹对方式是以行为单位的，所以匹对出的 <TT>freedom</TT> 和 <TT>GNU</TT> 必须在同一行。

<P>
这里是一个对规则表达式中的变字符的一个归纳：

<P>
<DL>
<DT><STRONG><TT>.</TT></STRONG></DT>
<DD>对应出换行符 (newline) 以外的所有单一字符。</DD>
<DT><STRONG><TT>*</TT></STRONG></DT>
<DD>对应 0 或以上个前面那个东西。比如表达式<TT>a*</TT>&nbsp;对应零或多个小写&nbsp;a，而&nbsp;<TT>.*</TT> 对应零或多个任意字符。</DD>
<DT><STRONG><TT>[<SPAN  CLASS="textit">字符字符字符</SPAN>]</TT></STRONG></DT>
<DD>括号内必须含有一个或以上的字符，整个括号表达式只对应给出的字符集合中的一个字符。例如 <TT>[abc]</TT> 对应一个 a，一个 b，或者一个 c；它不对应 0 字符，也不对应这三个字符以外的任何字符。
</DD>
<DT><STRONG><TT>^</TT></STRONG></DT>
<DD>把你的搜查限制在每行的开头。表达式<TT>^The</TT>&nbsp;对应一个在行首的&nbsp;<TT>The</TT>；在这个&nbsp;<TT>The</TT> 前面不能有空格或者任何其他的文字。如果你要允许有前面有空格，你可以用表达式 <TT>^*The</TT> 来允许前面有 0 或多个空格。
</DD>
<DT><STRONG><TT>$</TT></STRONG></DT>
<DD>把搜索限制在行尾。<TT>end$</TT> 要求文字 <TT>end</TT> 出现在一行的最后，后面没有空格或其它。
</DD>
<DT><STRONG><TT>[^<SPAN  CLASS="textit">字符字符</SPAN>]</TT></STRONG></DT>
<DD>这个表达颠倒一个括号字符表达式，即 <TT>[^abc]</TT> 对应所有<SPAN  CLASS="textit">除了</SPAN> a、b、c 以外的单一字符。
</DD>
<DT><STRONG><TT>[<SPAN  CLASS="textit">字符</SPAN>-<SPAN  CLASS="textit">字符</SPAN>]</TT></STRONG></DT>
<DD>你可以在括号表达式里包含一个范围。要对应所有小写字母，使用 <TT>[a-z]</TT>。其间可以使用多个范围，例如对应前三个和后三个英文字母，使用 <TT>[a-cx-z]</TT>。对应所有英文大小写字母，使用 <TT>[a-zA-Z]</TT>。你可以把范围，单个字母，以及 <TT>^</TT> 变字符混用，比如 <TT>[^a-zBZ]</TT> 对应“除了一个小写字母，大写 B，大写 Z 以外的所有单一东西”。
</DD>
<DT><STRONG><TT>()</TT></STRONG></DT>
<DD>你可以用圆括号把一部分表达式结成一组，就像一般的数学表达式一样。
</DD>
<DT><STRONG><TT>|</TT></STRONG></DT>
<DD><TT>|</TT> 的意思是“或者”(or)。你可以用它来提供一系列的可选表达式。一般可选的表达式会用圆括号分开，像：<TT>c(ad|ab|at)</TT> 对应的是cad 或 cab 或 cat。如果没有圆括号，则对应的就成了 cad 或 ab 或at 了：cad|ab|at。
</DD>
<DT><STRONG><TT>&#92;</TT></STRONG></DT>
<DD>这个变字符逃脱任何一个特殊字符。如果你想要搜索 <TT>*</TT>&nbsp;这个字，你需要用&nbsp;<TT>&#92;*</TT>。这个斜杠的意思是忽略 <TT>*</TT> 的特殊意思。
</DD>
</DL>
这里是一些范例，让你更好的掌握规则表达式的用法：
<A NAME="3803"></A><A NAME="3804"></A><A NAME="3805"></A><A NAME="3806"></A><A NAME="3807"></A>
<DL>
<DT><STRONG><TT>c.pe</TT></STRONG></DT>
<DD>对应 cope、cape、caper。
</DD>
<DT><STRONG><TT>c&#92;&nbsp;.pe</TT></STRONG></DT>
<DD>对应 c.pe、c.per。
</DD>
<DT><STRONG><TT>sto*p</TT></STRONG></DT>
<DD>对应 stp、stop、stoop。
</DD>
<DT><STRONG><TT>car.*n</TT></STRONG></DT>
<DD>对应 carton、cartoon、carmen。
</DD>
<DT><STRONG><TT>xyz.*</TT></STRONG></DT>
<DD>对应 xyz 和它后面跟的所有东西，有些工具，例如
<TT>egrep</TT>，只对应到那一行结束为止。
</DD>
<DT><STRONG><TT>^The</TT></STRONG></DT>
<DD>对应一行开头的 The。
</DD>
<DT><STRONG><TT>atime$</TT></STRONG></DT>
<DD>对应一行结尾的 atime。
</DD>
<DT><STRONG><TT>^Only$</TT></STRONG></DT>
<DD>对应一个只含有 Only 一个字的行，没有空格，没有其它字符，别的什么都没有，就一个 Only。
</DD>
<DT><STRONG><TT>b[aou]rn</TT></STRONG></DT>
<DD>对应 barn、born、burn。
</DD>
<DT><STRONG><TT>Ver[D-F]</TT></STRONG></DT>
<DD>对应 VerD、VerE、VerF。
</DD>
<DT><STRONG><TT>Ver[^0-9]</TT></STRONG></DT>
<DD>对应一个 Ver 后面跟任何非数字的东西。
</DD>
<DT><STRONG><TT>the[ir][re]</TT></STRONG></DT>
<DD>对应 their、therr、there、theie。
</DD>
<DT><STRONG><TT>[A-Za-z][A-Za-z]*</TT></STRONG></DT>
<DD>对应任何只含有英文字母的单词，并且最少有一个字母，不对应数字或空格。
</DD>
</DL>

<P>

<H1><A NAME="SECTION041320000000000000000">
<SPAN CLASS="arabic">2</SPAN> 深入文件</A>
</H1>

<P>
现在你已经知道关于文件的基本知识，该学些更加深入的东西了。

<P>

<H2><A NAME="SECTION041321000000000000000"></A><A NAME="advanced-files-hardlinks"></A>
<A NAME="3837"></A><A NAME="3838"></A><A NAME="3839"></A>
<BR>
<SPAN CLASS="arabic">1</SPAN> 文件的本质：硬连接和资料结点 (Hard Links and Inodes)
</H2><A NAME="3840"></A><A NAME="3841"></A><A NAME="3842"></A><A NAME="3843"></A>系统中的每个文件是以<SPAN  CLASS="textit">资料结点</SPAN> (<SPAN  CLASS="textit">inode</SPAN>: Information Node;
发音 ``eye-node'') 表示的，一个资料结点含有一个文件的所有信息。但是，资料结点不能直接看到，每个资料结点通过一个或多个的<SPAN  CLASS="textit">硬连接</SPAN>跟文件系统联系起来。硬连接含有一个文件的文件名和资料结点序号 (inode number)。
而资料结点含有那个文件本身，就是文件在磁盘上储存的位置，它的访问权限，文件的类型等等。如果一个资料结点有它的资料结点序号 (inode number)，那么系统总能把它找到。

<P>
一个文件可以有超过一个的硬连接，就是说多个不同的文件名可以指向同一个文件（它们都和同一个资料结点需要结合）。但你不能做跨越文件系统的硬连接：所有的对某一个文件（资料结点）做直接参考必需在同一个文件系统上，这是因为每个文件系统都有它自己的一套资料结点，不同的文件系统间的资料结点序号可能会重复。<A NAME="3847"></A>

<P>
因为所有指向同一个资料结点的硬连接都是参照<SPAN  CLASS="textit">同一个文件</SPAN>，你可以用一个文件名来修改一个文件，用指向同一个资料结点但使用一个不同的文件名来查看你的更改结果。试一下这个：

<P>

<DL COMPACT>
<DT>
<DD>cd;&nbsp;echo&nbsp;&#34;hello&#34;&nbsp;&gt;&nbsp;firstlink
</DD>
</DL><TT>cd</TT> 到你的家目录，建立一个有单词 ``hello'' 的叫<TT>firstlink</TT> 的文件，你实际上是把 <TT>echo</TT> 命令的输出重新定向，把输出放到 <TT>firstlink</TT> 里，<TT>echo</TT> 命令仅仅重复你传给它的任何东西。细节请参考有关 shell 的章节。

<P>

<DL COMPACT>
<DT>
<DD>cat&nbsp;firstlink
</DD>
</DL>确定文件 <TT>firstlink</TT> 的内容。

<P>

<DL COMPACT>
<DT>
<DD>ln&nbsp;firstlink&nbsp;secondlink
</DD>
</DL>建立一个硬连接：<TT>secondlink</TT> 现在指向和 <TT>firstlink</TT> 相同的资料结点。

<P>

<DL COMPACT>
<DT>
<DD>cat&nbsp;secondlink
</DD>
</DL>确定 <TT>secondlink</TT> 的内容和 <TT>firstlink</TT> 一样。

<P>

<DL COMPACT>
<DT>
<DD>ls&nbsp;-l
</DD>
</DL>注意列出的 <TT>firstlink</TT> 和
 <TT>secondlink</TT> 文件的资料结点联合的硬连接数目<A NAME="3873"></A><A NAME="3874"></A><A NAME="3875"></A><A NAME="3876"></A><A NAME="3877"></A><A NAME="3878"></A><A NAME="3879"></A><A NAME="3880"></A><A NAME="3881"></A><A NAME="3882"></A><A NAME="3883"></A><A NAME="3884"></A>是 2。

<P>

<DL COMPACT>
<DT>
<DD>echo&nbsp;&#34;change&#34;&nbsp;&gt;&gt;&nbsp;secondlink
</DD>
</DL>这个另外一个 shell 重新定向诀窍（现在不用考虑细节部分）。你实际上是把单词 ``change'' 附加在 <TT>secondlink</TT> 的最后。可以用 <TT>cat secondlink</TT> 来确定。

<P>

<DL COMPACT>
<DT>
<DD>cat&nbsp;firstlink
</DD>
</DL><TT>firstlink</TT> 现在后面也有了单词 ``change''！这是因为<TT>firstlink</TT> 和 <TT>secondlink</TT> 指的是<SPAN  CLASS="textit">同一个文件</SPAN>。当你修改它的时候，它叫什么名字是没有关系的。

<P>

<DL COMPACT>
<DT>
<DD>chmod&nbsp;a+rwx&nbsp;firstlink
</DD>
</DL>改变文件 <TT>firstlink</TT> 的访问权限。键入命令<TT>ls&nbsp;-l</TT> 以确定文件 <TT>secondlink</TT> 的访问权限也被改变了，这说明访问权限的资料是存在资料结点里而不是硬连接里的。

<P>

<DL COMPACT>
<DT>
<DD>rm&nbsp;firstlink
</DD>
</DL>删除这个连接，这是 <TT>rm</TT> 命令的微妙之处：它实际上删除的是连接而不是真正的文件。现在键入 <TT>ls&nbsp;-l</TT>，你会看到<TT>secondlink</TT> 还在。注意现在 <TT>secondlink</TT> 的硬连接数降到了1 个。<A NAME="3909"></A><A NAME="3910"></A><A NAME="3911"></A><A NAME="3912"></A><A NAME="3913"></A> 

<P>

<DL COMPACT>
<DT>
<DD>rm&nbsp;secondlink
</DD>
</DL>删除另外一个连接。当一个文件没有任何连接的时候，Linux 本身会删除真正的文件，即它的资料结点。

<P>
所有的文件都是这样的──即使是像设备文件这样的特殊文件（例如 <TT>/dev/hda</TT>）。

<P>
一个目录只是一个文件名和资料结点序号的列表，也就是说是一个硬连接的列表。当你建立一个硬连接时，你只是在一个目录上加入了一个“文件名─序号”对。当你删除一个文件，你只是从目录中删除了一个硬连接。<A NAME="3917"></A>

<P>

<H2><A NAME="SECTION041322000000000000000"></A><A NAME="file-types"></A>
<BR>
<SPAN CLASS="arabic">2</SPAN> 文件类型
</H2>

<P>
到目前为止，我们隐藏了一个细节：Linux 内核把所有东西都看成是一个文件。这包括目录和各种设备，它们只是一些特殊的文件罢了。

<P>
你可能记得，<TT>ls&nbsp;-l</TT> 显示的第一个字符代表的是该文件的类型，对于一个普通的文件来说，这个字符就是个简单的 <TT>-</TT>。其它可能的字符包括一下：

<P>
<DL>
<DT><STRONG><TT>d</TT></STRONG></DT>
<DD>目录 (directory)
</DD>
<DT><STRONG><TT>l</TT></STRONG></DT>
<DD>符号连接 (symbolic link)
</DD>
<DT><STRONG><TT>b</TT></STRONG></DT>
<DD>块设备 (block device)
</DD>
<DT><STRONG><TT>c</TT></STRONG></DT>
<DD>字符设备 (character device)
</DD>
<DT><STRONG><TT>p</TT></STRONG></DT>
<DD>具名管道 (named pipe)
</DD>
<DT><STRONG><TT>s</TT></STRONG></DT>
<DD>套接口 (socket)
</DD>
</DL>

<P>

<H3><A NAME="SECTION041322100000000000000"></A>
<A NAME="3930"></A><A NAME="3931"></A><A NAME="3932"></A>
<BR>
<SPAN CLASS="arabic">1</SPAN> 符号连接 (Symbolic Links) 
</H3><A NAME="3933"></A><A NAME="3934"></A><A NAME="3935"></A><A NAME="3936"></A>符号连接（也叫 ``symlinks'' 或软连接 ``soft links''）是除硬连接以外的另外一种连接。一个符号连接是个特殊的文件，它“指向”任意一个加载了的文件系统上的一个硬连接。当你读取一个符号连接的内容时，它给出它所指向的文件的内容而不是这个符号连接本身的内容。因为目录，设备，以及其它的符号连接都是各种类型的文件，所以你可以使用一个符号连接指向所有这些文件。

<P>
因此一个硬连接是一个文件名和一个资料结点序号。一个文件其实是一个资料结点：在磁盘上的地址，文件类型，允许模式等等。一个符号连接是一个资料结点，它的内容包含一个硬连接的名字。一个符号连接把一个文件名和另外一个文件名配对，而一个硬连接把一个文件名和一个资料结点配对。

<P>
所有的指向同一个文件的硬连接有相同的形态，就是说任何一个跟其他的都是一样的，如果你在其中一个上面进行操作，其效果跟再其它的连接上进行操作是一样的。而在符号连接上的操作，有时候会影响这个符号连接自己的资料结点（含有硬连接名字的那个结点）的资料，有时候影响的是它指向的那个硬连接的内容。

<P>
符号连接和硬连接之间有几个重要的分别。

<P>
<A NAME="3937"></A><A NAME="3938"></A><A NAME="3939"></A><A NAME="3940"></A>符号连接可以跨越文件系统，因为它们含有从根目录开始的完整的文件名，而所有的完整的文件名都是唯一的。但硬连接指向的是资料结点序号，资料结点序号仅仅在一个文件系统内是唯一的，如果不知道文件系统，则这个序号就会不明确。

<P>
你可以建立目录的符号连接，但不能建立目录的硬连接。每个目录都有它的硬连接──在它的母目录中以 <TT>.</TT><A NAME="3942"></A> 列出，在它的所有子目录中以 <TT>..</TT> 列出──但为了在文件系统中强制次序，不允许有其它的目录硬连接存在。因而一个目录中的文件数目等于该目录的所有硬连接的数目减 2 （减去目录名和 <TT>.</TT> 连接）。<A NAME="3945"></A><A NAME="3946"></A><A NAME="3947"></A>比较符号连接和硬连接，你只能跟一个存在的文件建立硬连接，因为它必需指向一个资料结点序号，但你可以把符号连接连到任何文件名，不论这个文件名的文件是否存在。

<P>
<A NAME="3948"></A><A NAME="3949"></A><A NAME="3950"></A><A NAME="3951"></A><A NAME="3952"></A>删除一个符号连接只删除这个连接，这对于连到的那个目标文件没有影响，而删除一个文件的最后的那个硬连接，则会把那个文件完全删除。

<P>
范例：

<P>

<DL COMPACT>
<DT>
<DD>cd;&nbsp;ln&nbsp;-s&nbsp;/tmp/me&nbsp;MyTmp
</DD>
</DL><TT>cd</TT> 到你的家目录，命令 <TT>ln</TT> 的 <TT>-s</TT> 选项建立一个符号连接。这里建立的是一个叫 <TT>MyTmp</TT> 的文件指向文件名 <TT>/tmp/me</TT>。

<P>

<DL COMPACT>
<DT>
<DD>ls&nbsp;-l&nbsp;MyTmp
</DD>
</DL>输出结果应该类似：

<P>

<DL COMPACT>
<DT>
<DD><SMALL CLASS="SMALL">lrwxrwxrwx&nbsp;1&nbsp;havoc&nbsp;havoc&nbsp;7&nbsp;Dec&nbsp;6&nbsp;12:50&nbsp;MyTmp&nbsp;-&gt;&nbsp;/tmp/me</SMALL>&nbsp;
</DD>
</DL>当然日期和用户 / 群体名在你的系统上是不一样的。注意文件类别是 <TT>l</TT>，指示着这是一个符号连接，另外注意它的许可状态：符号连接的许可状态总是这样的。如果你尝试改变一个符号连接的状态（使用 <TT>chmod</TT> 命令），你改变的是它所指向的那个文件的状态。

<P>

<DL COMPACT>
<DT>
<DD>chmod&nbsp;700&nbsp;MyTmp
</DD>
</DL>你会得到 <TT>No&nbsp;such&nbsp;file&nbsp;or&nbsp;directory</TT>（没有这个文件或目录）的错误信息，这是因为文件 <TT>/tmp/me</TT> 并不存在，虽然你仍然可以就这么建立一个符号连接。

<P>

<DL COMPACT>
<DT>
<DD>mkdir&nbsp;/tmp/me
</DD>
</DL>建立目录 <TT>/tmpme</TT>。

<P>

<DL COMPACT>
<DT>
<DD>chmod&nbsp;700&nbsp;MyTmp
</DD>
</DL>这个命令现在应该可以成功。

<P>

<DL COMPACT>
<DT>
<DD>touch&nbsp;MyTmp/myfile
</DD>
</DL>在 <TT>MyTmp</TT> 下建立一个文件。

<P>

<DL COMPACT>
<DT>
<DD>ls&nbsp;/tmp/me
</DD>
</DL>这个文件其实是在目录 <TT>/tmp/me</TT> 下建立的。

<P>

<DL COMPACT>
<DT>
<DD>rm&nbsp;MyTmp
</DD>
</DL>删除这个符号连接，主要这只删除了连接，而不是那个它指向的目录，所以使用的是 <TT>rm</TT> 而不是 <TT>rmdir</TT>（<TT>rmdir</TT> 用来删除目录）。

<P>

<DL COMPACT>
<DT>
<DD>rm&nbsp;/tmp/me/myfile;&nbsp;rmdir&nbsp;/tmp/me
</DD>
</DL>现在你自己清扫一下。<A NAME="3989"></A><A NAME="3990"></A><A NAME="3991"></A><A NAME="3992"></A><A NAME="3993"></A>

<P>

<H3><A NAME="SECTION041322200000000000000">
<SPAN CLASS="arabic">2</SPAN> 设备文件 (Device Files)</A>
</H3>

<P>
<A NAME="3995"></A><A NAME="3996"></A><A NAME="3997"></A><A NAME="3998"></A><A NAME="3999"></A><A NAME="4000"></A><A NAME="4001"></A><A NAME="4002"></A>设备文件指向你的系统里的物理设备或者虚拟设备，例如你的硬盘、显卡、屏幕和键盘。虚拟设备则包括控制台 (console)，以 <TT>/dev/console</TT> 来表示。

<P>
设备分为两种：字符式 (character) 和块式 (block)。<SPAN  CLASS="textit">字符设备</SPAN>可以每次访问一个字符，记住从这种设备中可以读取和写入的最小单位是一个字符（一个字节）。

<P>
<SPAN  CLASS="textit">块设备</SPAN>的存取必需以一个大的单位进行，我们叫作‘块’<A NAME="4006"></A>。一块里包含了一些字符。硬盘就是一个块设备。

<P>
<A NAME="4007"></A><A NAME="4008"></A>你可以像对其它文件一样对设备文件进行读写，不过这些设备文件里可能含有一些你根本看不懂的乱七八糟的东西。一般来说往这些文件里随便写入数据不是什么好事儿，但又是却会有用，例如，你可以把一个 postscript 文件直接倾倒进打印机设备文件 <TT>/dev/lp0</TT> 或者把一些调制解调器 (modem) 指令传给相应的串连埠的设备文件。

<P>

<H4><A NAME="SECTION041322210000000000000">
<SPAN CLASS="arabic">1</SPAN> <TT>/dev/null</TT></A>
</H4>

<P>
<TT>/dev/null</TT> 是一个特殊的设备文件，你写入它的任何东西都会被丢弃。如果你不想要什么了，把它扔进 <TT>/dev/null</TT>。它基本上<A NAME="4013"></A><A NAME="4014"></A><A NAME="4015"></A><A NAME="4016"></A><A NAME="4017"></A><A NAME="4018"></A><A NAME="4019"></A><A NAME="4020"></A>就是个无底深渊，如果你从 <TT>/dev/null</TT> 里读入，你立刻会得到一个文件结束 (EOF : end-of-file) 字符。<TT>/dev/zero</TT> 是另一个类似的设备文件，只是如果你从这里读取，你得到的是一个 <TT>&#92;0</TT> 字符（这是一个空字符，代表什么也不是，与数字 0 是不同的）。

<P>

<H3><A NAME="SECTION041322300000000000000">
<SPAN CLASS="arabic">3</SPAN> 具名管道 (Named Pipes, FIFOs)</A>
</H3>

<P>
<A NAME="4025"></A><A NAME="4026"></A><A NAME="4027"></A><A NAME="4028"></A><A NAME="4029"></A><A NAME="4030"></A>一个管道是一个作用象个管道的文件。你放东西进这个文件，你放的东西从文件的另一端出来，因此它也叫 FIFO（First-In-First-Out 缩写，即先入先出），你放进去的第一个东西也是最先从另外一端出来的那个。

<P>
如果对一个具名的管道进行写入，这个写入的进程不到所有写入的资料被从管道中都读走了是不会结束的。如果你从一个管道中读取，读取进程会一直等到读到一些东西以后才结束。管道的大小总是 0：它不储存任何数据，它只是把两个进程连接起来，就像 shell 里的 <TT>|</TT> 一样。但是因为这个管道是有名字的，所以那两个被连的进程不需要总同一个命令行出现，它们甚至不需要是属于同一个用户的。

<P>
你可以试一下这个例子：

<P>

<DL COMPACT>
<DT>
<DD>cd;&nbsp;mkfifo&nbsp;mypipe
</DD>
</DL>做一个管道。

<P>

<DL COMPACT>
<DT>
<DD>echo&nbsp;&#34;hello&#34;&nbsp;&gt;&nbsp;mypipe&nbsp;&amp;
</DD>
</DL>用 <TT>echo</TT> 把 ``hello'' 写入管道 <TT>mypipe</TT>，同时把这个进程放到后台。注意这个进程在后台并不返回，因为它在等待有人从它的管道把数据读出。

<P>

<DL COMPACT>
<DT>
<DD>cat&nbsp;mypipe
</DD>
</DL>这时候，<TT>echo</TT> 的进程将会返回，因为 <TT>cat</TT> 把管道里的资料都读了，而 <TT>cat</TT> 命令会印出单词 <TT>hello</TT>。

<P>

<DL COMPACT>
<DT>
<DD>rm&nbsp;mypipe
</DD>
</DL>你可以用一般方式删除这个管道。<A NAME="4048"></A>

<P>

<H3><A NAME="SECTION041322400000000000000">
<SPAN CLASS="arabic">4</SPAN> 套接口 (Sockets)</A>
</H3>

<P>
<A NAME="4050"></A><A NAME="4051"></A><A NAME="4052"></A>套接口 (sockets) 类似于管道 (pipes) 但它是在网络上面工作的。你到计算机就是靠它来做网络处理的。你可能听说过 ``Winsock''，那是 Windows 的套接口。

<P>
我们在这里不深入谈有关套接口，因为如果你不写程序，你不会用到它，但如果你看到你系统里有个文件类型是 <TT>s</TT>，你知道它是什么就行了。

<P>

<H2><A NAME="SECTION041323000000000000000">
<SPAN CLASS="arabic">3</SPAN> <TT>proc</TT> 文件系统 (The <TT>proc</TT> Filesystem)</A>
</H2>

<P>
<A NAME="4056"></A><A NAME="4057"></A><A NAME="4058"></A>Linux 的内核会建立一个特别的文件系统，在 Debian 系统上，这个文件系统加载于 <TT>/proc</TT> 目录下。这是一个“伪文件系统” (``pseudo-filesystem'')，因为它不在任何一个物理设备上。

<P>
<TT>proc</TT> 文件系统包含系统和执行中的进程的资料。<TT>/proc</TT> 下的“文件”，有些是可以读懂的简单文本格式（试着键入<TT>cat&nbsp;/proc/meminfo</TT> 或<TT>cat&nbsp;/proc/cpuinfo</TT>），另外一些是一些神秘的数字组合。系统会有一些工具可以读取这些资料，然后翻译成一些你看的懂的东西。

<P>
有些人当看到一个特别的文件时常会觉得紧张，就是 <TT>/proc/kcore</TT> 文件。这个文件一般来说都很大，它是用来对内核进行除错用的。它其实根本不存在你的物理设备里（记住 <TT>/proc</TT> 下是一个伪文件系统），所以用不着担心它的大小。

<P>
如果你想知道所有关于 <TT>/proc</TT> 的资料，参看它的手册，键入<TT>man 5&nbsp;proc</TT>。

<P>

<H2><A NAME="SECTION041324000000000000000">
<SPAN CLASS="arabic">4</SPAN> 大规模复制</A>
</H2>

<P>
<A NAME="4069"></A><A NAME="4070"></A><A NAME="4071"></A><A NAME="4072"></A>有时候你会要把一个目录复制 (copy) 到另外一个地方，可能是因为你加了一个新硬盘，你要把你的 <TT>/usr/local</TT> 复制到它上面。有几个方法都可以达到这个目的。

<P>
第一个是用复制命令 <TT>cp</TT>。命令 <TT>cp&nbsp;-a</TT> 告诉 <TT>cp</TT> 在复制的时候，尽量保存可能保存的资料（这个 a 有 all 的意思）。因此，你可以用

<P>

<DL COMPACT>
<DT>
<DD>cp&nbsp;-a&nbsp;/usr/local&nbsp;/destination
</DD>
</DL>但是有些东西即使 <TT>cp&nbsp;-a</TT> 也不能保存下来<A NAME="tex2html41" HREF="footnode_mn.html#foot4080" TARGET="footer"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="footnote.png"></SUP></A>。因此，进行大规模复制工作的最好方法是使用两个连在一起的 <TT>tar</TT> 命令，像是：

<DL COMPACT>
<DT>
<DD>tar&nbsp;-cSpf&nbsp;-&nbsp;/usr/local&nbsp;|&nbsp;tar&nbsp;-xvSpf&nbsp;-&nbsp;-C&nbsp;/destination
</DD>
</DL>第一个 <TT>tar</TT> 命令会把想要的目录归档，然后通过管道把它送给第二个<TT>tar</TT> 命令。第二个命令把归好的档解开，放到 <TT>-C</TT> 所指定的目的地。<A NAME="4087"></A><A NAME="4088"></A><A NAME="4089"></A><A NAME="4090"></A>

<P>

<H1><A NAME="SECTION041330000000000000000">
<SPAN CLASS="arabic">3</SPAN> 系统安全</A>
</H1>

<P>
<A NAME="4092"></A><A NAME="4093"></A><A NAME="4094"></A>在第 <A HREF="node11_ct.html#Permissions"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A> 页，第 <A HREF="node11_ct.html#Permissions">7.1</A> 节，我们讲过Linux 上的文件许可模式 (file permissions)。这是保证你的系统安全的基础。如果设立一个多用户系统或者一个服侍器，则文件许可模式的正确设定是非常重要的。一个好的惯例是，只给文件它们所需要的最小许可。

<P>
如果你跑的是一个网络服务器，你还要其他的一些事情。第一，你应该把所有你不需要提供的网络服务都关掉。最好从文件 <TT>/etc/inetd.conf</TT> 开始，你可能需要里面的一些服务。对于很多网络服务，你还可以控制谁有权使用它们，文件 <TT>/etc/hosts.allow</TT> 和 <TT>/etc/hosts.deny</TT>（它们的手册在<TT>man&nbsp;5&nbsp;hosts_access</TT> 里）是专门控制服务使用权的。你还应该保证有最新的补丁和 Debian 更新，你可以从离你最近的 Debian FTP 镜像处取得。

<P>
其他的一些常识性的规则也是有用的：

<P>

<UL>
<LI>永远不要告诉别人你的口令。
</LI>
<LI>永远不要通过互联网以简单文本输入你的口令，像使用 telnet 或者 FTP 的时候。你应该在这些程序上层使用一些加密协定或者避免远程登录。
</LI>
<LI>尽可能的避免使用 root 用户登录。
</LI>
<LI>不要安装不可信的软件，非装不可的时候，绝对不要以 root 身份安装。
</LI>
<LI>避免把文件设定成谁的可以写的模式。<TT>/tmp</TT> 在这里是个例外，它必须是都可写可读的。
</LI>
</UL>
虽然这些对于一个不需要维护服侍器的人来说好像没有意义，其实了解一些系统安全是很有用的。你系统免被病毒侵入是靠 Debian 的系统安全机制达到的。

<P>

<H1><A NAME="SECTION041340000000000000000">
<SPAN CLASS="arabic">4</SPAN> Debian 上的软件开发</A>
</H1>

<P>
<A NAME="4105"></A><A NAME="4106"></A><A NAME="4107"></A><A NAME="4108"></A>Debian 是一个非常好的软件开发，编程平台。它支持的编程语言或类语言有：C, C++, Objective-C, Perl, Python, m4, Ada, Pascal, Java, awk, Tcl/Tk,
SQL, assembler, Bourne Shell, csh 等等。如何编程的东西超出了本书的范围，但在这里，我们列出一些 Debian 里常用的开发程序：

<P>
<DL>
<DT><STRONG>gcc</STRONG></DT>
<DD>GNU C 编译器，一个现代的优化的 C 语言编译器。
</DD>
<DT><STRONG>g++</STRONG></DT>
<DD>gcc 系列中的 C++ 编译器。
</DD>
<DT><STRONG>cpp</STRONG></DT>
<DD>gcc 中的 C 前处理器 (preprocessor)。
</DD>
<DT><STRONG>perl</STRONG></DT>
<DD>Perl 解释器。Perl 是一个优秀的“粘合”语言。
</DD>
<DT><STRONG>gdb</STRONG></DT>
<DD>GNU Debugger（除错程序），用来对多种语言进行除错的工具。
</DD>
<DT><STRONG>gprof</STRONG></DT>
<DD>对程序进行模型，可以帮助你提高你写的程序的表现。它会告诉你你的程序在各阶段的表现，你可以再有针对性的加以改进。
</DD>
<DT><STRONG>emacs</STRONG></DT>
<DD>GNU Emacs 是一个程序员的编辑器和集成开发环境。
</DD>
<DT><STRONG>as</STRONG></DT>
<DD>GNU Assembler（组合语言编译器）。
</DD>
</DL>
<A NAME="4111"></A><A NAME="4112"></A><A NAME="4113"></A><A NAME="4114"></A>

<P>

<P>

<HR>
<ADDRESS>
John Goerzen / Ossama Othman / Debian 中文计划
</ADDRESS>
</BODY>
</HTML>

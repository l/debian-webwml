
<!--Converted with LaTeX2HTML 99.2beta6 (1.42)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Contents of 13 進階話題</TITLE>
<META NAME="description" CONTENT="Contents of 13 進階話題">
<META NAME="keywords" CONTENT="debian-tutorial-zh_TW-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=big5">
<META NAME="Generator" CONTENT="LaTeX2HTML v99.2beta6">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="debian-tutorial-zh_TW-html.css">

<LINK REL="previous" HREF="node16_mn.html">
<LINK REL="up" HREF="node4_mn.html">
<LINK REL="next" HREF="node18_mn.html">
</HEAD>
 
<BODY bgcolor="#ffffff" text="#000000" link="#9944EE" vlink="#0000ff" alink="#00ff00">
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html883" HREF="node17_ct.html#SECTION041310000000000000000" TARGET="contents"><SPAN CLASS="arabic">1</SPAN> 規則表達式 (Regular Expressions)</A>
<LI><A NAME="tex2html884" HREF="node17_ct.html#SECTION041320000000000000000" TARGET="contents"><SPAN CLASS="arabic">2</SPAN> 深入文件</A>
<UL>
<LI><A NAME="tex2html885" HREF="node17_ct.html#SECTION041321000000000000000" TARGET="contents"><SPAN CLASS="arabic">1</SPAN> 文件的本質：硬連接和資料結點 (Hard Links and Inodes)</A>
<LI><A NAME="tex2html886" HREF="node17_ct.html#SECTION041322000000000000000" TARGET="contents"><SPAN CLASS="arabic">2</SPAN> 文件類型</A>
<UL>
<LI><A NAME="tex2html887" HREF="node17_ct.html#SECTION041322100000000000000" TARGET="contents"><SPAN CLASS="arabic">1</SPAN> 符號連接 (Symbolic Links) </A>
<LI><A NAME="tex2html888" HREF="node17_ct.html#SECTION041322200000000000000" TARGET="contents"><SPAN CLASS="arabic">2</SPAN> 設備檔案 (Device Files)</A>
<UL>
<LI><A NAME="tex2html889" HREF="node17_ct.html#SECTION041322210000000000000" TARGET="contents"><SPAN CLASS="arabic">1</SPAN> <TT>/dev/null</TT></A>
</UL>
<LI><A NAME="tex2html890" HREF="node17_ct.html#SECTION041322300000000000000" TARGET="contents"><SPAN CLASS="arabic">3</SPAN> 具名管道 (Named Pipes, FIFOs)</A>
<LI><A NAME="tex2html891" HREF="node17_ct.html#SECTION041322400000000000000" TARGET="contents"><SPAN CLASS="arabic">4</SPAN> 套接口 (Sockets)</A>
</UL>
<LI><A NAME="tex2html892" HREF="node17_ct.html#SECTION041323000000000000000" TARGET="contents"><SPAN CLASS="arabic">3</SPAN> <TT>proc</TT> 文件系統 (The <TT>proc</TT> Filesystem)</A>
<LI><A NAME="tex2html893" HREF="node17_ct.html#SECTION041324000000000000000" TARGET="contents"><SPAN CLASS="arabic">4</SPAN> 大規模複製</A>
</UL>
<LI><A NAME="tex2html894" HREF="node17_ct.html#SECTION041330000000000000000" TARGET="contents"><SPAN CLASS="arabic">3</SPAN> 系統安全</A>
<LI><A NAME="tex2html895" HREF="node17_ct.html#SECTION041340000000000000000" TARGET="contents"><SPAN CLASS="arabic">4</SPAN> Debian 上的軟件開發</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION041300000000000000000">
<SPAN CLASS="arabic">13</SPAN> 進階話題</A>
</H1>

<P>
現在你應該了一個很好的基礎，可以在此基礎上增強你的 GNU/Linux 技巧了。本章我們探討一些 GNU/Linux 上的較有用的應用資料。

<P>

<H1><A NAME="SECTION041310000000000000000"></A>
<A NAME="3706"></A><A NAME="3707"></A><A NAME="3708"></A><A NAME="3709"></A><A NAME="3710"></A>
<BR>
<SPAN CLASS="arabic">1</SPAN> 規則表達式 (Regular Expressions)
</H1>規則表達式是一組字符集合的描述。這個描述可以用來搜索一篇文章，尋找一段<SPAN  CLASS="textit">符合</SPAN>我們用規則表達式描述的文字。規則表達式類似於 shell 的通配符 (shell wildcards) （見第 <A HREF="node10_ct.html#expansion">6.6</A> 頁第<A HREF="node10_ct.html#expansion">6.6</A> 節），但是它更複雜，功能也更強大。

<P>
一段規則表達式是由文字和
<SPAN  CLASS="textit">變字符</SPAN> (<SPAN  CLASS="textit">metacharacters</SPAN>) 組成的。一個變字符就是一個字符但是有特殊的意思。變字符包括：<TT>.&nbsp;*&nbsp;[]&nbsp;-&nbsp;&#92;^&nbsp;$</TT>。

<P>
如果一段規則表達式只含有文字（沒有變字符），那它就相對應那些文字。例如規則表達式 ``<TT>my regular expression</TT>'' 就匹對``<TT>my regular expression</TT>''，僅此而已。規則表達式一般是大小寫敏感的。

<P>
你可以用命令 <TT>egrep</TT> 顯示一個文件中所有匹對一個規則表達式的行。語法是：

<P>

<DL COMPACT>
<DT>
<DD>egrep&nbsp;'regexp'&nbsp;filename1&nbsp;...
</DD>
</DL>其中的單引號不是所有情況下都需要的，但最好加上。

<P>
例如，要找到 GPL 裡所有含有 GNU 這個單詞的行，鍵入：

<P>

<DL COMPACT>
<DT>
<DD>egrep&nbsp;'GNU'&nbsp;/usr/doc/copyright/GPL
</DD>
</DL><TT>egrep</TT> 會把那些行印在標準輸出的。
<A NAME="3729"></A><A NAME="3730"></A><A NAME="3731"></A><A NAME="3732"></A><A NAME="3733"></A>
如果你想要所有含有 <TT>freedom</TT> 後跟一些其它的字然後再跟 <TT>GNU</TT> 的行，可以用命令：

<P>

<DL COMPACT>
<DT>
<DD><A NAME="3737"></A><A NAME="3738"></A><A NAME="3739"></A><A NAME="3740"></A><A NAME="3741"></A><A NAME="3742"></A><A NAME="3743"></A><A NAME="3744"></A><A NAME="3745"></A>egrep&nbsp;'freedom.*GNU'&nbsp;/usr/doc/copyright/GPL
</DD>
</DL>這兒的 <TT>.</TT> 是指“所有字符”，而 <TT>*</TT> 指“0 或以上個前面的那個東西”，合起來就是“零或一個任意的字符”，因此 <TT>.*</TT> 基本上對應幾乎所有的文字。<TT>egrep</TT> 對匹對方式是以行為單位的，所以匹對出的 <TT>freedom</TT> 和 <TT>GNU</TT> 必須在同一行。

<P>
這裡是一個對規則表達式中的變字符的一個歸納：

<P>
<DL>
<DT><STRONG><TT>.</TT></STRONG></DT>
<DD>對應出換行符 (newline) 以外的所有單一字符。</DD>
<DT><STRONG><TT>*</TT></STRONG></DT>
<DD>對應 0 或以上個前面那個東西。比如表達式<TT>a*</TT>&nbsp;對應零或多個小寫&nbsp;a，而&nbsp;<TT>.*</TT> 對應零或多個任意字符。</DD>
<DT><STRONG><TT>[<SPAN  CLASS="textit">字符字符字符</SPAN>]</TT></STRONG></DT>
<DD>括號內必須含有一個或以上的字符，整個括號表達式只對應給出的字符集合中的一個字符。例如 <TT>[abc]</TT> 對應一個 a，一個 b，或者一個 c﹔它不對應 0 字符，也不對應這三個字符以外的任何字符。
</DD>
<DT><STRONG><TT>^</TT></STRONG></DT>
<DD>把你的搜查限制在每行的開頭。表達式<TT>^The</TT>&nbsp;對應一個在行首的&nbsp;<TT>The</TT>﹔在這個&nbsp;<TT>The</TT> 前面不能有空格或者任何其他的文字。如果你要允許有前面有空格，你可以用表達式 <TT>^*The</TT> 來允許前面有 0 或多個空格。
</DD>
<DT><STRONG><TT>$</TT></STRONG></DT>
<DD>把搜索限制在行尾。<TT>end$</TT> 要求文字 <TT>end</TT> 出現在一行的最後，後面沒有空格或其它。
</DD>
<DT><STRONG><TT>[^<SPAN  CLASS="textit">字符字符</SPAN>]</TT></STRONG></DT>
<DD>這個表達顛倒一個括號字符表達式，即 <TT>[^abc]</TT> 對應所有<SPAN  CLASS="textit">除了</SPAN> a、b、c 以外的單一字符。
</DD>
<DT><STRONG><TT>[<SPAN  CLASS="textit">字符</SPAN>-<SPAN  CLASS="textit">字符</SPAN>]</TT></STRONG></DT>
<DD>你可以在括號表達式裡包含一個範圍。要對應所有小寫字母，使用 <TT>[a-z]</TT>。其間可以使用多個範圍，例如對應前三個和後三個英文字母，使用 <TT>[a-cx-z]</TT>。對應所有英文大小寫字母，使用 <TT>[a-zA-Z]</TT>。你可以把範圍，單個字母，以及 <TT>^</TT> 變字符混用，比如 <TT>[^a-zBZ]</TT> 對應“除了一個小寫字母，大寫 B，大寫 Z 以外的所有單一東西”。
</DD>
<DT><STRONG><TT>()</TT></STRONG></DT>
<DD>你可以用圓括號把一部分表達式結成一組，就像一般的數學表達式一樣。
</DD>
<DT><STRONG><TT>|</TT></STRONG></DT>
<DD><TT>|</TT> 的意思是“或者”(or)。你可以用它來提供一系列的可選表達式。一般可選的表達式會用圓括號分開，像：<TT>c(ad|ab|at)</TT> 對應的是cad 或 cab 或 cat。如果沒有圓括號，則對應的就成了 cad 或 ab 或at 了：cad|ab|at。
</DD>
<DT><STRONG><TT>&#92;</TT></STRONG></DT>
<DD>這個變字符逃脫任何一個特殊字符。如果你想要搜索 <TT>*</TT>&nbsp;這個字，你需要用&nbsp;<TT>&#92;*</TT>。這個斜杠的意思是忽略 <TT>*</TT> 的特殊意思。
</DD>
</DL>
這裡是一些範例，讓你更好的掌握規則表達式的用法：
<A NAME="3806"></A><A NAME="3807"></A><A NAME="3808"></A><A NAME="3809"></A><A NAME="3810"></A>
<DL>
<DT><STRONG><TT>c.pe</TT></STRONG></DT>
<DD>對應 cope、cape、caper。
</DD>
<DT><STRONG><TT>c&#92;&nbsp;.pe</TT></STRONG></DT>
<DD>對應 c.pe、c.per。
</DD>
<DT><STRONG><TT>sto*p</TT></STRONG></DT>
<DD>對應 stp、stop、stoop。
</DD>
<DT><STRONG><TT>car.*n</TT></STRONG></DT>
<DD>對應 carton、cartoon、carmen。
</DD>
<DT><STRONG><TT>xyz.*</TT></STRONG></DT>
<DD>對應 xyz 和它後面跟的所有東西，有些工具，例如
<TT>egrep</TT>，只對應到那一行結束為止。
</DD>
<DT><STRONG><TT>^The</TT></STRONG></DT>
<DD>對應一行開頭的 The。
</DD>
<DT><STRONG><TT>atime$</TT></STRONG></DT>
<DD>對應一行結尾的 atime。
</DD>
<DT><STRONG><TT>^Only$</TT></STRONG></DT>
<DD>對應一個只含有 Only 一個字的行，沒有空格，沒有其它字符，別的什麼都沒有，就一個 Only。
</DD>
<DT><STRONG><TT>b[aou]rn</TT></STRONG></DT>
<DD>對應 barn、born、burn。
</DD>
<DT><STRONG><TT>Ver[D-F]</TT></STRONG></DT>
<DD>對應 VerD、VerE、VerF。
</DD>
<DT><STRONG><TT>Ver[^0-9]</TT></STRONG></DT>
<DD>對應一個 Ver 後面跟任何非數字的東西。
</DD>
<DT><STRONG><TT>the[ir][re]</TT></STRONG></DT>
<DD>對應 their、therr、there、theie。
</DD>
<DT><STRONG><TT>[A-Za-z][A-Za-z]*</TT></STRONG></DT>
<DD>對應任何只含有英文字母的單詞，並且最少有一個字母，不對應數字或空格。
</DD>
</DL>

<P>

<H1><A NAME="SECTION041320000000000000000">
<SPAN CLASS="arabic">2</SPAN> 深入文件</A>
</H1>

<P>
現在你已經知道關於文件的基本知識，該學些更加深入的東西了。

<P>

<H2><A NAME="SECTION041321000000000000000"></A><A NAME="advanced-files-hardlinks"></A>
<A NAME="3840"></A><A NAME="3841"></A><A NAME="3842"></A>
<BR>
<SPAN CLASS="arabic">1</SPAN> 文件的本質：硬連接和資料結點 (Hard Links and Inodes)
</H2><A NAME="3843"></A><A NAME="3844"></A><A NAME="3845"></A><A NAME="3846"></A>系統中的每個文件是以<SPAN  CLASS="textit">資料結點</SPAN> (<SPAN  CLASS="textit">inode</SPAN>: Information Node;
發音 ``eye-node'') 表示的，一個資料結點含有一個文件的所有信息。但是，資料結點不能直接看到，每個資料結點通過一個或多個的<SPAN  CLASS="textit">硬連接</SPAN>跟文件系統聯系起來。硬連接含有一個文件的文件名和資料結點序號 (inode number)。
而資料結點含有那個文件本身，就是文件在磁碟上儲存的位置，它的訪問權限，文件的類型等等。如果一個資料結點有它的資料結點序號 (inode number)，那麼系統總能把它找到。

<P>
一個文件可以有超過一個的硬連接，就是說多個不同的文件名可以指向同一個文件（它們都和同一個資料結點需要結合）。但你不能做跨越文件系統的硬連接：所有的對某一個文件（資料結點）做直接參考必需在同一個文件系統上，這是因為每個文件系統都有它自己的一套資料結點，不同的文件系統間的資料結點序號可能會重複。<A NAME="3850"></A>

<P>
因為所有指向同一個資料結點的硬連接都是參照<SPAN  CLASS="textit">同一個文件</SPAN>，你可以用一個文件名來修改一個文件，用指向同一個資料結點但使用一個不同的文件名來查看你的更改結果。試一下這個：

<P>

<DL COMPACT>
<DT>
<DD>cd;&nbsp;echo&nbsp;&#34;hello&#34;&nbsp;&gt;&nbsp;firstlink
</DD>
</DL><TT>cd</TT> 到你的家目錄，建立一個有單詞 ``hello'' 的叫<TT>firstlink</TT> 的文件，你實際上是把 <TT>echo</TT> 命令的輸出重新定向，把輸出放到 <TT>firstlink</TT> 裡，<TT>echo</TT> 命令僅僅重複你傳給它的任何東西。細節請參考有關 shell 的章節。

<P>

<DL COMPACT>
<DT>
<DD>cat&nbsp;firstlink
</DD>
</DL>確定文件 <TT>firstlink</TT> 的內容。

<P>

<DL COMPACT>
<DT>
<DD>ln&nbsp;firstlink&nbsp;secondlink
</DD>
</DL>建立一個硬連接：<TT>secondlink</TT> 現在指向和 <TT>firstlink</TT> 相同的資料結點。

<P>

<DL COMPACT>
<DT>
<DD>cat&nbsp;secondlink
</DD>
</DL>確定 <TT>secondlink</TT> 的內容和 <TT>firstlink</TT> 一樣。

<P>

<DL COMPACT>
<DT>
<DD>ls&nbsp;-l
</DD>
</DL>注意列出的 <TT>firstlink</TT> 和
 <TT>secondlink</TT> 文件的資料結點聯合的硬連接數目<A NAME="3876"></A><A NAME="3877"></A><A NAME="3878"></A><A NAME="3879"></A><A NAME="3880"></A><A NAME="3881"></A><A NAME="3882"></A><A NAME="3883"></A><A NAME="3884"></A><A NAME="3885"></A><A NAME="3886"></A><A NAME="3887"></A>是 2。

<P>

<DL COMPACT>
<DT>
<DD>echo&nbsp;&#34;change&#34;&nbsp;&gt;&gt;&nbsp;secondlink
</DD>
</DL>這個另外一個 shell 重新定向訣竅（現在不用考慮細節部分）。你實際上是把單詞 ``change'' 附加在 <TT>secondlink</TT> 的最後。可以用 <TT>cat secondlink</TT> 來確定。

<P>

<DL COMPACT>
<DT>
<DD>cat&nbsp;firstlink
</DD>
</DL><TT>firstlink</TT> 現在後面也有了單詞 ``change''！這是因為<TT>firstlink</TT> 和 <TT>secondlink</TT> 指的是<SPAN  CLASS="textit">同一個文件</SPAN>。當你修改它的時候，它叫什麼名字是沒有關係的。

<P>

<DL COMPACT>
<DT>
<DD>chmod&nbsp;a+rwx&nbsp;firstlink
</DD>
</DL>改變文件 <TT>firstlink</TT> 的訪問權限。鍵入命令<TT>ls&nbsp;-l</TT> 以確定文件 <TT>secondlink</TT> 的訪問權限也被改變了，這說明訪問權限的資料是存在資料結點裡而不是硬連接裡的。

<P>

<DL COMPACT>
<DT>
<DD>rm&nbsp;firstlink
</DD>
</DL>刪除這個連接，這是 <TT>rm</TT> 命令的微妙之處：它實際上刪除的是連接而不是真正的文件。現在鍵入 <TT>ls&nbsp;-l</TT>，你會看到<TT>secondlink</TT> 還在。注意現在 <TT>secondlink</TT> 的硬連接數降到了1 個。<A NAME="3912"></A><A NAME="3913"></A><A NAME="3914"></A><A NAME="3915"></A><A NAME="3916"></A> 

<P>

<DL COMPACT>
<DT>
<DD>rm&nbsp;secondlink
</DD>
</DL>刪除另外一個連接。當一個文件沒有任何連接的時候，Linux 本身會刪除真正的文件，即它的資料結點。

<P>
所有的文件都是這樣的──即使是像設備文件這樣的特殊文件（例如 <TT>/dev/hda</TT>）。

<P>
一個目錄只是一個文件名和資料結點序號的列表，也就是說是一個硬連接的列表。當你建立一個硬連接時，你只是在一個目錄上加入了一個“文件名─序號”對。當你刪除一個文件，你只是從目錄中刪除了一個硬連接。<A NAME="3920"></A>

<P>

<H2><A NAME="SECTION041322000000000000000"></A><A NAME="file-types"></A>
<BR>
<SPAN CLASS="arabic">2</SPAN> 文件類型
</H2>

<P>
到目前為止，我們隱藏了一個細節：Linux 核心把所有東西都看成是一個文件。這包括目錄和各種設備，它們只是一些特殊的文件罷了。

<P>
你可能記得，<TT>ls&nbsp;-l</TT> 顯示的第一個字符代表的是該文件的類型，對於一個普通的文件來說，這個字符就是個簡單的 <TT>-</TT>。其它可能的字符包括一下：

<P>
<DL>
<DT><STRONG><TT>d</TT></STRONG></DT>
<DD>目錄 (directory)
</DD>
<DT><STRONG><TT>l</TT></STRONG></DT>
<DD>符號連接 (symbolic link)
</DD>
<DT><STRONG><TT>b</TT></STRONG></DT>
<DD>塊設備 (block device)
</DD>
<DT><STRONG><TT>c</TT></STRONG></DT>
<DD>字符設備 (character device)
</DD>
<DT><STRONG><TT>p</TT></STRONG></DT>
<DD>具名管道 (named pipe)
</DD>
<DT><STRONG><TT>s</TT></STRONG></DT>
<DD>套接口 (socket)
</DD>
</DL>

<P>

<H3><A NAME="SECTION041322100000000000000"></A>
<A NAME="3933"></A><A NAME="3934"></A><A NAME="3935"></A>
<BR>
<SPAN CLASS="arabic">1</SPAN> 符號連接 (Symbolic Links) 
</H3><A NAME="3936"></A><A NAME="3937"></A><A NAME="3938"></A><A NAME="3939"></A>符號連接（也叫 ``symlinks'' 或軟連接 ``soft links''）是除硬連接以外的另外一種連接。一個符號連接是個特殊的文件，它“指向”任意一個加載了的文件系統上的一個硬連接。當你讀取一個符號連接的內容時，它給出它所指向的文件的內容而不是這個符號連接本身的內容。因為目錄，設備，以及其它的符號連接都是各種類型的文件，所以你可以使用一個符號連接指向所有這些文件。

<P>
因此一個硬連接是一個文件名和一個資料結點序號。一個文件其實是一個資料結點：在磁碟上的地址，文件類型，允許模式等等。一個符號連接是一個資料結點，它的內容包含一個硬連接的名字。一個符號連接把一個文件名和另外一個文件名配對，而一個硬連接把一個文件名和一個資料結點配對。

<P>
所有的指向同一個文件的硬連接有相同的形態，就是說任何一個跟其他的都是一樣的，如果你在其中一個上面進行操作，其效果跟再其它的連接上進行操作是一樣的。而在符號連接上的操作，有時候會影響這個符號連接自己的資料結點（含有硬連接名字的那個結點）的資料，有時候影響的是它指向的那個硬連接的內容。

<P>
符號連接和硬連接之間有幾個重要的分別。

<P>
<A NAME="3940"></A><A NAME="3941"></A><A NAME="3942"></A><A NAME="3943"></A>符號連接可以跨越文件系統，因為它們含有從根目錄開始的完整的文件名，而所有的完整的文件名都是唯一的。但硬連接指向的是資料結點序號，資料結點序號僅僅在一個文件系統內是唯一的，如果不知道文件系統，則這個序號就會不明確。

<P>
你可以建立目錄的符號連接，但不能建立目錄的硬連接。每個目錄都有它的硬連接──在它的母目錄中以 <TT>.</TT><A NAME="3945"></A> 列出，在它的所有子目錄中以 <TT>..</TT> 列出──但為了在文件系統中強制次序，不允許有其它的目錄硬連接存在。因而一個目錄中的文件數目等於該目錄的所有硬連接的數目減 2 （減去目錄名和 <TT>.</TT> 連接）。<A NAME="3948"></A><A NAME="3949"></A><A NAME="3950"></A>比較符號連接和硬連接，你只能跟一個存在的文件建立硬連接，因為它必需指向一個資料結點序號，但你可以把符號連接連到任何文件名，不論這個文件名的文件是否存在。

<P>
<A NAME="3951"></A><A NAME="3952"></A><A NAME="3953"></A><A NAME="3954"></A><A NAME="3955"></A>刪除一個符號連接只刪除這個連接，這對於連到的那個目標文件沒有影響，而刪除一個文件的最後的那個硬連接，則會把那個文件完全刪除。

<P>
範例：

<P>

<DL COMPACT>
<DT>
<DD>cd;&nbsp;ln&nbsp;-s&nbsp;/tmp/me&nbsp;MyTmp
</DD>
</DL><TT>cd</TT> 到你的家目錄，命令 <TT>ln</TT> 的 <TT>-s</TT> 選項建立一個符號連接。這裡建立的是一個叫 <TT>MyTmp</TT> 的文件指向文件名 <TT>/tmp/me</TT>。

<P>

<DL COMPACT>
<DT>
<DD>ls&nbsp;-l&nbsp;MyTmp
</DD>
</DL>輸出結果應該類似：

<P>

<DL COMPACT>
<DT>
<DD><SMALL CLASS="SMALL">lrwxrwxrwx&nbsp;1&nbsp;havoc&nbsp;havoc&nbsp;7&nbsp;Dec&nbsp;6&nbsp;12:50&nbsp;MyTmp&nbsp;-&gt;&nbsp;/tmp/me</SMALL>&nbsp;
</DD>
</DL>當然日期和用戶／群體名在你的系統上是不一樣的。注意文件類別是 <TT>l</TT>，指示著這是一個符號連接，另外注意它的許可狀態：符號連接的許可狀態總是這樣的。如果你嘗試改變一個符號連接的狀態（使用 <TT>chmod</TT> 命令），你改變的是它所指向的那個文件的狀態。

<P>

<DL COMPACT>
<DT>
<DD>chmod&nbsp;700&nbsp;MyTmp
</DD>
</DL>你會得到 <TT>No&nbsp;such&nbsp;file&nbsp;or&nbsp;directory</TT>（沒有這個文件或目錄）的錯誤信息，這是因為文件 <TT>/tmp/me</TT> 並不存在，雖然你仍然可以就這麼建立一個符號連接。

<P>

<DL COMPACT>
<DT>
<DD>mkdir&nbsp;/tmp/me
</DD>
</DL>建立目錄 <TT>/tmpme</TT>。

<P>

<DL COMPACT>
<DT>
<DD>chmod&nbsp;700&nbsp;MyTmp
</DD>
</DL>這個命令現在應該可以成功。

<P>

<DL COMPACT>
<DT>
<DD>touch&nbsp;MyTmp/myfile
</DD>
</DL>在 <TT>MyTmp</TT> 下建立一個文件。

<P>

<DL COMPACT>
<DT>
<DD>ls&nbsp;/tmp/me
</DD>
</DL>這個文件其實是在目錄 <TT>/tmp/me</TT> 下建立的。

<P>

<DL COMPACT>
<DT>
<DD>rm&nbsp;MyTmp
</DD>
</DL>刪除這個符號連接，主要這只刪除了連接，而不是那個它指向的目錄，所以使用的是 <TT>rm</TT> 而不是 <TT>rmdir</TT>（<TT>rmdir</TT> 用來刪除目錄）。

<P>

<DL COMPACT>
<DT>
<DD>rm&nbsp;/tmp/me/myfile;&nbsp;rmdir&nbsp;/tmp/me
</DD>
</DL>現在你自己清掃一下。<A NAME="3992"></A><A NAME="3993"></A><A NAME="3994"></A><A NAME="3995"></A><A NAME="3996"></A>

<P>

<H3><A NAME="SECTION041322200000000000000">
<SPAN CLASS="arabic">2</SPAN> 設備檔案 (Device Files)</A>
</H3>

<P>
<A NAME="3998"></A><A NAME="3999"></A><A NAME="4000"></A><A NAME="4001"></A><A NAME="4002"></A><A NAME="4003"></A><A NAME="4004"></A><A NAME="4005"></A>設備檔案指向你的系統裡的物理設備或者虛擬設備，例如你的硬碟、顯卡、屏幕和鍵盤。虛擬設備則包括控制台 (console)，以 <TT>/dev/console</TT> 來表示。

<P>
設備分為兩種：字符式 (character) 和塊式 (block)。<SPAN  CLASS="textit">字符設備</SPAN>可以每次訪問一個字符，記住從這種設備中可以讀取和寫入的最小單位是一個字符（一個字節）。

<P>
<SPAN  CLASS="textit">塊設備</SPAN>的存取必需以一個大的單位進行，我們叫作‘塊’<A NAME="4009"></A>。一塊裡包含了一些字符。硬盤就是一個塊設備。

<P>
<A NAME="4010"></A><A NAME="4011"></A>你可以像對其它文件一樣對設備文件進行讀寫，不過這些設備文件裡可能含有一些你根本看不懂的亂七八糟的東西。一般來說往這些文件裡隨便寫入數據不是什麼好事兒，但又是卻會有用，例如，你可以把一個 postscript 文件直接傾倒進打印機設備文件 <TT>/dev/lp0</TT> 或者把一些調制解調器 (modem) 指令傳給相應的串連埠的設備文件。

<P>

<H4><A NAME="SECTION041322210000000000000">
<SPAN CLASS="arabic">1</SPAN> <TT>/dev/null</TT></A>
</H4>

<P>
<TT>/dev/null</TT> 是一個特殊的設備文件，你寫入它的任何東西都會被丟棄。如果你不想要什麼了，把它扔進 <TT>/dev/null</TT>。它基本上<A NAME="4016"></A><A NAME="4017"></A><A NAME="4018"></A><A NAME="4019"></A><A NAME="4020"></A><A NAME="4021"></A><A NAME="4022"></A><A NAME="4023"></A>就是個無底深淵，如果你從 <TT>/dev/null</TT> 裡讀入，你立刻會得到一個文件結束 (EOF : end-of-file) 字符。<TT>/dev/zero</TT> 是另一個類似的設備文件，只是如果你從這裡讀取，你得到的是一個 <TT>&#92;0</TT> 字符（這是一個空字符，代表什麼也不是，與數字 0 是不同的）。

<P>

<H3><A NAME="SECTION041322300000000000000">
<SPAN CLASS="arabic">3</SPAN> 具名管道 (Named Pipes, FIFOs)</A>
</H3>

<P>
<A NAME="4028"></A><A NAME="4029"></A><A NAME="4030"></A><A NAME="4031"></A><A NAME="4032"></A><A NAME="4033"></A>一個管道是一個作用象個管道的文件。你放東西進這個文件，你放的東西從文件的另一端出來，因此它也叫 FIFO（First-In-First-Out 縮寫，即先入先出），你放進去的第一個東西也是最先從另外一端出來的那個。

<P>
如果對一個具名的管道進行寫入，這個寫入的進程不到所有寫入的資料被從管道中都讀走了是不會結束的。如果你從一個管道中讀取，讀取進程會一直等到讀到一些東西以後才結束。管道的大小總是 0：它不儲存任何數據，它只是把兩個進程連接起來，就像 shell 裡的 <TT>|</TT> 一樣。但是因為這個管道是有名字的，所以那兩個被連的進程不需要總同一個命令行出現，它們甚至不需要是屬於同一個用戶的。

<P>
你可以試一下這個例子：

<P>

<DL COMPACT>
<DT>
<DD>cd;&nbsp;mkfifo&nbsp;mypipe
</DD>
</DL>做一個管道。

<P>

<DL COMPACT>
<DT>
<DD>echo&nbsp;&#34;hello&#34;&nbsp;&gt;&nbsp;mypipe&nbsp;&amp;
</DD>
</DL>用 <TT>echo</TT> 把 ``hello'' 寫入管道 <TT>mypipe</TT>，同時把這個進程放到後台。注意這個進程在後台並不返回，因為它在等待有人從它的管道把數據讀出。

<P>

<DL COMPACT>
<DT>
<DD>cat&nbsp;mypipe
</DD>
</DL>這時候，<TT>echo</TT> 的進程將會返回，因為 <TT>cat</TT> 把管道裡的資料都讀了，而 <TT>cat</TT> 命令會印出單詞 <TT>hello</TT>。

<P>

<DL COMPACT>
<DT>
<DD>rm&nbsp;mypipe
</DD>
</DL>你可以用一般方式刪除這個管道。<A NAME="4051"></A>

<P>

<H3><A NAME="SECTION041322400000000000000">
<SPAN CLASS="arabic">4</SPAN> 套接口 (Sockets)</A>
</H3>

<P>
<A NAME="4053"></A><A NAME="4054"></A><A NAME="4055"></A>套接口 (sockets) 類似於管道 (pipes) 但它是在網絡上面工作的。你到電腦就是靠它來做網絡處理的。你可能聽說過 ``Winsock''，那是 Windows 的套接口。

<P>
我們在這裡不深入談有關套接口，因為如果你不寫程序，你不會用到它，但如果你看到你系統裡有個文件類型是 <TT>s</TT>，你知道它是什麼就行了。

<P>

<H2><A NAME="SECTION041323000000000000000">
<SPAN CLASS="arabic">3</SPAN> <TT>proc</TT> 文件系統 (The <TT>proc</TT> Filesystem)</A>
</H2>

<P>
<A NAME="4059"></A><A NAME="4060"></A><A NAME="4061"></A>Linux 的核心會建立一個特別的文件系統，在 Debian 系統上，這個文件系統加載於 <TT>/proc</TT> 目錄下。這是一個“偽文件系統” (``pseudo-filesystem'')，因為它不在任何一個物理設備上。

<P>
<TT>proc</TT> 文件系統包含系統和執行中的進程的資料。<TT>/proc</TT> 下的“文件”，有些是可以讀懂的簡單文本格式（試著鍵入<TT>cat&nbsp;/proc/meminfo</TT> 或<TT>cat&nbsp;/proc/cpuinfo</TT>），另外一些是一些神秘的數字組合。系統會有一些工具可以讀取這些資料，然後翻譯成一些你看的懂的東西。

<P>
有些人當看到一個特別的文件時常會覺得緊張，就是 <TT>/proc/kcore</TT> 文件。這個文件一般來說都很大，它是用來對核心進行除錯用的。它其實根本不存在你的物理設備裡（記住 <TT>/proc</TT> 下是一個偽文件系統），所以用不著擔心它的大小。

<P>
如果你想知道所有關於 <TT>/proc</TT> 的資料，參看它的手冊，鍵入<TT>man 5&nbsp;proc</TT>。

<P>

<H2><A NAME="SECTION041324000000000000000">
<SPAN CLASS="arabic">4</SPAN> 大規模複製</A>
</H2>

<P>
<A NAME="4072"></A><A NAME="4073"></A><A NAME="4074"></A><A NAME="4075"></A>有時候你會要把一個目錄複製 (copy) 到另外一個地方，可能是因為你加了一個新硬盤，你要把你的 <TT>/usr/local</TT> 複製到它上面。有幾個方法都可以達到這個目的。

<P>
第一個是用複製命令 <TT>cp</TT>。命令 <TT>cp&nbsp;-a</TT> 告訴 <TT>cp</TT> 在複製的時候，盡量保存可能保存的資料（這個 a 有 all 的意思）。因此，你可以用

<P>

<DL COMPACT>
<DT>
<DD>cp&nbsp;-a&nbsp;/usr/local&nbsp;/destination
</DD>
</DL>但是有些東西即使 <TT>cp&nbsp;-a</TT> 也不能保存下來<A NAME="tex2html41" HREF="footnode_mn.html#foot4083" TARGET="footer"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="footnote.png"></SUP></A>。因此，進行大規模複製工作的最好方法是使用兩個連在一起的 <TT>tar</TT> 命令，像是：

<DL COMPACT>
<DT>
<DD>tar&nbsp;-cSpf&nbsp;-&nbsp;/usr/local&nbsp;|&nbsp;tar&nbsp;-xvSpf&nbsp;-&nbsp;-C&nbsp;/destination
</DD>
</DL>第一個 <TT>tar</TT> 命令會把想要的目錄歸檔，然後通過管道把它送給第二個<TT>tar</TT> 命令。第二個命令把歸好的檔解開，放到 <TT>-C</TT> 所指定的目的地。<A NAME="4090"></A><A NAME="4091"></A><A NAME="4092"></A><A NAME="4093"></A>

<P>

<H1><A NAME="SECTION041330000000000000000">
<SPAN CLASS="arabic">3</SPAN> 系統安全</A>
</H1>

<P>
<A NAME="4095"></A><A NAME="4096"></A><A NAME="4097"></A>在第 <A HREF="node11_ct.html#Permissions"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A> 頁，第 <A HREF="node11_ct.html#Permissions">7.1</A> 節，我們講過Linux 上的文件許可模式 (file permissions)。這是保証你的系統安全的基礎。如果設立一個多用戶系統或者一個服侍器，則文件許可模式的正確設定是非常重要的。一個好的慣例是，只給文件它們所需要的最小許可。

<P>
如果你跑的是一個網絡服務器，你還要其他的一些事情。第一，你應該把所有你不需要提供的網絡服務都關掉。最好從文件 <TT>/etc/inetd.conf</TT> 開始，你可能需要裡面的一些服務。對於很多網絡服務，你還可以控制誰有權使用它們，文件 <TT>/etc/hosts.allow</TT> 和 <TT>/etc/hosts.deny</TT>（它們的手冊在<TT>man&nbsp;5&nbsp;hosts_access</TT> 裡）是專門控制服務使用權的。你還應該保証有最新的補丁和 Debian 更新，你可以從離你最近的 Debian FTP 鏡像處取得。

<P>
其他的一些常識性的規則也是有用的：

<P>

<UL>
<LI>永遠不要告訴別人你的密碼。
</LI>
<LI>永遠不要通過互聯網以簡單文本輸入你的密碼，像使用 telnet 或者 FTP 的時候。你應該在這些程序上層使用一些加密協定或者避免遠程登錄。
</LI>
<LI>盡可能的避免使用 root 用戶登錄。
</LI>
<LI>不要安裝不可信的軟件，非裝不可的時候，絕對不要以 root 身份安裝。
</LI>
<LI>避免把文件設定成誰的可以寫的模式。<TT>/tmp</TT> 在這裡是個例外，它必須是都可寫可讀的。
</LI>
</UL>
雖然這些對於一個不需要維護服侍器的人來說好像沒有意義，其實了解一些系統安全是很有用的。你系統免被病毒侵入是靠 Debian 的系統安全機制達到的。

<P>

<H1><A NAME="SECTION041340000000000000000">
<SPAN CLASS="arabic">4</SPAN> Debian 上的軟件開發</A>
</H1>

<P>
<A NAME="4108"></A><A NAME="4109"></A><A NAME="4110"></A><A NAME="4111"></A>Debian 是一個非常好的軟件開發，編程平台。它支持的編程語言或類語言有：C, C++, Objective-C, Perl, Python, m4, Ada, Pascal, Java, awk, Tcl/Tk,
SQL, assembler, Bourne Shell, csh 等等。如何編程的東西超出了本書的範圍，但在這裡，我們列出一些 Debian 裡常用的開發程序：

<P>
<DL>
<DT><STRONG>gcc</STRONG></DT>
<DD>GNU C 編譯器，一個現代的優化的 C 語言編譯器。
</DD>
<DT><STRONG>g++</STRONG></DT>
<DD>gcc 系列中的 C++ 編譯器。
</DD>
<DT><STRONG>cpp</STRONG></DT>
<DD>gcc 中的 C 前處理器 (preprocessor)。
</DD>
<DT><STRONG>perl</STRONG></DT>
<DD>Perl 解釋器。Perl 是一個優秀的“粘合”語言。
</DD>
<DT><STRONG>gdb</STRONG></DT>
<DD>GNU Debugger（除錯程序），用來對多種語言進行除錯的工具。
</DD>
<DT><STRONG>gprof</STRONG></DT>
<DD>對程序進行模型，可以幫助你提高你寫的程序的表現。它會告訴你你的程序在各階段的表現，你可以再有針對性的加以改進。
</DD>
<DT><STRONG>emacs</STRONG></DT>
<DD>GNU Emacs 是一個程序員的編輯器和集成開發環境。
</DD>
<DT><STRONG>as</STRONG></DT>
<DD>GNU Assembler（組合語言編譯器）。
</DD>
</DL>
<A NAME="4114"></A><A NAME="4115"></A><A NAME="4116"></A><A NAME="4117"></A>

<P>

<P>

<HR>
<ADDRESS>
John Goerzen / Ossama Othman / Debian 中文計劃
</ADDRESS>
</BODY>
</HTML>

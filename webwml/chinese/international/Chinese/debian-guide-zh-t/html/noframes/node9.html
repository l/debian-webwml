
<!--Converted with LaTeX2HTML 99.2beta6 (1.42)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>5 The Basics</TITLE>
<META NAME="description" CONTENT="5 The Basics">
<META NAME="keywords" CONTENT="debian-tutorial-zh_TW-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=big5">
<META NAME="Generator" CONTENT="LaTeX2HTML v99.2beta6">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="debian-tutorial-zh_TW-html.css">

<LINK REL="next" HREF="node10.html">
<LINK REL="previous" HREF="node8.html">
<LINK REL="up" HREF="node4.html">
<LINK REL="next" HREF="node10.html">
</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<A NAME="tex2html713"
  HREF="node10.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html707"
  HREF="node4.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html701"
  HREF="node8.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html709"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html711"
  HREF="node23.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html714"
  HREF="node10.html">6 Using the Shell</A>
<B> Up:</B> <A NAME="tex2html708"
  HREF="node4.html">1 導論</A>
<B> Previous:</B> <A NAME="tex2html702"
  HREF="node8.html">4 Logging In</A>
 &nbsp <B>  <A NAME="tex2html710"
  HREF="node1.html">Contents</A></B> 
 &nbsp <B>  <A NAME="tex2html712"
  HREF="node23.html">Index</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html715"
  HREF="node9.html#SECTION04510000000000000000"><SPAN CLASS="arabic">1</SPAN> The Command Line and Man Pages</A>
<UL>
<LI><A NAME="tex2html716"
  HREF="node9.html#SECTION04511000000000000000"><SPAN CLASS="arabic">1</SPAN> Describing the Command Line </A>
</UL>
<LI><A NAME="tex2html717"
  HREF="node9.html#SECTION04520000000000000000"><SPAN CLASS="arabic">2</SPAN> Files and Directories</A>
<UL>
<LI><A NAME="tex2html718"
  HREF="node9.html#SECTION04521000000000000000"><SPAN CLASS="arabic">1</SPAN> Using Files: A Tutorial </A>
<LI><A NAME="tex2html719"
  HREF="node9.html#SECTION04522000000000000000"><SPAN CLASS="arabic">2</SPAN> Dot Files and <TT>ls&nbsp;-a</TT></A>
</UL>
<LI><A NAME="tex2html720"
  HREF="node9.html#SECTION04530000000000000000"><SPAN CLASS="arabic">3</SPAN> Processes</A>
<LI><A NAME="tex2html721"
  HREF="node9.html#SECTION04540000000000000000"><SPAN CLASS="arabic">4</SPAN> The Shell</A>
<LI><A NAME="tex2html722"
  HREF="node9.html#SECTION04550000000000000000"><SPAN CLASS="arabic">5</SPAN> Managing Processes with <TT>bash</TT></A>
<LI><A NAME="tex2html723"
  HREF="node9.html#SECTION04560000000000000000"><SPAN CLASS="arabic">6</SPAN> A Few <TT>bash</TT> Features </A>
<UL>
<LI><A NAME="tex2html724"
  HREF="node9.html#SECTION04561000000000000000"><SPAN CLASS="arabic">1</SPAN> Tab Completion </A>
</UL>
<LI><A NAME="tex2html725"
  HREF="node9.html#SECTION04570000000000000000"><SPAN CLASS="arabic">7</SPAN> Managing Your Identity </A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION04500000000000000000">
<SPAN CLASS="arabic">5</SPAN> The Basics</A>
</H1>

<P>
It's now time to explore the system in more detail. You've seen how to log in
and shut down the system. In this chapter, we explore the Linux comand line,
how Linux deals with files and directories, and some basics on identifying yourself
to others.

<P>

<H1><A NAME="SECTION04510000000000000000"></A><A NAME="1491"></A><A NAME="man_pages"></A>
<BR>
<SPAN CLASS="arabic">1</SPAN> The Command Line and Man Pages
</H1>

<P>
We've already discussed the <SPAN  CLASS="textit"><SPAN  CLASS="textit">command line</SPAN></SPAN> - that is, commands
you type after the shell prompt. This section describes the structure of more
complicated command lines. <A NAME="1494"></A>

<P>
<A NAME="1495"></A><A NAME="1496"></A><A NAME="1497"></A><A NAME="1498"></A><A NAME="1499"></A><A NAME="1500"></A><A NAME="1501"></A>A minimal command line contains just a command name, such as <TT>whoami</TT>.
But other things are possible. For example, you might type: <TT>man&nbsp;whoami</TT>.
This command requests the online manual for the <TT>whoami</TT> program (you
may have to press the space bar to scroll through the documentation or press
<TT>q</TT> to quit). A more complicated example is <TT>man&nbsp;-k&nbsp;PostScript</TT>.
This command line has three parts. It begins with the command name, <TT>man</TT>.
Then it has an <SPAN  CLASS="textit">option</SPAN> or <SPAN  CLASS="textit">switch</SPAN>, <TT>-k</TT>, followed by
an <SPAN  CLASS="textit">argument</SPAN>, <TT>PostScript</TT>. Some people refer to everything except
the command name as the <SPAN  CLASS="textit">parameters</SPAN> of the command. So, options and
arguments are both parameters. 

<P>
Options change the behavior of a command, switching on particular features or
functionality. They usually have a <TT>-</TT> before them. The <A NAME="1515"></A><A NAME="1516"></A>GNU utilities
also have ``long forms'' for the options; the long form of <TT>-k</TT> is
<TT>-apropos</TT>. You can enter <TT>man&nbsp;-h</TT> or <TT>man&nbsp;-help</TT>
to get a full list of options for the <TT>man</TT> command. Every command will
have its own set of options, though most have <TT>-help</TT> and <TT>-version</TT>
options. Some commands, such as <TT>tar</TT>, do not require the ``<TT>-</TT>''
before their options for historical reasons. 

<P>
Anything that isn't an option and isn't the command name is an <SPAN  CLASS="textit">argument</SPAN>
(in this case, <TT>PostScript</TT>). Arguments can serve many purposes; most
commonly, they are filenames that the command should operate on. In this case,
<TT>PostScript</TT> is the word you want <TT>man</TT> to search for. In the
case of <TT>man&nbsp;whoami</TT>, the argument was the command you wanted information
about. 

<P>
Here's a breakdown of the <TT>man&nbsp;-k&nbsp;PostScript</TT> command line: 

<P>
<DL>
<DT><STRONG><TT>man</TT>.</STRONG></DT>
<DD>The command name, tells the computer to look at the manual pages.
These provide documentation for commands. For example, <TT>man&nbsp;whoami</TT> will
give you documentation on the <TT>whoami</TT> command. 
</DD>
<DT><STRONG><TT>-k</TT>.</STRONG></DT>
<DD>The option, changes the behavior of <TT>man</TT>. Normally <TT>man</TT>
expects a command name, such as <TT>whoami</TT>, for an argument and looks for
documentation of that command. But with the <TT>-k</TT> or <TT>-apropos</TT>
option, it expects the argument to be a keyword. It then gives a list of all
manual pages with that keyword in their description. 
</DD>
<DT><STRONG><TT>PostScript</TT>.</STRONG></DT>
<DD>is the argument; because we used the <TT>-k</TT> option,
it's the keyword to search for. 
</DD>
</DL>
<TT>-k</TT> and <TT>PostScript</TT> are both parameters. 

<P>
Go ahead and type <TT>man&nbsp;-k&nbsp;PostScript</TT>, and you will see a list of all
the manual pages on your system that have something to do with PostScript. If
you haven't installed much software, you might see the message <TT>PostScript:&nbsp;nothing
appropriate</TT> instead.

<P>

<H2><A NAME="SECTION04511000000000000000">
<SPAN CLASS="arabic">1</SPAN> Describing the Command Line </A>
</H2>

<P>
<A NAME="1550"></A><A NAME="1551"></A><A NAME="1552"></A>Note: You can skip this section if you want to move on. 

<P>
There's a traditional, concise way of describing command <SPAN  CLASS="textit">syntax. Syntax</SPAN>
means the correct ways to combine various options and arguments. For example,
if you type <TT>man&nbsp;man</TT> to get the manual page about <TT>man</TT>, you'll
see several syntax descriptions beginning with the command name <TT>man</TT>.
One of them will look like this: <TT>man&nbsp;-k&nbsp;[-M&nbsp;path]&nbsp;keyword&nbsp;...</TT> 

<P>
Anything in brackets (<TT>[]</TT>) is an optional unit. In this case you
don't have to use the <TT>-M</TT> option, but if you do, you must use a <TT>path</TT>
argument. You must use the <TT>-k</TT> option and the <TT>keyword</TT> argument.
The <TT>...</TT> means that you could have more of whatever came before it,
so you could look up several keywords. 

<P>
Let's look at one of the more complex descriptions from the <TT>man</TT> manual
page: 

<P>

<DL COMPACT>
<DT>
<DD><SPAN  CLASS="textbf">man</SPAN>&nbsp;[<SPAN  CLASS="textbf">-c</SPAN>|<SPAN  CLASS="textbf">-w</SPAN>|<SPAN  CLASS="textbf">-tZT</SPAN>&nbsp;device]&nbsp;[<SPAN  CLASS="textbf">-adhu7V</SPAN>]

<P>
[<SPAN  CLASS="textbf">-m</SPAN>&nbsp;system[,...]]&nbsp;[<SPAN  CLASS="textbf">-L</SPAN>&nbsp;locale]&nbsp;[<SPAN  CLASS="textbf">-p</SPAN>&nbsp;string]

<P>
[<SPAN  CLASS="textbf">-M</SPAN>&nbsp;path]&nbsp;[<SPAN  CLASS="textbf">-P</SPAN>&nbsp;pager]&nbsp;[<SPAN  CLASS="textbf">-r</SPAN>&nbsp;prompt]&nbsp;[<SPAN  CLASS="textbf">-S</SPAN>&nbsp;list]

<P>
[<SPAN  CLASS="textbf">-e</SPAN>&nbsp;extension]&nbsp;[[section]&nbsp;page&nbsp;...]&nbsp;...
</DD>
</DL>There's no need to go through all of this (and don't worry about what it all
means), but do pay attention to the organization of the description. 

<P>
First, clusters of options usually mean you can use one or more of them in different
combinations, so <TT>-adhu7V</TT> means you can also use <TT>-h</TT>. However,
you can't always use all combinations; this description doesn't make that clear.
For example, <TT>-h</TT> is incompatible with other options, but you could do
<TT>man&nbsp;-du</TT>. Unfortunately, the description's format does not make this
clear. <A NAME="1612"></A><A NAME="1613"></A><A NAME="1614"></A>

<P>
Second, the | symbol means ``or.'' So you can use the <TT>-c</TT>,
the <TT>-w</TT>, <SPAN  CLASS="textit">or</SPAN> the <TT>-tZT</TT> option, followed by a <TT>device</TT>
argument. 

<P>
Third, notice that you can nest the brackets, because they indicate optional
<SPAN  CLASS="textit">unit</SPAN>s. So if you have a <TT>section</TT>, you must also have a <TT>page</TT>,
because e <TT>page</TT> is not optional within the <TT>[[section]
page]</TT> unit. 

<P>
There's no need to memorize any of this, just refer to this section as you read
documentation. 

<P>

<H1><A NAME="SECTION04520000000000000000"></A><A NAME="basics-files"></A><A NAME="1629"></A><A NAME="1630"></A>
<BR>
<SPAN CLASS="arabic">2</SPAN> Files and Directories
</H1>

<P>
<A NAME="1631"></A><A NAME="1632"></A><A NAME="1633"></A><A NAME="1634"></A><A NAME="1635"></A><SPAN  CLASS="textit">Files</SPAN> are a facility for storing and organizing information, analogous
to paper documents. They're organized into <SPAN  CLASS="textit">directories</SPAN>, which are called
<SPAN  CLASS="textit">folders</SPAN> on some other systems. Let's look at the organization of files
on a Debian system: 

<P>
<DL>
<DT><STRONG><TT>/.</TT></STRONG></DT>
<DD>A simple <TT>/</TT> represents the root directory. All other files
and directories are contained in the root directory. If you are coming from
the DOS/Windows world, <TT>/</TT> is very similar to what <TT>C:</TT>is for
DOS, that is the root of the filesystem. A notable difference between DOS and
Linux however, is that DOS keeps several filesystems: <TT>C:</TT> (first hard
disk), <TT>A:</TT> (first floppy disk), and <TT>D:</TT> (either CD-ROM or second
hard disk), whereas Linux has all its files organized above the same <TT>/</TT>
root.
</DD>
<DT><STRONG><TT>/home/janeq.</TT></STRONG></DT>
<DD>This is the home directory of user ``janeq.'' Reading
left to right, to get to this directory you start in the root directory, enter
directory <TT>home</TT>, and then enter directory <TT>janeq</TT>. 
</DD>
<DT><STRONG><TT>/etc/X11/XF86Config.</TT></STRONG></DT>
<DD>This is the configuration file for the X Window
system. It resides in the <TT>X11</TT> subdirectory of the <TT>/etc</TT> directory.
<TT>/etc</TT> is in turn a subdirectory of the root directory, <TT>/</TT>. 
</DD>
</DL>
Things to note: 

<P>

<UL>
<LI>Filenames are case-sensitive. That is, <TT>MYFILE</TT> and <TT>MyFile</TT> are
<SPAN  CLASS="textit">different</SPAN> files. 
</LI>
<LI>The root directory is referred to as simply <TT>/</TT>. Don't confuse this ``root''<A NAME="1662"></A><A NAME="1663"></A><A NAME="1664"></A><A NAME="1665"></A><A NAME="1666"></A>
with the root user, the user on your system with ``super powers.'' 
</LI>
<LI>Every directory has a name, which can contain any letters or symbols <SPAN  CLASS="textit">except</SPAN>
<TT>/</TT>. The root directory is an exception; its name is <TT>/</TT> (pronounced
``slash'' or ``the root directory''), and it cannot be renamed. 
</LI>
<LI>While you <SPAN  CLASS="textit">can</SPAN> use almost any letters or symbols in a filename, in practice
it's a bad idea. It is better to avoid characters that often have special meanings
on the command line, including: <TT>{ } ( ) [ ] ' `
&#34; &#92;/
&gt; &lt; | ; ! # &amp; ^ * %</TT>
</LI>
<LI>Also avoid putting spaces in filenames. If you want to separate words in a name,
good choices are the period, hyphen, and underscore. You could also capitalize
each word, <TT>LikeThis</TT>. 
</LI>
<LI>Each file or directory is designated by a <SPAN  CLASS="textit">fully-qualified filename</SPAN>,<A NAME="1679"></A><A NAME="1680"></A>
<SPAN  CLASS="textit">absolute filename</SPAN>, or <SPAN  CLASS="textit">path</SPAN>, giving the sequence of directories
which must be passed through to reach it. The three terms are synonymous. All
absolute filenames begin with the <TT>/</TT> directory, and there's a <TT>/</TT>
before each directory or file in the filename. The first <TT>/</TT> is the name
of a directory, but the others are simply separators to distinguish the parts
of the filename. 
</LI>
<LI>The words used here can be confusing. Take the following example: <A NAME="1686"></A><A NAME="1687"></A><TT>/usr/share/keytables/us.map.gz</TT>.
This is a fully-qualified filename; some people call it a <SPAN  CLASS="textit">path</SPAN>. However,
people will also refer to <TT>us.map.gz</TT> alone as a filename. 
</LI>
<LI>There is also another use for the word ``path.'' The intended meaning is usually
clear from the context. 
</LI>
<LI>Directories are arranged in a tree structure. All absolute filenames start with
the root directory. The root directory has a number of branches, such as <TT>/etc</TT>
and <TT>/usr</TT>. These subdirectories in turn branch into still more subdirectories,
such as <TT>/etc/init.d</TT> and <TT>/usr/local</TT>. The whole thing together
is called the ``directory tree.'' 
</LI>
<LI>You can think of an absolute filename as a route from the base of the tree (<TT>/</TT>)
to the end of some branch (a file). You'll also hear people talk about the directory
tree as if it were a <SPAN  CLASS="textit">family</SPAN> tree: Thus subdirectories have ``parent,''
and a path shows the complete ancestry of a file. 
</LI>
<LI>There are also relative paths that begin somewhere other than the root directory.
More on this later. 
</LI>
<LI>No directory corresponds to a physical device, such as your hard disk. This
differs from DOS and Windows, in which all paths begin with a device name such
as <TT>C:&#92;</TT>. <A NAME="1698"></A><A NAME="1699"></A><A NAME="1700"></A>The directory tree is meant to be an abstraction
of the physical hardware, so you can use the system without knowing what the
hardware is. All your files could be on one disk - or you could have 20 disks,
some of them connected to a different computer elsewhere on the network. You
can't tell just by looking at the directory tree, and nearly all commands work
just the same way no matter what physical device(s) your files are really on. 
</LI>
</UL>
Don't worry if all this isn't completely clear yet. There are many examples
to come. 

<P>

<H2><A NAME="SECTION04521000000000000000">
<SPAN CLASS="arabic">1</SPAN> Using Files: A Tutorial </A>
</H2>

<P>
To use your system, you'll have to know how to create, move, rename, and delete
files and directories. This section describes how to do so with the standard
Debian commands. 

<P>
The best way to learn is to try things. As long as you aren't root (and haven't
yet created any important personal files), you cannot mess up too seriously.
Jump in - type each of these commands at the prompt and press <TT>Enter</TT>. 

<P>

<DL COMPACT>
<DT>
<DD>pwd<A NAME="1705"></A>
</DD>
</DL>One directory is always considered the <SPAN  CLASS="textit">current working directory<A NAME="1707"></A></SPAN>
<A NAME="1708"></A><A NAME="1709"></A><A NAME="1710"></A><A NAME="1711"></A><A NAME="1712"></A>for the shell you're using. You can view this directory with the <TT>pwd</TT>
command, which stands for Print Working Directory. <TT>pwd</TT> prints the name
of the directory you're working in - probably <TT>/home/yourname</TT>. 

<P>

<DL COMPACT>
<DT>
<DD>ls<A NAME="1717"></A>
</DD>
</DL><TT>ls</TT> stands for ``list,'' as in ``list files.'' When you type <TT>ls</TT>,
the system displays a list of all the files in your current working directory.
If you've just installed Debian, your home directory may well be empty. If your
working directory is empty, <TT>ls</TT> produces no output, because there are
no files to list. <A NAME="1722"></A><A NAME="1723"></A>

<P>

<DL COMPACT>
<DT>
<DD>cd&nbsp;/<A NAME="1725"></A>
</DD>
</DL><A NAME="1727"></A><A NAME="1728"></A>
<TT>cd</TT> means ``change directory<A NAME="4532"></A>.'' In
this case, you've asked to change to the root directory. 

<P>

<DL COMPACT>
<DT>
<DD>pwd
</DD>
</DL><A NAME="1733"></A>
This verifies that you're working in the root directory. 

<P>

<DL COMPACT>
<DT>
<DD>ls
</DD>
</DL>Lets you see what's in <TT>/</TT>. 

<P>

<DL COMPACT>
<DT>
<DD><A NAME="1738"></A><A NAME="1739"></A><A NAME="1740"></A><A NAME="1741"></A>
cd
</DD>
</DL>Typing <TT>cd</TT> with no arguments selects your home directory -
<TT>/home/ yourname</TT>
- as the current working directory. Try <TT>pwd</TT> to verify this. 

<P>
<A NAME="1746"></A><A NAME="1747"></A><A NAME="1748"></A>Before continuing, you should know that there are actually two different kinds
of filenames. Some of them begin with <TT>/</TT>, the root directory, such as
<TT>/etc/profile</TT>. These are called <SPAN  CLASS="textit">absolute</SPAN> filenames because
they refer to the same file no matter what your current directory is. The other
kind of filename is <SPAN  CLASS="textit">relative</SPAN>. 

<P>
Two directory names are used <SPAN  CLASS="textit">only</SPAN> in relative filenames: <TT>.</TT>
and <TT>..</TT>. The directory <TT>.</TT> refers to the current directory, and
<TT>..</TT> is the parent directory. These are ``shortcut'' directories. They
exist in <SPAN  CLASS="textit">every</SPAN> directory. Even the root directory has a parent directory<A NAME="1759"></A><A NAME="1760"></A>
- it's its own parent! 

<P>
So filenames that include <TT>.</TT> or <TT>..</TT> are <SPAN  CLASS="textit">relative</SPAN>, because
their meaning depends on the current directory. If I'm in <TT>/usr/bin</TT>
and type <TT>../etc</TT>, I'm referring to <TT>/usr/etc</TT>. If I'm in <TT>/var</TT>
and type <TT>../etc</TT>, I'm referring to <TT>/etc</TT>. Note that a filename
without the root directory at the front implicitly has <TT>./</TT> at the front.
So you can type <TT>local/bin</TT>, or <TT>./local/bin</TT> and it means the
same thing. 

<P>
A final handy tip: The <A NAME="1773"></A><A NAME="1774"></A>tilde <TT>~</TT> is equivalent to your home directory.
So typing <TT>cd&nbsp;~</TT> is the same as typing <TT>cd</TT> with no arguments.
Also, you can type things like <TT>cd&nbsp;~/practice/mysubdirectory</TT> to change
to the directory <TT>/home/yourname/practice/mysubdirectory</TT>. In a similar
way, <TT>~myuser</TT> is equivalent to the home directory of the user ``myuser,''
which is probably something like <TT>/home/myuser</TT>; so
<TT>~myuser/docs/debian.ps</TT>
is equivalent to <TT>/home/myuser/doc/debian.ps</TT>. 

<P>
Here are some more file commands to try out, now that you know about relative
filenames. <TT>cd</TT> to your home directory before you begin. 

<P>

<DL COMPACT>
<DT>
<DD>mkdir&nbsp;practice
</DD>
</DL>In your home directory, make a directory called <TT>practice</TT>. You'll use
this directory to try out some other commands. You might type <TT>ls</TT> to
verify that your new directory exists. 

<P>

<DL COMPACT>
<DT>
<DD>cd&nbsp;practice
</DD>
</DL>Changes the directory to <TT>practice</TT>.

<P>

<DL COMPACT>
<DT>
<DD>mkdir&nbsp;mysubdirectory<A NAME="1793"></A><A NAME="1794"></A><A NAME="1795"></A><A NAME="1796"></A>
</DD>
</DL>Creates a subdirectory of <TT>practice</TT>.

<P>

<DL COMPACT>
<DT>
<DD>cp&nbsp;/etc/profile&nbsp;.
</DD>
</DL><TT>cp</TT> is short for ``copy.'' <TT>/etc/profile</TT> is just a random
file on your system, don't worry about what it is for now. We've copied it to
<TT>.</TT> (recall that <TT>.</TT> just means ``the directory I'm in now,''
or the current working directory). So this creates a copy of <TT>/etc/profile</TT>
and puts it in your <TT>practice</TT> directory. Try typing <TT>ls</TT> to verify
that there's indeed a file called <TT>profile</TT> in your working directory,
alongside the new <TT>mysubdirectory</TT>. 

<P>

<DL COMPACT>
<DT>
<DD>more&nbsp;profile<A NAME="1811"></A><A NAME="1812"></A><A NAME="1813"></A>
</DD>
</DL>This lets you view the contents of the file <TT>profile</TT>. <TT>more</TT>
is used to view the contents of text files. It's called <TT>more</TT> because
it shows one screenful of the file at a time, and you press the space bar to
see more. <TT>more</TT> will exit when you get to the end of the file, or when
you press <TT>q</TT> (quit). 

<P>

<DL COMPACT>
<DT>
<DD>more&nbsp;/etc/profile
</DD>
</DL>Verifies that the original looks just like the copy you made. 

<P>

<DL COMPACT>
<DT>
<DD>mv&nbsp;profile&nbsp;mysubdirectory
</DD>
</DL><TT>mv</TT> stands for ``move.'' You've moved the file <TT>profile</TT> from
the current directory into the subdirectory you created earlier. 

<P>

<DL COMPACT>
<DT>
<DD>ls
</DD>
</DL>Verifies that <TT>profile</TT> is no longer in the current directory. 

<P>

<DL COMPACT>
<DT>
<DD>ls&nbsp;mysubdirectory
</DD>
</DL>Verifies that <TT>profile</TT> has moved to <TT>mysubdirectory</TT>. 

<P>

<DL COMPACT>
<DT>
<DD>cd&nbsp;mysubdirectory
</DD>
</DL>Changes to the subdirectory. 

<P>

<DL COMPACT>
<DT>
<DD><A NAME="1836"></A><A NAME="1837"></A><A NAME="1838"></A>
mv&nbsp;profile&nbsp;myprofile
</DD>
</DL>Note that unlike some operating systems, there is no difference between moving
a file and renaming it. Thus there's no separate <TT>rename</TT> command. Note
that the second argument to <TT>mv</TT> can be a directory to move the file
or directory into, or it can be a new filename. <TT>cp</TT> works the same way. 

<P>
As usual, you can type <TT>ls</TT> to see the result of <TT>mv</TT>. 

<P>

<DL COMPACT>
<DT>
<DD>mv&nbsp;myprofile&nbsp;..
</DD>
</DL>Just as <TT>.</TT> means ``the directory I'm in now,'' <TT>..</TT> means ``parent
of the current directory,'' in this case the <TT>practice</TT> directory you
created earlier. Use <TT>ls</TT> to verify that that's where <TT>myprofile</TT>
is now. 

<P>

<DL COMPACT>
<DT>
<DD>cd&nbsp;..
</DD>
</DL>Changes directories to the parent directory - in this case <TT>practice</TT>,
where you just put <TT>myprofile</TT>. 

<P>

<DL COMPACT>
<DT>
<DD>rm&nbsp;myprofile<A NAME="1857"></A><A NAME="1858"></A>
</DD>
</DL><TT>rm<A NAME="1860"></A><A NAME="4538"></A></TT> means ``remove,''
so this deletes <TT>myprofile</TT>.<A NAME="1863"></A><A NAME="1864"></A> Be careful! Deleting a file on a GNU/Linux
system is <SPAN  CLASS="textit">permanent</SPAN> - there is no undelete. If you <TT>rm</TT> it,
it's <SPAN  CLASS="textit">gone</SPAN>, <SPAN  CLASS="textit">forever</SPAN>. Be careful! To repeat, deleting a file
on a GNU/Linux system is <SPAN  CLASS="textit">permanent</SPAN> - there is no undelete. If you
<TT>rm</TT> it, it's <SPAN  CLASS="textit">gone</SPAN>, <SPAN  CLASS="textit">forever</SPAN>. 

<P>

<DL COMPACT>
<DT>
<DD>rmdir&nbsp;mysubdirectory<A NAME="1874"></A>
</DD>
</DL><TT>rmdir</TT> is just like <TT>rm</TT>, only it's for directories. Notice that
<TT>rmdir</TT> only works on empty directories. If the directory contains files,
you must delete those files first, or alternatively you can use <TT>rm&nbsp;-r</TT>
in place of <TT>rmdir</TT>. 

<P>

<DL COMPACT>
<DT>
<DD>cd&nbsp;..
</DD>
</DL>This moves out of the current directory, and into its parent directory. Now
you can type the following: 

<P>

<DL COMPACT>
<DT>
<DD>rmdir&nbsp;practice
</DD>
</DL>This will delete the last remnants of your practice session. 

<P>
So now you know how to create, copy, move, rename, and delete files and directories.
You also learned some shortcuts, like typing simply <TT>cd</TT> to jump to your
home directory, and how <TT>.</TT> and <TT>..</TT> refer to the current directory
and its parent, respectively. You should also remember the concept of the <SPAN  CLASS="textit">root
directory</SPAN>, or <TT>/</TT>, and the alias <TT>~</TT> for your home directory. 

<P>

<H2><A NAME="SECTION04522000000000000000"></A><A NAME="1891"></A><A NAME="1892"></A>
<BR>
<SPAN CLASS="arabic">2</SPAN> Dot Files and <TT>ls&nbsp;-a</TT>
</H2>

<P>
<A NAME="1893"></A><A NAME="1894"></A><A NAME="1895"></A><A NAME="1896"></A>When you type <TT>ls</TT>, files beginning with a dot are not listed. Traditionally,
files that contain configuration information, user preferences, and so on begin
with a dot; these are hidden and out of your way while you do your day-to-day
work. Sample dot files are <TT>~/.emacs</TT>, <TT>~/.newsrc</TT>, <TT>~/.bashrc</TT>,
<TT>~/.xsession</TT>, and <TT>~/.fvwmrc</TT>. These are used by Emacs,
news readers, the Bash shell, the X Window System, and the fvwm window manager,
respectively. It is conventional to end the dot filename with <TT>rc</TT>, but
some programs don't. There are also directories beginning with a dot, such as
<TT>~/.gimp</TT> and <TT>~/.netscape</TT>, which store preferences for
the Gimp and Netscape.

<P>
Sometimes a program will create a dot file automatically; for example, Netscape
allows you to edit your preferences with a graphical dialog box and then it
saves your choices. Other times you will create them yourself using a text editor;
this is the traditional way to do it, but you have to learn the peculiar format
of each file - inconvenient at first, but it can give you a lot of power.

<P>
To see dot files, you must use the <TT>-a</TT> option to <TT>ls</TT>. The long
form of <TT>-a</TT> is <TT>-all</TT>, if you find that easier to remember.
You can also use <TT>-A</TT> or <TT>-almost-all</TT>, which displays all
dot files except <TT>.</TT> and <TT>..</TT>. Remember that <TT>.</TT> is the
current directory, and <TT>..</TT> is the parent of the current directory; because
these are guaranteed to be in every directory, there is no real reason to list
them with <TT>ls</TT>. You already know they are there.

<P>

<H1><A NAME="SECTION04530000000000000000"></A><A NAME="1917"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN> Processes
</H1>

<P>
<A NAME="1918"></A><A NAME="1919"></A><A NAME="1920"></A>We mentioned before that GNU/Linux is a <SPAN  CLASS="textit">multitasking</SPAN> system. It can
do many tasks at once. Each of these tasks is called a <SPAN  CLASS="textit">process</SPAN>. The
best way to get a sense of this is to type <TT>top</TT> at the shell prompt.
You'll get a list of processes, sorted according to how much of the computer's
processing time they're using. The order will continuously change before your
eyes. At the top of the display, there's some information about the system:
how many users are logged in, how many total processes there are, how much memory
you have and how much you're using. 

<P>
In the far left column, you'll see the user owning each process. The far right
column shows which command invoked the process. You'll probably notice that
<TT>top</TT> itself, invoked by you, is near the top of the list (because anytime
<TT>top</TT> checks on CPU usage, it will be active and using CPU to do the
check). 

<P>
Note that in all the commands ending in&nbsp;``<TT>d</TT>'' - such as
<TT>kflushd</TT> and <TT>inetd</TT> - the ``<TT>d</TT>''&nbsp;stands
for <SPAN  CLASS="textit">daemon.</SPAN>

<P>
<A NAME="1933"></A><A NAME="1934"></A><A NAME="1935"></A>Daemon originally meant Disks And Extensions MONitor. A daemon is a non-interactive
process, that is, it's run by the system and users never have to worry about
it. Daemons provide services like Internet connectivity, printing, or e-mail. 

<P>
Now press <TT>u</TT> and give <TT>top</TT> your username when it asks. The <TT>u</TT>
command asks to see only those processes belonging to you; it allows you to
ignore all the daemons and whatever other people are doing. You might notice
<TT>bash</TT>, the name of your shell. You'll pretty much always be running
<TT>bash</TT>. 

<P>
<A NAME="1941"></A><A NAME="1942"></A><A NAME="1943"></A><A NAME="1944"></A><A NAME="1945"></A>Note that column two of the <TT>top</TT> display shows you the <SPAN  CLASS="textit">PID</SPAN><A NAME="1948"></A>,
or Process IDentification number. Each process is assigned a unique PID. You
can use the PID to control individual processes (more on that later). Another
useful trick is to press <TT>?</TT> to get a list of <TT>top</TT> commands. 

<P>
You may wonder about the difference between a ``process'' and a ``program.''
In practice, people use the terms interchangeably. Technically, the <SPAN  CLASS="textit">program</SPAN>
is the set of instructions written by a programmer and kept on disk. The <SPAN  CLASS="textit">process</SPAN>
is the working instantiation of the program kept in memory by Linux. But it's
not that important to keep the terms straight.

<P>
Much of your interaction with a computer involves controlling processes. You'll
want to start them, stop them, and see what they're up to. Your primary tool
for this is the <SPAN  CLASS="textit">shell</SPAN>.

<P>

<H1><A NAME="SECTION04540000000000000000"></A><A NAME="1954"></A>
<BR>
<SPAN CLASS="arabic">4</SPAN> The Shell
</H1>

<P>
<A NAME="1955"></A><A NAME="1956"></A><A NAME="1957"></A><A NAME="1958"></A><A NAME="1959"></A>The <SPAN  CLASS="textit">shell</SPAN> is a program that allows you to interact with your computer.
It's called a shell because it provides an environment for you to work in -
sort of a little electronic home for you as you compute. (Think hermit crab.) 

<P>
The simplest function of the shell is to launch other programs. You type the
name of the program you want to run, followed by the arguments you want, and
the shell asks the system to run the program for you. 

<P>
Of course, graphical windowing systems also fill this need. Technically, Windows
95 provides a graphical shell, and the X Window System is another kind of graphical
shell. But ``shell'' is commonly used to mean ``command-line shell.''

<P>
<A NAME="1961"></A><A NAME="1962"></A><A NAME="1963"></A><A NAME="1964"></A><A NAME="1965"></A><A NAME="1966"></A><A NAME="1967"></A><A NAME="1968"></A><A NAME="1969"></A><A NAME="1970"></A><A NAME="1971"></A>Needless to say, the hackers who work on shells aren't satisfied with simply
launching commands. Your shell has a bewildering number of convenient
and powerful features
if you would like to take advantage of them. 

<P>
There are countless different shells available; most are based on either the
<SPAN  CLASS="textit">Bourne shell</SPAN> or the <SPAN  CLASS="textit">C shell</SPAN>, two of the oldest shells. The
original Bourne shell's program name is <TT>sh</TT>, while <TT>csh</TT> is the
C shell. Bourne shell variants include the Bourne Again Shell from the GNU project
(<TT>bash</TT>, the Debian default), the Korn shell<A NAME="1977"></A> (<TT>ksh</TT>), and the
Z shell (<TT>zsh</TT>). There is also <TT>ash</TT>, a traditional implementation
of the Bourne shell. The most common C shell variant is <TT>tcsh</TT> (the <TT>t</TT>
pays tribute to the TENEX and TOPS-20 operating systems, which inspired some
of <TT>tcsh</TT>'s improvements over <TT>csh</TT>). <A NAME="1985"></A>

<P>
<TT>bash</TT> is probably the best choice for new users. It is the default and
has all the features you're likely to need. But all the shells have loyal followings;
if you want to experiment, install some different shell packages and change
your shell with the chsh command. Just type <TT>chsh</TT>, supply a password
when asked, and choose a shell. When you next log in, you'll be using the new
shell. 

<P>

<H1><A NAME="SECTION04550000000000000000"></A><A NAME="1988"></A>
<BR>
<SPAN CLASS="arabic">5</SPAN> Managing Processes with <TT>bash</TT>
</H1>

<P>
<A NAME="1989"></A><A NAME="1990"></A><A NAME="1991"></A><A NAME="1992"></A><A NAME="1993"></A>Debian is a multitasking system, so you need a way to do more than one thing
at once. Graphical environments like X provide a natural way to do this; they
allow multiple windows on the screen at any one time. Naturally, <TT>bash</TT>
(or any other shell) provides similar facilities. 

<P>
Earlier you used <TT>top</TT> to look at the different processes on the system.
Your shell provides some convenient ways to keep track of only those processes
you've started from the command line. Each command line starts a <SPAN  CLASS="textit">job<A NAME="1996"></A></SPAN>
(also called a <SPAN  CLASS="textit">process group</SPAN>) to be carried out by the shell. A job
can consist of a single process or a set of processes in a <SPAN  CLASS="textit">pipeline<A NAME="1998"></A></SPAN>
(more on pipelines later). 

<P>
Entering a command line will start a job. Try typing <TT>man&nbsp;cp</TT>, and the
<TT>cp</TT> manual page will appear on the screen. The shell will go into the
background and return when you finish reading the manual page (or you can press
<TT>q</TT> to quit rather than scrolling through the whole thing). 

<P>
<A NAME="2002"></A><A NAME="2003"></A><A NAME="2004"></A><A NAME="2005"></A><A NAME="2006"></A>But say you're reading the manual page, and you want to do something else for
a minute. No problem. Press <TT>Ctrl-z</TT> while you're reading to <SPAN  CLASS="textit">suspend</SPAN><A NAME="2009"></A><A NAME="2010"></A><A NAME="2011"></A><A NAME="2012"></A>
the current foreground job and put the shell in the foreground. When you suspend
a job, <TT>bash</TT> will first give you some information on it, followed by
a shell prompt. You will see something like this on the screen: 

<P>

<DL COMPACT>
<DT>
<DD>NAME&nbsp;cp&nbsp;-&nbsp;copy&nbsp;files&nbsp;SYNOPSIS&nbsp;cp&nbsp;[options]&nbsp;source
-More-&nbsp;

<P>
[1]+&nbsp;Stopped&nbsp;man&nbsp;cp

<P>
$
</DD>
</DL>Note the last two lines. The next to last is the job information, and then you
have a shell prompt.<A NAME="2022"></A><A NAME="2023"></A><A NAME="2024"></A><A NAME="2025"></A> 

<P>
<TT>bash</TT> assigns a <SPAN  CLASS="textit">job number</SPAN> to each command line you run from
the shell. This allows you to refer to the process easily. In this case, <TT>man
cp</TT> is job number 1, displayed as <TT>[1]</TT>. The <TT>+</TT> means that
this is the last job you had in the foreground. <TT>bash</TT> also tells you
the current state of the job - <TT>Stopped</TT> - and the job's command line.

<P>
There are many things you can do with jobs. With <TT>man&nbsp;cp</TT> still suspended,
try the following commands:

<P>

<DL COMPACT>
<DT>
<DD>man&nbsp;ls
</DD>
</DL>Starts a new job.<A NAME="2037"></A><A NAME="2038"></A><A NAME="2039"></A>

<P>

<DL COMPACT>
<DT>
<DD><A NAME="2041"></A><A NAME="2042"></A><A NAME="2043"></A>
Ctrl-z
</DD>
</DL>Suspends the <TT>man&nbsp;ls</TT> job; you should see its job information.

<P>

<DL COMPACT>
<DT>
<DD>man&nbsp;mv
</DD>
</DL>Starts yet another job.

<P>

<DL COMPACT>
<DT>
<DD>Ctrl-z
</DD>
</DL>Suspends it.

<P>

<DL COMPACT>
<DT>
<DD>jobs
</DD>
</DL><A NAME="2052"></A><A NAME="2053"></A><A NAME="2054"></A>
Asks <TT>bash</TT> for a display of current jobs. The result looks like this:

<P>

<DL COMPACT>
<DT>
<DD>{$}&nbsp;jobs&nbsp;

<P>
[1]&nbsp;Stopped&nbsp;man&nbsp;cp

<P>
[2]-&nbsp;Stopped&nbsp;man&nbsp;ls

<P>
[3]+&nbsp;Stopped&nbsp;man&nbsp;mv

<P>
{$}
</DD>
</DL>Notice the <TT>-</TT> and <TT>+</TT>, denoting respectively the next to last
and last foreground jobs. 

<P>

<DL COMPACT>
<DT>
<DD>fg
</DD>
</DL>Places the last foreground job (<TT>man&nbsp;mv</TT>, the one with the <TT>+</TT>)
in the foreground again. If you press the space bar, the man page will continue
scrolling.

<P>

<DL COMPACT>
<DT>
<DD>Ctrl-z
</DD>
</DL>Re-suspends <TT>man&nbsp;mv</TT>. 

<P>

<DL COMPACT>
<DT>
<DD>fg&nbsp;%1
</DD>
</DL>You can refer to any job by placing a <TT>%</TT> in front of its number. If
you use <TT>fg</TT> without specifying a job, the last active one is assumed. 

<P>

<DL COMPACT>
<DT>
<DD>Ctrl-z
</DD>
</DL>Re-suspends <TT>man&nbsp;cp</TT>. 

<P>

<DL COMPACT>
<DT>
<DD>kill&nbsp;%1
</DD>
</DL>Kills off job 1. <TT>bash</TT> will report the job information, which will look<A NAME="2083"></A><A NAME="2084"></A><A NAME="2085"></A><A NAME="2086"></A>
like this:

<P>

<DL COMPACT>
<DT>
<DD>$&nbsp;kill&nbsp;%1

<P>
[1]-&nbsp;Terminated&nbsp;man&nbsp;cp

<P>
$&nbsp;
</DD>
</DL><TT>bash</TT> is only asking the job to quit, and sometimes a job will not want
to do so. If the job doesn't terminate, you can add the <TT>-KILL</TT><A NAME="tex2html32"
  HREF="footnode.html#foot4556"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="footnote.png"></SUP></A>&nbsp;option to <TT>kill</TT> to stop asking and start demanding. For example:

<P>

<DL COMPACT>
<DT>
<DD>$&nbsp;kill&nbsp;-KILL&nbsp;%1&nbsp;

<P>
[1]-&nbsp;Killed&nbsp;man&nbsp;mv

<P>
$&nbsp;
</DD>
</DL>The <TT>-KILL</TT> option forcibly and unconditionally kills off the job. 

<P>
In technical terms, <TT>kill</TT> simply sends a signal. By default, it sends
a signal that requests termination (<TT>TERM</TT>, or signal 15) but you can
also specify a signal, and signal 9 (<TT>KILL</TT>) is the signal that forces
termination. The command name <TT>kill</TT> is not necessarily appropriate to
the signal sent; for example, sending the <TT>TSTP</TT> (terminal stop) signal
suspends the process but allows it to be continued later.

<P>

<DL COMPACT>
<DT>
<DD>top
</DD>
</DL>This brings the <TT>top</TT> display back up. Give the <TT>u</TT> command in
<TT>top</TT> to see only your processes. Look in the right-hand column for the
<TT>man&nbsp;ls</TT> and <TT>man&nbsp;mv</TT> commands. <TT>man&nbsp;cp</TT> won't be there
because you killed it. <TT>top</TT> is showing you the system processes corresponding
to your jobs; notice that the PID on the left of the screen does not correspond
to the job number. 

<P>
You may not be able to find your processes because they're off the bottom of
the screen; if you're using X (see Chapter <A HREF="node13.html#X_Window_System">9</A> on page <A HREF="node13.html#X_Window_System"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>),
you can resize the <TT>xterm</TT> to solve this problem. 

<P>
Even these simple jobs actually consist of multiple processes, including the
<TT>man</TT> process and the pager <TT>more</TT>, which handles scrolling one
page at a time. You may notice the <TT>more</TT> processes are also visible
in <TT>top</TT>. 

<P>
You can probably figure out how to clean up the remaining two jobs. You can
either kill them (with the <TT>kill</TT> command) or foreground each one (with
<TT>fg</TT>) and exit it. Remember that the <TT>jobs</TT> command gives you
a list of existing jobs and their status. <A NAME="2126"></A><A NAME="2127"></A><A NAME="2128"></A><A NAME="2129"></A><A NAME="2130"></A><A NAME="2131"></A><A NAME="2132"></A>

<P>
One final note: The documentation for <TT>bash</TT> is quite good, but it is
found in the Info help system<A NAME="2134"></A><A NAME="2135"></A><A NAME="2136"></A><A NAME="2137"></A> rather than the man pages. To read it, type <TT>info
bash</TT>. See section <A HREF="node19.html#docs-info">A.1.1</A> for instructions on using the <TT>info</TT>
program. <TT>bash</TT> also contains a very good summary of its commands accessible
by the <TT>help</TT> command. <TT>help</TT> displays a list of available topics;
more information about each of them is accessible with the command <TT>help
topic&nbsp;name</TT>. Try typing <TT>help&nbsp;cd</TT>, for example. This will give you details
on the <TT>-P</TT> and <TT>-L</TT> arguments recognized by <TT>cd</TT>. 

<P>

<H1><A NAME="SECTION04560000000000000000">
<SPAN CLASS="arabic">6</SPAN> A Few <TT>bash</TT> Features </A>
</H1>

<P>
This section mentions just a few of the most commonly used Bash features; for
a more complete discussion see Chapter <A HREF="node10.html#shell">6</A>. 

<P>

<H2><A NAME="SECTION04561000000000000000">
<SPAN CLASS="arabic">1</SPAN> Tab Completion </A>
</H2>

<P>
<A NAME="2152"></A><A NAME="2153"></A><A NAME="2154"></A>The <TT>bash</TT> shell can guess what filename or command you are trying to
type and automatically finish typing it for you. Just type the beginning of
a command or filename and press <TT>Tab</TT>. If <TT>bash</TT> finds a single
unique completion, it will finish the word and put a space after it. If it finds
multiple possible completions, it will fill out the part all completions have
in common and beep. You can then enter enough of the word to make it unique
and press <TT>Tab</TT> again. If it finds no completions, it will simply beep. 

<P>

<H1><A NAME="SECTION04570000000000000000">
<SPAN CLASS="arabic">7</SPAN> Managing Your Identity </A>
</H1>

<P>
<A NAME="2160"></A><A NAME="2161"></A><A NAME="2162"></A><A NAME="2163"></A><A NAME="2164"></A>Unix-like systems are multiuser, and so you have your own electronic identity
as a user on the system. Type <TT>finger</TT>&nbsp;<TT><SPAN  CLASS="textit">yourusername</SPAN></TT> to
look at some of the information about you that's publically available. To change
the name and shell listed there, you can use the commands <TT>chfn</TT> and
<TT>chsh</TT>. Only the superuser can change your login (username) and directory.
You'll notice that it says ``No plan.'' A ``plan'' is just some information
you can make available to others. To create a plan, you put whatever information
you want people to see in a file called <TT>.plan</TT>. To do this you'll use
a text editor; see section <A HREF="node12.html#editor">8.2</A> on page <A HREF="node12.html#editor"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>. Then <TT>finger</TT>
yourself to see your plan. Others can <TT>finger</TT> you to see your plan and
to check whether you've received new mail or read your mail. 

<P>
<A NAME="2174"></A><A NAME="2175"></A><A NAME="2176"></A><A NAME="2177"></A><A NAME="2178"></A><A NAME="2179"></A>Note that this finger information is available to the entire Internet by default.
If you don't want this, read about configuring <TT>inetd</TT> and the file <TT>/etc/services</TT>.
Eventually the installation manual will describe this configuration, but for
now you might try the man pages or just put nonsense in for your finger information.

<P>

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A NAME="tex2html713"
  HREF="node10.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html707"
  HREF="node4.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html701"
  HREF="node8.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html709"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html711"
  HREF="node23.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html714"
  HREF="node10.html">6 Using the Shell</A>
<B> Up:</B> <A NAME="tex2html708"
  HREF="node4.html">1 導論</A>
<B> Previous:</B> <A NAME="tex2html702"
  HREF="node8.html">4 Logging In</A>
 &nbsp <B>  <A NAME="tex2html710"
  HREF="node1.html">Contents</A></B> 
 &nbsp <B>  <A NAME="tex2html712"
  HREF="node23.html">Index</A></B> </DIV>
<!--End of Navigation Panel-->
<ADDRESS>
John Goerzen / Ossama Othman / Debian 中文計劃
</ADDRESS>
</BODY>
</HTML>

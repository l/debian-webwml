#use wml::debian::template title="Debian GNU/Hurd --- 개발" NOHEADER="yes"
[ <a href="../">포트</a> ]
[ <a href="index">Debian GNU/Hurd</a> ]
[ <a href="hurd-news">뉴스</a> ]
[ <a href="hurd-install">설치</a> ]
[ <a href="hurd-doc">문서</a> ]
[ <a href="hurd-devel">개발</a> ]
[ <a href="hurd-links">링크</a> ]
[ <a href="hurd-contact">연락</a> ]<p>

<h1>
Debian GNU/Hurd</h1>
<h2>
배포판의 개발</h2>
<h3>
부트 디스크</h3>
<p>
현재 최소한의 허드 시스템을 부팅시키는 다양한 방법과 부트 플로피를
만드는 방법을 연구하고 있다. 예비(preliminary) 부트 디스크는 <code><a
href="ftp://alpha.gnu.org/gnu/hurd/contrib/marcus/">ftp://alpha.gnu.org/gnu/hurd/contrib/marcus</a></code>의
<code>boot-YYYYMMDD</code> 파일에서 구할 수 있다. 이 디스크는 GNU
Mach, <code>ext2fs</code> 서버, <code>ld.so</code> 링커, 부트스트랩
프로그램 <code>serverboot</code>와 GRUB의 복사본을 포함하고 있다. 이
디스크는 부팅하고 루트 디스크를 준비할(wait for) 것이다. 그러나 아직
사용가능한 것은 아니다.
</p>

<h3>
데비안 패키지 포팅하기</h3>
<p>
Debian GNU/Hurd 포트를 돕고 싶다면 데비안 패키징 시스템에 대해 잘 알고
있어야 한다. 구할 수 있는 문서를 읽고 <a
href="../../devel/">개발자 란</a>를 방문해서 이것에 대해 잘 알고
있다면 데비안 소스 패키지를 푸는(extract) 방법과 데비안 패키지를
만드는 방법을 알아야 한다. 여기 매우 게으른 사람들을 위한 속성(crash)
과정이 있다.
</p>

<h3>
소스를 얻어서 패키지 만들기</h3>
<p>
데비안 소스 패키지를 풀 때 <code>package_version.dsc</code> 파일과 그
안에 열거된 파일들이 필요하다. <code>dpkg-source -x
package_version.dsc</code> 명령으로 데비안 빌드 디렉토리를 만든다. 
</p>

<p>
이제 데비안 빌드 디렉토리 <code>package-version</code>에서 <code>dpkg -B -rsudo
"-mMyName <MyEmail>"</code> 명령어로 패키지를 만든다. 패키지의
아키텍처 독립적인 부분을 만들기를 원한다면 <code>-B</code> 대신
<code>-b</code>를 사용할 수도 있다. fakeroot 패키지를 사용한다면
<code>-rsudo</code> 대신 <code>-rfakeroot</code>를 사용할 수 있다. 
  You can do
without the <code>-r</code> if you build as user root. 자신의 pgp
열쇠가 패키지에 기록되는 것을 피하기 위해 <code>-uc</code>를 추가할 수
있다.
</p>

<h3>
패키지를 하나 고른다</h3>
<p>
어떤 패키지를 작업할 필요가 있는가? 아마 작업할 필요가 없는 패키지를
알려주는 것이 가장 좋을 것이다. 
</p>

<h4>
Packages That Won't Be Ported</h4>
<p>
이들 몇몇 패키지에 대한 설명을 아래에서 발견할 것이다.</p>
<p>
<code>base/update</code>,
<code>base/makedev</code></p>

<h4>수정 없이 깨끗하게 컴파일한 패키지들</h4>
 <code>base</code> 섹션에 있는 대부분의 패키지,
<code>libs/aalib</code>,
<code>games/an</code>,
<code>math/bc</code>,
<code>devel/bison</code>,
<code>utils/bzip2</code>,
<code>utils/cpio</code>,
<code>utils/cracklib</code>,
<code>devel/cvs</code>,
<code>libs/db</code>,
<code>devel/diffstat</code>,
<code>editors/ed</code>,
<code>mail/exim</code>,
<code>mail/fetchmail</code>,
<code>utils/file</code>,
<code>devel/flex</code>,
<code>text/groff</code>,
<code>text/gs</code>,
<code>net/inetutils</code>,
<code>utils/iselect</code>,
<code>text/jade</code>,
<code>editors/jed</code>,
<code>editors/joe</code> (아주 잘 동작하지는 않는다),
<code>text/less</code>,
<code>net/lftp</code> (아주 잘 동작하지는 않는다),
<code>libs/libglib</code>,
<code>libs/libident</code>,
<code>libs/libpaperg</code>,
<code>libs/libpng</code>,
<code>web/lynx</code>,
<code>devel/make</code>,
<code>text/most</code>,
<code>comm/minicom</code>,
<code>mail/mpack</code>,
<code>net/ncftp</code>,
<code>net/netcat</code> (reported by Andres),
<code>text/par</code>
<code>libs/pcre2</code>,
<code>doc/pinfo</code>,
<code>mail/procmail</code>,
<code>text/psutils</code>,
<code>text/recode</code>,
<code>utils/sharutils</code>,
<code>libs/svgalib-dummy</code>,
<code>libs/tk8.0</code>,
<code>web/wget</code>.

<h4>BTS에서 한번 패치한 후 깨끗하게 컴파일한 패키지들</h4>
<code>games/fortune-mod</code>  <a
href="http://bugs.debian.org/37091">Bug#37091</a>을 보라,
<code>libs/libpaperg</code>  <a
href="http://bugs.debian.org/39036">Bug#39036</a>을 보라,
<code>doc/man-db</code>  <a
href="http://bugs.debian.org/39039">Bug#39039</a>를 보라,
<code>otherosfs/mtools</code>  <a
href="http://bugs.debian.org/37757">Bug#37757</a>을 보라,
<code>interpreters/gawk</code>  <a
href="http://bugs.debian.org/40309">Bug#40309</a>를 보라,
<code>mail/mutt</code>  <a
href="http://bugs.debian.org/43956">Bug#43956</a>를 보라.

<h4>소스 NMU가 필요했던 패키지들</h4>
<p>
<code>base/shellutils</code>,
<code>base/shadow</code>  <a
href="http://bugs.debian.org/42480">Bug#42480</a>를 보라.
</p>

<h4>해킹이 약간 필요한 패키지들</h4>
<p>
다음 패키지들은 약간의 해킹이 필요하다고 알려진 패키지들이지만 이미
관심을 가지고 있는 사람들이 있다. 이 목록에 있는 특별한 패키지들을
돕고 싶다면 우리에게 알려주기 바란다. 그러나 이들 패키지 외에 다른
패키지를 고를지도 모른다.
</p>

<ul>
<li><b>Marcus Brinkmann</b>
<p><code>base</code> 섹션에 있는 몇몇 패키지들,
<code>devel/egcs</code> (대부분 해결함),
<code>devel/gdb</code> (Mark Kettenis의 패치),
<code>interpreters/perl</code> (perl 5.005 대부분 끝남),
<code>web/apache</code> (easy, see <a href="http://bugs.debian.org/38328">Bug#38328</a>
and implement use of <code>dpkg-architecture</code> in <code>debian/rules</code>),
<code>admin/apt</code> (<code>archtable</code> mess, some building issues),
<code>bind</code> (implement <code>dpkg-architecture</code> in <code>debian/rules</code>),
<code>devel/binutils</code> (<code>gprof</code> 깨짐),
<code>bsdmainutils</code>와 <code>bsdutils</code> (
<code>util-linux</code>에 의해 폐기됨 (Jeff Bailey is working on it?)),
<code>admin/cron</code> (<code>MAXPATHLEN</code>, Robert Stepanek is working on it),
<code>editors/emacs</code> (<code>dpkg-architecture</code> 지원),
<code>gdbm</code>,
<code>libs/libc0.2</code> (가끔 CVS로부터 패치),
<code>libs/liblockfile</code> (유해한),
<code>mail/mailx</code> (<code>NOFILE</code>, <code>MAXPATHLEN</code>,
 <code>MAXHOSTNAMLEN</code>, 헤더 파일들),
<code>mail/mutt</code>,
<code>text/sgml-tools</code> (<code>sgml2txt</code> 깨짐... 또는 펄),
<code>libs/slang</code>,
<code>tex/tetex</code> (includes ncurses man pages, klibtool issue).
</p>
<p>
보시는 바와 같이 나는 짐을 잔뜩 지고 있다(quite loaded). 나는 최소한
그것들 중 몇가지를 빼버리고 싶다(예를 들어 <code>mailx</code>에 관심이
있다면 알려주기 바란다).</p></li>
<li><b>Brent Fulgham</b>: <code>editors/vim</code>,
<code>interpreters/python</code>, <code>libs/tcl8.0</code>.</li>
<li><b>Kalle Olavi Niemitalo</b>: <code>libs/libpaperg</code>,
<code>graphics/netpbm</code>, <code>graphics/aalib</code>, <code>pointerize</code>,
<code>libtiff</code>, <code>libs/svgalib</code>?.</li>
</ul>

<p>내가 여러분 또는 몇몇 정보를 갱신하는 것을 잊었다면 
<a href="hurd-contact">나에게 알려주기 바란다!</a>.</p>

<h3>특별한 패키지에 대한 다른 정보</h3>
<h4>base/update</h4>
<p>
 update 패키지는 필요하지 않다. 파일 시스템은 translator에 의해
관리되고 주기적으로 동기화(sync)하기 때문이다. 동기화 간격을 바꾸기
위해 <code>fsysopts</code>를 <code>--sync</code> 옵션을 덧붙여서
사용할 수 있다. 각각의 파일 시스템에 서로 다른 동기화 간격을 설정할
수도 있다!
</p>
To do this manully, use the <a href="hurd-doc-utils#syncfs"><code>syncfs</code>
utility</a>.</p>
<p>
이것은 update 패키지는 오직 Debian
GNU/Linux에서만 흥미 있는 패키지라는 것을 뜻하며 포트되지 않을 것이다.
</p>

<h3>일반적인 포팅의 문제들(Issues)</h3>
부적당한 포터블 소프트웨어를 허드에서 컴파일할 때 만나게 될 일반적인
비호환성 목록이다.
</P>
<P>
<UL>
<LI><code>Bad File Descriptor</code>
<P>
파일로부터 읽으려고 할 때(또는 파일에 접근할 때) <code>Bad File
Descriptor</code> 에러가 나온다면 <code>open()</code> invocation를
점검하라. 두번째 인수가 접근 도구(access method)이다. 표준 헤더
파일에서 정의한 심볼이 아닌 hard coded number라면 코드가
비뚤어진(screwed) 것이고 <code>O_RDONLY</code>, <code>O_WRONLY</code>
또는 <code>O_RDWR</code>을 사용해 바로잡아야 한다. 예를 들면 이
버그는 <code>fortunes</code>와 <code>mtools</code>에서 발견했다. 
</P></LI>
<LI><code>PATH_MAX</code>
<P>
모든 <code>PATH_MAX</code>의 무조건화한 사용은 POSIX 비호환이다.
경로의 길이에 대한 상위(upper)의 제한이 없다면 이 심볼은 어떤 헤더
파일에도 정의되지 않은 것이다. 대신 스트링의 길이에 의존하지 않는 다른
implementation을 사용하거나 실행시간(runtime) 길이를 질의하기 위해
<code>sysconf()</code>를 사용할 필요가 있다. 
<code>sysconf()</code>가 <code>-1</code>을 돌려주면 필요한 메모리를 
동적으로 할당하기 위해 <code>realloc()</code>을 사용해야 한다.
</p></li>
<LI><code>MAXHOSTNAMELEN</code>
<P> <code>PATH_MAX</code>를 보라.
</p></li>
<li><code>MAXPATHLEN</code>
<p> <code>PATH_MAX</code>를 보라.
</p></li>
<li><code>NOFILE</code>
<p> <code>PATH_MAX></code>를 보라.
</p></li>
<li>허드의 특별한 <code>#define</code>
<p>허드를 위해 <code>#if...#endif</code>를 사용하여 특별한 코드를
포함시킬 필요가 있다면 <code>__GNU__</code> symbol을 사용할 수
있다. 그러나 그렇게 하기 전에 (최소한) 세 번 생각하라! 
 <em>대부분의</em> 경우에 이것은 전혀 불필요하며 그것이 해결하는
것보다 더 많은 문제를 만들 것이다. 더 나은 해결책을 생각할 수 없다면
정확한 방법을 메일링 리스트에 묻는 것이 더 좋다.
</p></li>

<li><code>sys_errlist[]</code> vs. <code>strerror()</code></li>
<p>If a program has only support for <code>sys_errlist[]</code> you will
have to do some work to make it compile on the Hurd, which has dropped
support for it and does only provide <code>strerror()</code>. Steinar Hamre
writes about <code>strerror():</p>
<blockquote>
<p><code>strerror()</code>가 사용되어야 한다. 왜냐하면,
<ul><li>현대적이며 POSIX 방식이다.</li>
<li>지역화되었다.</li>
<li>잘못된 신호와 범위를 벗어난 숫자를 다룬다. (에러를 더 잘 다루고
 buffer-overflow를 잘 일으키지 않으며 보안 위험도 적다)</li>
</ul></p>
<p>
가능하다면 <code>strerror()</code>를 항상 사용해야 한다.
불행히도 여전히 몇몇 <em>오래된</em> 비POSIX 시스템은 
 <code>strerror()</code>가 없고 오직
<code>sys_errlist[]</code>만 있다.</p>
<p>
오늘날 <code>strerror()</code>만 지원하는 것이  
<code>sys_errlist[]</code>만 지원하는 것보다 더 좋다. 그렇지만 가장
좋은 것은(이식성의 관점에서 보면) 둘 다 지원하는 것이다.
 For <code>configure.in</code>, you will need:
</p>
<code>AC_CHECK_FUNCS(strerror)</code></p>
<p>
<code>config.h.in</code>:</p>
<p>
<code>#undef HAVE_STRERROR</code></p>
<p>
Then something like:
<pre>
        #ifndef HAVE_STRERROR
        static char *
        private_strerror (errnum)
             int errnum;
        {
          extern char *sys_errlist[];
          extern int sys_nerr;

          if (errnum > 0 && errnum <= sys_nerr)
            return sys_errlist[errnum];
          return "Unknown system error";
        }
        #define strerror private_strerror
        #endif /* HAVE_STRERROR */
</pre></p>
<p>
You can for example look in the latest fileutils (the above is a simplified
version of what I found there.) Patches should of course be sent to upstream
maintainers, this is very useful even for systems with a working
<code>sys_errlist[]</code>.</p></blockquote></li>

</UL>

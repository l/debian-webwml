#use wml::debian::template title="Debian GNU/Hurd --- 문서" NOHEADER="yes"
[ <a href="..">Ports</a> ]
[ <a href="index">Debian GNU/Hurd</a> ]
[ <a href="hurd-news">News</a> ]
[ <a href="hurd-install">Installation</a> ]
[ <a href="hurd-doc">Documentation</a> ]
[ <a href="hurd-devel">Development</a> ]
[ <a href="hurd-links">Links</a> ]
[ <a href="hurd-contact">Contact</a> ]<p>

<h1>Debian GNU/Hurd</h1>
<h2>Translators</h2>
<ul>
<li><a href="#concept" name="TOC_concept">개념</a></li>
<li><a href="#examples" name="TOC_examples">예</a></li>
<li><a href="#actpas" name="TOC_actpas">Passive Translators, Active Translators</a></li>
<li><a href="#manage" name="TOC_manage"> Translators 다루기</a></li>
</ul>

<a href="#TOC_concept" name="concept"><h3>개념</h3></a>
<p>
 translator에 대해 자세히 살펴보기 전에
정규 파일 시스템에 대해 생각해 보자. 파일 시스템은 디렉토리와 파일의
계층적인 가지를 위한 기억 장치이다. 특별한 문자열과 경로에 의해
디렉토리와 파일에 접근한다. 게다가 가지에는 몇 군데에 한 파일을
가리키는 심볼릭 링크와 같은 한 파일에 몇 가지 이름을 주는 하드 링크가
있다. 또한 커널의 하드웨어 장치 드라이버와 통신하기 위한 몇 가지 장치
파일이 있고 디렉토리 가지 안에 다른 기억 장치를 포함하는 마운트
포인트가 있다. 그리고 하드 링크와 fifo와 같은 불분명한 객체가 있다.
 </p>
<p>
이 객체들이 매우 다르기는 하지만 몇 가지 공통의 특성을 공유하고
있다. 예를 들면, 접근 권한(허가권) 뿐 아니라 그것들과 관련된 소유자와
그룹을 모두 가지고 있다. 이 정보는 아이노드에 기록된다. 이것은 실제로
그 이상의 공통성이다. 모든 객체는 그것과 관련된 아이노드를 꼭
갖고 있다(하드 링크는 같은 한 아이노드를 공유하고 있기 때문에 다소
특별하다). 때때로, 아이노드는 저장된 이상의 정보를 가지고 있다. 예를
들면, 아이노드는 심볼릭 링크의 대상을 포함하고 있다. 
</p>
<p>
However, these commonalities are usually not exploited in the
implementations, despite the common programming interface to
them. 모든 아이노드는 표준 POSIX 호출(예를 들면 <code>read()</code>와
<code>write()</code>)을 통해 접근한다. 예를 들어 새로운 객체 형(새로운
링크 형태)을 일반적인 단일(monolithic) 유닉스 커널에 추가하기 위해 각 파일
시스템에 각각 코드를 수정해야 할 필요가 있다.
</p>
<p>
허드에서는 다르게 동작한다. 허드에서는 특별한 파일 시스템 서버가
링크(예를 들면 빠른 링크가 있는 ext2 파일 시스템)와 같은 표준 객체
타입의 특성을 이용할 수 있지만 기존의 코드를 수정하지 않고 그러한
특성을 추가할 수 있는 일반적인 인터페이스를 가지고 있다.
</p>
<p>
비결(trick)은 파일의 실제 내용과 사용자의 파일 접근 사이에 프로그램이
삽입되도록 하는 것이다. 그러한 프로그램을 translator라
부른다. 들어오는 요청을 많은 다른 방식으로 처리할 수 있기
때문이다. 다른 말로 translator는 기본 파일 시스템 인터페이스를
제공하는 허드 서버이다.
</p>
<p>
translator는 매우 흥미로운 특징을 가지고 있다. 커널의 관점에서 보면
translator는 단지 사용자 프로세스이다. 이것은 어느 사용자이든지
translator를 작동시킬 수 있다는 것을 의미한다. translator를 설치하고
수정하기 위해 root 특권이 필요없다.
 you only need the access rights for the underlying inode the
translator is attached to. 많은 translator는 운영할 실제 파일이
필요하지 않다. translator는 자신의 방법으로 정보를 제공할 수
있다. 이것이 왜 translator에 대한 정보가 아이노드에 저장되는지에 대한
이유이다. 
</p>
<p>
translator는 자신이 속한 아이노드를 포함한 모든 파일 시스템 운영을
제공할 책임이 있다. translator는 일반적인 객체(장치 파일, 링크 등)의
집합에 제한받지 않기 때문에 프로그래머가 이해할 수 있는 어떤 것을
돌려주는 데 자유롭다. <code>cd</code>나 <code>ls</code>로 접근할 때
디렉토리처럼 동작하는 translator와 동시에 <code>cat</code>로 접근할 때
파일처럼 행동하는 translator를 상상할 수 있다.
</p>

<a href="#TOC_examples" name="examples"><h3>예</h3></a>
<h4>마운트 포인트</h4>
<p>
마운트 포인트는 특별한 translator가 부착되어 있는 아이노드로 볼 수
있다. 
 Its purpose would be to translate filesystem operations on the mount
point in filesystem operations on another store, let's say, another
partition.</p>
<p>
실제로는 이것이 허드에서 파일 시스템을 실행하는 방법이다. 파일
시스템은 translator이다. 이 translator는 그것의 인수로서 기억 장치를
사용하고 모든 파일 시스템 운영을 투명하게 제공한다.
</p>

<h4>장치 파일</h4>
<p>
많은 장치 파일이 있다. 단일 커널 시스템에서는 장치 파일들이 커널
자체에 의해 제공된다. 허드에서는 모든 장치 파일이 translator에 의해
제공된다. translator는 많은 유사한 장치 파일, 예를 들면 모든 하드
디스크 파티션을 위한 지원을 제공한다. 이 방식은 필요한 실제
translator의 수가 매우 적다. 그러나 각 장치 파일에 접근하기 위해
독립된 translator 작업이 시작된다는 것에 주의하라. 
Because the Hurd is heavily multi threaded, this is very cheap.</p>
<p>
하드웨어가 관련되었을 때 translator는 대개 하드웨어로부터 자료를 얻기 위해
커널과 통신하기 시작한다. 그러나 어떤 하드웨어 접근도 필요하지 않다면
커널은 관련될 필요가 없다.
 예를 들면
<code>/dev/zero</code>는 하드웨어 접근이 필요하지 않다. 따라서 사용자
공간에서 완전하게 실행될 수 있다.
</p>

<h4>심볼릭 링크</h4>
<p>
심볼릭 링크는 translator로 보일 것이다. 심볼릭 링크게 접근하면
translator가 움직이고 translator는 링크가 가리키는 파일을 포함하고
있는 파일 시스템으로 요청을 전달한다.
</p>
<p>
그러나 더 나은 성능을 위해 심볼릭 링크를 위한 고유의 지원을 가지고
있는 파일 시스템은 이 장점을 이용해 심볼릭 링크를 다르게
실행한다. 내부적으로 심볼릭 링크에 접근하는 것은 새로운 translator
프로세스를 시작하지 않는다. 그러나 사용자에게는 여전히 passive
translator가 포함된 것으로 보일 것이다(passive translator가 무엇인가에
대한 설명은 다음을 보라).
</p>
<p>
Because the Hurd ships with a symlink translator, any filesystem server that
provides support for translators automatically has support for symlinks (and
firmlinks, and device files etc)! 이것은 동작하는 파일 시스템을 빨리
얻을 수 있고 나중에 symlink와 다른 특징에 대한 고유한 지원을 추가할 수
있다는 것을 의미한다.
</p>

<a href="#TOC_actpas" name="actpas"><h3>Passive Translator, Active Translator</h3></a>
<p>
passive와 active, 두 가지 형태의 translator가 있다. 두 가지는 실제로
전혀 다른 것들이어서 서로 섞을 수 없다. 그러나 서로 밀접한 관련을
가지고 있다.
</p>

<h4>Active Translator</h4>
<p>
 active translator는 앞에서 소개한 것처럼 실행 중인 translator
프로세스이다. <a
href="reference-manual/hurd_7.html#SEC49"><code>settrans -a</code></a>
명령을 사용하여 active translator를 설정하고 제거할 수
있다. <code>-a</code> 옵션은 <code>settrans</code>에게 active
translator를 수정해야 한다고 알려주기 위해 필요하다. 
</p>
<p>
 <code>settrans</code> 명령은 세 가지 인수를 사용한다. 첫째, active
translator를 수정하는 <code>-a</code>와 같은, <code>settrans</code>
명령 자체를 위한 옵션을 설정할 수 있다. 그리고 나서 수정하고자 하는
아이노드를 설정한다. translator는 디렉토리 계층 안에서 한 아이노드와
항상 연관되어 있다는 것을 기억하라. 한 번에 한 아이노드만을 수정할 수
있다. 인수를 지정하지 않는다면 <code>settrans</code>는 현존하는
translator를 제거하려 할 것이다. 얼마나 시도하는가는 지정한 강제
옵션에 달려 있다(translator가 어떤 프로세스에 의해 사용 중이라면
강제로 제거하지 않는 이상 "device or resource busy" 에러 메세지를 보게
될 것이다).
</p>
<p>
그러나 그 이상의 인수를 지정한다면 translator를 실행하는 명령줄로
해석될 것이다. 이것은 다음 인수가 translator 실행 파일의 파일
이름이라는 것을 의미한다. 그 이상의 인수는 translator의 인수이지
<code>settrans</code> 명령의 인수가 아니다.
</p>
<p>
예를 들면 ext2fs 파티션을 마운트하기 위해 <code>settrans -a -c /mnt
/hurd/ext2fs /dev/hd2s5</code>를 실행할 수 있다. <code>-c</code>
옵션은 마운트 포인트가 이미 존재하지 않는다면 마운트 포인트를 만들
것이다. 그런데 이것이 디렉토리일 필요는 없다. 언마운트하기 위해
<code>settrans -a /mnt</code>를 실행하면 된다.
</p>

<h4>Passive Translator</h4>
<p>
 passive translator는 active
translator와 같은 구문으로 설정하고 수정한다
 (단지 <code>-a</code>를 제외하면 앞에서 이야기한 모든 것이 passive
translator에게도 동일하다). 그러나 다른 점이 있다. passive
translators are not yet started.
</p>
<p>
This makes sense, because this is what you usually want. 실제로 파티션
위의 파일에 접근하지 않는 한 파티션이 마운트되는 것을 원하지 않을
것이다. 
 You
don't want to bring up the network unless there is some traffic and so
on.</p>
<p>
대신 처음 passive translator에 접근할 때, passive translator를
아이노드로부터 자동으로 읽고 active translator가 아이노드에 저장된
명령줄을 사용하여 passive translator의 위에서 시작된다. 이것은
리눅스의 automounter functionality와 비슷하다. 그러나 이것은 수동으로
설정해야만 하는 덤(additional bonus)이 아니라 시스템의 없어서는 안 될
부분이다. 따라서 passive translator를 설정하는 것은 정말 필요할 때까지
translator 작업을 시작하는 것을 연기한다. 그런데 active translator가
어떤 이유 때문에 죽는다면 다음 번에 아이노드에 접근할 때 translator는
재시작된다. 
</p>
<p>
그 이상의 차이가 있다. active translator는 죽거나 잃어버릴 수가
있다. active translator 프로세스가 죽자마자(예를 들면 기계를
리부트했기 때문에) active translator를 영원히 잃어버리는
것이다. passive translator는 일시적이지 않고 <code>settrans</code>
프로그램으로 수정하거나 부착되어 있는 아이노드를 지우지 않는 이상
리부트하는 동안 아이노드에 머물러 있다. 이것은 마운트 포인트와 함께
설정 파일을 유지할 필요가 없다는 것을 뜻한다.
</p>
<p>
마지막 한 가지 요점: passive translator를 설정했다고 하더라도 다른 active
translator를 설정할 수 있다. 
 Only if the translator is automatically
started because there was no active translator the time the inode was
accessed the passive translator is considered.</p>

<a href="#TOC_manage" name="manage"><h3>translator 관리하기</h3></a>
<p>
앞에서 언급한 것처럼, passive, active translator를 설정하고 바꾸기
위해 <a
href="reference-manual/hurd_7.html#SEC49"><code>settrans</code></a>를
사용할 수 있다. 뭔가가 잘못되었을 경우에 <code>settrans</code>의
동작을 바꾸고 조건화하기 위한 많은 옵션이 있다. 몇 가지 일반적인
사용법이 있다.
</p>
<ul><li><code>settrans -c /mnt /hurd/ext2fs /dev/hd2s5</code> mounts a
partition, the translator will stay across reboots.</li>
<li><code>settrans -a /mnt /hurd/ext2fs ~/dummy.fs</code> mounts a
filesystem inside a data file, the translator will go away if it dies.</li>
<li><code>settrans -fg /nfs-data</code> forces a translator to go away.</li>
</ul>
<p>
translator가 아이노드에 부착되어 있는지 알아보기 위해 <a
href="hurd-doc-utils#showtrans"><code>showtrans</code></a> 명령어를
사용할 수 있다. 그렇지만 이것은 오직 passive translator만을 보여줄
것이다. 
</p>
<p>
<code>fsysopts</code>로 실제로 재시작하지 않고 active (filesystem)
translator의 옵션을 바꿀 수 있다. 이것은 매우 편리하다. 예를 들어
리눅스의 이른바 "읽기 전용으로 파티션을 다시 마운트"를 단순하게 <code>fsysopts
/mntpoint --readonly</code>를 실행함으로 할 수 있다. 실행 중인 active
translator는 가능한 한 요청에 따라 자신의 동작을 변경할 수 있다. 매개
변수가 없는 <code>fsysopts /mntpoint</code>는 현재 설정을 보여준다.
</p>

<h4>예</h4>
<p>
<code>/bin/mount</code> 명령어를 읽고서 시작할 것을 추천한다. 그것은
단지 작은 스크립트이다. 파일 시스템 translator를 설정하는 것은
파티션을 마운트하는 것과 비슷하기 때문에 이런 식으로 쉽게 개념을
파악할 수 있다. <code>dd if=/dev/zero of=dummy.fs bs=1024k
count=8; mke2fs dummy.fs</code>로 파일 시스템 이미지를 만들고 <code>settrans -c dummy
/hurd/ext2fs `pwd`/dummy.fs</code>로 "마운트"하라. translator가 아직
시작되지 않았고 새로운 <code>ext2fs</code> 프로세스도 실행되고 있지
않다는 것에 주의하라(<code>ps
Aux</code>로 확인하라). <code>showtrans</code>를 사용하여 모든 것이
정확한지 확인하라.
</p>
<p>
<code>ls dummy</code>를 입력하면 translator가 시작하면서 짧은 지연이
생기는 것을 볼 수 있을 것이다. 그 후로는 더미에 접근할 때 어떤 지연도
생기지 않을 것이다. 리눅스에서는 루프 파일 시스템을 오토마운트했다고
할 것이다. <code>ext2fs
dummy</code> 프로세스가 실행되고 있는지 <code>ps Aux</code>로
확인하라. 이제 새 디렉토리에 파일 몇 개를
만들라. <code>fsysopts</code>로 파일 시스템을 읽기 전용으로
만들어보라. 그 이상의 쓰기 시도가 어떻게 실패하는지
주의하라. <code>settrans -g</code>로 active translator를 죽인다.
</p>
<p>
이제 무엇이 일어나고 있는지를 조금 이해할 수 있을 것이다. 이것은
단지 <em>한 가지</em> 특별한 서버, 허드 ext2fs 서버라는 것을
기억하라. <code/hurd</code> 디렉토리에는 더 많은 서버가 있다. 그것들
중 몇몇은 파일 시스템을 위한 것이다. 어떤 것은 링크와 같은 파일
시스템의 특징을 위해 필요하다. 어떤 것은 장치 파일을 위해
필요하다. 어떤 것은 네트워크에 유용하다. <code>settrans</code>로 FTP
서버를 "마운팅"하고 단순하게 표준 <code>cp</code> 명령으로 파일을
내려받는 것을 상상해보라. 또는 <code>emacs
/ftp/homepage.my.server.org/index.html</code>로 웹 사이트를 편집하는
것을 상상해보라!
</p>

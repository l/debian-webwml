#use wml::debian::template title="데비안 BTS - 컨트롤 서버" NOHEADER=yes NOCOPYRIGHT=true
#use wml::debian::translation-check translation="1.19"

<h1>버그 컨트롤과 처리 메일 서버에 대한 소개</h1>

<p>버그 데이타와 문서를 전자우편로 받아 볼 수 있는
<code>request@bugs.debian.org</code>의 메일 서버에 추가해서, 버그 보고를
여러 가지 방법으로 처리할 수 있는 메일 서버가
<code>control@bugs.debian.org</code>에 있습니다. 
</p>

<p>컨트롤 서버는 요청 서버와 마찬가지로 동작하지만, 그 외에 여러 가지 명령어가
더 있습니다; 사실 이 두 서버는 같은 프로그램입니다. 이 두 개의 주소는
사용자가 정보를 요청하다가 실수로 문제를 일으키는 일을 방지하기 위해 분리되어
있을 뿐입니다.</p>

<p><A href="server-request#introduction">요청 서버에 대한 소개</A>를 웹에서,
<code>bug-log-mailserver.txt</code> 파일에서, 혹은 이 두 메일 서버 중
어느 쪽이든지 <code>help</code>라고 써서 보내면 읽을 수 있습니다.
여기에는 메일 서버를 사용하는 기본과 이 두 개의 주소에 보내는 메일에서
사용할 수 있는 공통적인 명령어 리스트가 들어 있습니다.</p>

<p>메일 서버의 <A href="server-refcard">참고 카드</A>를 웹에서,
<code>bug-mailserver-refcard.txt</code> 파일에서, 혹은
<code>refcard</code> 명령을 사용해 전자우편을 보내면 읽을 수 있습니다.</p>

<h1>컨트롤 메일 서버에서만 사용 가능한 명령어들</h1>

<dl>

<dt><code>reassign</code> <var>bugnumber</var> <var>package</var>
<dd>

bug #<var>bugnumber</var>가 <var>package</var>에 속한 버그라고 기록합니다.
이 명령어는 사용자가 가상의 헤더를 잊고 쓰지 않았거나, 전에 지정한 패키지를
바꾸고 싶을 때 사용합니다. 누구에게도 알리는 메일을 보내지 않습니다(처리
기록문에 나타나는 정보를 제외하고는).

<dt><code>reopen</code> <var>bugnumber</var>
 [ <var>originator-address</var> | <code>=</code> | <code>!</code> ]
<dd>

닫혔다면 #<var>bugnumber</var>를 다시 연다.

<p>기본적으로, 혹은 <code>=</code>라고 지정하면 원 보고자는 계속해서
버그 보고자(originator)가 됩니다. 즉, 나중에 이 버그가 종료되면 그 사람이 다시
알림(ack) 메일을 받게 됩니다. 
</p>

<p><var>originator-address</var>를 쓰면 보고자는 위 명령어에 주어진 주소로
바뀝니다. 자기 자신이 다시 열린 보고의 보고자가 되고 싶으면 간단히
<code>!</code>를 쓰거나 당신 자신의 전자우편 주소를 쓰면 됩니다. 
</p>

<p>보고자로 기록될 사람에게 이 버그를 다시 연다는 사실을 알리는 것이 좋습니다.
그래야 이 버그가 다시 종료될 때 알려줄 것을 기대하고 있을 것입니다. 
</p>

<p>버그가 종료되지 않으면 reopen은 아무 일도 하지 않고, 보고자를
바꾸는 일조차 하지 않습니다. 열려 있는 버그 보고의 보고자를 바꿀 수
있는 방법은 없습니다(신중하게, 아무에게도 알리지 않은 채 버그가 종료된 다음 28일이
지나서 지워지는 일이 없도록 해야 합니다).

<dt><code>forwarded</code> <var>bugnumber</var> <var>address</var>
<dd>

<var>bugnumber</var>가 <var>address</var>의 상위 관리자에게 포워드된다는
점에 주의합니다. 이 명령어는 실제로 버그 레포트를 포워드하지 않습니다.
이 명령어는 어디로 포워드되었는지, 그 주소가 잘못되었을 때 고치는 데
쓰이거나, 이미 포워드되었는데 포워드되었다고 기록되지 않은 버그에 대해
사용합니다.

<dt><code>notforwarded</code> <var>bugnumber</var>
<dd>

<var>bugnumber</var>가 상위 관리자에게 포워드되었다는 사실을 잊어버립니다.
버그가 포워드된 걸로 기록되지 않았다면, 아무 일도 하지 않습니다.

<dt><code>retitle</code> <var>bugnumber</var> <var>new-title</var>
<dd>

버그 보고의 제목을 지정한 대로 바꿉니다(기본 값은 원래 버그 보고의
<code>Subject</code> 메일 머리말).

<p>다른 버그-처리 명령어들과는 다르게, 여러 개가 합쳐진 버그 중 하나에 대해
이 명령을 내리면 오직 요청한 한 개의 버그 제목만 바꾸고,
다른 합쳐진 버그들은 그대로 놔 둡니다. 

<dt><code>severity</code> <var>bugnumber</var> <var>severity</var>
<dd>

<p>bug report #<var>bugnumber</var>의 심각도 단계를 <var>severity</var>로
맞춥니다. 버그를 보고한 사용자에게 알리지는 않습니다. 
</p>

<p>심각도는 <code>critical</code>, <code>grave</code>,
<code>normal</code>, <code>important</code>,
<code>wishlist</code>으로 나눌 수 있습니다.

<A href="Developer#severities">그 의미</A>에 관해서 버그 시스템의
일반 개발자 문서를 참조하기 바랍니다. 

<dt><code>merge</code> <var>bugnumber</var> <var>bugnumber</var> ...
<dd>

두 개 이상의 버그 보고를 하나로 합칩니다. 여러 개의 보고가 하나로 합쳐지면,
버그 열기, 버그 종료, 포워드 표시 및 표시 없애기, 패키지 재할당 등을 한 개
버그에만 하면 나머지 합쳐진 버그에도 똑같은 효과가 나타납니다. 

<p>버그가 합쳐지기 전에 이 버그들은 같은 상태에 있어야 합니다: 모두 열려
있거나 모두 종료되어 있어야 하며, 포워드된 상위 개발자 주소가 같거나
포워드되지 않았어야 하며, 같은 패키지에 할당되어 있어야 합니다(버그가
패키지에 할당되는 패키지에서 문자열을 정확히 검사합니다). 만약 같은
상태가 아니라면, <code>reassign</code>, <code>reopen</code> 등의 명령을
사용해서 <code>merge<code> 명령을 사용할 수 있는 상태로 만들어야 합니다.</p>

<p><code>merge</code> 명령어에 열거된 버그 중에 하나라도 다른 버그와 합쳐진
상태라면 이 버그와 합쳐진 모든 버그가 하나로 합쳐질 것입니다. 합치는 것은
같다는 것과 비슷합니다: reflexive, transitive, symmetric합니다.
</p>

<p>여러 개의 보고를 하나로 합치면 각 버그 보고의 기록에 남게 됩니다;
웹 페이지에서는 다른 버그의 링크가 만들어 집니다.
</p>

<p>합쳐진 보고는 동시에 지워지며, 이 경우는 거기에 있는 모든 버그 보고가
지워지는 기준에 맞아 떨어져야 합니다.

<dt><code>unmerge</code> <var>bugnumber</var>
<dd>

어떤 버그 보고를 합쳐진 다른 보고에서 분리합니다. 만약 이 버그가 여러 개의
버그와 합쳐진 상태라면 그 버그들은 합쳐진 상태로 둔다. 여기에 쓰여진 해당
버그만 빠져 나갑니다. 

<p>
여러 개의 버그 보고가 합쳐져 있고, 이것을 두 개의 그룹으로 나누려고
한다면 하나씩 분리한 다음에 다시 한 그룹으로 합쳐야 합니다. 
</p>

<p><code>unmerge</code> 명령에서는 오직 한 개의 버그만 분리할 수 있습니다;
여러 개의 버그를 분리하고 싶으면 간단히 여러 개의 <code>unmerge</code>
명령을 메세지에 쓰면 됩니다. </p>

<dt><code>tags</code> <var>bugnumber</var> [ <code>+</code> | <code>-</code> | <code>=</code> ] <var>tag</var>

  <dd>버그 보고 #<var>bugnumber</var>에 <var>tag</var>라는 표시(tag)를
붙입니다. 버그를 보고한 사용자에게는 어떤 통지(notification)도
전해지지 않습니다. <code>+</code>는 추가를 뜻하고 <code>-</code>는
제거를 뜻합니다. 그리고 <code>=</code>는 현재 태그를 무시하고 태그를
새로 세팅합니다. +/-/= 문자와 태그 이름 사이에 빈 칸(space)이 필요합니다.

  <p>현재 사용할 수 있는 태그는 <code>patch</code>, <code>wontfix</code>,
  <code>moreinfo</code>, <code>unreproducible</code>, <code>help</code>,
  <code>pending</code>, <code>fixed</code>, <code>security</code>,
  <code>upstream</code>, <code>potato</code>, <code>woody</code> and
  <code>sid</code>가 있습니다.

  <p><a href="Developer#tags">태그의 뜻</a>은 버그 추적 시스템의 일반
개발자 문서를 참고하세요.

<dt><code>close</code> <var>bugnumber</var>
<dd>

버그 보고 #<var>bugnumber</var>를 종료합니다.
<p>

종료를 알리는 메일이 버그를 보고한 사용자에게
보내집니다. 하지만(<var>bugnumber</var><code>-done@bugs</code>로
보내는 게 아닌) 그 알림 메일에는 버그를 종료하는 이유가 적혀 있지
<strong>않습니다</strong>. 보고를 종료하는 사람은, 별도의 메일을
보내서 버그를 보고한 사람이 왜 종료되는지 알 수 있도록 해야 합니다.

</dl>

<hr>

#use "otherpages.inc"

#use "footer.inc"

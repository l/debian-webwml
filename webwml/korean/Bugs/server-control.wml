#use wml::debian::template title="Debian bug tracking system" NOHEADER=yes WEBMASTER=bugs
#use wml::debian::translation-check translation="1.1"

<h1>버그 컨트롤 및 처리 메일서버에 대한 소개</h1>

버그 데이타와 문서를 이메일로 받아 볼 수 있는
<code>request@bugs.debian.org</code>의 메일서버에 추가해서, 버그 보고를
여러가지 방법으로 처리할 수 있는 메일 서버가
<code>control@bugs.debian.org</code>에 있습니다. 
<p>

컨트롤 서버는 요청 서버와 마찬가지로 동작하지만, 그 외에 여러가지 명령어가
더 있습니다; 사실 이 두 서버는 같은 프로그램입니다. 이 두 개의 주소는
사용자가 정보를 요청하다가 실수로 문제를 일으키는 일을 방지하기 위해 분리되어
있을 뿐입니다.
<p>

<A href="server-request#introduction">요청 서버에 대한 소개</A>를 웹에서,
<code>bug-log-mailserver.txt</code> 파일에서, 혹은 이 두 메일서버중
어느 쪽이든지 <code>help</code>라고 써서 보내면 읽을 수 있습니다.
여기에는 메일서버를 사용하는 기본과 이 두개의 주소에 보내는 메일에서
사용할 수 있는 공통적인 명령어 리스트가 들어 있습니다.
<p>

메일서버의 <A href="server-refcard">참고 카드</A>를 웹에서,
<code>bug-mailserver-refcard.txt</code> 파일에서, 혹은
<code>refcard</code> 명령을 사용해 이메일을 보내면 읽을 수 있습니다.

<h1>컨트롤 메일서버에서만 사용 가능한 명령어들</h1>

<dl>

<dt><code>close</code> <var>bugnumber</var>
<dd>

Close bug report #<var>bugnumber</var>.
<p>

종료를 알리는 메일이 버그를 보고한 사용자에게 보내집니다. 하지만
( r>bugnumber</var><code>-done@bugs</code>로 보내는 게 아닌) 그 알림
메일에는 버그를 종료하는 이유가 적혀 있지 <em>않습니다</em>. 보고를
종료하는 사람은, 별도의 메일을 보내서 버그를 보고한 사람이 왜 종료되는지
알 수 있도록 해야 합니다.

<dt><code>reassign</code> <var>bugnumber</var> <var>package</var>
<dd>

bug #<var>bugnumber</var>가 <var>package</var>에 속한 버그라고 기록합니다.
이 명령어는 사용자가 가상의 헤더를 잊고 쓰지 않았거나, 전에 지정한 패키지를
바꾸고 싶을 때 사용합니다. 누구에게도 알리는 메일을 보내지 않습니다 (처리
기록문에 나타나는 정보를 제외하고는).

<dt><code>reopen</code> <var>bugnumber</var>
 [ <var>originator-address</var> | <code>=</code> | <code>!</code> ]
<dd>

이미 종료된 #<var>bugnumber</var>를 다시 엽니다.
<p>

기본적으로, 혹은 <code>=</code>라고 지정하면 원 보고자는 계속해서
버그 보고자가 됩니다. 즉, 나중에 이 버그가 종료되면 그 사람이 다시
알림메일을 받게 됩니다. 
<p>

<var>originator-address</var>를 쓰면 보고자는 위 명령어에 주어진 주소로
바뀝니다. 자기 자신이 다시 열린 보고의 보고자가 되고 싶으면 간단히
<code>!</code>를 쓰거나 당신 자신의 이메일 주소를 쓰면 됩니다. 
<p>

보고자로 기록될 사람에게 이 버그를 다시 연다는 사실을 알리는 것이 좋습니다.
그래야 이 버그가 다시 종료될 때 알려줄 것을 기대하고 있을 것입니다. 
<p>

버그가 종료되지 않으면 reopen은 아무 일도 하지 않고, 보고자를 바꾸는 일
조차 하지 않습니다. 열려 있는 버그 보고의 보고자를 바꿀 수 있는 방법은
없습니다 (신중하게, 아무에게도 알리지 않은 채 버그가 종료된 다음 28일이
지나서 지워지는 일이 없도록 해야 합니다).

<dt><code>forwarded</code> <var>bugnumber</var> <var>address</var>
<dd>

<var>bugnumber</var>가 <var>address</var>의 상위 관리자에게 포워드된다는
점에 주의합니다. 위 명령어는 실제로 버그 레포트를 포워드하지 않습니다.
이 명령어는 어디로 포워드되었는지, 그 주소가 잘못되었을 때 고치는 데
쓰이거나, 이미 포워드되었는데 포워드되었다고 기록되지 않은 버그에 대해
사용합니다.

<dt><code>notforwarded</code> <var>bugnumber</var>
<dd>

<var>bugnumber</var>가 상위 관리자에게 포워드되었다는 사실을 잊어버린다.
버그가 포워드된 걸로 기록되지 않았다면, 아무 일도 하지 않습니다.

<dt><code>retitle</code> <var>bugnumber</var> <var>new-title</var>
<dd>

버그 보고의 제목을 지정한 대로 바꿉니다 (기본 값은 원래 버그 보고의
<code>Subject</code> 메일헤더이다).
<p>

다른 버그-처리 명령어들과는 다르게, 여러개가 합쳐진 버그 중 하나에 대해
<code>retitle</code>명령을 내리면 오직 요청한 한 개의 버그 제목만 바꾸고,
다른 합쳐진 버그들은 그대로 놔 둡니다. 

<dt><code>severity</code> <var>bugnumber</var> <var>severity</var>
<dd>

bug report #<var>bugnumber</var>의 심각도 단계를 <var>severity</var>로
맞춥니다. 버그를 보고한 사용자에게 알리지는 않습니다. 
<p>

심각도는 <code>심각한(critical)</code>, <code>중대한(grave)</code>,
<code>보통의(normal)</code>, <code>중요한(important)</code>,
<code>희망사항(wishlist)</code>으로 나눌 수 있습니다.

<A href="Developer#severities">그 의미</A>에 관해서 버그 시스템의
일반 개발자 문서를 참조하기 바랍니다. 

<dt><code>merge</code> <var>bugnumber</var> <var>bugnumber</var> ...
<dd>

두 개 이상의 버그 보고를 하나로 합칩니다. 여러개의 보고가 하나로 합쳐지면,
버그열기, 버그종료, 포워드 표시 및 표시 없애기, 패키지 재할당 등을 한 개
버그에만 하면 나머지 합쳐진 버그들에도 똑같은 효과가 나타납니다. 
<p>

버그가 합쳐지기 전에 이 버그들은 같은 상태에 있어야 합니다: 모두 열려
있거나 모두 종료되어 있어야 하며, 포워드된 상위 개발자 주소가 같거나
포워드되지 않았어야 하며, 같은 패키지에 할당되어 있어야 합니다 (버그가
패키지에 할당되는 패키지에서 문자열을 정확히 검사합니다). 만약 같은
상태가 아니라면, <code>reassign</code>, <code>reopen</code> 등의 명령을
사용해서 <code>merge<code> 명령을 사용할 수 있는 상태로 만들어야 합니다.
<p>

<code>merge</code> 명령어에 열거된 버그중에 하나라도 다른 버그와 합쳐진
상태라면 이 버그와 합쳐진 모든 버그가 하나로 합쳐질 것입니다. 합치는 것은
같다는 것과 비슷합니다: reflexive, transitive 그리고 symmetric 합니다.
<p>

여러개의 보고를 하나로 합치면 각 버그보고의 기록 상에 남게 됩니다;
웹 페이지에서는 다른 버그의 링크가 만들어 집니다.
<p>

합쳐진 보고는 동시에 지워지며, 이 경우는 거기에 있는 모든 버그 보고가
지워지는 기준에 맞아 떨어져야 합니다.

<dt><code>unmerge</code> <var>bugnumber</var>
<dd>

어떤 버그 보고를 합쳐진 다른 보고에서 분리합니다. 만약 이 버그가 여러개의
버그와 합쳐진 상태라면 그 버그들은 합쳐진 상태로 둔다; 여기에 쓰여진 해당
버그만 빠져 나갑니다. 
<p>

여러 개의 버그 보고가 합쳐져 있고, 이 것을 두 개의 그룹으로 나누려고
한다면 하나씩 분리한 다음에 다시 한 그룹으로 합쳐야 합니다. 
<p>

<code>unmerge</code> 명령에서는 오직 한 개의 버그만 분리할 수 있습니다;
여러 개의 버그를 분리하고 싶으면 간단히 여러 개의 <code>unmerge</code>
명령을 메세지에 쓰면 됩니다. 

</dl>

<hr>
그 외의 페이지:
<ul>
<li><A href="./">버그 추적 시스템 메인 페이지.</A>
<li><A href="Reporting">버그를 보고하는 방법.</A>
<li><A href="Access">웹 이외의 방법으로 버그 추적 기록 접근하기.</A>
<li><A href="Developer">버그 처리 시스템에 관한 개발자 정보.</A>
<li><A href="server-request">메일서버의 기본 및 버그를 가져오는 명령어들 설명.</A>
<li><A href="server-refcard">메일서버의 참고 카드.</A>
<li><A href="db/ix/full.html">미해결 혹은 최근의 버그 보고의 완전한 리스트.</A>
<li><A href="db/ix/packages.html">버그 보고가 있는 패키지.</A>
<li><A href="db/ix/maintainers.html">버그 보고가 있는 패키지의 관리자.</A>
 <li><A href="../">Debian GNU/Linux 홈 페이지.</A>

</ul>

<hr>
<address>
Darren Benham
 /
<A href="mailto:owner@bugs.debian.org">owner@bugs.debian.org</A>.
12 Sep 1999.
<p>
Debian bug tracking system<BR>
copyright 1999 Darren O. Benham,
1994-7 Ian Jackson, 1997 nCipher Corporation Ltd,
1995 Steven Brenner.<BR>
<A href="http://www.benham.net/debbugs/">Available under the GPL.</A>
</address>

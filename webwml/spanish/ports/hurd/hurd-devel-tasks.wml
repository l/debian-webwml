#use wml::debian::template title="Debian GNU/Hurd --- Desarrollo" NOHEADER="yes"
#use wml::debian::translation-check translation="1.10" 
[ <a href="..">Arquitecturas</a> ]
[ <a href="index">Debian GNU/Hurd</a> ]
[ <a href="hurd-news">Noticias</a> ]
[ <a href="hurd-install">Instalación</a> ]
[ <a href="hurd-cd">CDes del Hurd</a> ]
[ <a href="hurd-doc">Documentación</a> ]
[ <a href="hurd-devel">Desarrollo</a> ]
[ <a href="hurd-links">Enlaces</a> ]
[ <a href="hurd-contact">Contacto</a> ]<p>

<h1>
Debian GNU/Hurd</h1>
<h2>
Errores Conocidos o Limitaciones</h2>
<p>
Aquí se presenta una lista rápida de errores visibles para el usuario
conocidos y limitaciones. Puede estar anticuada. No son listas oficiales. 
Estas listas son fundamentalmente para mí, para que no olvide 
cosas importantes.
</p>
<ul>
<li>
GNU Mach
<ul>
<li>
No hay soporte para los Dispositivos de Caracteres de Linux (necesario para X).
Sin embargo, hay disponibles <a
href="ftp://alpha.gnu.org/gnu/hurd/contrib/marcus/">parches experimentales
</a>.</li>
<li>
El
<a href="#fpe" name="TOC_fpe">código de emulación de coma flotante</a> está
roto y no es libre. Se debería portar el FPE de Linux.</li>
<li>
Usar Corba en lugar de MiG (¿?).</li>
<li>
La lista de tareas oficial del CVS:
<ul>
<li>
¡¡¡!!! Los gestores de dispositivo serie de Mach 3.0 soportan sólo un pequeño
subconjunto de las posibilidades disponibles en los campos termios c_cflag
Posix. Arreglar esto, añadiendo una nueva llamada device_set_status que
establezca todo y no sólo las posibilidades limitadas antiguas.</li>
<li>
¡¡¡!!! El Mach 3.0 necesita muchos nuevos gestores de dispositivos para
dispositivos populares del PC.
Shantanu Goel está trabajando en este área; coordinarse con él.</li>
<li>
¡¡¡!!! Un sustituto de MiG que comprenda los archivos .h del C.</li>
<li>
¡¡¡!!! El Mach 3.0 necesita proporcionar soporte para temporizadores virtuales
de tareas similares en función a los ITIMER_PROF y ITIMER_VIRTUAL de Unix.</li>
<li>
¡¡¡!!! El Mach 3.0 necesita hacer que los cambios desde MEMORY_OBJECT_COPY_DELAY
a MEMORY_OBJECT_COPY_NONE tengan el efecto de completar cualquier copia
postergada.</li>
<li>
El Mach 3.0 necesita un medio de envío automático del estado de las tareas
e hilos en el exit de las tareas/hilos a un puerto que sólo pueda cambiar
un usuario privilegiado; esto se podría usar para implementar el recuento
de procesos>
<li>
El Mach 3.0 necesita un medio de determinar que tarea es la madre de una
tarea dada.</li>
<li>
El Mach 3.0 necesita un medio de determinar que páginas del espacio de 
direcciones de una tarea están en el núcleo para implementar la 
llamada de Unix mincore.</li>
<li>
El Mach 3.0 necesita un medio de hacer msync.</li>
<li>
El Mach de Utah necesita la llamada vm_remap OSF.</li>
<li>
El Mach 3.0 necesita un sustituto de MEMORY_OBJECT_COPY_CALL
que funcione al menos para los casos requeridos por los archivos
ordinarios. (Escríbale a Thomas si quiere saber cuál es el problema
y algunas ideas acerca de cómo solucionarlo.)</li>
<li>
¡¡¡!!! El Mach 3.0 necesita objetos representantes de memoria. (Thomas
puede decrile qué son y por qué son importantes.)</li>
<li>
El Mach 3.0 necesita un modo de realizar contadores de recursos por
tarea que sean accesibles para los servidores a los que llame la tarea.</li>
<li>
El Mach 3.0 necesita medios para implementar la limitación de recursos
de varios tipos.</li>
<li>
El Mach 3.0 necesita un modo de tener estadísticas de tiempo de CPU de
un hilo, incluyendo el tiempo que los servidores emplean en atenderle. [
Esto se ha hecho para la versión de Mach con hilos migratorios; hable con
Thomas antes de empezar a trabajar en ello.]</li>
<li>
Por supuesto, siempre se necesitan versiones libres para máquinas que
no la tienen todavía.</li>
<li>
Se puede hacer mucho trabajo de investigación acerca de cómo mejorar
las prestaciones de la VM de Mach y la política de planificación con
tiempo compartido.</li>
<li>
El Mach 3.0 necesita medios para obtener una lista de todos los 
dispositivos que pueden ser abiertos con open, así como para obtener 
el tipo de un dispositivo.</li>
<li>
Un modo de hacer que el núcleo envíe un mensaje a algún puerto designado
cada vez que se inicie una nueva tarea.</li>
<li>
El OSF ha mejorado el protocolo de elevación de excepciones (exception_raise)
para incluir la información de estado del hilo (thread_state)
information. Se debería introducir este código en el núcleo; la gente de
OSF han dicho que lo podrían distribuir públicamente (pero no ha
aparecido).</li>
<li>
Implementar TASK_EVENTS_INFO.</li>
<li>
Añadir un matasellos para la creación de tareas e hilos para las 
estructuras de información relevante (y asegurar que funciona
para las tareas e hilos del núcleo).</li>
<li>
Añadir estadísticas de asignación de intercambio anónimas a la estructura
de información de las tareas.</li></ul></li></ul>

<li>GNU Hurd
<ul>
<li>
El tamaño de las particiones de discos está limitado por el mapa de
memoria (alrededor de 1 GB) (Thomas trabajó algo en ello).
<li>
Soporte para múltiples interfaces de red. (Hay disponible un parche
que ha de evaluar Thomas).
<li>
No hay PPP.
<li>
Se necesita trazar perfiles de prestaciones.
<li>
Reunir errores del servidor <code>nfsd</code>. Funciona parcialmente,
pero definitivamente hay problemas con él.
<li>
El servidor exec no puede ejecutar los binarios gzip y bzip. No se sabe
nada acerca de este error. No parece que sea un error del propio servidor
exec, porque parece que descomprime e inicia el programa. OKUJI dice que
<code>S_exec_exec</code> termina satisfactoriamente.
<li>
Proporcionar un modo de obtener todos los sistemas de archivo montados
del Hurd (y escribir un traductor para <code>/var/run/mtab</code>).
<li>
La lista oficial de tareas del Hurd fresca desde el CVS (3 de Julio de 1999):
<ul>
<li>
Hacer cualquier magia necesaria para que Perl saque ventaja de todas
las maravillosas característica de Hurd que no tiene Unix.</li>
<li>
Algo para tratar los casos en los que el reloj del sistema está en
hora local en lugar de UCT. Linux ya lo hace; nosotros también 
deberíamos.</li>
<li>
Hacer que funcione el tiempo máximo de espera de libports/manage-multithread.c.</li>
<li>
Hacer que la muerte de hilos de los hilos C libere los recursos realmente.</li>
<li>
¡¡¡!!! Un programa de trazas de RPC para ayudar a la depuración. Preguntar a
Roland para más información.
[ MB: Hay un programa rpctrace en la distribución, comprobarlo y mejorarlo.]</li>
<li>
Hay que cambiar los programas que usan utmp para usar /utmp y
utmp.defs.</li>
<li>
Necesitamos algunos traductores estándar para los nodos /utmp nodes;
sobre todo uno para los terminales ordinarios (establecidos por login)
y uno para los displays X (establecidos por xdm).</li>
<li>
¡¡¡!!! Necesitamos cambiar algunos programas del shell existentes para
hacer cosas del Hurd: como ls, tar, cpio, etc. Ya se ha hecho algo 
de este trabajo, pero todavía se necesita más.</li>
<li>
¡¡¡!!! Ampliar bash para llamar a las funciones del shell cuando
ocurran varios sucesos asíncronos del Hurd.</li>
<li>
Manipular programas del shell para enviar mensajes msgport msgs, 
y cambiar los puertos e interrupciones por defecto de init.</li>
<li>
Traductores de directorios sombra.</li>
<li>
Un sistema para que write, send, talkd y esos reconozcan a los 
usuarios; esto se debería integrar con el sustituto de utmp
de arriba.</li>
<li>
Un sistema de archivos para  /tmp que use memoria virtual en lugar de disco
(Roland tiene algunas ideas sobre esto.)</li>
<li>
Implementación de sistemas de archivos (usando libdiskfs) para otros
formatos populares. Es importante el format MSDOS FAT.</li>
<li>
Un maravilloso gestor de terminales que use readline y soporte
detach/attach.</li>
<li>
Un programa block de notas para mantener y seguir la pista de los
puertos para los guiones del shell.</li></ul></li></ul>

<li>GNU Lib C
<ul>
<li>
¡Hilos POSIX! (Mark Kettenis está trabajando en esto)</li>
<li>
Bloqueo de archivos POSIX (parcial).</li>
<li>
¡Herramientas de monitorización de red!</li>
<li>
&lt;net/*.h&gt; y soporte para esas ioctls().</li>
<li>
Implementar código para los esqueletos de
<code>gnu/stubs.h</code></li>
<li>
La lista oficial de tareas:
<p>Trabajo en la biblioteca de C.  Véase roland@gnu.ai.mit.edu si está 
interesado en algo acerca de la biblioteca de C.
<ul>
<li>
Respuesta útil a SIGINFO.
<li>
Mejor integración de los cthreads.</li></ul></li></ul>

<li>Debian
<ul>
<li>
Emulación del init de SysV. (casi hecho).</li>
<li>
Adaptar el <code>syslogd</code> de Linux.</li>
<li>
Adaptar <a href="#fdisk" name="TOC_fdisk"><code>fdisk</code></a>.</li>
<li>
Gestión de arquitecturas más inteligente por medio de Depends.</li>
<li>
<a href="hurd-devel-debian">Adaptar más paquetes</a>.</li>
</ul>
<li>GRUB
<ul>
<li>
soporte de iso9660 para los CDes de instalación.</li>
</ul>
</ul>

<h2>
Más Información Acerca De Tareas Particulares</h2>
<h3>
Mach de GNU</h3>

<h4><a href="#TOC_fpe" name="fpe">Código de Emulación de Coma Flotante</a></h4>
<p>
El Mach GNU contiene actualmente un emulador de coma flotante propiedad
de Intel. No tenemos el código fuente de él (<code>fpe.o</code> está
decodificado de <code>gnumach/i386/i386/fpe.b_elf</code>).  Incluso peor,
no funciona. <code>:(</code></p>
<p>
Esta es la razón por la que las máquinas sin FPU (tales como las 
máquinas 486SX) no pueden arrancar el Hurd. Si alguien tiene tiempo
o energías para adaptar los fpus de Linux o BSD, por favor, que lo
haga... esta podría ser una contribución valiosa que permitiría 
ejecutar el Hurd a
gente con hardware viejo (que constituye segundas máquinas baratas).</p>
<p>
Si desea ocuparse de este trabajo, por favor, envíe una carta a la <a
href="hurd-contact">lista de desarrolladores</a> o a <a
href="mailto:gord@trick.fig.org">Gordon Matzigkeit</a> si le gusta
más discutirlo de forma privada.</p>

<h3>
Debian</h3>

<h4><a href="#TOC_fdisk" name="fdisk"><code>fdisk</code></a></h4>
<p>
Hay una versión vieja de <code>fdisk</code> en alpha.gnu.org, pero no 
se debería usar más. Yoshinori dice:</p>
<p><blockquote>
<code>fdisk</code> no detecta la geometría de una unidad automáticamente,
y el <code>fdisk</code> original es bastante antiguo. Creo que
<code>storeio</code> debería soportar la llamada <code>V_GETPARMS
device_get_status</code> y, entonces, <code>fdisk</code> debería usar
la llamada para detectar la geometría antes de que hagas el paquete
 <code>fdisk</code>, porque eso podría crear problemas si el usuario
establece la geometría de forma manual.</p>
</blockquote>

<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from hurd.texi on 29 June 1999 -->

<TITLE>Hurd Reference Manual - Input and Output</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="hurd_1.html">first</A>, <A HREF="hurd_5.html">previous</A>, <A HREF="hurd_7.html">next</A>, <A HREF="hurd_17.html">last</A> section, <A HREF="hurd_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC33" HREF="hurd_toc.html#TOC33">Input and Output</A></H1>

<P>
There are no specific programs or servers associated with the I/O
subsystem, since it is used to interact with almost all servers in the
GNU Hurd.  It provides facilities for reading and writing I/O channels,
which are the underlying implementation of file and socket descriptors
in the GNU C library.




<H2><A NAME="SEC34" HREF="hurd_toc.html#TOC34">Iohelp Library</A></H2>
<P>
<A NAME="IDX71"></A>
<A NAME="IDX72"></A>


<P>
The <CODE>&#60;hurd/iohelp.h&#62;</CODE> file declares several functions which are
useful for low-level I/O implementations.  Most Hurd servers do not call
these functions directly, but they are used by several of the Hurd
filesystem and networking helper libraries.  <CODE>libiohelp</CODE> requires
<CODE>libthreads</CODE>.




<H3><A NAME="SEC35" HREF="hurd_toc.html#TOC35">I/O Users</A></H3>

<P>
Most I/O servers need to implement some kind of user authentication
checking.  In order to facilitate that process, <CODE>libiohelp</CODE> has
some functions which encapsulate a set of idvecs (FIXME: xref to C
library) in a single <CODE>struct iouser</CODE>.


<P>
<DL>
<DT><U>Function:</U> struct iouser * <B>iohelp_create_iouser</B> <I>(struct idvec *<VAR>uids</VAR>, struct idvec *<VAR>gids</VAR>)</I>
<DD><A NAME="IDX73"></A>
Create a new <VAR>iouser</VAR> for the specified <VAR>uids</VAR> and <VAR>gids</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> struct iouser * <B>iohelp_dup_iouser</B> <I>(struct iouser *<VAR>iouser</VAR>)</I>
<DD><A NAME="IDX74"></A>
Return a copy of <VAR>iouser</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>iohelp_free_iouser</B> <I>(struct iouser *<VAR>iouser</VAR>)</I>
<DD><A NAME="IDX75"></A>
Release a reference to <VAR>iouser</VAR>.
</DL>


<P>
I/O reauthentication is a rather complex protocol involving the
authserver as a trusted third party (see section <A HREF="hurd_16.html#SEC146">Auth Protocol</A>).  In order
to reduce the risk of flawed implementations, I/O reauthentication is
encapsulated in the <CODE>iohelp_reauth</CODE> function:


<P>
<DL>
<DT><U>Function:</U> struct iouser * <B>iohelp_reauth</B> <I>(auth_t <VAR>authserver</VAR>, mach_port_t <VAR>rend_port</VAR>, mach_port_t <VAR>newright</VAR>, int <VAR>permit_failure</VAR>)</I>
<DD><A NAME="IDX76"></A>
Conduct a reauthentication transaction, and return a new <VAR>iouser</VAR>.
<VAR>authserver</VAR> is the I/O server's auth port.  The rendezvous port
provided by the user is <VAR>rend_port</VAR>.


<P>
If the transaction cannot be completed, return zero, unless
<VAR>permit_failure</VAR> is nonzero.  If <VAR>permit_failure</VAR> is nonzero,
then should the transaction fail, return an <VAR>iouser</VAR> that has no
ids.  The new port to be sent to the user is <VAR>newright</VAR>.
</DL>




<H3><A NAME="SEC36" HREF="hurd_toc.html#TOC36">Conch Management</A></H3>

<P>
<A NAME="IDX77"></A>
<A NAME="IDX78"></A>
<A NAME="IDX79"></A>
<A NAME="IDX80"></A>
<A NAME="IDX81"></A>
<A NAME="IDX82"></A>
<A NAME="IDX83"></A>
<A NAME="IDX84"></A>
The <EM>conch</EM> is at the heart of the shared memory I/O system.
Several Hurd libraries implement shared I/O, and so <CODE>libiohelp</CODE>
contains functions to facilitate conch management.


<P>
Everything about shared I/O is undocumented because it is not needed for
adequate performance, and the RPC interface is simpler (see section <A HREF="hurd_6.html#SEC40">I/O Interface</A>).  It is not useful for new libraries or servers to implement
shared I/O.




<H2><A NAME="SEC37" HREF="hurd_toc.html#TOC37">Pager Library</A></H2>
<P>
<A NAME="IDX85"></A>
<A NAME="IDX86"></A>


<P>
<A NAME="IDX87"></A>
<A NAME="IDX88"></A>
The <EM>external pager</EM> (<EM>XP</EM>) microkernel interface allows
applications to provide the backing store for a memory object, by
converting hardware page faults into RPC requests.  External pagers are
required for memory-mapped I/O (see section <A HREF="hurd_6.html#SEC46">Mapped Data</A>) and stored
filesystems (see section <A HREF="hurd_10.html#SEC101">Stored Filesystems</A>).


<P>
The external pager interface is quite complex, so the Hurd pager library
contains functions which aid in creating multithreaded external pagers.
<CODE>libpager</CODE> is declared in <CODE>&#60;hurd/pager.h&#62;</CODE>, and requires only
the threads and ports libraries.




<H3><A NAME="SEC38" HREF="hurd_toc.html#TOC38">Pager Management</A></H3>

<P>
The pager library defines the <CODE>struct pager</CODE> data type in order to
represent a multi-threaded pager.  The general procedure for creating a
pager is to define the functions listed in section <A HREF="hurd_6.html#SEC39">Pager Callbacks</A>,
allocate a <CODE>libports</CODE> bucket for the ports which will access the
pager, and create at least one new <CODE>struct pager</CODE> with
<CODE>pager_create</CODE>.


<P>
<DL>
<DT><U>Function:</U> struct pager * <B>pager_create</B> <I>(struct user_pager_info *<VAR>u_pager</VAR>, struct port_bucket *<VAR>bucket</VAR>, boolean_t <VAR>may_cache</VAR>, memory_object_copy_strategy_t <VAR>copy_strategy</VAR>)</I>
<DD><A NAME="IDX89"></A>
Create a new pager.  The pager will have a port created for it (using
<CODE>libports</CODE>, in <VAR>bucket</VAR>) and will be immediately ready to
receive requests.  <VAR>u_pager</VAR> will be provided to later calls to
<CODE>pager_find_address</CODE>.  The pager will have one user reference
created.  <VAR>may_cache</VAR> and <VAR>copy_strategy</VAR> are the original
values of those attributes as for <CODE>memory_object_ready</CODE>.  Users may
create references to pagers by use of the relevant ports library
functions.  On errors, return null and set <CODE>errno</CODE>.
</DL>


<P>
Once you are ready to turn over control to the pager library, you should
call <CODE>ports_manage_port_operations_multithread</CODE> on the
<VAR>bucket</VAR>, using <CODE>pager_demuxer</CODE> as the ports <VAR>demuxer</VAR>.
This will handle all external pager RPCs, invoking your pager callbacks
when necessary.


<P>
<DL>
<DT><U>Function:</U> int <B>pager_demuxer</B> <I>(mach_msg_header_t *<VAR>inp</VAR>, mach_msg_header_t *<VAR>outp</VAR>)</I>
<DD><A NAME="IDX90"></A>
Demultiplex incoming <CODE>libports</CODE> messages on pager ports.
</DL>


<P>
The following functions are the body of the pager library, and provide a
clean interface to pager functionality:


<P>
<DL>
<DT><U>Function:</U> void <B>pager_sync</B> <I>(struct pager *<VAR>pager</VAR>, int <VAR>wait</VAR>)</I>
<DD><A NAME="IDX91"></A>
<DT><U>Function:</U> void <B>pager_sync_some</B> <I>(struct pager *<VAR>pager</VAR>, vm_address_t <VAR>start</VAR>, vm_size_t <VAR>len</VAR>, int <VAR>wait</VAR>)</I>
<DD><A NAME="IDX92"></A>
Write data from pager <VAR>pager</VAR> to its backing store.  Wait for all
the writes to complete if and only if <VAR>wait</VAR> is set.


<P>
<CODE>pager_sync</CODE> writes all data; <CODE>pager_sync_some</CODE> only writes
data starting at <VAR>start</VAR>, for <VAR>len</VAR> bytes.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>pager_flush</B> <I>(struct pager *<VAR>pager</VAR>, int <VAR>wait</VAR>)</I>
<DD><A NAME="IDX93"></A>
<DT><U>Function:</U> void <B>pager_flush_some</B> <I>(struct pager *<VAR>pager</VAR>, vm_address_t <VAR>start</VAR>, vm_size_t <VAR>len</VAR>, int <VAR>wait</VAR>)</I>
<DD><A NAME="IDX94"></A>
Flush data from the kernel for pager <VAR>pager</VAR> and force any pending
delayed copies.  Wait for all pages to be flushed if and only if
<VAR>wait</VAR> is set.


<P>
<CODE>pager_flush</CODE> flushes all data; <CODE>pager_flush_some</CODE> only
flushes data starting at <VAR>start</VAR>, for <VAR>len</VAR> bytes.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>pager_return</B> <I>(struct pager *<VAR>pager</VAR>, int <VAR>wait</VAR>)</I>
<DD><A NAME="IDX95"></A>
<DT><U>Function:</U> void <B>pager_return_some</B> <I>(struct pager *<VAR>pager</VAR>, vm_address_t <VAR>start</VAR>, vm_size_t <VAR>len</VAR>, int <VAR>wait</VAR>)</I>
<DD><A NAME="IDX96"></A>
Flush data from the kernel for pager <VAR>pager</VAR> and force any pending
delayed copies.  Wait for all pages to be flushed if and only if
<VAR>wait</VAR> is set.  Have the kernel write back modifications.


<P>
<CODE>pager_return</CODE> flushes and restores all data;
<CODE>pager_return_some</CODE> only flushes and restores data starting at
<VAR>start</VAR>, for <VAR>len</VAR> bytes.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>pager_offer_page</B> <I>(struct pager *<VAR>pager</VAR>, int <VAR>precious</VAR>, int <VAR>writelock</VAR>, vm_offset_t <VAR>page</VAR>, vm_address_t <VAR>buf</VAR>)</I>
<DD><A NAME="IDX97"></A>
Offer a page of data to the kernel.  If <VAR>precious</VAR> is set, then this
page will be paged out at some future point, otherwise it might be
dropped by the kernel.  If the page is currently in core, the kernel
might ignore this call.
</DL>


<P>
attributes@deftypefun void pager_change_attributes (struct pager *<VAR>pager</VAR>, boolean_t <VAR>may_cache</VAR>, memory_object_copy_strategy_t <VAR>copy_strategy</VAR>, int <VAR>wait</VAR>)
Change the attributes of the memory object underlying pager <VAR>pager</VAR>.
The <VAR>may_cache</VAR> and <VAR>copy_strategy</VAR> arguments are as for
<CODE>memory_object_change_</CODE>.  Wait for the kernel to report
completion if and only if <VAR>wait</VAR> is set.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>pager_shutdown</B> <I>(struct pager *<VAR>pager</VAR>)</I>
<DD><A NAME="IDX98"></A>
Force termination of a pager.  After this returns, no more paging
requests on the pager will be honoured, and the pager will be
deallocated.  The actual deallocation might occur asynchronously if
there are currently outstanding paging requests that will complete
first.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>pager_get_error</B> <I>(struct pager *<VAR>p</VAR>, vm_address_t <VAR>addr</VAR>)</I>
<DD><A NAME="IDX99"></A>
Return the error code of the last page error for pager <VAR>p</VAR> at
address <VAR>addr</VAR>.<A NAME="DOCF5" HREF="hurd_foot.html#FOOT5">(5)</A>
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>pager_memcpy</B> <I>(struct pager *<VAR>pager</VAR>, memory_object_t <VAR>memobj</VAR>, vm_offset_t <VAR>offset</VAR>, void *<VAR>other</VAR>, size_t *<VAR>size</VAR>, vm_prot_t <VAR>prot</VAR>)</I>
<DD><A NAME="IDX100"></A>
Try to copy <CODE>*<VAR>size</VAR></CODE> bytes between the region <VAR>other</VAR>
points to and the region at <VAR>offset</VAR> in the pager indicated by
<VAR>pager</VAR> and <VAR>memobj</VAR>.  If <VAR>prot</VAR> is <CODE>VM_PROT_READ</CODE>,
copying is from the pager to <VAR>other</VAR>; if <VAR>prot</VAR> contains
<CODE>VM_PROT_WRITE</CODE>, copying is from <VAR>other</VAR> into the pager.
<CODE>*<VAR>size</VAR></CODE> is always filled in with the actual number of bytes
successfully copied.  Returns an error code if the pager-backed memory
faults; if there is no fault, returns zero and <CODE>*<VAR>size</VAR></CODE> will
be unchanged.
</DL>


<P>
These functions allow you to recover the internal <CODE>struct pager</CODE>
state, in case the <CODE>libpager</CODE> interface doesn't provide an
operation you need:


<P>
<DL>
<DT><U>Function:</U> struct user_pager_info * <B>pager_get_upi</B> <I>(struct pager *<VAR>p</VAR>)</I>
<DD><A NAME="IDX101"></A>
Return the <CODE>struct user_pager_info</CODE> associated with a pager.
</DL>


<P>
<DL>
<DT><U>Function:</U> mach_port_t <B>pager_get_port</B> <I>(struct pager *<VAR>pager</VAR>)</I>
<DD><A NAME="IDX102"></A>
Return the port (receive right) for requests to the pager.  It is
absolutely necessary that a new send right be created from this receive
right.
</DL>




<H3><A NAME="SEC39" HREF="hurd_toc.html#TOC39">Pager Callbacks</A></H3>

<P>
Like several other Hurd libraries, <CODE>libpager</CODE> depends on you to
implement application-specific callback functions.  You <EM>must</EM>
define the following functions:


<P>
<DL>
<DT><U>Function:</U> error_t <B>pager_read_page</B> <I>(struct user_pager_info *<VAR>pager</VAR>, vm_offset_t <VAR>page</VAR>, vm_address_t *<VAR>buf</VAR>, int *<VAR>write_lock</VAR>)</I>
<DD><A NAME="IDX103"></A>
For pager <VAR>pager</VAR>, read one page from offset <VAR>page</VAR>.  Set
<CODE>*<VAR>buf</VAR></CODE> to be the address of the page, and set
<CODE>*<VAR>write_lock</VAR></CODE> if the page must be provided read-only.  The
only permissible error returns are <CODE>EIO</CODE>, <CODE>EDQUOT</CODE>, and
<CODE>ENOSPC</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>pager_write_page</B> <I>(struct user_pager_info *<VAR>pager</VAR>, vm_offset_t <VAR>page</VAR>, vm_address_t <VAR>buf</VAR>)</I>
<DD><A NAME="IDX104"></A>
For pager <VAR>pager</VAR>, synchronously write one page from <VAR>buf</VAR> to
offset <VAR>page</VAR>.  In addition, <CODE>vm_deallocate</CODE> (or equivalent)
<VAR>buf</VAR>.  The only permissible error returns are <CODE>EIO</CODE>,
<CODE>EDQUOT</CODE>, and <CODE>ENOSPC</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>pager_unlock_page</B> <I>(struct user_pager_info *<VAR>pager</VAR>, vm_offset_t <VAR>address</VAR>)</I>
<DD><A NAME="IDX105"></A>
A page should be made writable.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>pager_report_extent</B> <I>(struct user_pager_info *<VAR>pager</VAR>, vm_address_t *<VAR>offset</VAR>, vm_size_t *<VAR>size</VAR>)</I>
<DD><A NAME="IDX106"></A>
This function should report in <CODE>*<VAR>offset</VAR></CODE> and
<CODE>*<VAR>size</VAR></CODE> the minimum valid address the pager will accept and
the size of the object.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>pager_clear_user_data</B> <I>(struct user_pager_info *<VAR>pager</VAR>)</I>
<DD><A NAME="IDX107"></A>
This is called when a pager is being deallocated after all extant send
rights have been destroyed.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>pager_dropweak</B> <I>(struct user_pager_info *<VAR>p</VAR>)</I>
<DD><A NAME="IDX108"></A>
This will be called when the ports library wants to drop weak
references.  The pager library creates no weak references itself, so if
the user doesn't either, then it is all right for this function to do
nothing.
</DL>




<H2><A NAME="SEC40" HREF="hurd_toc.html#TOC40">I/O Interface</A></H2>
<P>
<A NAME="IDX109"></A>


<P>
The I/O interface facilities are described in <CODE>&#60;hurd/io.defs&#62;</CODE>.
This section discusses only RPC-based I/O operations.<A NAME="DOCF6" HREF="hurd_foot.html#FOOT6">(6)</A>




<H3><A NAME="SEC41" HREF="hurd_toc.html#TOC41">I/O Object Ports</A></H3>

<P>
The I/O server must associate each I/O port with a particular set of
uids and gids, identifying the user who is responsible for operations on
the port.  Every port to an I/O server should also support either the
file protocol (see section <A HREF="hurd_7.html#SEC64">File Interface</A>) or the socket protocol
(see section <A HREF="hurd_13.html#SEC130">Socket Interface</A>); naked I/O ports are not allowed.


<P>
In addition, the server associates with each port a default file
pointer, a set of open mode bits, a pid (called the "owner"), and some
underlying object which can absorb data (for write) or provide data (for
read).


<P>
The uid and gid sets associated with a port may not be visibly shared
with other ports, nor may they ever change.  The server must fix the
identification of a set of uids and gids with a particular port at the
moment of the port's creation.  The other characteristics of an I/O port
may be shared with other users.  The I/O server interface does not
generally specify the way in which servers may share these other
characteristics (with the exception of the deprecated
<CODE>O_ASYNC</CODE> interface); however, the file and socket interfaces make
further requirements about what sharing is required and what sharing is prohibited.


<P>
In general, users get send rights to I/O ports by some mechanism that is
external to the I/O protocol.  (For example, fileservers give out I/O
ports in response to the <CODE>dir_lookup</CODE> and <CODE>fsys_getroot</CODE>
calls.  Socket servers give out ports in response to the
<CODE>socket_create</CODE> and <CODE>socket_accept</CODE> calls.)  However, the I/O
protocol provides methods of obtaining new ports that refer to the same
underlying object as another port.  In response to all of these calls,
all underlying state (including, but not limited to, the default file
pointer, open mode bits, and underlying object) must be shared between
the old and new ports.  In the following descriptions of these calls,
the term "identical" means this kind of sharing.  All these calls must
return send rights to a newly-constructed Mach port.


<P>
<A NAME="IDX110"></A>
The <CODE>io_duplicate</CODE> call simply returns another port which is
identical to an existing port and has the same uid and gid set.


<P>
<A NAME="IDX111"></A>
The <CODE>io_restrict_auth</CODE> call returns another port, identical to the
provided port, but which has a smaller associated uid and gid set.  The
uid and gid sets of the new port are the intersection of the set on the
existing port and the lists of uids and gids provided in the call.


<P>
<A NAME="IDX112"></A>
Users use the <CODE>io_reauthenticate</CODE> call when they wish to have an
entirely new set of uids or gids associated with a port.  In response to
the <CODE>io_reauthenticate</CODE> call, the server must create a new port,
and then make the call <CODE>auth_server_authenticate</CODE> to the auth
server.  The rendezvous port for the <CODE>auth_server_authenticate</CODE>
call is the I/O port to which was made the <CODE>io_reauthenticate</CODE>
call.  The server provides the <VAR>rend_int</VAR> parameter to the auth
server as a copy from the corresponding parameter in the
<CODE>io_reauthenticate</CODE> call.  The I/O server also gives the auth
server a new port; this must be a newly created port identical to the
old port.  The authserver will return the set of uids and gids
associated with the user, and guarantees that the new port will go
directly to the user that possessed the associated authentication port.
The server then identifies the new port given out with the specified
ID's.




<H3><A NAME="SEC42" HREF="hurd_toc.html#TOC42">Simple Operations</A></H3>

<P>
<A NAME="IDX113"></A>
Users write to I/O ports by calling the <CODE>io_write</CODE> RPC.  They
specify an <VAR>offset</VAR> parameter; if the object supports writing at
arbitrary offsets, the server should honour this parameter.  If <EM>-1</EM>
is passed as the offset, then the server should use the default file
pointer.  The server should return the amount of data which was
successfully written.  If the operation was interrupted after some but
not all of the data was written, then it is considered to have succeeded
and the server should return the amount written.  If the port is not an
I/O port at all, the server should reply with the error
<CODE>EOPNOTSUPP</CODE>.  If the port is an I/O port, but does not happen to
support writing, then the correct error is <CODE>EBADF</CODE>.


<P>
<A NAME="IDX114"></A>
Users read from I/O ports by calling the <CODE>io_read</CODE> RPC.  They
specify the amount of data they wish to read, and the offset.  The offset
has the same meaning as for <CODE>io_write</CODE> above.  The server should
return the data that was read.  If the call is interrupted after some
data has been read (and the operation is not idempotent) then the server
should return the amount read, even if it was less than the amount requested.
The server should return as much data as possible, but never more than
requested by the user.  If there is no data, but there might be later,
the call should block until data becomes available.  The server indicates
end-of-file by returning zero bytes.  If the call is
interrupted after some data has been read, but the call is idempotent,
then the server may return <CODE>EINTR</CODE> rather than actually filling the
buffer (taking care that any modifications of the default file pointer
have been reversed).  Preferably, however, servers should return data.


<P>
There are two categories of objects: seekable and non-seekable.
Seekable objects must accept arbitrary offset parameters in the
<CODE>io_read</CODE> and <CODE>io_write</CODE> calls, and must implement the
<CODE>io_seek</CODE> call.  Non-seekable objects must ignore the offset
parameters to <CODE>io_read</CODE> and <CODE>io_write</CODE>, and should return
<CODE>ESPIPE</CODE> to the <CODE>io_seek</CODE> call.


<P>
<A NAME="IDX115"></A>
On seekable objects, <CODE>io_seek</CODE> changes the default file pointer for
reads and writes.  (See section `File Positioning' in <CITE>The GNU C Library Reference Manual</CITE>,
for the interpretation of the <VAR>whence</VAR> and <VAR>offset</VAR> arguments.)
It returns the new offset as modified by <CODE>io_seek</CODE>.


<P>
<A NAME="IDX116"></A>
The <CODE>io_readable</CODE> interface returns the amount of data which can be
immediately read.  For the special technical meaning of "immediately",
see section <A HREF="hurd_6.html#SEC44">Asynchronous I/O</A>.




<H3><A NAME="SEC43" HREF="hurd_toc.html#TOC43">Open Modes</A></H3>

<P>
<A NAME="IDX117"></A>
<A NAME="IDX118"></A>
<A NAME="IDX119"></A>
<A NAME="IDX120"></A>
The server associates each port with a set of bits that affect its
operation.  The <CODE>io_set_all_openmodes</CODE> call modifies these bits and
the <CODE>io_get_openmodes</CODE> call returns them.  In addition, the
<CODE>io_set_some_openmodes</CODE> and <CODE>io_clear_some_openmodes</CODE> do an
atomic read/modify/write of the openmodes.


<P>
The <CODE>O_APPEND</CODE> bit, when set, changes the behaviour of
<CODE>io_write</CODE> when it uses the default file pointer on seekable
objects.  When <CODE>io_write</CODE> is done on a port with the
<CODE>O_APPEND</CODE> bit set, is must set the file pointer to the current
file size before doing the write (which would then increment the file
pointer as usual).  The <EM>current file size</EM> is the smallest offset
which returns end-of-file when provided to <CODE>io_read</CODE>.  The server
must atomically bind this update to the actual data write with respect
to other users of <CODE>io_read</CODE>, <CODE>io_write</CODE>, and <CODE>io_seek</CODE>.


<P>
The <CODE>O_FSYNC</CODE> bit, when set, guarantees that <CODE>io_write</CODE> will
not return until data is fully written to the underlying medium.


<P>
The <CODE>O_NONBLOCK</CODE> bit, when set, prevents read and write from
blocking.  They should copy such data as is immediately available.  If
no data is immediately available they should return <CODE>EWOULDBLOCK</CODE>.


<P>
The definition of "immediately" is more or less server-dependent.
Some servers, notably stored filesystem servers (see section <A HREF="hurd_10.html#SEC101">Stored Filesystems</A>), regard all data as immediately available.  The one
criterion is that something which must happen <EM>immediately</EM> may not
wait for any user-synchronizable event.


<P>
The <CODE>O_ASYNC</CODE> bit is deprecated; its use is documented in the
following section.  This bit must be shared between all users of the
same underlying object.




<H3><A NAME="SEC44" HREF="hurd_toc.html#TOC44">Asynchronous I/O</A></H3>

<P>
<A NAME="IDX121"></A>
Users may wish to be notified when I/O can be done without blocking;
they use the <CODE>io_async</CODE> call to indicate this to the server.  In
the <CODE>io_async</CODE> call the user provides a port on which will the
server should send <CODE>sig_post</CODE> messages as I/O becomes possible.
The server must return a port which will be the reference port in the
<CODE>sig_post</CODE> messages.  Each <CODE>io_async</CODE> call should generate a
new reference port.  (FIXME: xref the C library manual for information
on how to send sig_post messages.)


<P>
The server then sends one <CODE>SIGIO</CODE> signal to each registered async
user everytime I/O becomes possible.  I/O is possible if at least one
byte can be read or written immediately.  The definition of
"immediately" must be the same as for the implementation of the
<CODE>O_NONBLOCK</CODE> flag (see section <A HREF="hurd_6.html#SEC43">Open Modes</A>).  In addition, every time a
user calls <CODE>io_read</CODE> or <CODE>io_write</CODE> on a non-seekable object, or at the
default file pointer on a seekable object, another signal should be sent
to each user if I/O is still possible.


<P>
Some objects may also define "urgent" conditions.  Such servers should
send the <CODE>SIGURG</CODE> signal to each registered async user anytime an
urgent condition appears.  After any RPC that has the possibility of
clearing the urgent condition, the server should again send the signal
to all registered users if the urgent condition is still present.


<P>
<A NAME="IDX122"></A>
A more fine-grained mechanism for doing async I/O is the
<CODE>io_select</CODE> call.  The user specifies the kind of access desired,
and a send-once right.  If I/O of the kind the user desires is
immediately possible, then the server should return so indicating, and
destroy the send-once right.  If I/O is not immediately possible, the
server should save the send-once right, and send a <CODE>select_done</CODE>
message as soon as I/O becomes immediately possible.  Again, the
definition of "immediately" must be the same for <CODE>io_select</CODE>,
<CODE>io_async</CODE>, and <CODE>O_NONBLOCK</CODE> (see section <A HREF="hurd_6.html#SEC43">Open Modes</A>).


<P>
<A NAME="IDX123"></A>
<A NAME="IDX124"></A>
<A NAME="IDX125"></A>
For compatibility with 4.2 and 4.3 BSD, the I/O interface provides a
deprecated feature (known as <EM>icky async I/O</EM>).  The calls
<CODE>io_mod_owner</CODE> and <CODE>io_get_owner</CODE> set the "owner" of the
object, providing either a pid or a pgrp (if the value is negative).
This implies that only one process at a time can do icky I/O on a given
object.  Whenever the I/O server is sending <CODE>sig_post</CODE> messages to
all the <CODE>io_async</CODE> users, if the <CODE>O_ASYNC</CODE> bit is set, the
server should also send a signal to the owning pid/pgrp.  The ID port
for this call should be different from all the <CODE>io_async</CODE> ID ports
given to users.  Users may find out what ID port the server uses for
this by calling <CODE>io_get_icky_async_id</CODE>.




<H3><A NAME="SEC45" HREF="hurd_toc.html#TOC45">Information Queries</A></H3>

<P>
<A NAME="IDX126"></A>
Users may call <CODE>io_stat</CODE> to find out information about the I/O
object.  Most of the fields of a <CODE>struct stat</CODE> are meaningful only
for files.  All objects, however, must support the fields
<VAR>st_fstype</VAR>, <VAR>st_fsid</VAR>, <VAR>st_ino</VAR>, <VAR>st_atime</VAR>,
<VAR>st_atime_usec</VAR>, <VAR>st_mtime_user</VAR>, <VAR>st_ctime</VAR>,
<VAR>st_ctime_usec</VAR>, and <VAR>st_blksize</VAR>.


<P>
<VAR>st_fstype</VAR>, <VAR>st_fsid</VAR>, and <VAR>st_ino</VAR> must be unique for
the underlying object across the entire system.


<P>
<VAR>st_atime</VAR> and <VAR>st_atime_usec</VAR> hold the seconds and
microseconds, respectively, of the system clock at the last time the
object was read with <CODE>io_read</CODE>.


<P>
<VAR>st_mtime</VAR> and <VAR>st_mtime_usec</VAR> hold the seconds and microseconds,
respectively, of the system clock at the last time the object was
written with <CODE>io_write</CODE>.


<P>
Other appropriate operations may update the <VAR>atime</VAR> and the
<VAR>mtime</VAR> as well; both the file and socket interfaces specify such
operations.


<P>
<VAR>st_ctime</VAR> and <VAR>st_ctime_usec</VAR> hold the seconds and
microseconds, respectively, of the system clock at the last time
permanent meta-data associated with the object was changed.  The exact
operations which cause such an update are server-dependent, but must
include the creation of the object.


<P>
The server is permitted to delay the actual update of these times until
stat is called; before the server stores the times on permanent media
(if it ever does so) it should update them if necessary.


<P>
<VAR>st_blksize</VAR> gives the optimal I/O size in bytes for <CODE>io_read</CODE>
and <CODE>io_write</CODE>; users should endeavor to read and write amounts
which are multiples of the optimal size, and to use offsets which are
multiples of the optimal size.


<P>
In addition, objects which are seekable should set <VAR>st_size</VAR> to the
current file size as in the description of the <CODE>O_APPEND</CODE> flag
(see section <A HREF="hurd_6.html#SEC43">Open Modes</A>).


<P>
The <VAR>st_uid</VAR> and <VAR>st_gid</VAR> fields are unrelated to the "owner"
as described above for icky async I/O.


<P>
<A NAME="IDX127"></A>
Users may find out the version of the server they are talking to by
calling <CODE>io_server_version</CODE>; this should return strings and
integers describing the version number of the server, as well as its
name.




<H3><A NAME="SEC46" HREF="hurd_toc.html#TOC46">Mapped Data</A></H3>

<P>
<A NAME="IDX128"></A>
Servers may optionally implement the <CODE>io_map</CODE> call.  The ports
returned by <CODE>io_map</CODE> must implement the external pager kernel
interface (see section <A HREF="hurd_6.html#SEC37">Pager Library</A>) and be suitable as arguments to
<CODE>vm_map</CODE>.


<P>
Seekable objects must allow access from zero up to (but not including)
the current file size as described for <CODE>O_APPEND</CODE> (see section <A HREF="hurd_6.html#SEC43">Open Modes</A>).  Whether they provide access beyond such a point is
server-dependent; in addition, the meaning of accessing a non-seekable
object is server-dependent.


<P><HR><P>
Go to the <A HREF="hurd_1.html">first</A>, <A HREF="hurd_5.html">previous</A>, <A HREF="hurd_7.html">next</A>, <A HREF="hurd_17.html">last</A> section, <A HREF="hurd_toc.html">table of contents</A>.
</BODY>
</HTML>

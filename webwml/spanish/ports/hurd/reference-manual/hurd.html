<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from hurd.texi on 29 June 1999 -->

<TITLE>Hurd Reference Manual</TITLE>
</HEAD>
<BODY>
<H1>The GNU Hurd Reference Manual</H1>
<ADDRESS>Thomas Bushnell, BSG</ADDRESS>
<ADDRESS>Gordon Matzigkeit</ADDRESS>
<P>
<P><HR><P>

<P>
@dircategory Kernel
* Hurd: (hurd).                 Using and programming the Hurd kernel servers.


<P>
Copyright (C) 1994--1998 Free Software Foundation, Inc.


<P>
Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.


<P>
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.


<P>
Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.




<H1><A NAME="SEC1" HREF="hurd_toc.html#TOC1">Introduction</A></H1>

<P>
The GNU Hurd<A NAME="DOCF1" HREF="hurd_foot.html#FOOT1">(1)</A> is the GNU Project's replacement for
the Unix kernel. The Hurd is a collection of servers that run on the
Mach microkernel to implement file systems, network protocols, file
access control, and other features that are normally implemented by the
Unix kernel or similar kernels (such as Linux).




<H2><A NAME="SEC2" HREF="hurd_toc.html#TOC2">Audience</A></H2>

<P>
This manual is designed to be useful to everybody who is interested in
using, administering, or programming the Hurd.


<P>
If you are an end-user and you are looking for help on running the Hurd,
the first few chapters of this manual describe the essential parts of
installing, starting up, and shutting down a Hurd workstation.  If you
need help with a specific program, the best way to use this manual is to
find the program's name in the index and go directly to the appropriate section.  You
may also wish to try running <KBD><VAR>program</VAR> --help</KBD>, which will
display a brief usage message for <VAR>program</VAR> (see section <A HREF="hurd.html#SEC21">Foundations</A>).


<P>
The rest of this manual is a technical discussion of the Hurd servers
and their implementation, and would not be helpful until you want to
learn how to modify the Hurd.


<P>
This manual is organized according to the subsystems of the Hurd, and each chapter begins
with descriptions of utilities and servers that are related to that
subsystem.  If you are a system administrator, and you want to learn
more about, say, the Hurd networking subsystem, you can skip to the
networking chapter (see section <A HREF="hurd.html#SEC126">Networking</A>), and read about the related
utilities and servers.


<P>
Programmers who are interested in learning how to modify Hurd servers, or
write new ones, should begin by learning about a microkernel to which the
Hurd has been ported (currently only GNU Mach) and reading
section <A HREF="hurd.html#SEC21">Foundations</A>.  You should then familiarize yourself with a
subsystem that interests you by reading about existing servers and the
libraries they use.  At that point, you should be able to study the
source code of existing Hurd servers and understand how they use the
Hurd libraries.


<P>
The final level of mastery is learning the RPC<A NAME="DOCF2" HREF="hurd_foot.html#FOOT2">(2)</A> interfaces which the Hurd
libraries implement.  The last section of each chapter describes any
Hurd interfaces used in that subsystem.  Those sections assume that you
are perusing the referenced interface definitions as you read.  After
you have understood a given interface, you will be in a good position to
improve the Hurd libraries, design your own interfaces, and implement
new subsystems.




<H2><A NAME="SEC3" HREF="hurd_toc.html#TOC3">Features</A></H2>

<P>
The Hurd is not the most advanced operating system known to the planet
(yet), but it does have a number of enticing features:


<DL COMPACT>

<DT>it's free software
<DD>
Anybody can use, modify, and redistribute it under the terms of the GNU
General Public License (see section <A HREF="hurd.html#SEC6">GNU General Public License</A>).  The Hurd is part of the GNU
system, which is a complete operating system licensed under the GPL.

<DT>it's compatible
<DD>
The Hurd provides a familiar programming and user environment.  For all
intents and purposes, the Hurd is a modern Unix-like kernel.  The Hurd
uses the GNU C Library, whose development closely tracks standards such
as ANSI/ISO, BSD, POSIX, Single Unix, SVID, and X/Open.

<DT>it is built to survive
<DD>
Unlike other popular kernel software, the Hurd has an object-oriented
structure that allows it to evolve without compromising its design.
This structure will help the Hurd undergo major redesign and
modifications without having to be entirely rewritten.

<DT>it's scalable
<DD>
The Hurd implementation is aggressively multithreaded so that it runs
efficiently on both single processors and symmetric multiprocessors.
The Hurd interfaces are designed to allow transparent network clusters
(<EM>collectives</EM>), although this feature has not yet been implemented.

<DT>it's extensible
<DD>
The Hurd is an attractive platform for learning how to become a kernel
hacker or for implementing new ideas in kernel technology.  Every part
of the system is designed to be modified and extended.

<DT>it's stable
<DD>
It is possible to develop and test new Hurd kernel components without
rebooting the machine (not even accidentally).  Running your own kernel
components doesn't interfere with other users, and so no special system
privileges are required.  The mechanism for kernel extensions is secure
by design: it is impossible to impose your changes upon other users
unless they authorize them or you are the system administrator.

<DT>it exists
<DD>
The Hurd is real software that works Right Now.  It is not a research
project or a proposal.  You don't have to wait at all before you can
start using and developing it.
</DL>



<H2><A NAME="SEC4" HREF="hurd_toc.html#TOC4">Overview</A></H2>

<P>
FIXME: overview of basic Hurd architecture, FAQish in nature




<H2><A NAME="SEC5" HREF="hurd_toc.html#TOC5">History</A></H2>

<P>
Richard Stallman (RMS) started GNU in 1983, as a project to create a
complete free operating system.  In the text of the GNU Manifesto, he
mentioned that there is a primitive kernel.  In the first GNUsletter,
Feb. 1986, he says that GNU's kernel is TRIX, which was developed at the
Massachusetts Institute of Technology.


<P>
By December of 1986, the Free Software Foundation (FSF) had "started
working on the changes needed to TRIX" [Gnusletter, Jan. 1987].
Shortly thereafter, the FSF began "negotiating with Professor Rashid of
Carnegie-Mellon University about working with them on the development of
the Mach kernel" [Gnusletter, June, 1987].  The text implies that the
FSF wanted to use someone else's work, rather than have to fix TRIX.


<P>
In [Gnusletter, Feb. 1988], RMS was talking about taking Mach and
putting the Berkeley Sprite filesystem on top of it, "after the parts
of Berkeley Unix... have been replaced."


<P>
Six months later, the FSF is saying that "if we can't get Mach, we'll
use TRIX or Berkeley's Sprite."  Here, they present Sprite as a
full-kernel option, rather than just a filesystem.


<P>
In January, 1990, they say "we aren't doing any kernel work.  It does
not make sense for us to start a kernel project now, when we still hope
to use Mach" [Gnusletter, Jan. 1990].  Nothing significant occurs until
1991, when a more detailed plan is announced:



<PRE>
``We are still interested in a multi-process kernel running on top of
Mach. The CMU lawyers are currently deciding if they can release Mach
with distribution conditions that will enable us to distribute it. If
they decide to do so, then we will probably start work. CMU has
available under the same terms as Mach a single-server partial Unix
emulator named Poe; it is rather slow and provides minimal
functionality. We would probably begin by extending Poe to provide full
functionality. Later we hope to have a modular emulator divided into
multiple processes.'' [Gnusletter, Jan. 1991].
</PRE>

<P>
RMS explains the relationship between the Hurd and Linux in
<A HREF="http://www.gnu.org/software/hurd/hurd-and-linux.html">http://www.gnu.org/software/hurd/hurd-and-linux.html</A>, where he
mentions that the FSF started developing the Hurd in 1990.  As of
[Gnusletter, Nov. 1991], the Hurd (running on Mach) is GNU's official
kernel.




<H2><A NAME="SEC6" HREF="hurd_toc.html#TOC6">GNU General Public License</A></H2>



<H1><A NAME="SEC7" HREF="hurd_toc.html#TOC7">GNU GENERAL PUBLIC LICENSE</A></H1>
<P>
Version 2, June 1991



<PRE>
Copyright (C) 1989, 1991 Free Software Foundation, Inc.
59 Temple Place -- Suite 330, Boston, MA 02111-1307, USA

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
</PRE>



<H2><A NAME="SEC8" HREF="hurd_toc.html#TOC8">Preamble</A></H2>

<P>
  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.


<P>
  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.


<P>
  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.


<P>
  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.


<P>
  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.


<P>
  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.


<P>
  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.


<P>
  The precise terms and conditions for copying, distribution and
modification follow.




<H2><A NAME="SEC9" HREF="hurd_toc.html#TOC9">TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION</A></H2>


<OL>
<LI>

This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

<LI>

You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

<LI>

You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:


<OL>
<LI>

You must cause the modified files to carry prominent notices
stating that you changed the files and the date of any change.

<LI>

You must cause any work that you distribute or publish, that in
whole or in part contains or is derived from the Program or any
part thereof, to be licensed as a whole at no charge to all third
parties under the terms of this License.

<LI>

If the modified program normally reads commands interactively
when run, you must cause it, when started running for such
interactive use in the most ordinary way, to print or display an
announcement including an appropriate copyright notice and a
notice that there is no warranty (or else, saying that you provide
a warranty) and that users may redistribute the program under
these conditions, and telling the user how to view a copy of this
License.  (Exception: if the Program itself is interactive but
does not normally print such an announcement, your work based on
the Program is not required to print an announcement.)
</OL>

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

<LI>

You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:


<OL>
<LI>

Accompany it with the complete corresponding machine-readable
source code, which must be distributed under the terms of Sections
1 and 2 above on a medium customarily used for software interchange; or,

<LI>

Accompany it with a written offer, valid for at least three
years, to give any third party, for a charge no more than your
cost of physically performing source distribution, a complete
machine-readable copy of the corresponding source code, to be
distributed under the terms of Sections 1 and 2 above on a medium
customarily used for software interchange; or,

<LI>

Accompany it with the information you received as to the offer
to distribute corresponding source code.  (This alternative is
allowed only for noncommercial distribution and only if you
received the program in object code or executable form with such
an offer, in accord with Subsection b above.)
</OL>

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

<LI>

You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

<LI>

You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

<LI>

Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

<LI>

If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

<LI>

If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

<LI>

The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

<LI>

If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.



<P><STRONG>NO WARRANTY</STRONG>

<LI>

BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

<LI>

IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.
</OL>


<H2>END OF TERMS AND CONDITIONS</H2>



<H2><A NAME="SEC10" HREF="hurd_toc.html#TOC10">How to Apply These Terms to Your New Programs</A></H2>

<P>
  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.


<P>
  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.



<PRE>
<VAR>one line to give the program's name and an idea of what it does.</VAR>
Copyright (C) 19<VAR>yy</VAR>  <VAR>name of author</VAR>

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
</PRE>

<P>
Also add information on how to contact you by electronic and paper mail.


<P>
If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:



<PRE>
Gnomovision version 69, Copyright (C) 19<VAR>yy</VAR> <VAR>name of author</VAR>
Gnomovision comes with ABSOLUTELY NO WARRANTY; for details
type `show w'.  This is free software, and you are welcome
to redistribute it under certain conditions; type `show c' 
for details.
</PRE>

<P>
The hypothetical commands <SAMP>`show w'</SAMP> and <SAMP>`show c'</SAMP> should show
the appropriate parts of the General Public License.  Of course, the
commands you use may be called something other than <SAMP>`show w'</SAMP> and
<SAMP>`show c'</SAMP>; they could even be mouse-clicks or menu items--whatever
suits your program.


<P>
You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:



<PRE>
Yoyodyne, Inc., hereby disclaims all copyright
interest in the program `Gnomovision'
(which makes passes at compilers) written 
by James Hacker.

<VAR>signature of Ty Coon</VAR>, 1 April 1989
Ty Coon, President of Vice
</PRE>

<P>
This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Library General
Public License instead of this License.




<H1><A NAME="SEC11" HREF="hurd_toc.html#TOC11">Installing</A></H1>

<P>
Before you can use the Hurd on your favorite machine, you'll need to
install all of its software components.  Currently, the Hurd only runs
on Intel i386-compatible architectures (such as the Pentium), using the
GNU Mach microkernel.


<P>
If you have unsupported hardware or a different microkernel, you will
not be able to run the Hurd until all the required software has been
<EM>ported</EM> to your architecture.  Porting is an involved process which
requires considerable programming skills, and is not recommended for the
faint-of-heart.  If you have the talent and desire to do a port, contact
<A HREF="mailto:bug-hurd@gnu.org">bug-hurd@gnu.org</A> in order to coordinate the effort.




<H2><A NAME="SEC12" HREF="hurd_toc.html#TOC12">Binary Distributions</A></H2>

<P>
By far the easiest and best way to install the Hurd is to obtain a GNU
binary distribution.  Even if you plan on recompiling the Hurd itself,
it is best to start off with an already-working GNU system so that you
can avoid having to reboot every time you want to test a program.


<P>
You can get GNU from a friend under the conditions allowed by the GNU
GPL (see section <A HREF="hurd.html#SEC6">GNU General Public License</A>).  Please consider sending a donation to the Free
Software Foundation so that we can continue to improve GNU software.


<P>
You can also FTP the complete GNU system from your closest GNU mirror,
or <A HREF="ftp://ftp.gnu.org/pub/gnu/">ftp://ftp.gnu.org/pub/gnu/</A>.  The GNU binary distribution is
available in a subdirectory called <TT>`gnu-<VAR>n.m</VAR>'</TT>, where <VAR>n.m</VAR>
is the version of the Hurd that this GNU release corresponds to
(0.2 at the time of this writing).  Again, please consider
donating to the Free Software Foundation.


<P>
The format of the binary distribution is prone to change, so this manual
does not describe the details of how to install GNU.  The <TT>`README'</TT>
file distributed with the binary distribution gives you complete
instructions.


<P>
After you follow all the appropriate instructions, you will have a
working GNU/Hurd system.  If you have used Linux-based GNU systems or
other Unix-like systems before, the Hurd will look quite familiar.  You
should play with it for a while, referring to this manual only when you
want to learn more about the Hurd.  Have fun!


<P>
If the Hurd is your first introduction to the GNU operating system, then
you will need to learn more about GNU in order to be able to use it.
You should talk to friends who are familiar with GNU, in order to find
out about classes, online tutorials, or books which can help you learn
more about GNU.


<P>
If you have no friends who are already using GNU, you can find some
useful starting points at the GNU web site, <A HREF="http://www.gnu.org/">http://www.gnu.org/</A>.
You can also send e-mail to <A HREF="mailto:help-hurd@gnu.org">help-hurd@gnu.org</A>, to contact
fellow Hurd users.  You can join this mailing list by sending a request
to <A HREF="mailto:help-hurd-request@gnu.org">help-hurd-request@gnu.org</A>.




<H2><A NAME="SEC13" HREF="hurd_toc.html#TOC13">Cross-Compiling</A></H2>

<P>
Another way to install the Hurd is to use an existing operating system
in order to compile all the required Hurd components from source code.
This is called <EM>cross-compiling</EM>, because it is done between two
different platforms.


<P>
<EM>This process is not recommended unless you are porting the Hurd to
a new platform.</EM>  Cross-compiling the Hurd to a platform which already
has a binary distribution is a tremendous waste of time... it is
frequently necessary to repeat steps over and over again, and you are
not even guaranteed to get a working system.  Please, obtain a GNU
binary distribution (see section <A HREF="hurd.html#SEC12">Binary Distributions</A>), and use your time to
do more useful things.  If you are capable of cross-compiling, then you
are definitely skilled enough to make more useful (and creative)
modifications to the GNU system.


<P>
To emphasize this point: downloading the entire GNU system over a 9600
baud modem takes <EM>much less time</EM> than cross-compilation, and
provides better results, too.


<P>
If you are still sure that you would like to cross-compile the Hurd, you
should send e-mail to the <A HREF="mailto:bug-hurd@gnu.org">bug-hurd@gnu.org</A> mailing list in
order to coordinate your efforts.  People on that list will give you
advice on what to look out for, as well as helping you figure out a way
that your cross-compilation can benefit Hurd development.  After that,
don your bug-resistant suit, and read the <TT>`INSTALL-cross'</TT> file,
which comes with the latest Hurd source code distribution.  The
instructions in <TT>`INSTALL-cross'</TT> are usually out-of-date, but they contain
some useful hints buried amongst the errors.




<H1><A NAME="SEC14" HREF="hurd_toc.html#TOC14">Bootstrap</A></H1>

<P>
Bootstrapping<A NAME="DOCF3" HREF="hurd_foot.html#FOOT3">(3)</A> is the procedure by
which your machine loads the microkernel and transfers control to the
Hurd servers.




<H2><A NAME="SEC15" HREF="hurd_toc.html#TOC15">Bootloader</A></H2>

<P>
The <EM>bootloader</EM> is the first software that runs on your machine.
Many hardware architectures have a very simple startup routine which
reads a very simple bootloader from the beginning of the internal hard
disk, then transfers control to it.  Other architectures have startup
routines which are able to understand more of the contents of the hard
disk, and directly start a more advanced bootloader.


<P>
<A NAME="IDX1"></A>
<A NAME="IDX2"></A>
Currently, <EM>GRUB</EM><A NAME="DOCF4" HREF="hurd_foot.html#FOOT4">(4)</A> is the preferred GNU bootloader.
GRUB provides advanced functionality, and is capable of loading several
different kernels (such as Linux, DOS, and the *BSD family).


<P>
From the standpoint of the Hurd, the bootloader is just a mechanism to
get the microkernel running and transfer control to <CODE>serverboot</CODE>.
You will need to refer to your bootloader and microkernel documentation
for more information about the details of this process.




<H2><A NAME="SEC16" HREF="hurd_toc.html#TOC16">Server Bootstrap</A></H2>
<P>
<A NAME="IDX3"></A>


<P>
The <CODE>serverboot</CODE> program is responsible for loading and executing
the rest of the Hurd servers.  Rather than containing specific
instructions for starting the Hurd, it follows general steps given in a
user-supplied boot script.


<P>
To boot the Hurd, the microkernel must start <CODE>serverboot</CODE> as its
first task, and pass it appropriate arguments.  <CODE>serverboot</CODE> may
also be invoked while the Hurd is already running, which allows users to
start their own complete sub-Hurds (see section <A HREF="hurd.html#SEC19">Recursive Bootstrap</A>).




<H3><A NAME="SEC17" HREF="hurd_toc.html#TOC17">Invoking <CODE>serverboot</CODE></A></H3>

<P>
The <CODE>serverboot</CODE> program has the following synopsis:



<PRE>
serverboot -<VAR>switch</VAR>... [[<VAR>host-port</VAR> <VAR>device-port</VAR>] <VAR>root-name</VAR>]
</PRE>

<P>
Each <VAR>switch</VAR> is a single character, out of the following set:


<DL COMPACT>

<DT><SAMP>`a'</SAMP>
<DD>
Prompt the user for the <VAR>root-name</VAR>, even if it was already supplied
on the command line.

<DT><SAMP>`d'</SAMP>
<DD>
Prompt the user to strike a key after the boot script has been read.

<DT><SAMP>`q'</SAMP>
<DD>
Prompt the user for the name of the boot script.  By default, use
<TT>`<VAR>root-name</VAR>:/boot/servers.boot'</TT>.
</DL>

<P>
All the <VAR>switches</VAR> are put into the <CODE>${boot-args}</CODE> script
variable.


<P>
<VAR>host-port</VAR> and <VAR>device-port</VAR> are integers which represent the
microkernel host and device ports, respectively (and are used to
initialize the <CODE>${host-port}</CODE> and <CODE>${device-port}</CODE> boot
script variables).  If these ports are not specified, then
<CODE>serverboot</CODE> assumes that the Hurd is already running, and fetches
the current ports from the procserver (FIXME xref).


<P>
<VAR>root-name</VAR> is the name of the microkernel device that should be
used as the Hurd bootstrap filesystem.  <CODE>serverboot</CODE> uses this name
to locate the boot script (described above), and to initialize the
<CODE>${root-device}</CODE> script variable.




<H3><A NAME="SEC18" HREF="hurd_toc.html#TOC18">Boot Scripts</A></H3>
<P>
<A NAME="IDX4"></A>
<A NAME="IDX5"></A>


<P>
FIXME: finish




<H3><A NAME="SEC19" HREF="hurd_toc.html#TOC19">Recursive Bootstrap</A></H3>

<P>
The most appealing use of the <CODE>serverboot</CODE> program is to start a
set of core Hurd servers while another Hurd is already running.  You
will rarely need to do this, and it requires superuser privileges, but
it is interesting to note that it can be done.


<P>
Usually, you would make changes to only one server, and simply tell your
programs to use it in order to test out your changes.  This process can
be applied even to the core servers.  However, some changes have
far-reaching effects, and so it is nice to be able to test those effects
without having to reboot the machine.


<P>
Here are the steps you can follow to test out a new set of servers:



<OL>
<LI>

Create a new root partition.  Usually, you would do this under your old
Hurd, and initialize it with your favorite filesystem format.

<LI>

Copy the core servers, C library, and any of your modified programs onto
the new partition.

<LI>

Use some clever shadowfs hacks (FIXME xref) to mirror the rest of your
programs under the modified partition.  Copying them will work, too, if
you don't like shadowfs.

<LI>

Create a boot script on the new partition, in <TT>`/boot/servers.boot'</TT>.

<LI>

Run <KBD>serverboot -aqd <VAR>root-name</VAR></KBD>, where <VAR>root-name</VAR> is the
microkernel name for your new root device.
</OL>

<P>
Note that it is impossible to share microkernel devices between the two
running Hurds, so don't get any funny ideas.  When you're finished
testing your new Hurd, then you can run the <CODE>halt</CODE> or <CODE>reboot</CODE>
programs to return control to the parent Hurd.


<P>
If you're satisfied with your new Hurd, you can arrange for your
bootloader to start it, and reboot your machine.  Then, you'll be in a
safe place to overwrite your old Hurd with the new one, and reboot back
to your old configuration (with the new Hurd servers).




<H2><A NAME="SEC20" HREF="hurd_toc.html#TOC20">Shutdown</A></H2>
<P>
<A NAME="IDX6"></A>
<A NAME="IDX7"></A>


<P>
FIXME: finish




<H1><A NAME="SEC21" HREF="hurd_toc.html#TOC21">Foundations</A></H1>

<P>
Every Hurd program accepts the following optional arguments:


<DL COMPACT>

<DT><SAMP>`--help'</SAMP>
<DD>
Display a brief usage message, then exit.  This message is not a
substitute for reading program documentation; rather, it provides useful
reminders about specific command-line options that a program
understands.

<DT><SAMP>`--version'</SAMP>
<DD>
Output program version information and exit.
</DL>

<P>
The rest of this chapter provides a programmer's introduction to the
Hurd.  If you are not a programmer, then this chapter will not make much
sense to you... you should consider skipping to descriptions of
specific Hurd programs (see section <A HREF="hurd.html#SEC2">Audience</A>).


<P>
The Hurd distribution includes many libraries in order to provide a
useful set of tools for writing Hurd utilities and servers.  Several of
these libraries are useful not only for the Hurd, but also for writing
microkernel-based programs in general.  These fundamental libraries are
not difficult to understand, and they are a good starting point, because
the rest of the Hurd relies upon them quite heavily.




<H2><A NAME="SEC22" HREF="hurd_toc.html#TOC22">Threads Library</A></H2>
<P>
<A NAME="IDX8"></A>
<A NAME="IDX9"></A>


<P>
All Hurd servers and libraries are aggressively multithreaded in order
to take full advantage of any multiprocessing capabilities provided by
the microkernel and the underlying hardware.  The Hurd threads library,
<CODE>libthreads</CODE>, contains the default Hurd thread implementation, which
is declared in <CODE>&#60;cthreads.h&#62;</CODE>.


<P>
Currently (April 1998), the Hurd uses cthreads, which have already been
documented thoroughly by CMU.  Eventually, it will be migrated to use
POSIX pthreads, which are documented in a lot of places.


<P>
Every single library in the Hurd distribution (including the GNU C
library) is completely thread-safe, and the Hurd servers themselves are
aggressively multithreaded.




<H2><A NAME="SEC23" HREF="hurd_toc.html#TOC23">Microkernel Object Library</A></H2>
<P>
<A NAME="IDX10"></A>
<A NAME="IDX11"></A>


<P>
A commonly asked question is whether the Hurd has been ported to the
Open Group's version of the Mach microkernel.  The answer is "no".


<P>
Currently (April 1998), the Hurd is quite dependent on the GNU Mach
microkernel, which is a derivative of the University of Utah's Mach 4.
However, the Hurd developers are all too aware of the limitations of
Mach.


<P>
<A NAME="IDX12"></A>
<A NAME="IDX13"></A>
<CODE>libmom</CODE> is the first of several steps that need to be taken in
order to make the Hurd portable to other message-passing microkernels.
<EM>MOM</EM> stands for <EM>Microkernel Object Model</EM>, and is an
abstraction of the basic services provided by common message-passing
microkernels.  It will provide the necessary insulation so that Hurd
servers and the C library can avoid making microkernel-dependent kernel
calls.


<P>
At the present, though, <CODE>libmom</CODE> is still evolving, and will take
some time to be fully incorporated into the Hurd.




<H2><A NAME="SEC24" HREF="hurd_toc.html#TOC24">Ports Library</A></H2>
<P>
<A NAME="IDX14"></A>
<A NAME="IDX15"></A>


<P>
Ports are communication channels that are held by the kernel.


<P>
A port has separate send rights and receive rights, which may be
transferred from task to task via the kernel.  Port rights are similar
to Unix file descriptors: they are per-task integers which are used to
identify ports when making kernel calls.  Send rights are required in
order to send an RPC request down a port, and receive rights are
required to serve the RPC request.  Receive rights may be aggregated
into a single <EM>portset</EM>, which serve as useful organizational units.


<P>
In a single-threaded RPC client, managing and categorizing ports is not
a difficult process.  However, in a complex multithreaded server, it is
useful to have a more abstract interface to managing portsets, as well
as maintaining server metadata.


<P>
The Hurd ports library, <CODE>libports</CODE>, fills that need.  The
<CODE>libports</CODE> functions are declared in <CODE>&#60;hurd/ports.h&#62;</CODE>.




<H3><A NAME="SEC25" HREF="hurd_toc.html#TOC25">Buckets and Classes</A></H3>

<P>
The <CODE>libports</CODE> <EM>bucket</EM> is simply a port set, with some
metadata and a lock.  All of the <CODE>libports</CODE> functions operate on
buckets.


<P>
<DL>
<DT><U>Function:</U> struct port_bucket * <B>ports_create_bucket</B> <I>(void)</I>
<DD><A NAME="IDX16"></A>
Create and return a new, empty bucket.
</DL>


<P>
A port <EM>class</EM> is a collection of individual ports, which can be
manipulated conveniently, and have enforced deallocation routines.
Buckets and classes are entirely orthogonal: there is no requirement
that all the ports in a class be in the same bucket, nor is there a
requirement that all the ports in a bucket be in the same class.


<P>
<DL>
<DT><U>Function:</U> struct port_class <B>ports_create_class</B> <I>(void (*<VAR>clean_routine</VAR>) (void *<VAR>port</VAR>), void (*<VAR>dropweak_routine</VAR>) (void *<VAR>port</VAR>))</I>
<DD><A NAME="IDX17"></A>
Create and return a new port class.  If nonzero, <VAR>clean_routine</VAR>
will be called for each allocated port object in this class when it is
being destroyed.  If nonzero, <VAR>dropweak_routine</VAR> will be called to
request weak references to be dropped.  (If <VAR>dropweak_routine</VAR> is
null, then weak references and hard references will be identical for
ports of this class.)
</DL>


<P>
Once you have created at least one bucket and class, you may create new
ports, and store them in those buckets.  There are a few different
functions for port creation, depending on your application's
requirements:


<P>
<DL>
<DT><U>Function:</U> error_t <B>ports_create_port</B> <I>(struct port_class *<VAR>class</VAR>, struct port_bucket *<VAR>bucket</VAR>, size_t <VAR>size</VAR>, void *<VAR>result</VAR>)</I>
<DD><A NAME="IDX18"></A>
Create and return in <VAR>result</VAR> a new port in <VAR>class</VAR> and
<VAR>bucket</VAR>; <VAR>size</VAR> bytes will be allocated to hold the port
structure and whatever private data the user desires.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ports_create_port_noinstall</B> <I>(struct port_class *<VAR>class</VAR>, struct port_bucket *<VAR>bucket</VAR>, size_t <VAR>size</VAR>, void *<VAR>result</VAR>)</I>
<DD><A NAME="IDX19"></A>
Just like <CODE>ports_create_port</CODE>, except don't actually put the port
into the portset underlying <VAR>bucket</VAR>.  This is intended to be used
for cases where the port right must be given out before the port is
fully initialized; with this call you are guaranteed that no RPC service
will occur on the port until you have finished initializing it and
installed it into the portset yourself.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ports_import_port</B> <I>(struct port_class *<VAR>class</VAR>, struct port_bucket *<VAR>bucket</VAR>, mach_port_t <VAR>port</VAR>, size_t <VAR>size</VAR>, void *<VAR>result</VAR>)</I>
<DD><A NAME="IDX20"></A>
For an existing <EM>receive</EM> right, create and return in <VAR>result</VAR>
a new port structure; <VAR>bucket</VAR>, <VAR>size</VAR>, and <VAR>class</VAR> args are
as for <CODE>ports_create_port</CODE>.
</DL>




<H3><A NAME="SEC26" HREF="hurd_toc.html#TOC26">Port Rights</A></H3>

<P>
The following functions move port receive rights to and from the port
structure:


<P>
<DL>
<DT><U>Function:</U> void <B>ports_reallocate_port</B> <I>(void *<VAR>port</VAR>)</I>
<DD><A NAME="IDX21"></A>
Destroy the receive right currently associated with <VAR>port</VAR> and
allocate a new one.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_reallocate_from_external</B> <I>(void *<VAR>port</VAR>, mach_port_t <VAR>receive</VAR>)</I>
<DD><A NAME="IDX22"></A>
Destroy the receive right currently associated with <VAR>port</VAR> and
designate <VAR>receive</VAR> as the new one.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_destroy_right</B> <I>(void *<VAR>port</VAR>)</I>
<DD><A NAME="IDX23"></A>
Destroy the receive right currently associated with <VAR>port</VAR>.  After
this call, <CODE>ports_reallocate_port</CODE> and
<CODE>ports_reallocate_from_external</CODE> may not be used.
</DL>


<P>
<DL>
<DT><U>Function:</U> mach_port_t <B>ports_claim_right</B> <I>(void *<VAR>port</VAR>)</I>
<DD><A NAME="IDX24"></A>
Return the receive right currently associated with <VAR>port</VAR>.  The
effects on <VAR>port</VAR> are the same as in <CODE>ports_destroy_right</CODE>,
except that the receive right itself is not affected.  Note that in
multi-threaded servers, messages might already have been dequeued for
this port before it gets removed from the portset; such messages will
get <CODE>EOPNOTSUPP</CODE> errors.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ports_transfer_right</B> <I>(void *<VAR>topt</VAR>, void *<VAR>frompt</VAR>)</I>
<DD><A NAME="IDX25"></A>
Transfer the receive right from <VAR>frompt</VAR> to <VAR>topt</VAR>.
<VAR>frompt</VAR> ends up with a destroyed right (as if
<CODE>ports_destroy_right</CODE> were called) and <VAR>topt</VAR>'s old right is
destroyed (as if <CODE>ports_reallocate_from_external</CODE> were called).
</DL>


<P>
<DL>
<DT><U>Function:</U> mach_port_t <B>ports_get_right</B> <I>(void *<VAR>port</VAR>)</I>
<DD><A NAME="IDX26"></A>
Return the name of the receive right associated with <VAR>port</VAR>.  The
user is responsible for creating an ordinary send right from this name.
</DL>




<H3><A NAME="SEC27" HREF="hurd_toc.html#TOC27">Port Metadata</A></H3>

<P>
It is important to point out that the <VAR>port</VAR> argument to each of
the <CODE>libports</CODE> functions is a <CODE>void *</CODE> and not a <CODE>struct
port_info *</CODE>.  This is done so that you may add arbitrary
meta-information to your <CODE>libports</CODE>-managed ports.  Simply define
your own structure whose first element is a <CODE>struct port_info</CODE>, and
then you can use pointers to these structures as the <VAR>port</VAR> argument
to any <CODE>libports</CODE> function.


<P>
The following functions are useful for maintaining metadata that is
stored in your own custom ports structure:


<P>
<DL>
<DT><U>Function:</U> void * <B>ports_lookup_port</B> <I>(struct port_bucket *<VAR>bucket</VAR>, mach_port_t <VAR>port</VAR>, struct port_class *<VAR>class</VAR>)</I>
<DD><A NAME="IDX27"></A>
Look up <VAR>port</VAR> and return the associated port structure, allocating
a reference.  If the call fails, return zero.  If <VAR>bucket</VAR> is nonzero,
then it specifies a bucket to search; otherwise all buckets will be
searched.  If <VAR>class</VAR> is nonzero, then the lookup will fail if
<VAR>port</VAR> is not in <VAR>class</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ports_bucket_iterate</B> <I>(struct port_bucket *<VAR>bucket</VAR>, error_t (*<VAR>fun</VAR>) (void *<VAR>port</VAR>))</I>
<DD><A NAME="IDX28"></A>
Call <VAR>fun</VAR> once for each port in <VAR>bucket</VAR>.
</DL>




<H3><A NAME="SEC28" HREF="hurd_toc.html#TOC28">Port References</A></H3>

<P>
These functions maintain references to ports so that the port
information structures may be freed if and only if they are no longer
needed.  It is your responsibility to tell <CODE>libports</CODE> when
references to ports change.


<P>
<DL>
<DT><U>Function:</U> void <B>ports_port_ref</B> <I>(void *<VAR>port</VAR>)</I>
<DD><A NAME="IDX29"></A>
Allocate a hard reference to <VAR>port</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_port_deref</B> <I>(void *<VAR>port</VAR>)</I>
<DD><A NAME="IDX30"></A>
Drop a hard reference to <VAR>port</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_no_senders</B> <I>(void *<VAR>port</VAR>, mach_port_mscount_t <VAR>mscount</VAR>)</I>
<DD><A NAME="IDX31"></A>
The user is responsible for listening for no senders notifications; when
one arrives, call this routine for the <VAR>port</VAR> the message was sent
to, providing the <VAR>mscount</VAR> from the notification.
</DL>


<P>
<DL>
<DT><U>Function:</U> int <B>ports_count_class</B> <I>(struct port_class *<VAR>class</VAR>)</I>
<DD><A NAME="IDX32"></A>
Block creation of new ports in <VAR>class</VAR>.  Return the number of ports
currently in <VAR>class</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> int <B>ports_count_bucket</B> <I>(struct port_bucket *<VAR>bucket</VAR>)</I>
<DD><A NAME="IDX33"></A>
Block creation of new ports in <VAR>bucket</VAR>.  Return the number of ports
currently in <VAR>bucket</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_enable_class</B> <I>(struct port_class *<VAR>class</VAR>)</I>
<DD><A NAME="IDX34"></A>
Permit suspended port creation (blocked by <CODE>ports_count_class</CODE>) to
continue.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_enable_bucket</B> <I>(struct port_bucket *<VAR>bucket</VAR>)</I>
<DD><A NAME="IDX35"></A>
Permit suspended port creation (blocked by <CODE>ports_count_bucket</CODE>) to
continue.
</DL>


<P>
Weak references are not often used, as they are the same as hard
references for port classes where <VAR>dropweak_routine</VAR> is null.
See section <A HREF="hurd.html#SEC25">Buckets and Classes</A>.


<P>
<DL>
<DT><U>Function:</U> void <B>ports_port_ref_weak</B> <I>(void *<VAR>port</VAR>)</I>
<DD><A NAME="IDX36"></A>
Allocate a weak reference to <VAR>port</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_port_deref_weak</B> <I>(void *<VAR>port</VAR>)</I>
<DD><A NAME="IDX37"></A>
Drop a weak reference to <VAR>port</VAR>.
</DL>




<H3><A NAME="SEC29" HREF="hurd_toc.html#TOC29">RPC Management</A></H3>

<P>
The rest of the <CODE>libports</CODE> functions are dedicated to controlling
RPC operations.  These functions help you do all the locking and thread
cancellations that are required in order to build robust servers.


<P>
<DL>
<DT><U>Typedef:</U> typedef int (* <B>ports_demuxer_type</B> <I>) (mach_msg_header_t *<VAR>inp</VAR>, mach_msg_header_t *<VAR>outp</VAR>)</I>
<DD><A NAME="IDX38"></A>
Type of MiG demuxer routines.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ports_begin_rpc</B> <I>(void *<VAR>port</VAR>, mach_msg_id_t <VAR>msg_id</VAR>, struct rpc_info *<VAR>info</VAR>)</I>
<DD><A NAME="IDX39"></A>
Call this when an RPC is beginning on <VAR>port</VAR>.  <VAR>info</VAR> should be
allocated by the caller and will be used to hold dynamic state.  If this
RPC should be abandoned, return <CODE>EDIED</CODE>; otherwise we return zero.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_end_rpc</B> <I>(void *<VAR>port</VAR>, struct rpc_info *<VAR>info</VAR>)</I>
<DD><A NAME="IDX40"></A>
Call this when an RPC is concluding.  The arguments must match the ones
passed to the paired call to <CODE>ports_begin_rpc</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_manage_port_operations_one_thread</B> <I>(struct port_bucket *<VAR>bucket</VAR>, ports_demuxer_type <VAR>demuxer</VAR>, int <VAR>timeout</VAR>)</I>
<DD><A NAME="IDX41"></A>
Begin handling operations for the ports in <VAR>bucket</VAR>, calling
<VAR>demuxer</VAR> for each incoming message.  Return if <VAR>timeout</VAR> is
nonzero and no messages have been received for <VAR>timeout</VAR>
milliseconds.  Use only one thread (the calling thread).
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_manage_port_operations_multithread</B> <I>(struct port_bucket *<VAR>bucket</VAR>, ports_demuxer_type <VAR>demuxer</VAR>, int <VAR>thread_timeout</VAR>, int <VAR>global_timeout</VAR>, void (*<VAR>hook</VAR>) (void))</I>
<DD><A NAME="IDX42"></A>
Begin handling operations for the ports in <VAR>bucket</VAR>, calling
<VAR>demuxer</VAR> for each incoming message.  Return if <VAR>global_timeout</VAR>
is nonzero and no messages have been received for <VAR>global_timeout</VAR>
milliseconds.  Create threads as necessary to handle incoming messages
so that no port is starved because of sluggishness on another port.  If
<VAR>thread_timeout</VAR> is nonzero, then individual threads will die off
if they handle no incoming messages for <VAR>local_timeout</VAR>
milliseconds.  If non-null, <VAR>hook</VAR> will be called in each new thread
immediately after it is created.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ports_inhibit_port_rpcs</B> <I>(void *<VAR>port</VAR>)</I>
<DD><A NAME="IDX43"></A>
Interrupt any pending RPC on <VAR>port</VAR>.  Wait for all pending RPCs to
finish, and then block any new RPCs starting on that port.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ports_inhibit_class_rpcs</B> <I>(struct port_class *<VAR>class</VAR>)</I>
<DD><A NAME="IDX44"></A>
Similar to <CODE>ports_inhibit_port_rpcs</CODE>, but affects all ports in
<VAR>class</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ports_inhibit_bucket_rpcs</B> <I>(struct port_bucket *<VAR>bucket</VAR>)</I>
<DD><A NAME="IDX45"></A>
Similar to <CODE>ports_inhibit_port_rpcs</CODE>, but affects all ports in
<VAR>bucket</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ports_inhibit_all_rpcs</B> <I>(void)</I>
<DD><A NAME="IDX46"></A>
Similar to <CODE>ports_inhibit_port_rpcs</CODE>, but affects all ports
whatsoever.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_resume_port_rpcs</B> <I>(void *<VAR>port</VAR>)</I>
<DD><A NAME="IDX47"></A>
Reverse the effect of a previous <CODE>ports_inhibit_port_rpcs</CODE> for this
<VAR>port</VAR>, allowing blocked RPCs to continue.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_resume_class_rpcs</B> <I>(struct port_class *<VAR>class</VAR>)</I>
<DD><A NAME="IDX48"></A>
Reverse the effect of a previous <CODE>ports_inhibit_class_rpcs</CODE> for
<VAR>class</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_resume_bucket_rpcs</B> <I>(struct port_bucket *<VAR>bucket</VAR>)</I>
<DD><A NAME="IDX49"></A>
Reverse the effect of a previous <CODE>ports_inhibit_bucket_rpcs</CODE> for
<VAR>bucket</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_resume_all_rpcs</B> <I>(void)</I>
<DD><A NAME="IDX50"></A>
Reverse the effect of a previous <CODE>ports_inhibit_all_rpcs</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_interrupt_rpcs</B> <I>(void *<VAR>port</VAR>)</I>
<DD><A NAME="IDX51"></A>
Cancel (with <CODE>thread_cancel</CODE>) any RPCs in progress on <VAR>port</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> int <B>ports_self_interrupted</B> <I>(void)</I>
<DD><A NAME="IDX52"></A>
If the current thread's RPC has been interrupted with
<CODE>ports_interrupt_rpcs</CODE>, return nonzero and clear the interrupted
flag.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ports_interrupt_rpc_on_notification</B> <I>(void *<VAR>object</VAR>, struct rpc_info *<VAR>rpc</VAR>, mach_port_t <VAR>port</VAR>, mach_msg_id_t <VAR>what</VAR>)</I>
<DD><A NAME="IDX53"></A>
Arrange for <CODE>hurd_cancel</CODE> to be called on <VAR>rpc</VAR>'s thread if
<VAR>object</VAR> gets notified that any of the things in <VAR>what</VAR> have
happened to <VAR>port</VAR>.  <VAR>rpc</VAR> should be an RPC on <VAR>object</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ports_interrupt_self_on_notification</B> <I>(void *<VAR>object</VAR>, mach_port_t <VAR>port</VAR>, mach_msg_id_t <VAR>what</VAR>)</I>
<DD><A NAME="IDX54"></A>
Arrange for <CODE>hurd_cancel</CODE> to be called on the current thread, which
should be an RPC on <VAR>object</VAR>, if <VAR>port</VAR> gets notified with the
condition <VAR>what</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ports_interrupt_self_on_port_death</B> <I>(void *<VAR>object</VAR>, mach_port_t <VAR>port</VAR>)</I>
<DD><A NAME="IDX55"></A>
Same as calling <CODE>ports_interrupt_self_on_notification</CODE> with
<VAR>what</VAR> set to <CODE>MACH_NOTIFY_DEAD_NAME</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_interrupt_notified_rpcs</B> <I>(void *<VAR>object</VAR>, mach_port_t <VAR>port</VAR>, mach_msg_id_t <VAR>what</VAR>)</I>
<DD><A NAME="IDX56"></A>
Interrupt any RPCs on <VAR>object</VAR> that have requested such.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ports_dead_name</B> <I>(void *<VAR>object</VAR>, mach_port_t <VAR>port</VAR>)</I>
<DD><A NAME="IDX57"></A>
Same as calling <CODE>ports_interrupt_notified_rpcs</CODE> with <VAR>what</VAR> set
to <CODE>MACH_NOTIFY_DEAD_NAME</CODE>.
</DL>




<H2><A NAME="SEC30" HREF="hurd_toc.html#TOC30">Integer Hash Library</A></H2>
<P>
<A NAME="IDX58"></A>
<A NAME="IDX59"></A>


<P>
<CODE>libihash</CODE> provides integer-keyed hash tables, for arbitrary
element data types.  Such hash tables are frequently used when
implementing sparse arrays or buffer caches.


<P>
The following functions are declared in <CODE>&#60;hurd/ihash.h&#62;</CODE>:


<P>
<DL>
<DT><U>Function:</U> error_t <B>ihash_create</B> <I>(ihash_t *<VAR>ht</VAR>)</I>
<DD><A NAME="IDX60"></A>
Create an integer hash table and return it in <VAR>ht</VAR>.  If a memory
allocation error occurs, <CODE>ENOMEM</CODE> is returned, otherwise zero.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ihash_free</B> <I>(ihash_t <VAR>ht</VAR>)</I>
<DD><A NAME="IDX61"></A>
Free <VAR>ht</VAR> and all resources it consumes.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ihash_set_cleanup</B> <I>(ihash_t <VAR>ht</VAR>, void (*<VAR>cleanup</VAR>) (void *<VAR>value</VAR>, void *<VAR>arg</VAR>), void *<VAR>arg</VAR>)</I>
<DD><A NAME="IDX62"></A>
Sets <VAR>ht</VAR>'s element cleanup function to <VAR>cleanup</VAR>, and its
second argument to <VAR>arg</VAR>.  <VAR>cleanup</VAR> will be called on every
element <VAR>value</VAR> to be subsequently overwritten or deleted, with
<VAR>arg</VAR> as the second argument.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ihash_add</B> <I>(ihash_t <VAR>ht</VAR>, int <VAR>id</VAR>, void *<VAR>item</VAR>, void ***<VAR>locp</VAR>)</I>
<DD><A NAME="IDX63"></A>
Add <VAR>item</VAR> to the hash table <VAR>ht</VAR> under the integer key
<VAR>id</VAR>.  <VAR>locp</VAR> is the address of a pointer located in <VAR>item</VAR>;
If non-null, <VAR>locp</VAR> should point to a variable of type <CODE>void
**</CODE>, and will be filled with a pointer that may be used as an argument
to <CODE>ihash_locp_remove</CODE>.  The variable pointed to by <VAR>locp</VAR> may
be overwritten sometime between this call and when the element is
deleted, so you cannot stash its value elsewhere and hope to use the
stashed value with <CODE>ihash_locp_remove</CODE>.  If a memory allocation
error occurs, <CODE>ENOMEM</CODE> is returned, otherwise zero.
</DL>


<P>
<DL>
<DT><U>Function:</U> void * <B>ihash_find</B> <I>(ihash_t <VAR>ht</VAR>, int <VAR>id</VAR>)</I>
<DD><A NAME="IDX64"></A>
Find and return the item in hash table <VAR>ht</VAR> with key <VAR>id</VAR>.
Returns null if the specified item doesn't exist.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>ihash_iterate</B> <I>(ihash_t <VAR>ht</VAR>, error_t (*<VAR>fun</VAR>) (void *<VAR>value</VAR>))</I>
<DD><A NAME="IDX65"></A>
Call function <VAR>fun</VAR> on every element of <VAR>ht</VAR>.  <VAR>fun</VAR>'s only
arg, <VAR>value</VAR>, is a pointer to the value stored in the hash table.  If
<VAR>fun</VAR> ever returns nonzero, then iteration stops and
<CODE>ihash_iterate</CODE> returns that value, otherwise it (eventually)
returns 0.
</DL>


<P>
<DL>
<DT><U>Function:</U> int <B>ihash_remove</B> <I>(ihash_t <VAR>ht</VAR>, int <VAR>id</VAR>)</I>
<DD><A NAME="IDX66"></A>
Remove the entry with a key of <VAR>id</VAR> from <VAR>ht</VAR>.  If there was no
such element, then return zero, otherwise nonzero.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>ihash_locp_remove</B> <I>(ihash_t <VAR>ht</VAR>, void **<VAR>ht_locp</VAR>)</I>
<DD><A NAME="IDX67"></A>
Remove the entry at <VAR>locp</VAR> from the hashtable <VAR>ht</VAR>.  <VAR>locp</VAR>
is as returned from an earlier call to <CODE>ihash_add</CODE>.  This call
should be faster than <CODE>ihash_remove</CODE>.  <VAR>ht</VAR> can be null, in
which case the call still succeeds, but no cleanup is done.
</DL>




<H2><A NAME="SEC31" HREF="hurd_toc.html#TOC31">Misc Library</A></H2>
<P>
<A NAME="IDX68"></A>


<P>
The GNU C library is constantly developing to meet the needs of the
Hurd.  However, because the C library needs to be very stable, it is
irresponsible to add new functions to it without carefully specifying
their interface, and testing them thoroughly.


<P>
The Hurd distribution includes a library called
<CODE>libshouldbeinlibc</CODE>, which serves as a proving ground for additions
to the GNU C library.  This library is in flux, as some functions are
added to it by the Hurd developers and others are moved to the official
C library.


<P>
These functions aren't currently documented (other than in their header
files), but complete documentation will be added to
<EM>The GNU C Library Reference Manual</EM>
when these functions become part of the GNU C library.




<H2><A NAME="SEC32" HREF="hurd_toc.html#TOC32">Bug Address Library</A></H2>
<P>
<A NAME="IDX69"></A>


<P>
<CODE>libhurdbugaddr</CODE> exists only to define a single variable:


<P>
<DL>
<DT><U>Variable:</U> char * <B>argp_program_bug_address</B>
<DD><A NAME="IDX70"></A>
<CODE>argp_program_bug_address</CODE> is the default Hurd bug-reporting e-mail
address, <A HREF="mailto:bug-hurd@gnu.org">bug-hurd@gnu.org</A>.  This address is displayed to the
user when any of the standard Hurd servers and utilities are invoked
using the <SAMP>`--help'</SAMP> option.
</DL>




<H1><A NAME="SEC33" HREF="hurd_toc.html#TOC33">Input and Output</A></H1>

<P>
There are no specific programs or servers associated with the I/O
subsystem, since it is used to interact with almost all servers in the
GNU Hurd.  It provides facilities for reading and writing I/O channels,
which are the underlying implementation of file and socket descriptors
in the GNU C library.




<H2><A NAME="SEC34" HREF="hurd_toc.html#TOC34">Iohelp Library</A></H2>
<P>
<A NAME="IDX71"></A>
<A NAME="IDX72"></A>


<P>
The <CODE>&#60;hurd/iohelp.h&#62;</CODE> file declares several functions which are
useful for low-level I/O implementations.  Most Hurd servers do not call
these functions directly, but they are used by several of the Hurd
filesystem and networking helper libraries.  <CODE>libiohelp</CODE> requires
<CODE>libthreads</CODE>.




<H3><A NAME="SEC35" HREF="hurd_toc.html#TOC35">I/O Users</A></H3>

<P>
Most I/O servers need to implement some kind of user authentication
checking.  In order to facilitate that process, <CODE>libiohelp</CODE> has
some functions which encapsulate a set of idvecs (FIXME: xref to C
library) in a single <CODE>struct iouser</CODE>.


<P>
<DL>
<DT><U>Function:</U> struct iouser * <B>iohelp_create_iouser</B> <I>(struct idvec *<VAR>uids</VAR>, struct idvec *<VAR>gids</VAR>)</I>
<DD><A NAME="IDX73"></A>
Create a new <VAR>iouser</VAR> for the specified <VAR>uids</VAR> and <VAR>gids</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> struct iouser * <B>iohelp_dup_iouser</B> <I>(struct iouser *<VAR>iouser</VAR>)</I>
<DD><A NAME="IDX74"></A>
Return a copy of <VAR>iouser</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>iohelp_free_iouser</B> <I>(struct iouser *<VAR>iouser</VAR>)</I>
<DD><A NAME="IDX75"></A>
Release a reference to <VAR>iouser</VAR>.
</DL>


<P>
I/O reauthentication is a rather complex protocol involving the
authserver as a trusted third party (see section <A HREF="hurd.html#SEC146">Auth Protocol</A>).  In order
to reduce the risk of flawed implementations, I/O reauthentication is
encapsulated in the <CODE>iohelp_reauth</CODE> function:


<P>
<DL>
<DT><U>Function:</U> struct iouser * <B>iohelp_reauth</B> <I>(auth_t <VAR>authserver</VAR>, mach_port_t <VAR>rend_port</VAR>, mach_port_t <VAR>newright</VAR>, int <VAR>permit_failure</VAR>)</I>
<DD><A NAME="IDX76"></A>
Conduct a reauthentication transaction, and return a new <VAR>iouser</VAR>.
<VAR>authserver</VAR> is the I/O server's auth port.  The rendezvous port
provided by the user is <VAR>rend_port</VAR>.


<P>
If the transaction cannot be completed, return zero, unless
<VAR>permit_failure</VAR> is nonzero.  If <VAR>permit_failure</VAR> is nonzero,
then should the transaction fail, return an <VAR>iouser</VAR> that has no
ids.  The new port to be sent to the user is <VAR>newright</VAR>.
</DL>




<H3><A NAME="SEC36" HREF="hurd_toc.html#TOC36">Conch Management</A></H3>

<P>
<A NAME="IDX77"></A>
<A NAME="IDX78"></A>
<A NAME="IDX79"></A>
<A NAME="IDX80"></A>
<A NAME="IDX81"></A>
<A NAME="IDX82"></A>
<A NAME="IDX83"></A>
<A NAME="IDX84"></A>
The <EM>conch</EM> is at the heart of the shared memory I/O system.
Several Hurd libraries implement shared I/O, and so <CODE>libiohelp</CODE>
contains functions to facilitate conch management.


<P>
Everything about shared I/O is undocumented because it is not needed for
adequate performance, and the RPC interface is simpler (see section <A HREF="hurd.html#SEC40">I/O Interface</A>).  It is not useful for new libraries or servers to implement
shared I/O.




<H2><A NAME="SEC37" HREF="hurd_toc.html#TOC37">Pager Library</A></H2>
<P>
<A NAME="IDX85"></A>
<A NAME="IDX86"></A>


<P>
<A NAME="IDX87"></A>
<A NAME="IDX88"></A>
The <EM>external pager</EM> (<EM>XP</EM>) microkernel interface allows
applications to provide the backing store for a memory object, by
converting hardware page faults into RPC requests.  External pagers are
required for memory-mapped I/O (see section <A HREF="hurd.html#SEC46">Mapped Data</A>) and stored
filesystems (see section <A HREF="hurd.html#SEC101">Stored Filesystems</A>).


<P>
The external pager interface is quite complex, so the Hurd pager library
contains functions which aid in creating multithreaded external pagers.
<CODE>libpager</CODE> is declared in <CODE>&#60;hurd/pager.h&#62;</CODE>, and requires only
the threads and ports libraries.




<H3><A NAME="SEC38" HREF="hurd_toc.html#TOC38">Pager Management</A></H3>

<P>
The pager library defines the <CODE>struct pager</CODE> data type in order to
represent a multi-threaded pager.  The general procedure for creating a
pager is to define the functions listed in section <A HREF="hurd.html#SEC39">Pager Callbacks</A>,
allocate a <CODE>libports</CODE> bucket for the ports which will access the
pager, and create at least one new <CODE>struct pager</CODE> with
<CODE>pager_create</CODE>.


<P>
<DL>
<DT><U>Function:</U> struct pager * <B>pager_create</B> <I>(struct user_pager_info *<VAR>u_pager</VAR>, struct port_bucket *<VAR>bucket</VAR>, boolean_t <VAR>may_cache</VAR>, memory_object_copy_strategy_t <VAR>copy_strategy</VAR>)</I>
<DD><A NAME="IDX89"></A>
Create a new pager.  The pager will have a port created for it (using
<CODE>libports</CODE>, in <VAR>bucket</VAR>) and will be immediately ready to
receive requests.  <VAR>u_pager</VAR> will be provided to later calls to
<CODE>pager_find_address</CODE>.  The pager will have one user reference
created.  <VAR>may_cache</VAR> and <VAR>copy_strategy</VAR> are the original
values of those attributes as for <CODE>memory_object_ready</CODE>.  Users may
create references to pagers by use of the relevant ports library
functions.  On errors, return null and set <CODE>errno</CODE>.
</DL>


<P>
Once you are ready to turn over control to the pager library, you should
call <CODE>ports_manage_port_operations_multithread</CODE> on the
<VAR>bucket</VAR>, using <CODE>pager_demuxer</CODE> as the ports <VAR>demuxer</VAR>.
This will handle all external pager RPCs, invoking your pager callbacks
when necessary.


<P>
<DL>
<DT><U>Function:</U> int <B>pager_demuxer</B> <I>(mach_msg_header_t *<VAR>inp</VAR>, mach_msg_header_t *<VAR>outp</VAR>)</I>
<DD><A NAME="IDX90"></A>
Demultiplex incoming <CODE>libports</CODE> messages on pager ports.
</DL>


<P>
The following functions are the body of the pager library, and provide a
clean interface to pager functionality:


<P>
<DL>
<DT><U>Function:</U> void <B>pager_sync</B> <I>(struct pager *<VAR>pager</VAR>, int <VAR>wait</VAR>)</I>
<DD><A NAME="IDX91"></A>
<DT><U>Function:</U> void <B>pager_sync_some</B> <I>(struct pager *<VAR>pager</VAR>, vm_address_t <VAR>start</VAR>, vm_size_t <VAR>len</VAR>, int <VAR>wait</VAR>)</I>
<DD><A NAME="IDX92"></A>
Write data from pager <VAR>pager</VAR> to its backing store.  Wait for all
the writes to complete if and only if <VAR>wait</VAR> is set.


<P>
<CODE>pager_sync</CODE> writes all data; <CODE>pager_sync_some</CODE> only writes
data starting at <VAR>start</VAR>, for <VAR>len</VAR> bytes.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>pager_flush</B> <I>(struct pager *<VAR>pager</VAR>, int <VAR>wait</VAR>)</I>
<DD><A NAME="IDX93"></A>
<DT><U>Function:</U> void <B>pager_flush_some</B> <I>(struct pager *<VAR>pager</VAR>, vm_address_t <VAR>start</VAR>, vm_size_t <VAR>len</VAR>, int <VAR>wait</VAR>)</I>
<DD><A NAME="IDX94"></A>
Flush data from the kernel for pager <VAR>pager</VAR> and force any pending
delayed copies.  Wait for all pages to be flushed if and only if
<VAR>wait</VAR> is set.


<P>
<CODE>pager_flush</CODE> flushes all data; <CODE>pager_flush_some</CODE> only
flushes data starting at <VAR>start</VAR>, for <VAR>len</VAR> bytes.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>pager_return</B> <I>(struct pager *<VAR>pager</VAR>, int <VAR>wait</VAR>)</I>
<DD><A NAME="IDX95"></A>
<DT><U>Function:</U> void <B>pager_return_some</B> <I>(struct pager *<VAR>pager</VAR>, vm_address_t <VAR>start</VAR>, vm_size_t <VAR>len</VAR>, int <VAR>wait</VAR>)</I>
<DD><A NAME="IDX96"></A>
Flush data from the kernel for pager <VAR>pager</VAR> and force any pending
delayed copies.  Wait for all pages to be flushed if and only if
<VAR>wait</VAR> is set.  Have the kernel write back modifications.


<P>
<CODE>pager_return</CODE> flushes and restores all data;
<CODE>pager_return_some</CODE> only flushes and restores data starting at
<VAR>start</VAR>, for <VAR>len</VAR> bytes.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>pager_offer_page</B> <I>(struct pager *<VAR>pager</VAR>, int <VAR>precious</VAR>, int <VAR>writelock</VAR>, vm_offset_t <VAR>page</VAR>, vm_address_t <VAR>buf</VAR>)</I>
<DD><A NAME="IDX97"></A>
Offer a page of data to the kernel.  If <VAR>precious</VAR> is set, then this
page will be paged out at some future point, otherwise it might be
dropped by the kernel.  If the page is currently in core, the kernel
might ignore this call.
</DL>


<P>
attributes@deftypefun void pager_change_attributes (struct pager *<VAR>pager</VAR>, boolean_t <VAR>may_cache</VAR>, memory_object_copy_strategy_t <VAR>copy_strategy</VAR>, int <VAR>wait</VAR>)
Change the attributes of the memory object underlying pager <VAR>pager</VAR>.
The <VAR>may_cache</VAR> and <VAR>copy_strategy</VAR> arguments are as for
<CODE>memory_object_change_</CODE>.  Wait for the kernel to report
completion if and only if <VAR>wait</VAR> is set.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>pager_shutdown</B> <I>(struct pager *<VAR>pager</VAR>)</I>
<DD><A NAME="IDX98"></A>
Force termination of a pager.  After this returns, no more paging
requests on the pager will be honoured, and the pager will be
deallocated.  The actual deallocation might occur asynchronously if
there are currently outstanding paging requests that will complete
first.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>pager_get_error</B> <I>(struct pager *<VAR>p</VAR>, vm_address_t <VAR>addr</VAR>)</I>
<DD><A NAME="IDX99"></A>
Return the error code of the last page error for pager <VAR>p</VAR> at
address <VAR>addr</VAR>.<A NAME="DOCF5" HREF="hurd_foot.html#FOOT5">(5)</A>
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>pager_memcpy</B> <I>(struct pager *<VAR>pager</VAR>, memory_object_t <VAR>memobj</VAR>, vm_offset_t <VAR>offset</VAR>, void *<VAR>other</VAR>, size_t *<VAR>size</VAR>, vm_prot_t <VAR>prot</VAR>)</I>
<DD><A NAME="IDX100"></A>
Try to copy <CODE>*<VAR>size</VAR></CODE> bytes between the region <VAR>other</VAR>
points to and the region at <VAR>offset</VAR> in the pager indicated by
<VAR>pager</VAR> and <VAR>memobj</VAR>.  If <VAR>prot</VAR> is <CODE>VM_PROT_READ</CODE>,
copying is from the pager to <VAR>other</VAR>; if <VAR>prot</VAR> contains
<CODE>VM_PROT_WRITE</CODE>, copying is from <VAR>other</VAR> into the pager.
<CODE>*<VAR>size</VAR></CODE> is always filled in with the actual number of bytes
successfully copied.  Returns an error code if the pager-backed memory
faults; if there is no fault, returns zero and <CODE>*<VAR>size</VAR></CODE> will
be unchanged.
</DL>


<P>
These functions allow you to recover the internal <CODE>struct pager</CODE>
state, in case the <CODE>libpager</CODE> interface doesn't provide an
operation you need:


<P>
<DL>
<DT><U>Function:</U> struct user_pager_info * <B>pager_get_upi</B> <I>(struct pager *<VAR>p</VAR>)</I>
<DD><A NAME="IDX101"></A>
Return the <CODE>struct user_pager_info</CODE> associated with a pager.
</DL>


<P>
<DL>
<DT><U>Function:</U> mach_port_t <B>pager_get_port</B> <I>(struct pager *<VAR>pager</VAR>)</I>
<DD><A NAME="IDX102"></A>
Return the port (receive right) for requests to the pager.  It is
absolutely necessary that a new send right be created from this receive
right.
</DL>




<H3><A NAME="SEC39" HREF="hurd_toc.html#TOC39">Pager Callbacks</A></H3>

<P>
Like several other Hurd libraries, <CODE>libpager</CODE> depends on you to
implement application-specific callback functions.  You <EM>must</EM>
define the following functions:


<P>
<DL>
<DT><U>Function:</U> error_t <B>pager_read_page</B> <I>(struct user_pager_info *<VAR>pager</VAR>, vm_offset_t <VAR>page</VAR>, vm_address_t *<VAR>buf</VAR>, int *<VAR>write_lock</VAR>)</I>
<DD><A NAME="IDX103"></A>
For pager <VAR>pager</VAR>, read one page from offset <VAR>page</VAR>.  Set
<CODE>*<VAR>buf</VAR></CODE> to be the address of the page, and set
<CODE>*<VAR>write_lock</VAR></CODE> if the page must be provided read-only.  The
only permissible error returns are <CODE>EIO</CODE>, <CODE>EDQUOT</CODE>, and
<CODE>ENOSPC</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>pager_write_page</B> <I>(struct user_pager_info *<VAR>pager</VAR>, vm_offset_t <VAR>page</VAR>, vm_address_t <VAR>buf</VAR>)</I>
<DD><A NAME="IDX104"></A>
For pager <VAR>pager</VAR>, synchronously write one page from <VAR>buf</VAR> to
offset <VAR>page</VAR>.  In addition, <CODE>vm_deallocate</CODE> (or equivalent)
<VAR>buf</VAR>.  The only permissible error returns are <CODE>EIO</CODE>,
<CODE>EDQUOT</CODE>, and <CODE>ENOSPC</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>pager_unlock_page</B> <I>(struct user_pager_info *<VAR>pager</VAR>, vm_offset_t <VAR>address</VAR>)</I>
<DD><A NAME="IDX105"></A>
A page should be made writable.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>pager_report_extent</B> <I>(struct user_pager_info *<VAR>pager</VAR>, vm_address_t *<VAR>offset</VAR>, vm_size_t *<VAR>size</VAR>)</I>
<DD><A NAME="IDX106"></A>
This function should report in <CODE>*<VAR>offset</VAR></CODE> and
<CODE>*<VAR>size</VAR></CODE> the minimum valid address the pager will accept and
the size of the object.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>pager_clear_user_data</B> <I>(struct user_pager_info *<VAR>pager</VAR>)</I>
<DD><A NAME="IDX107"></A>
This is called when a pager is being deallocated after all extant send
rights have been destroyed.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>pager_dropweak</B> <I>(struct user_pager_info *<VAR>p</VAR>)</I>
<DD><A NAME="IDX108"></A>
This will be called when the ports library wants to drop weak
references.  The pager library creates no weak references itself, so if
the user doesn't either, then it is all right for this function to do
nothing.
</DL>




<H2><A NAME="SEC40" HREF="hurd_toc.html#TOC40">I/O Interface</A></H2>
<P>
<A NAME="IDX109"></A>


<P>
The I/O interface facilities are described in <CODE>&#60;hurd/io.defs&#62;</CODE>.
This section discusses only RPC-based I/O operations.<A NAME="DOCF6" HREF="hurd_foot.html#FOOT6">(6)</A>




<H3><A NAME="SEC41" HREF="hurd_toc.html#TOC41">I/O Object Ports</A></H3>

<P>
The I/O server must associate each I/O port with a particular set of
uids and gids, identifying the user who is responsible for operations on
the port.  Every port to an I/O server should also support either the
file protocol (see section <A HREF="hurd.html#SEC64">File Interface</A>) or the socket protocol
(see section <A HREF="hurd.html#SEC130">Socket Interface</A>); naked I/O ports are not allowed.


<P>
In addition, the server associates with each port a default file
pointer, a set of open mode bits, a pid (called the "owner"), and some
underlying object which can absorb data (for write) or provide data (for
read).


<P>
The uid and gid sets associated with a port may not be visibly shared
with other ports, nor may they ever change.  The server must fix the
identification of a set of uids and gids with a particular port at the
moment of the port's creation.  The other characteristics of an I/O port
may be shared with other users.  The I/O server interface does not
generally specify the way in which servers may share these other
characteristics (with the exception of the deprecated
<CODE>O_ASYNC</CODE> interface); however, the file and socket interfaces make
further requirements about what sharing is required and what sharing is prohibited.


<P>
In general, users get send rights to I/O ports by some mechanism that is
external to the I/O protocol.  (For example, fileservers give out I/O
ports in response to the <CODE>dir_lookup</CODE> and <CODE>fsys_getroot</CODE>
calls.  Socket servers give out ports in response to the
<CODE>socket_create</CODE> and <CODE>socket_accept</CODE> calls.)  However, the I/O
protocol provides methods of obtaining new ports that refer to the same
underlying object as another port.  In response to all of these calls,
all underlying state (including, but not limited to, the default file
pointer, open mode bits, and underlying object) must be shared between
the old and new ports.  In the following descriptions of these calls,
the term "identical" means this kind of sharing.  All these calls must
return send rights to a newly-constructed Mach port.


<P>
<A NAME="IDX110"></A>
The <CODE>io_duplicate</CODE> call simply returns another port which is
identical to an existing port and has the same uid and gid set.


<P>
<A NAME="IDX111"></A>
The <CODE>io_restrict_auth</CODE> call returns another port, identical to the
provided port, but which has a smaller associated uid and gid set.  The
uid and gid sets of the new port are the intersection of the set on the
existing port and the lists of uids and gids provided in the call.


<P>
<A NAME="IDX112"></A>
Users use the <CODE>io_reauthenticate</CODE> call when they wish to have an
entirely new set of uids or gids associated with a port.  In response to
the <CODE>io_reauthenticate</CODE> call, the server must create a new port,
and then make the call <CODE>auth_server_authenticate</CODE> to the auth
server.  The rendezvous port for the <CODE>auth_server_authenticate</CODE>
call is the I/O port to which was made the <CODE>io_reauthenticate</CODE>
call.  The server provides the <VAR>rend_int</VAR> parameter to the auth
server as a copy from the corresponding parameter in the
<CODE>io_reauthenticate</CODE> call.  The I/O server also gives the auth
server a new port; this must be a newly created port identical to the
old port.  The authserver will return the set of uids and gids
associated with the user, and guarantees that the new port will go
directly to the user that possessed the associated authentication port.
The server then identifies the new port given out with the specified
ID's.




<H3><A NAME="SEC42" HREF="hurd_toc.html#TOC42">Simple Operations</A></H3>

<P>
<A NAME="IDX113"></A>
Users write to I/O ports by calling the <CODE>io_write</CODE> RPC.  They
specify an <VAR>offset</VAR> parameter; if the object supports writing at
arbitrary offsets, the server should honour this parameter.  If <EM>-1</EM>
is passed as the offset, then the server should use the default file
pointer.  The server should return the amount of data which was
successfully written.  If the operation was interrupted after some but
not all of the data was written, then it is considered to have succeeded
and the server should return the amount written.  If the port is not an
I/O port at all, the server should reply with the error
<CODE>EOPNOTSUPP</CODE>.  If the port is an I/O port, but does not happen to
support writing, then the correct error is <CODE>EBADF</CODE>.


<P>
<A NAME="IDX114"></A>
Users read from I/O ports by calling the <CODE>io_read</CODE> RPC.  They
specify the amount of data they wish to read, and the offset.  The offset
has the same meaning as for <CODE>io_write</CODE> above.  The server should
return the data that was read.  If the call is interrupted after some
data has been read (and the operation is not idempotent) then the server
should return the amount read, even if it was less than the amount requested.
The server should return as much data as possible, but never more than
requested by the user.  If there is no data, but there might be later,
the call should block until data becomes available.  The server indicates
end-of-file by returning zero bytes.  If the call is
interrupted after some data has been read, but the call is idempotent,
then the server may return <CODE>EINTR</CODE> rather than actually filling the
buffer (taking care that any modifications of the default file pointer
have been reversed).  Preferably, however, servers should return data.


<P>
There are two categories of objects: seekable and non-seekable.
Seekable objects must accept arbitrary offset parameters in the
<CODE>io_read</CODE> and <CODE>io_write</CODE> calls, and must implement the
<CODE>io_seek</CODE> call.  Non-seekable objects must ignore the offset
parameters to <CODE>io_read</CODE> and <CODE>io_write</CODE>, and should return
<CODE>ESPIPE</CODE> to the <CODE>io_seek</CODE> call.


<P>
<A NAME="IDX115"></A>
On seekable objects, <CODE>io_seek</CODE> changes the default file pointer for
reads and writes.  (See section `File Positioning' in <CITE>The GNU C Library Reference Manual</CITE>,
for the interpretation of the <VAR>whence</VAR> and <VAR>offset</VAR> arguments.)
It returns the new offset as modified by <CODE>io_seek</CODE>.


<P>
<A NAME="IDX116"></A>
The <CODE>io_readable</CODE> interface returns the amount of data which can be
immediately read.  For the special technical meaning of "immediately",
see section <A HREF="hurd.html#SEC44">Asynchronous I/O</A>.




<H3><A NAME="SEC43" HREF="hurd_toc.html#TOC43">Open Modes</A></H3>

<P>
<A NAME="IDX117"></A>
<A NAME="IDX118"></A>
<A NAME="IDX119"></A>
<A NAME="IDX120"></A>
The server associates each port with a set of bits that affect its
operation.  The <CODE>io_set_all_openmodes</CODE> call modifies these bits and
the <CODE>io_get_openmodes</CODE> call returns them.  In addition, the
<CODE>io_set_some_openmodes</CODE> and <CODE>io_clear_some_openmodes</CODE> do an
atomic read/modify/write of the openmodes.


<P>
The <CODE>O_APPEND</CODE> bit, when set, changes the behaviour of
<CODE>io_write</CODE> when it uses the default file pointer on seekable
objects.  When <CODE>io_write</CODE> is done on a port with the
<CODE>O_APPEND</CODE> bit set, is must set the file pointer to the current
file size before doing the write (which would then increment the file
pointer as usual).  The <EM>current file size</EM> is the smallest offset
which returns end-of-file when provided to <CODE>io_read</CODE>.  The server
must atomically bind this update to the actual data write with respect
to other users of <CODE>io_read</CODE>, <CODE>io_write</CODE>, and <CODE>io_seek</CODE>.


<P>
The <CODE>O_FSYNC</CODE> bit, when set, guarantees that <CODE>io_write</CODE> will
not return until data is fully written to the underlying medium.


<P>
The <CODE>O_NONBLOCK</CODE> bit, when set, prevents read and write from
blocking.  They should copy such data as is immediately available.  If
no data is immediately available they should return <CODE>EWOULDBLOCK</CODE>.


<P>
The definition of "immediately" is more or less server-dependent.
Some servers, notably stored filesystem servers (see section <A HREF="hurd.html#SEC101">Stored Filesystems</A>), regard all data as immediately available.  The one
criterion is that something which must happen <EM>immediately</EM> may not
wait for any user-synchronizable event.


<P>
The <CODE>O_ASYNC</CODE> bit is deprecated; its use is documented in the
following section.  This bit must be shared between all users of the
same underlying object.




<H3><A NAME="SEC44" HREF="hurd_toc.html#TOC44">Asynchronous I/O</A></H3>

<P>
<A NAME="IDX121"></A>
Users may wish to be notified when I/O can be done without blocking;
they use the <CODE>io_async</CODE> call to indicate this to the server.  In
the <CODE>io_async</CODE> call the user provides a port on which will the
server should send <CODE>sig_post</CODE> messages as I/O becomes possible.
The server must return a port which will be the reference port in the
<CODE>sig_post</CODE> messages.  Each <CODE>io_async</CODE> call should generate a
new reference port.  (FIXME: xref the C library manual for information
on how to send sig_post messages.)


<P>
The server then sends one <CODE>SIGIO</CODE> signal to each registered async
user everytime I/O becomes possible.  I/O is possible if at least one
byte can be read or written immediately.  The definition of
"immediately" must be the same as for the implementation of the
<CODE>O_NONBLOCK</CODE> flag (see section <A HREF="hurd.html#SEC43">Open Modes</A>).  In addition, every time a
user calls <CODE>io_read</CODE> or <CODE>io_write</CODE> on a non-seekable object, or at the
default file pointer on a seekable object, another signal should be sent
to each user if I/O is still possible.


<P>
Some objects may also define "urgent" conditions.  Such servers should
send the <CODE>SIGURG</CODE> signal to each registered async user anytime an
urgent condition appears.  After any RPC that has the possibility of
clearing the urgent condition, the server should again send the signal
to all registered users if the urgent condition is still present.


<P>
<A NAME="IDX122"></A>
A more fine-grained mechanism for doing async I/O is the
<CODE>io_select</CODE> call.  The user specifies the kind of access desired,
and a send-once right.  If I/O of the kind the user desires is
immediately possible, then the server should return so indicating, and
destroy the send-once right.  If I/O is not immediately possible, the
server should save the send-once right, and send a <CODE>select_done</CODE>
message as soon as I/O becomes immediately possible.  Again, the
definition of "immediately" must be the same for <CODE>io_select</CODE>,
<CODE>io_async</CODE>, and <CODE>O_NONBLOCK</CODE> (see section <A HREF="hurd.html#SEC43">Open Modes</A>).


<P>
<A NAME="IDX123"></A>
<A NAME="IDX124"></A>
<A NAME="IDX125"></A>
For compatibility with 4.2 and 4.3 BSD, the I/O interface provides a
deprecated feature (known as <EM>icky async I/O</EM>).  The calls
<CODE>io_mod_owner</CODE> and <CODE>io_get_owner</CODE> set the "owner" of the
object, providing either a pid or a pgrp (if the value is negative).
This implies that only one process at a time can do icky I/O on a given
object.  Whenever the I/O server is sending <CODE>sig_post</CODE> messages to
all the <CODE>io_async</CODE> users, if the <CODE>O_ASYNC</CODE> bit is set, the
server should also send a signal to the owning pid/pgrp.  The ID port
for this call should be different from all the <CODE>io_async</CODE> ID ports
given to users.  Users may find out what ID port the server uses for
this by calling <CODE>io_get_icky_async_id</CODE>.




<H3><A NAME="SEC45" HREF="hurd_toc.html#TOC45">Information Queries</A></H3>

<P>
<A NAME="IDX126"></A>
Users may call <CODE>io_stat</CODE> to find out information about the I/O
object.  Most of the fields of a <CODE>struct stat</CODE> are meaningful only
for files.  All objects, however, must support the fields
<VAR>st_fstype</VAR>, <VAR>st_fsid</VAR>, <VAR>st_ino</VAR>, <VAR>st_atime</VAR>,
<VAR>st_atime_usec</VAR>, <VAR>st_mtime_user</VAR>, <VAR>st_ctime</VAR>,
<VAR>st_ctime_usec</VAR>, and <VAR>st_blksize</VAR>.


<P>
<VAR>st_fstype</VAR>, <VAR>st_fsid</VAR>, and <VAR>st_ino</VAR> must be unique for
the underlying object across the entire system.


<P>
<VAR>st_atime</VAR> and <VAR>st_atime_usec</VAR> hold the seconds and
microseconds, respectively, of the system clock at the last time the
object was read with <CODE>io_read</CODE>.


<P>
<VAR>st_mtime</VAR> and <VAR>st_mtime_usec</VAR> hold the seconds and microseconds,
respectively, of the system clock at the last time the object was
written with <CODE>io_write</CODE>.


<P>
Other appropriate operations may update the <VAR>atime</VAR> and the
<VAR>mtime</VAR> as well; both the file and socket interfaces specify such
operations.


<P>
<VAR>st_ctime</VAR> and <VAR>st_ctime_usec</VAR> hold the seconds and
microseconds, respectively, of the system clock at the last time
permanent meta-data associated with the object was changed.  The exact
operations which cause such an update are server-dependent, but must
include the creation of the object.


<P>
The server is permitted to delay the actual update of these times until
stat is called; before the server stores the times on permanent media
(if it ever does so) it should update them if necessary.


<P>
<VAR>st_blksize</VAR> gives the optimal I/O size in bytes for <CODE>io_read</CODE>
and <CODE>io_write</CODE>; users should endeavor to read and write amounts
which are multiples of the optimal size, and to use offsets which are
multiples of the optimal size.


<P>
In addition, objects which are seekable should set <VAR>st_size</VAR> to the
current file size as in the description of the <CODE>O_APPEND</CODE> flag
(see section <A HREF="hurd.html#SEC43">Open Modes</A>).


<P>
The <VAR>st_uid</VAR> and <VAR>st_gid</VAR> fields are unrelated to the "owner"
as described above for icky async I/O.


<P>
<A NAME="IDX127"></A>
Users may find out the version of the server they are talking to by
calling <CODE>io_server_version</CODE>; this should return strings and
integers describing the version number of the server, as well as its
name.




<H3><A NAME="SEC46" HREF="hurd_toc.html#TOC46">Mapped Data</A></H3>

<P>
<A NAME="IDX128"></A>
Servers may optionally implement the <CODE>io_map</CODE> call.  The ports
returned by <CODE>io_map</CODE> must implement the external pager kernel
interface (see section <A HREF="hurd.html#SEC37">Pager Library</A>) and be suitable as arguments to
<CODE>vm_map</CODE>.


<P>
Seekable objects must allow access from zero up to (but not including)
the current file size as described for <CODE>O_APPEND</CODE> (see section <A HREF="hurd.html#SEC43">Open Modes</A>).  Whether they provide access beyond such a point is
server-dependent; in addition, the meaning of accessing a non-seekable
object is server-dependent.




<H1><A NAME="SEC47" HREF="hurd_toc.html#TOC47">Files</A></H1>

<P>
A file is traditionally thought of as a quantity of disk storage.  In
the Hurd, files are an extension of the I/O interface, but they do not
necessarily correspond to disk storage.


<P>
Every file in the Hurd is represented by a port, which is connected to
the server that manages the file.  When a client wants to operate on a
file, it makes RPC requests via a file port to its server process, which
is commonly called a <EM>translator</EM>.




<H2><A NAME="SEC48" HREF="hurd_toc.html#TOC48">Translators</A></H2>

<P>
The Hurd filesystem allows you to set translators on any file or
directory that you own.  A <EM>translator</EM> is any Hurd server which
provides the basic filesystem interface.  Translated nodes are somewhat
like a cross between Unix symbolic links and mount points.


<P>
Whenever a program tries to access the contents of a translated node,
the filesystem server redirects the request to the appropriate
translator (starting it if necessary).  Then, the new translator
services the client's request.  The GNU C library makes this behaviour
seamless from the client's perspective, so that standard Unix programs
behave correctly under the Hurd.


<P>
Translators run with the privileges of the translated node's
<EM>owner</EM>, so they cannot be used to compromise the security of the
system.  This also means that <EM>any</EM> user can write their own
translators, and provide other users with arbitrary
filesystem-structured data, regardless of the data's actual source.
Other chapters in this manual describe existing translators, and how you
can modify them or write your own.


<P>
The standard Hurd filesystem servers are constantly evolving to provide
innovative features that users want.  Here are a few examples of
existing translators:



<UL>
<LI>

Disk-based filesystem formats, such as <CODE>ext2fs</CODE>, <CODE>ufs</CODE>, and
<CODE>isofs</CODE> (see section <A HREF="hurd.html#SEC101">Stored Filesystems</A>).

<LI>

Network filesystems, such as <CODE>nfs</CODE> and <CODE>ftpfs</CODE>
(see section <A HREF="hurd.html#SEC118">Distributed Filesystems</A>).

<LI>

Single files with dynamic content, such as FIXME: we need a good
example.

<LI>

Hurd servers which translate rendezvous filesystem nodes in standard
locations, so that other programs can easily find them and use
server-specific interfaces.  For example, <CODE>pflocal</CODE> implements the
filesystem interfaces, but it also provides a special Unix-domain socket
RPC interface (FIXME xref).  Programs can fetch a port to this
translator simply by calling <CODE>file_name_lookup</CODE> (FIXME xref) on
<TT>`/servers/socket/1'</TT><A NAME="DOCF7" HREF="hurd_foot.html#FOOT7">(7)</A>, then use Unix
socket-specific RPCs on that port, rather than adhering to the file
protocol.
</UL>

<P>
This section focuses on the generic programs that you need to understand
in order to use existing translators.  Many other parts of this manual
describe how you can write your own translators.




<H3><A NAME="SEC49" HREF="hurd_toc.html#TOC49">Invoking <CODE>settrans</CODE></A></H3>
<P>
<A NAME="IDX129"></A>


<P>
The <CODE>settrans</CODE> program allows you to set a translator on a file or
directory.  By default, the passive translator is set (see the
<SAMP>`--passive'</SAMP> option).


<P>
The <CODE>settrans</CODE> program has the following synopsis:



<PRE>
settrans [<VAR>option</VAR>]... <VAR>node</VAR> [<VAR>translator</VAR> <VAR>arg</VAR>...]
</PRE>

<P>
where <VAR>translator</VAR> is the absolute filename of the new translator
program.  Each <VAR>arg</VAR> is passed to <VAR>translator</VAR> when it starts.
If <VAR>translator</VAR> is not specified, then <CODE>settrans</CODE> clears the
existing translator rather than setting a new one.


<P>
<CODE>settrans</CODE> accepts the following options:


<DL COMPACT>

<DT><SAMP>`-a'</SAMP>
<DD>
<DT><SAMP>`--active'</SAMP>
<DD>
Set <VAR>node</VAR>'s active translator.  <EM>Active translators</EM> are
started immediately and are not persistent: if the system is rebooted
then they are lost.

<DT><SAMP>`-c'</SAMP>
<DD>
<DT><SAMP>`--create'</SAMP>
<DD>
Create <VAR>node</VAR> as a zero-length file if it doesn't already exist.

<DT><SAMP>`-L'</SAMP>
<DD>
<DT><SAMP>`--dereference'</SAMP>
<DD>
If <VAR>node</VAR> is already translated, stack the new translator on top of
it (rather than replacing the existing translator).

<DT><SAMP>`--help'</SAMP>
<DD>
Display a brief usage message, then exit.

<DT><SAMP>`-p'</SAMP>
<DD>
<DT><SAMP>`--passive'</SAMP>
<DD>
Set <VAR>node</VAR>'s passive translator.  <EM>Passive translators</EM> are only
activated by the underlying filesystem when clients try to use the
<VAR>node</VAR>, and they shut down automatically after they are no longer
active in order to conserve system resources.

Passive translators are stored on the underlying filesystem media, and
so they persist between system reboots.  Not all filesystems support
passive translators, due to limitations in their underlying media.
Consult the filesystem-specific documentation to see if they are
supported.

If you are setting the passive translator, and <VAR>node</VAR> already has an
active translator, then the following options apply:

<DL COMPACT>

<DT><SAMP>`-g'</SAMP>
<DD>
<DT><SAMP>`--goaway'</SAMP>
<DD>
Tell the active translator to go away.  In this case, the following
additional options apply:

<DL COMPACT>

<DT><SAMP>`-f'</SAMP>
<DD>
<DT><SAMP>`--force'</SAMP>
<DD>
If the active translator doesn't go away, then force it.

<DT><SAMP>`-S'</SAMP>
<DD>
<DT><SAMP>`--nosync'</SAMP>
<DD>
Don't flush its contents to disk before terminating.

<DT><SAMP>`-R'</SAMP>
<DD>
<DT><SAMP>`--recursive'</SAMP>
<DD>
Shut down all of the active translator's children, too.
</DL>

<DT><SAMP>`-k'</SAMP>
<DD>
<DT><SAMP>`--keep-active'</SAMP>
<DD>
Leave the existing active translator running.  The new translator will
not be started unless the active translator has stopped.
</DL>

<DT><SAMP>`-P'</SAMP>
<DD>
<DT><SAMP>`--pause'</SAMP>
<DD>
When starting an active translator, prompt and wait for a newline on
standard input before completing the startup handshake.  This is useful
when debugging a translator, as it gives you time to start the debugger.

<DT><SAMP>`-t <VAR>sec</VAR>'</SAMP>
<DD>
<DT><SAMP>`--timeout=<VAR>sec</VAR>'</SAMP>
<DD>
If the translator does not start up in <VAR>sec</VAR> seconds (the default is
60), then return an error; if <VAR>sec</VAR> is 0, then never timeout.

<DT><SAMP>`--version'</SAMP>
<DD>
Output program version information and exit.

<DT><SAMP>`-x'</SAMP>
<DD>
<DT><SAMP>`--exclusive'</SAMP>
<DD>
Only set the translator if there is none already.
</DL>

<P>
FIXME: finish


<H3><A NAME="SEC50" HREF="hurd_toc.html#TOC50">Invoking <CODE>showtrans</CODE></A></H3>


<H3><A NAME="SEC51" HREF="hurd_toc.html#TOC51">Invoking <CODE>mount</CODE></A></H3>


<H3><A NAME="SEC52" HREF="hurd_toc.html#TOC52">Invoking <CODE>fsysopts</CODE></A></H3>



<H2><A NAME="SEC53" HREF="hurd_toc.html#TOC53">Trivfs Library</A></H2>
<P>
<A NAME="IDX130"></A>
<A NAME="IDX131"></A>


<P>
Certain translators do not need to be very complex, because they
represent a single file rather than an entire directory hierarchy.  The
trivfs library, which is declared in <CODE>&#60;hurd/trivfs.h&#62;</CODE>, does most of
the work of implementing this kind of translator.  This library requires
the iohelp and ports libraries.




<H3><A NAME="SEC54" HREF="hurd_toc.html#TOC54">Trivfs Startup</A></H3>

<P>
In order to use the trivfs library, you will need to define the
appropriate callbacks (see section <A HREF="hurd.html#SEC55">Trivfs Callbacks</A>).  As with all Hurd
servers, your trivfs-based translator should first parse any
command-line options, in case the user is just asking for help.  Trivfs
uses argp (see section `Argp' in <CITE>The GNU C Library Reference Manual</CITE>)
for parsing command-line arguments.


<P>
Your translator should redefine the following functions and variables as
necessary, and then call <CODE>argp_parse</CODE> with the relevant arguments:


<P>
<DL>
<DT><U>Variable:</U> extern struct argp * <B>trivfs_runtime_argp</B>
<DD><A NAME="IDX132"></A>
If this is defined or set to an argp structure, it will be used by the
default <CODE>trivfs_set_options</CODE> to handle runtime options parsing.
Redefining this is the normal way to add option parsing to a trivfs
program.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>trivfs_set_options</B> <I>(struct trivfs_control *<VAR>fsys</VAR>, char *<VAR>argz</VAR>, size_t <VAR>argz_len</VAR>)</I>
<DD><A NAME="IDX133"></A>
Set runtime options for <VAR>fsys</VAR> to <VAR>argz</VAR> and <VAR>argz_len</VAR>.
The default definition for this routine simply uses
<VAR>trivfs_runtime_argp</VAR> (supplying <VAR>fsys</VAR> as the argp input
field).
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>trivfs_append_args</B> <I>(struct trivfs_control *<VAR>fsys</VAR>, char **<VAR>argz</VAR>, size_t *<VAR>argz_len</VAR>)</I>
<DD><A NAME="IDX134"></A>
Append to the malloced string <CODE>*<VAR>argz</VAR></CODE> of length
<CODE>*<VAR>argz_len</VAR></CODE> a NUL-separated list of the arguments to this
translator.
</DL>


<P>
After your translator parses its command-line arguments, it should fetch
its bootstrap port by using <CODE>task_get_bootstrap_port</CODE>.  If this
port is <CODE>MACH_PORT_NULL</CODE>, then your program wasn't started as a
translator.  Otherwise, you can use the bootstrap port to create a new
control structure (and advertise its port) with <CODE>trivfs_startup</CODE>:


<P>
<DL>
<DT><U>Function:</U> error_t <B>trivfs_startup</B> <I>(mach_port_t <VAR>bootstrap</VAR>, int <VAR>flags</VAR>, struct port_class *<VAR>control_class</VAR>, struct port_bucket *<VAR>control_bucket</VAR>, struct port_class *<VAR>protid_class</VAR>, struct port_bucket *<VAR>protid_bucket</VAR>, struct trivfs_control **<VAR>control</VAR>)</I>
<DD><A NAME="IDX135"></A>
<DT><U>Function:</U> error_t <B>trivfs_create_control</B> <I>(mach_port_t <VAR>bootstrap</VAR>, struct port_class *<VAR>control_class</VAR>, struct port_bucket *<VAR>control_bucket</VAR>, struct port_class *<VAR>protid_class</VAR>, struct port_bucket *<VAR>protid_bucket</VAR>, struct trivfs_control **<VAR>control</VAR>)</I>
<DD><A NAME="IDX136"></A>
<CODE>trivfs_startup</CODE> creates a new trivfs control port, advertises it
to the underlying node <VAR>bootstrap</VAR> with <CODE>fsys_startup</CODE>,
returning the results of this call, and places its control structure in
<CODE>*<VAR>control</VAR></CODE>.  <CODE>trivfs_create_control</CODE> does the same
thing, except it doesn't advertise the control port to the underlying
node.  <VAR>control_class</VAR> and <VAR>control_bucket</VAR> are passed to
<CODE>libports</CODE> to create the control port, and <VAR>protid_class</VAR> and
<VAR>protid_bucket</VAR> are used when creating ports representing opens of
this node; any of these may be zero, in which case an appropriate port
class/bucket is created.  If <VAR>control</VAR> is non-null, the trivfs
control port is returned in it.  <VAR>flags</VAR> (a bitmask of the
appropriate <CODE>O_*</CODE> constants) specifies how to open the underlying
node.
</DL>


<P>
If you did not supply zeros as the class and bucket arguments to
<CODE>trivfs_startup</CODE>, you will probably need to use the trivfs port
management functions (see section <A HREF="hurd.html#SEC57">Trivfs Ports</A>).


<P>
Once you have successfully called <CODE>trivfs_startup</CODE>, and have a
pointer to the control structure stored in, say, the <VAR>fsys</VAR>
variable, you are ready to call one of the
<CODE>ports_manage_port_operations_*</CODE> functions using
<CODE><VAR>fsys</VAR>-&#62;pi.bucket</CODE> and <CODE>trivfs_demuxer</CODE>.  This will
handle any incoming filesystem requests, invoking your callbacks when
necessary.


<P>
<DL>
<DT><U>Function:</U> int <B>trivfs_demuxer</B> <I>(mach_msg_header_t *<VAR>inp</VAR>, mach_msg_header_t *<VAR>outp</VAR>)</I>
<DD><A NAME="IDX137"></A>
Demultiplex incoming <CODE>libports</CODE> messages on trivfs ports.
</DL>


<P>
The following functions are not usually necessary, but they allow you to
use the trivfs library even when it is not possible to turn
message-handling over to <CODE>trivfs_demuxer</CODE> and <CODE>libports</CODE>:


<P>
<DL>
<DT><U>Function:</U> struct trivfs_control * <B>trivfs_begin_using_control</B> <I>(mach_port_t <VAR>port</VAR>)</I>
<DD><A NAME="IDX138"></A>
<DT><U>Function:</U> struct trivfs_protid * <B>trivfs_begin_using_protid</B> <I>(mach_port_t <VAR>port</VAR>)</I>
<DD><A NAME="IDX139"></A>
These functions can be used as <CODE>intran</CODE> functions for a MiG port
type to have the stubs called with either the control or protid pointer.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>trivfs_end_using_control</B> <I>(struct trivfs_control *<VAR>port</VAR>)</I>
<DD><A NAME="IDX140"></A>
<DT><U>Function:</U> void <B>trivfs_end_using_protid</B> <I>(struct trivfs_protid *<VAR>port</VAR>)</I>
<DD><A NAME="IDX141"></A>
These can be used as `destructor' functions for a MiG port type, to have
the stubs called with the control or protid pointer.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>trivfs_open</B> <I>(struct trivfs_control *<VAR>fsys</VAR>, struct iouser *<VAR>user</VAR>, unsigned <VAR>flags</VAR>, mach_port_t <VAR>realnode</VAR>, struct trivfs_protid **<VAR>cred</VAR>)</I>
<DD><A NAME="IDX142"></A>
Return a new protid (that is, a port representing an open of this node)
pointing to a new peropen in <VAR>cred</VAR>, with <VAR>realnode</VAR> as the
underlying node reference, with the given identity, and open flags in
<VAR>flags</VAR>.  <VAR>cntl</VAR> is the trivfs control object.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>trivfs_protid_dup</B> <I>(struct trivfs_protid *<VAR>cred</VAR>, struct trivfs_protid **<VAR>dup</VAR>)</I>
<DD><A NAME="IDX143"></A>
Return a duplicate of <VAR>cred</VAR> in <VAR>dup</VAR>, sharing the same peropen
and hook.  A non-null protid <VAR>hook</VAR> indicates that
<VAR>trivfs_peropen_create_hook</VAR> created this protid (see section <A HREF="hurd.html#SEC56">Trivfs Options</A>).
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>trivfs_set_atime</B> <I>(struct trivfs_control *<VAR>cntl</VAR>)</I>
<DD><A NAME="IDX144"></A>
<DT><U>Function:</U> error_t <B>trivfs_set_mtime</B> <I>(struct trivfs_control *<VAR>cntl</VAR>)</I>
<DD><A NAME="IDX145"></A>
Call these to set atime or mtime for the node to the current time.
</DL>




<H3><A NAME="SEC55" HREF="hurd_toc.html#TOC55">Trivfs Callbacks</A></H3>

<P>
Like several other Hurd libraries, <CODE>libtrivfs</CODE> requires that you
define a number of application-specific callback functions and
configuration variables.  You <EM>must</EM> define the following variables
and functions:


<P>
<DL>
<DT><U>Variable:</U> extern int <B>trivfs_fstype</B>
<DD><A NAME="IDX146"></A>
<DT><U>Variable:</U> extern int <B>trivfs_fsid</B>
<DD><A NAME="IDX147"></A>
These variables are returned in the <VAR>st_fstype</VAR> and <VAR>st_fsid</VAR>
fields of <CODE>struct stat</CODE>.  <VAR>trivfs_fstype</VAR> should be chosen
from the <CODE>FSTYPE_*</CODE> constants found in <CODE>&#60;hurd/hurd_types.h&#62;</CODE>.
</DL>


<P>
<DL>
<DT><U>Variable:</U> extern int <B>trivfs_allow_open</B>
<DD><A NAME="IDX148"></A>
Set this to some bitwise OR combination of <CODE>O_READ</CODE>,
<CODE>O_WRITE</CODE>, and <CODE>O_EXEC</CODE>; trivfs will only allow opens of the
specified modes.
</DL>


<P>
<DL>
<DT><U>Variable:</U> extern int <B>trivfs_support_read</B>
<DD><A NAME="IDX149"></A>
<DT><U>Variable:</U> extern int <B>trivfs_support_write</B>
<DD><A NAME="IDX150"></A>
<DT><U>Variable:</U> extern int <B>trivfs_support_exec</B>
<DD><A NAME="IDX151"></A>
Set these to nonzero if trivfs should allow read, write, or execute of
the file.  These variables are necessary because <VAR>trivfs_allow_open</VAR>
is used only to validate opens, not actual operations.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>trivfs_modify_stat</B> <I>(struct trivfs_protid *<VAR>cred</VAR>, struct stat *<VAR>stbuf</VAR>)</I>
<DD><A NAME="IDX152"></A>
This should modify a <CODE>struct stat</CODE> (as returned from the underlying
node) for presentation to callers of <CODE>io_stat</CODE>.  It is permissible
for this function to do nothing, but it must still be defined.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>trivfs_goaway</B> <I>(struct trivfs_control *<VAR>cntl</VAR>, int <VAR>flags</VAR>)</I>
<DD><A NAME="IDX153"></A>
This function is called when someone wants the filesystem <VAR>cntl</VAR> to
go away.  <VAR>flags</VAR> are from the set <CODE>FSYS_GOAWAY_*</CODE> found in
<CODE>&#60;hurd/hurd_types.h&#62;</CODE>.
</DL>




<H3><A NAME="SEC56" HREF="hurd_toc.html#TOC56">Trivfs Options</A></H3>

<P>
The functions and variables described in this subsection already have
default definitions in <CODE>libtrivfs</CODE>, so you are not forced to define
them; rather, they may be redefined on a case-by-case basis.


<P>
<DL>
<DT><U>Variable:</U> extern struct port_class * <B>trivfs_protid_portclasses[]</B>
<DD><A NAME="IDX154"></A>
<DT><U>Variable:</U> extern int <B>trivfs_protid_nportclasses</B>
<DD><A NAME="IDX155"></A>
<DT><U>Variable:</U> extern struct port_class * <B>trivfs_cntl_portclasses[]</B>
<DD><A NAME="IDX156"></A>
<DT><U>Variable:</U> extern int <B>trivfs_cntl_nportclasses</B>
<DD><A NAME="IDX157"></A>
If you define these, they should be vectors (and the associated sizes)
of port classes that will be translated into control and protid pointers
for passing to RPCs, in addition to those passed to or created by
<CODE>trivfs_create_control</CODE> (or <CODE>trivfs_startup</CODE>), which will
automatically be recognized.
</DL>


<P>
<DL>
<DT><U>Variable:</U> error_t (* <B>trivfs_check_open_hook</B> <I>) (struct trivfs_control *<VAR>cntl</VAR>, struct iouser *<VAR>user</VAR>, int <VAR>flags</VAR>)</I>
<DD><A NAME="IDX158"></A>
If this variable is non-zero, it will be called every time an open happens.
<VAR>user</VAR> and <VAR>flags</VAR> are from the open; <VAR>cntl</VAR> identifies the
node being opened.  This call need not check permissions on the
underlying node.  This call can block as necessary, unless
<CODE>O_NONBLOCK</CODE> is set in <VAR>flags</VAR>.  Any desired error can be
returned, which will be reflected to the user and will prevent the open from
succeeding.
</DL>


<P>
<DL>
<DT><U>Variable:</U> error_t (* <B>trivfs_protid_create_hook</B> <I>) (struct trivfs_protid *<VAR>prot</VAR>)</I>
<DD><A NAME="IDX159"></A>
<DT><U>Variable:</U> error_t (* <B>trivfs_peropen_create_hook</B> <I>) (struct trivfs_peropen *<VAR>perop</VAR>)</I>
<DD><A NAME="IDX160"></A>
If these variables are non-zero, they will be called every time a new protid or
peropen structure is created and initialized.
</DL>


<P>
<DL>
<DT><U>Variable:</U> void (* <B>trivfs_protid_destroy_hook</B> <I>) (struct trivfs_protid *<VAR>prot</VAR>)</I>
<DD><A NAME="IDX161"></A>
<DT><U>Variable:</U> void (* <B>trivfs_peropen_destroy_hook</B> <I>) (struct trivfs_peropen *<VAR>perop</VAR>)</I>
<DD><A NAME="IDX162"></A>
If these variables is non-zero, they will be called every time a protid or
peropen structure is about to be destroyed.
</DL>


<P>
<DL>
<DT><U>Variable:</U> error_t (* <B>trivfs_getroot_hook</B> <I>) (struct trivfs_control *<VAR>cntl</VAR>, mach_port_t <VAR>reply_port</VAR>, mach_msg_type_name_t <VAR>reply_port_type</VAR>, mach_port_t <VAR>dotdot</VAR>, uid_t *<VAR>uids</VAR>, u_int <VAR>nuids</VAR>, uid_t *<VAR>gids</VAR>, u_int <VAR>ngids</VAR>, int <VAR>flags</VAR>, retry_type *<VAR>do_retry</VAR>, char *<VAR>retry_name</VAR>, mach_port_t *<VAR>node</VAR>, mach_msg_type_name_t *<VAR>node_type</VAR>)</I>
<DD><A NAME="IDX163"></A>
If this variable is set, it will be called by <CODE>trivfs_S_fsys_getroot</CODE>
before any other processing takes place.  If the return value is
<CODE>EAGAIN</CODE>, normal trivfs getroot processing continues, otherwise the
RPC returns with that return value.
</DL>




<H3><A NAME="SEC57" HREF="hurd_toc.html#TOC57">Trivfs Ports</A></H3>

<P>
If you choose to allocate your own trivfs port classes and buckets, the
following functions may come in handy:


<P>
<DL>
<DT><U>Function:</U> error_t <B>trivfs_add_port_bucket</B> <I>(struct port_bucket **<VAR>bucket</VAR>)</I>
<DD><A NAME="IDX164"></A>
Add the port bucket <CODE>*<VAR>bucket</VAR></CODE> to the list of dynamically-
allocated port buckets; if <CODE>*<VAR>bucket</VAR></CODE> is zero, an attempt is
made to allocate a new port bucket, which is then stored in
<CODE>*<VAR>bucket</VAR></CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>trivfs_remove_port_bucket</B> <I>(struct port_bucket *<VAR>bucket</VAR>)</I>
<DD><A NAME="IDX165"></A>
Remove the previously added dynamic port bucket <VAR>bucket</VAR>, freeing it
if it was allocated by <CODE>trivfs_add_port_bucket</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>trivfs_add_control_port_class</B> <I>(struct port_class **<VAR>class</VAR>)</I>
<DD><A NAME="IDX166"></A>
<DT><U>Function:</U> error_t <B>trivfs_add_protid_port_class</B> <I>(struct port_class **<VAR>class</VAR>)</I>
<DD><A NAME="IDX167"></A>
Add the port class <CODE>*<VAR>class</VAR></CODE> to the list of control or protid port
classes recognized by trivfs; if <CODE>*<VAR>class</VAR></CODE> is zero, an attempt is
made to allocate a new port class, which is stored in <CODE>*<VAR>class</VAR></CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>trivfs_remove_control_port_class</B> <I>(struct port_class *<VAR>class</VAR>)</I>
<DD><A NAME="IDX168"></A>
<DT><U>Function:</U> void <B>trivfs_remove_protid_port_class</B> <I>(struct port_class *<VAR>class</VAR>)</I>
<DD><A NAME="IDX169"></A>
Remove the previously added dynamic control or protid port class
<VAR>class</VAR>, freeing it if it was allocated by
<CODE>trivfs_add_control_port_class</CODE> or
<CODE>trivfs_add_protid_port_class</CODE>.
</DL>


<P>
Even if you do not use the above allocation functions, you may still be
able to use the default trivfs cleanroutines:


<P>
<DL>
<DT><U>Function:</U> void <B>trivfs_clean_cntl</B> <I>(void *<VAR>port</VAR>)</I>
<DD><A NAME="IDX170"></A>
<DT><U>Function:</U> void <B>trivfs_clean_protid</B> <I>(void *<VAR>port</VAR>)</I>
<DD><A NAME="IDX171"></A>
These functions should be installed as <CODE>libports</CODE> cleanroutines for
control port classes and protid port classes, respectively.
</DL>




<H2><A NAME="SEC58" HREF="hurd_toc.html#TOC58">Fshelp Library</A></H2>
<P>
<A NAME="IDX172"></A>
<A NAME="IDX173"></A>


<P>
The fshelp library implements various things that are useful to most
implementors of the file protocol.  It presumes that you are using the
iohelp library as well.  <CODE>libfshelp</CODE> is divided into separate
facilities which may be used independently.  These functions are
declared in <CODE>&#60;hurd/fshelp.h&#62;</CODE>.




<H3><A NAME="SEC59" HREF="hurd_toc.html#TOC59">Passive Translator Linkage</A></H3>

<P>
These routines are self-contained and start passive translators,
returning the control port.  They do not require multithreading or the
ports library.


<P>
<DL>
<DT><U>Typedef:</U> typedef error_t (* <B>fshelp_open_fn_t</B> <I>) (int <VAR>flags</VAR>, file_t *<VAR>node</VAR>, mach_msg_type_name_t *<VAR>node_type</VAR>)</I>
<DD><A NAME="IDX174"></A>
A callback used by the translator starting functions.
Given some open flags, opens the appropriate file, and
returns the node port.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>fshelp_start_translator_long</B> <I>(fshelp_open_fn_t <VAR>underlying_open_fn</VAR>, char *<VAR>name</VAR>, char *<VAR>argz</VAR>, int <VAR>argz_len</VAR>, mach_port_t *<VAR>fds</VAR>, mach_msg_type_name_t <VAR>fds_type</VAR>, int <VAR>fds_len</VAR>, mach_port_t *<VAR>ports</VAR>, mach_msg_type_name_t <VAR>ports_type</VAR>, int <VAR>ports_len</VAR>, int *<VAR>ints</VAR>, int <VAR>ints_len</VAR>, int <VAR>timeout</VAR>, fsys_t *<VAR>control</VAR>)</I>
<DD><A NAME="IDX175"></A>
Start a passive translator <VAR>name</VAR> with arguments <VAR>argz</VAR> (length
<VAR>argz_len</VAR>).  Initialize the initports to <VAR>ports</VAR> (length
<VAR>ports_len</VAR>), the initints to <VAR>ints</VAR> (length <VAR>ints_len</VAR>),
and the file descriptor table to <VAR>fds</VAR> (length <VAR>fds_len</VAR>).
Return the control port in <CODE>*<VAR>control</VAR></CODE>.  If the translator doesn't
respond or die in <VAR>timeout</VAR> milliseconds (if <VAR>timeout</VAR> is
greater than zero), return an appropriate error.  If the translator dies
before responding, return <CODE>EDIED</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>fshelp_start_translator</B> <I>(fshelp_open_fn_t <VAR>underlying_open_fn</VAR>, char *<VAR>name</VAR>, char *<VAR>argz</VAR>, int <VAR>argz_len</VAR>, int <VAR>timeout</VAR>, fsys_t *<VAR>control</VAR>)</I>
<DD><A NAME="IDX176"></A>
Same as <CODE>fshelp_start_translator_long</CODE>, except the initports and
ints are copied from our own state, <VAR>fd[2]</VAR> is copied from our own
stderr, and the other fds are cleared.  For full-service filesystems, it
is almost always wrong to use <CODE>fshelp_start_translator</CODE>, because
the current working directory of the translator will not then be as
normally expected.  (Current working directories of passive translators
should be the directory they were found in.)  In fact, full-service
filesystems should usually start passive translators as a side-effect of
calling <CODE>fshelp_fetch_root</CODE> (see section <A HREF="hurd.html#SEC60">Active Translator Linkage</A>).
</DL>




<H3><A NAME="SEC60" HREF="hurd_toc.html#TOC60">Active Translator Linkage</A></H3>

<P>
These routines implement the linkage to active translators needed
by any filesystem which supports them.  They require the threads
library and use the passive translator routines above, but they don't
require the ports library at all.


<P>
This interface is complex, because creating the ports and state
necessary for <CODE>start_translator_long</CODE> is expensive.  The caller to
<CODE>fshelp_fetch_root</CODE> should not need to create them on every call,
since usually there will be an existing active translator.


<P>
<DL>
<DT><U>Function:</U> void <B>fshelp_transbox_init</B> <I>(struct transbox *<VAR>transbox</VAR>, struct mutex *<VAR>lock</VAR>, void *<VAR>cookie</VAR>)</I>
<DD><A NAME="IDX177"></A>
Initialize a transbox, which contains state information for active
translators.
</DL>


<P>
<DL>
<DT><U>Typedef:</U> typedef error_t (* <B>fshelp_fetch_root_callback1_t</B> <I>) (void *<VAR>cookie1</VAR>, void *<VAR>cookie2</VAR>, uid_t *<VAR>uid</VAR>, gid_t *<VAR>gid</VAR>, char **<VAR>argz</VAR>, size_t *<VAR>argz_len</VAR>)</I>
<DD><A NAME="IDX178"></A>
This routine is called by <CODE>fshelp_fetch_root</CODE> to fetch more
information.  Return the owner and group of the underlying translated
file in <CODE>*<VAR>uid</VAR></CODE> and <CODE>*<VAR>gid</VAR></CODE>; point
<CODE>*<VAR>argz</VAR></CODE> at the entire passive translator specification for
the file (setting <CODE>*<VAR>argz_len</VAR></CODE> to the length).  If there is no
passive translator, then return <CODE>ENOENT</CODE>.  <VAR>cookie1</VAR> is the
cookie passed in <CODE>fshelp_transbox_init</CODE>.  <VAR>cookie2</VAR> is the
cookie passed in the call to <CODE>fshelp_fetch_root</CODE>.
</DL>


<P>
<DL>
<DT><U>Typedef:</U> typedef error_t (* <B>fshelp_fetch_root_callback2_t</B> <I>) (void *<VAR>cookie1</VAR>, void *<VAR>cookie2</VAR>, int <VAR>flags</VAR>, mach_port_t *<VAR>underlying</VAR>, mach_msg_type_name_t *<VAR>underlying_type</VAR>)</I>
<DD><A NAME="IDX179"></A>
This routine is called by <CODE>fshelp_fetch_root</CODE> to fetch more
information.  Return an unauthenticated node for the file itself in
<CODE>*<VAR>underlying</VAR></CODE> and <CODE>*<VAR>underlying_type</VAR></CODE> (opened with
<VAR>flags</VAR>).  <VAR>cookie1</VAR> is the cookie passed in
<CODE>fshelp_transbox_init</CODE>.  <VAR>cookie2</VAR> is the cookie passed in the
call to <CODE>fshelp_fetch_root</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>fshelp_fetch_root</B> <I>(struct transbox *<VAR>transbox</VAR>, void *<VAR>cookie</VAR>, file_t <VAR>dotdot</VAR>, struct iouser *<VAR>user</VAR>, int <VAR>flags</VAR>, fshelp_fetch_root_callback1_t <VAR>callback1</VAR>, fshelp_fetch_root_callback2_t <VAR>callback2</VAR>, retry_type *<VAR>retry</VAR>, char *<VAR>retryname</VAR>, mach_port_t *<VAR>root</VAR>)</I>
<DD><A NAME="IDX180"></A>
Fetch the root from <VAR>transbox</VAR>.  <VAR>dotdot</VAR> is an unauthenticated
port for the directory in which we are looking; <VAR>user</VAR> specifies the
ids of the user responsible for the call.  <VAR>flags</VAR> are as for
<CODE>dir_pathtrans</CODE> (but <CODE>O_CREAT</CODE> and <CODE>O_EXCL</CODE> are not
meaningful and are ignored).  The transbox lock (as set by
<CODE>fshelp_transbox_init</CODE>) must be held before the call, and will be
held upon return, but may be released during the operation of the call.
</DL>


<P>
<DL>
<DT><U>Function:</U> int <B>fshelp_translated</B> <I>(struct transbox *<VAR>box</VAR>)</I>
<DD><A NAME="IDX181"></A>
Return true if and only if there is an active translator on this box.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>fshelp_set_active</B> <I>(struct transbox *<VAR>box</VAR>, fsys_t <VAR>newactive</VAR>, int <VAR>excl</VAR>)</I>
<DD><A NAME="IDX182"></A>
Atomically replace the existing active translator port for this box with
<VAR>newactive</VAR>.  If <VAR>excl</VAR> is non-zero then don't modify an
existing active transbox; return <CODE>EBUSY</CODE> instead.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>fshelp_fetch_control</B> <I>(struct transbox *<VAR>box</VAR>, mach_port_t *<VAR>control</VAR>)</I>
<DD><A NAME="IDX183"></A>
Fetch the control port to make a request on it.  It's a bad idea to use
<CODE>fsys_getroot</CODE> with the result; use <CODE>fshelp_fetch_root</CODE>
instead.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>fshelp_drop_transbox</B> <I>(struct transbox *<VAR>box</VAR>)</I>
<DD><A NAME="IDX184"></A>
Clean transbox state so that deallocation or reuse is possible.
</DL>




<H3><A NAME="SEC61" HREF="hurd_toc.html#TOC61">Fshelp Locking</A></H3>

<P>
The <CODE>flock</CODE> call is in flux, as the current Hurd interface (as of
version 0.2) is not suitable for implementing the POSIX
record-locking semantics.




<H3><A NAME="SEC62" HREF="hurd_toc.html#TOC62">Fshelp Permissions</A></H3>

<P>
These functions are designed to aid with user permission checking.  It
is a good idea to use these routines rather than to roll your own, so
that Hurd users see consistent handling of file and directory permission
bits.


<P>
<DL>
<DT><U>Function:</U> error_t <B>fshelp_isowner</B> <I>(struct stat *<VAR>st</VAR>, struct iouser *<VAR>user</VAR>)</I>
<DD><A NAME="IDX185"></A>
Check to see whether <VAR>user</VAR> should be considered the owner of the
file identified by <VAR>st</VAR>.  If so, return zero; otherwise return an
appropriate error code.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>fshelp_access</B> <I>(struct stat *<VAR>st</VAR>, int <VAR>op</VAR>, struct iouser *<VAR>user</VAR>)</I>
<DD><A NAME="IDX186"></A>
Check to see whether the user <VAR>user</VAR> can operate on the file
identified by <VAR>st</VAR>.  <VAR>op</VAR> is one of <CODE>S_IREAD</CODE>,
<CODE>S_IWRITE</CODE>, and <CODE>S_IEXEC</CODE>.  If the access is permitted, return
zero; otherwise return an appropriate error code.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>fshelp_checkdirmod</B> <I>(struct stat *<VAR>dir</VAR>, struct stat *<VAR>st</VAR>, struct iouser *<VAR>user</VAR>)</I>
<DD><A NAME="IDX187"></A>
Check to see whether <VAR>user</VAR> is allowed to modify <VAR>dir</VAR> with respect to
existing file <VAR>st</VAR>.  If there is no existing file, then <VAR>st</VAR>
should be set to zero.  If the access is permissible, return zero;
otherwise return an appropriate error code.
</DL>




<H3><A NAME="SEC63" HREF="hurd_toc.html#TOC63">Fshelp Misc</A></H3>

<P>
The following functions are completely standalone:


<P>
<DL>
<DT><U>Function:</U> error_t <B>fshelp_delegate_translation</B> <I>(char *<VAR>server_name</VAR>, mach_port_t <VAR>requestor</VAR>, char **<VAR>argv</VAR>)</I>
<DD><A NAME="IDX188"></A>
Try to hand off responsibility from a translator to the server located
on the node <VAR>server_name</VAR>.  <VAR>requestor</VAR> is the translator's
bootstrap port, and <VAR>argv</VAR> is the command line.  If
<VAR>server_name</VAR> is null, then a name is concocted by prepending
<CODE>_servers</CODE> to <CODE>argv[0]</CODE> .
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>fshelp_exec_reauth</B> <I>(int <VAR>suid</VAR>, uid_t <VAR>uid</VAR>, int <VAR>sgid</VAR>, gid_t <VAR>gid</VAR>, auth_t <VAR>auth</VAR>, error_t (*<VAR>get_file_ids</VAR>) (struct idvec *<VAR>uids</VAR>, struct idvec *<VAR>gids</VAR>), mach_port_t *<VAR>ports</VAR>, mach_msg_type_number_t <VAR>num_ports</VAR>, mach_port_t *<VAR>fds</VAR>, mach_msg_type_number_t <VAR>num_fds</VAR>, int *<VAR>secure</VAR>)</I>
<DD><A NAME="IDX189"></A>
If <VAR>suid</VAR> or <VAR>sgid</VAR> is true, adds <VAR>uid</VAR> and/or <VAR>gid</VAR>
respectively to the authentication in
<CODE><VAR>ports</VAR>[INIT_PORT_AUTH]</CODE>, and replaces it with the result.
All the other ports in <VAR>ports</VAR> and <VAR>fds</VAR> are then
reauthenticated, using any privileges available through <VAR>auth</VAR>.  If
the auth port in <CODE><VAR>ports</VAR>[INIT_PORT_AUTH]</CODE> is bogus, and
<VAR>get_file_ids</VAR> is non-null, it is called to get a list
of uids and gids from the file to use as a replacement.  If <VAR>secure</VAR>
is non-null and any added ids are new, then the variable it points to is
set to nonzero, otherwise zero.  If either the uid or gid case fails,
then the other may still apply.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>fshelp_get_identity</B> <I>(struct port_bucket *<VAR>bucket</VAR>, ino_t <VAR>fileno</VAR>, mach_port_t *<VAR>pt</VAR>)</I>
<DD><A NAME="IDX190"></A>
Return an identity port in <CODE>*<VAR>pt</VAR></CODE> for the node numbered
<VAR>fileno</VAR>, suitable for returning from <CODE>io_identity</CODE>; exactly
one send right must be created from the returned value.  <VAR>fileno</VAR>
should be the same value returned as the <VAR>fileno</VAR> out-parameter in
<CODE>io_identity</CODE>, and in the enclosing directory (except for mount
points), and in the <CODE>st_ino</CODE> stat field.  <VAR>bucket</VAR> should be a
<CODE>libports</CODE> port bucket; fshelp requires the caller to make sure
port operations (for no-senders notifications) are used.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>fshelp_return_malloced_buffer</B> <I>(char *<VAR>buf</VAR>, size_t <VAR>len</VAR>, char **<VAR>rbuf</VAR>, mach_msg_type_number_t *<VAR>rlen</VAR>)</I>
<DD><A NAME="IDX191"></A>
Put data from the malloced buffer <VAR>buf</VAR>, <VAR>len</VAR> bytes long, into
<VAR>rbuf</VAR> (which is <VAR>rlen</VAR> bytes long), suitable for returning from
an RPC.  If <VAR>len</VAR> is greater than zero, <VAR>buf</VAR> is freed,
regardless of whether an error is returned or not.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>fshelp_set_options</B> <I>(struct argp *<VAR>argp</VAR>, int <VAR>flags</VAR>, char *<VAR>argz</VAR>, size_t <VAR>argz_len</VAR>, void *<VAR>input</VAR>)</I>
<DD><A NAME="IDX192"></A>
Invoke <CODE>argp_parse</CODE> in the standard way, with data from <VAR>argz</VAR>
and <VAR>argz_len</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>fshelp_touch</B> <I>(struct stat *<VAR>st</VAR>, unsigned <VAR>what</VAR>, volatile struct mapped_time_value *<VAR>maptime</VAR>)</I>
<DD><A NAME="IDX193"></A>
Change the stat times of <VAR>node</VAR> as indicated by <VAR>what</VAR> to
the current time.  <VAR>what</VAR> is a bitmask of one or more of
the <CODE>TOUCH_ATIME</CODE>, <CODE>TOUCH_MTIME</CODE>, and <CODE>TOUCH_CTIME</CODE>
constants.
</DL>




<H2><A NAME="SEC64" HREF="hurd_toc.html#TOC64">File Interface</A></H2>
<P>
<A NAME="IDX194"></A>


<P>
This section documents the interface for operating on files.




<H3><A NAME="SEC65" HREF="hurd_toc.html#TOC65">File Overview</A></H3>

<P>
The file interface is a superset of the I/O interface (see section <A HREF="hurd.html#SEC40">I/O Interface</A>).  Servers which provide the file interface are required to
support the I/O interface as well.  All objects reachable in the
filesystem are expected to provide the file interface, even if they do
not contain data.  (The <CODE>trivfs</CODE> library makes it easy to do so for
ordinary sorts of cases.  See section <A HREF="hurd.html#SEC53">Trivfs Library</A>.)


<P>
The interface definitions for the file interface are found in
<CODE>&#60;hurd/fs.defs&#62;</CODE>.


<P>
Files have various pieces of status information which are returned by
<CODE>io_stat</CODE> (see section <A HREF="hurd.html#SEC45">Information Queries</A>).  Most of this status
information can be directly changed by various calls in the file
interface; some of it should vary implicitly as the contents of the file
change.


<P>
Many of these calls have general rules associated with them describing
how security and privilege should operate.  The <CODE>diskfs</CODE> library
(see section <A HREF="hurd.html#SEC106">Diskfs Library</A>) implements these rules for stored filesystems.
These rules have also been implemented in the fshelp library
(see section <A HREF="hurd.html#SEC58">Fshelp Library</A>).  Trivfs-based servers generally have no need
to implement these rules at all.


<P>
In special cases, there may be a reason to implement a different
security check from that specified here, or to implement a call to do
something slightly different.  But such cases must be carefully
considered; make sure that you will not confuse innocent user programs
through excessive cleverness.


<P>
If some operation cannot be implemented (for example, <CODE>chauthor</CODE>
over FTP), then the call should return <CODE>EOPNOTSUPP</CODE>.  If it is
merely difficult to implement a call, it is much better to figure out a
way to implement it as a series of operations rather than to return
errors to the user.




<H3><A NAME="SEC66" HREF="hurd_toc.html#TOC66">Changing Status</A></H3>

<P>
There are several RPCs available for users to change much of the status
information associated with a file.  (The information is returned by the
<CODE>io_stat</CODE> RPC; see section <A HREF="hurd.html#SEC45">Information Queries</A>.)


<P>
All these operations are restricted to root and the owner of the file.
When attempted by another user, they should return <CODE>EPERM</CODE>.


<P>
<A NAME="IDX195"></A>
The <CODE>file_chown</CODE> RPC changes the owner and group of the file.  Only
root should be able to change the owner, and changing the group to a
group the caller is not in should also be prohibited.  Violating either
of these conditions should return <CODE>EPERM</CODE>.


<P>
<A NAME="IDX196"></A>
The <CODE>file_chauthor</CODE> RPC changes the author of the file.  It should
be legitimate to change the author to any value without restriction.


<P>
<A NAME="IDX197"></A>
The <CODE>file_chmod</CODE> RPC changes the file permission mode bits.


<P>
<A NAME="IDX198"></A>
The <CODE>file_chflags</CODE> RPC changes the flags of the file.  It should be
legitimate to change the flags to any value without restriction.  No
standard meanings have been assigned to the flags yet, but we intend to
do so.  Do not assume that the flags format we choose will map
identically to that of some existing filesystem format.


<P>
<A NAME="IDX199"></A>
The <CODE>file_utimes</CODE> RPC changes the <VAR>atime</VAR> and <VAR>mtime</VAR> of
the file.  Making this call must cause the <VAR>ctime</VAR> to be updated as
well, even if no actual change to either the <VAR>mtime</VAR> or the
<VAR>atime</VAR> occurs.


<P>
<A NAME="IDX200"></A>
The <CODE>file_set_size</CODE> RPC is special; not only does it change the
status word specifying the size of the file, but it also changes the
actual contents of the file.  If the file size is being reduced it
should release secondary storage associated with the previous contents
of the file.  If the file is being extended, the new region added to the
file must be zero-filled.  Unlike the other RPCs in this section,
<CODE>file_set_size</CODE> should be permitted to any user who is allowed to
write the file.




<H3><A NAME="SEC67" HREF="hurd_toc.html#TOC67">Program Execution</A></H3>

<P>
<A NAME="IDX201"></A>
Execution of programs on the Hurd is done through fileservers with the
<CODE>file_exec</CODE> RPC.  The fileserver is expected to verify that the
user is allowed to execute the file, make whatever modifications to the
ports are necessary for setuid execution, and then invoke the standard
execserver found on <TT>`/servers/exec'</TT>.


<P>
This section specifically addresses what fileservers are expected to do,
with minimal attention to the other parts of the process.  See section <A HREF="hurd.html#SEC134">Running Programs</A>, for more general information.


<P>
The file must be opened for execution; if it is not, <CODE>EBADF</CODE> should
be returned.  In addition, at least one of the execute bits must be on.  A
failure of this check should result in <CODE>EACCES</CODE>---not
<CODE>ENOEXEC</CODE>.  It is not proper for the fileserver ever to respond to
the <CODE>file_exec</CODE> RPC with <CODE>ENOEXEC</CODE>.


<P>
If either the setuid or setgid bits are set, the server needs to
construct a new authentication handle with the additional new ID's.
Then all the ports passed to <CODE>file_exec</CODE> need to be reauthenticated
with the new handle.  If the fileserver is unable to make the new
authentication handle (for example, because it is not running as root)
it is not acceptable to return an error; in such a case the server
should simply silently fail to implement the setuid/setgid semantics.


<P>
If the setuid/setgid transformation adds a new uid or gid to the user's
authentication handle that was not previously present (as opposed to
merely reordering them), then the <CODE>EXEC_SECURE</CODE> and
<CODE>EXEC_NEWTASK</CODE> flags should both be added in the call to
<CODE>exec_exec</CODE>.


<P>
The server then needs to open a new port onto the executed file which
will not share any file pointers with the port the user passed in,
opened with <CODE>O_READ</CODE>.  Finally, all the information (mutated
appropriately for setuid/setgid) should be sent to the execserver with
<CODE>exec_exec</CODE>.  Whatever error code <CODE>exec_exec</CODE> returns should
returned to the caller of <CODE>file_exec</CODE>.




<H3><A NAME="SEC68" HREF="hurd_toc.html#TOC68">File Locking</A></H3>

<P>
The <CODE>flock</CODE> call is in flux, as the current Hurd interface (as of
version 0.2) is not suitable for implementing the POSIX
record-locking semantics.


<P>
<A NAME="IDX202"></A>
<A NAME="IDX203"></A>
You should ignore the <CODE>file_lock</CODE> and <CODE>file_lock_stat</CODE> calls
until the new record-locking interface is implemented.




<H3><A NAME="SEC69" HREF="hurd_toc.html#TOC69">File Frobbing</A></H3>

<P>
FIXME: Other active calls on files


<P>
<CODE>file_sync</CODE>


<P>
<CODE>file_getfh</CODE>


<P>
<CODE>file_getlinknode</CODE>


<P>
<CODE>file_check_access</CODE>


<P>
These manipulate meta-information:


<P>
<CODE>file_reparent</CODE>


<P>
<CODE>file_statfs</CODE>


<P>
<CODE>file_syncfs</CODE>


<P>
<CODE>file_getcontrol</CODE>


<P>
<CODE>file_get_storage_info</CODE>


<P>
<CODE>file_get_fs_options</CODE>




<H3><A NAME="SEC70" HREF="hurd_toc.html#TOC70">Opening Files</A></H3>

<P>
FIXME: Looking up files in directories


<P>
<CODE>dir_lookup</CODE>


<P>
<CODE>dir_readdir</CODE>




<H3><A NAME="SEC71" HREF="hurd_toc.html#TOC71">Modifying Directories</A></H3>

<P>
FIXME: Creating and deleting nodes


<P>
<CODE>dir_mkfile</CODE>


<P>
<CODE>dir_mkdir</CODE>


<P>
<CODE>dir_rmdir</CODE>


<P>
<CODE>dir_unlink</CODE>


<P>
<CODE>dir_link</CODE>


<P>
<CODE>dir_rename</CODE>




<H3><A NAME="SEC72" HREF="hurd_toc.html#TOC72">Notifications</A></H3>

<P>
FIXME: File and directory change callbacks


<P>
File change notifications are not yet implemented, but directory
notifications are.


<P>
<CODE>file_notice_changes</CODE>


<P>
<CODE>dir_notice_changes</CODE>




<H3><A NAME="SEC73" HREF="hurd_toc.html#TOC73">File Translators</A></H3>

<P>
FIXME: How to set and get translators


<P>
<CODE>file_set_translator</CODE>


<P>
<CODE>file_get_translator</CODE>


<P>
<CODE>file_get_translator_cntl</CODE>




<H2><A NAME="SEC74" HREF="hurd_toc.html#TOC74">Filesystem Interface</A></H2>
<P>
<A NAME="IDX204"></A>


<P>
The filesystem interface (described in <CODE>&#60;hurd/fsys.defs&#62;</CODE>) is
supported by translator control ports.


<P>
FIXME: finish




<H1><A NAME="SEC75" HREF="hurd_toc.html#TOC75">Special Files</A></H1>

<P>
In Unix, any file that does not act as a general-purpose unit of storage
is called a <EM>special file</EM>.  These are FIFOs, Unix-domain sockets,
and device nodes.  In the Hurd, there is no need for the "special
file" distinction, since they are implemented by translators, just as
regular files are.


<P>
Nevertheless, the Hurd maintains this distinction, in order to provide
backward compatibility for Unix programs (which do not know about
translators).  Studying the implementation of Hurd special files is a
good way to introduce the idea of translators to people who are familiar
with Unix.


<P>
This chapter does not discuss <TT>`/dev/zero'</TT> or any of the
microkernel-based devices, since these are translated by the generalized
storeio server (FIXME xref).


<P>
FIXME: finish




<H2><A NAME="SEC76" HREF="hurd_toc.html#TOC76">fifo</A></H2>


<H2><A NAME="SEC77" HREF="hurd_toc.html#TOC77">ifsock</A></H2>


<H2><A NAME="SEC78" HREF="hurd_toc.html#TOC78">magic</A></H2>


<H2><A NAME="SEC79" HREF="hurd_toc.html#TOC79">null</A></H2>

<P>
FIXME: a chapter on libtreefs and libdirmgt will probably go here




<H1><A NAME="SEC80" HREF="hurd_toc.html#TOC80">Stores</A></H1>

<P>
A <EM>store</EM> is a fixed-size block of storage, which can be read and
perhaps written to.  A store is more general than a file: it refers to
any type of storage such as devices, files, memory, tasks, etc.  Stores
can also be representations of other stores, which may be combined and
filtered in various ways.




<H2><A NAME="SEC81" HREF="hurd_toc.html#TOC81">storeinfo, storecat, storeread</A></H2>


<H2><A NAME="SEC82" HREF="hurd_toc.html#TOC82">storeio</A></H2>

<P>
FIXME: finish




<H2><A NAME="SEC83" HREF="hurd_toc.html#TOC83">Store Library</A></H2>
<P>
<A NAME="IDX205"></A>
<A NAME="IDX206"></A>


<P>
The store library (which is declared in <CODE>&#60;hurd/store.h&#62;</CODE>)
implements many different backends which support the store abstraction.
Hurd programs use <CODE>libstore</CODE> so that new storage types can be
implemented with minimum impact.




<H3><A NAME="SEC84" HREF="hurd_toc.html#TOC84">Store Arguments</A></H3>

<P>
FIXME: describe startup sequence


<P>
<DL>
<DT><U>Structure:</U> struct <B>store_parsed</B>
<DD><A NAME="IDX207"></A>
The result of parsing a store, which should be enough information to
open it, or return the arguments.
</DL>


<P>
<DL>
<DT><U>Structure:</U> struct <B>store_argp_params</B> <I>{ struct store_parsed *<VAR>result</VAR>; const char *<VAR>default_type</VAR>; const struct store_class *const *<VAR>classes</VAR>; }</I>
<DD><A NAME="IDX208"></A>
This is the structure used to pass args back and forth from
<VAR>store_argp</VAR>.  <VAR>result</VAR> is the resulting parsed result.  If
<SAMP>`--store-type'</SAMP> isn't specified, then <VAR>default_type</VAR> should be
used as the store type; zero is equivalent to <CODE>"query"</CODE>.
<VAR>classes</VAR> is set of classes used to validate store types and
argument syntax.
</DL>


<P>
<DL>
<DT><U>Variable:</U> extern struct argp <B>store_argp</B>
<DD><A NAME="IDX209"></A>
This is an argument parser that may be used for parsing a simple command
line specification for stores.  The accompanying input parameter must be
a pointer to a <CODE>struct store_argp_params</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>store_parsed_free</B> <I>(struct store_parsed *<VAR>parsed</VAR>)</I>
<DD><A NAME="IDX210"></A>
Free all resources used by <VAR>parsed</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_parsed_open</B> <I>(const struct store_parsed *<VAR>parsed</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX211"></A>
Open the store specified by <VAR>parsed</VAR>, and return it in <VAR>store</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_parsed_append_args</B> <I>(const struct store_parsed *<VAR>parsed</VAR>, char **<VAR>argz</VAR>, size_t *<VAR>argz_len</VAR>)</I>
<DD><A NAME="IDX212"></A>
Add the arguments used to create <VAR>parsed</VAR> to <VAR>argz</VAR> and
<VAR>argz_len</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_parsed_name</B> <I>(const struct store_parsed *<VAR>parsed</VAR>, char **<VAR>name</VAR>)</I>
<DD><A NAME="IDX213"></A>
Make an option string describing <VAR>parsed</VAR>, and return it in malloced
storage in <VAR>name</VAR>.
</DL>




<H3><A NAME="SEC85" HREF="hurd_toc.html#TOC85">Store Management</A></H3>

<P>
The following functions provide basic management of stores:


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_create</B> <I>(file_t <VAR>source</VAR>, int <VAR>flags</VAR>, const struct store_class *const *<VAR>classes</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX214"></A>
Return a new store in <VAR>store</VAR>, which refers to the storage
underlying <VAR>source</VAR>.  <VAR>classes</VAR> is used to select classes
specified by the provider; if zero, <VAR>store_std_classes</VAR> is used.
<VAR>flags</VAR> is set with <CODE>store_set_flags</CODE>, with the exception of
<CODE>STORE_INACTIVE</CODE>, which merely indicates that no attempt should be
made to activate an inactive store; if <CODE>STORE_INACTIVE</CODE> is not
specified, and the store returned for SOURCE is inactive, an attempt is
made to activate it (failure of which causes an error to be returned).
A reference to <VAR>source</VAR> is created (but may be destroyed with
<CODE>store_close_source</CODE>).


<P>
It is usually better to use a specific store open or create function
such as <CODE>store_open</CODE> (see section <A HREF="hurd.html#SEC87">Store Classes</A>), since they are
tailored to the needs of a specific store.  Generally, you should only
use <CODE>store_create</CODE> if you are defining your own store class, or you
need options that are not provided by a more specific store creation
function.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>store_close_source</B> <I>(struct store *<VAR>store</VAR>)</I>
<DD><A NAME="IDX215"></A>
If <VAR>store</VAR> was created using <CODE>store_create</CODE>, remove the
reference to the source from which it was created.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>store_free</B> <I>(struct store *<VAR>store</VAR>)</I>
<DD><A NAME="IDX216"></A>
Clean up and deallocate <VAR>store</VAR>'s underlying stores.
</DL>


<P>
<DL>
<DT><U>Structure:</U> struct <B>store_run</B> <I>{ off_t <VAR>start</VAR>, <VAR>length</VAR>; }</I>
<DD><A NAME="IDX217"></A>
A <CODE>struct store_run</CODE> represents a contiguous region in a store's
address range.  These are used to designate active portions of a store.
If <VAR>start</VAR> is -1, then the region is a <EM>hole</EM> (it is zero-filled
and doesn't correspond to any real addresses).
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_set_runs</B> <I>(struct store *<VAR>store</VAR>, const struct store_run *<VAR>runs</VAR>, size_t <VAR>num_runs</VAR>)</I>
<DD><A NAME="IDX218"></A>
Set <VAR>store</VAR>'s current runs list to (a copy of) <VAR>runs</VAR> and
<VAR>num_runs</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_set_children</B> <I>(struct store *<VAR>store</VAR>, struct store *const *<VAR>children</VAR>, size_t <VAR>num_children</VAR>)</I>
<DD><A NAME="IDX219"></A>
Set <VAR>store</VAR>'s current children to (a copy of) <VAR>children</VAR> and
<VAR>num_children</VAR> (note that just the vector <VAR>children</VAR> is copied,
not the actual children).
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_children_name</B> <I>(const struct store *<VAR>store</VAR>, char **<VAR>name</VAR>)</I>
<DD><A NAME="IDX220"></A>
Try to come up with a name for the children in <VAR>store</VAR>, combining
the names of each child in a way that could be used to parse them with
<CODE>store_open_children</CODE>.  This is done heuristically, and so may not
succeed.  If a child doesn't have a name, <CODE>EINVAL</CODE> is returned.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_set_name</B> <I>(struct store *<VAR>store</VAR>, const char *<VAR>name</VAR>)</I>
<DD><A NAME="IDX221"></A>
Sets the name associated with <VAR>store</VAR> to a copy of <VAR>name</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_set_flags</B> <I>(struct store *<VAR>store</VAR>, int <VAR>flags</VAR>)</I>
<DD><A NAME="IDX222"></A>
Add <VAR>flags</VAR> to <VAR>store</VAR>'s currently set flags.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_clear_flags</B> <I>(struct store *<VAR>store</VAR>, int <VAR>flags</VAR>)</I>
<DD><A NAME="IDX223"></A>
Remove <VAR>flags</VAR> from <VAR>store</VAR>'s currently set flags.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_set_child_flags</B> <I>(struct store *<VAR>store</VAR>, int <VAR>flags</VAR>)</I>
<DD><A NAME="IDX224"></A>
Set <VAR>flags</VAR> in all children of <VAR>store</VAR>, and if successful, add
<VAR>flags</VAR> to <VAR>store</VAR>'s flags.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_clear_child_flags</B> <I>(struct store *<VAR>store</VAR>, int <VAR>flags</VAR>)</I>
<DD><A NAME="IDX225"></A>
Clear <VAR>flags</VAR> in all children of <VAR>store</VAR>, and if successful,
remove <VAR>flags</VAR> from <VAR>store</VAR>'s flags.
</DL>


<P>
<DL>
<DT><U>Function:</U> int <B>store_is_securely_returnable</B> <I>(struct store *<VAR>store</VAR>, int <VAR>open_flags</VAR>)</I>
<DD><A NAME="IDX226"></A>
Returns true if <VAR>store</VAR> can safely be returned to a user who has
accessed it via a node using <VAR>open_flags</VAR>, without compromising
security.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_clone</B> <I>(struct store *<VAR>from</VAR>, struct store **<VAR>to</VAR>)</I>
<DD><A NAME="IDX227"></A>
Return a copy of <VAR>from</VAR> in <VAR>to</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_remap</B> <I>(struct store *<VAR>source</VAR>, const struct store_run *<VAR>runs</VAR>, size_t <VAR>num_runs</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX228"></A>
Return a store in <VAR>store</VAR> that reflects the blocks in <VAR>runs</VAR> and
<VAR>runs_len</VAR> from source; <VAR>source</VAR> is consumed, but not
<VAR>runs</VAR>.  Unlike the <CODE>store_remap_create</CODE> function, this may
simply modify <VAR>source</VAR> and return it.
</DL>




<H3><A NAME="SEC86" HREF="hurd_toc.html#TOC86">Store I/O</A></H3>

<P>
The following functions allow you to read and modify the contents of a
store:


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_map</B> <I>(const struct store *<VAR>store</VAR>, vm_prot_t <VAR>prot</VAR>, mach_port_t *<VAR>memobj</VAR>)</I>
<DD><A NAME="IDX229"></A>
Return a memory object paging on <VAR>store</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_read</B> <I>(struct store *<VAR>store</VAR>, off_t <VAR>addr</VAR>, size_t <VAR>amount</VAR>, void **<VAR>buf</VAR>, size_t *<VAR>len</VAR>)</I>
<DD><A NAME="IDX230"></A>
Read <VAR>amount</VAR> bytes from <VAR>store</VAR> at <VAR>addr</VAR> into <VAR>buf</VAR>
and <VAR>len</VAR> (which follows the usual Mach buffer-return semantics) to
<VAR>store</VAR> at <VAR>addr</VAR>.  <VAR>addr</VAR> is in <VAR>blocks</VAR> (as defined by
<CODE><VAR>store</VAR>-&#62;block_size</CODE>).  Note that <VAR>len</VAR> is in bytes.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_write</B> <I>(struct store *<VAR>store</VAR>, off_t <VAR>addr</VAR>, void *<VAR>buf</VAR>, size_t <VAR>len</VAR>, size_t *<VAR>amount</VAR>)</I>
<DD><A NAME="IDX231"></A>
Write <VAR>len</VAR> bytes from <VAR>buf</VAR> to <VAR>store</VAR> at <VAR>addr</VAR>.
Returns the amount written in <VAR>amount</VAR> (in bytes).  <VAR>addr</VAR> is in
<VAR>blocks</VAR> (as defined by <CODE><VAR>store</VAR>-&#62;block_size</CODE>).
</DL>




<H3><A NAME="SEC87" HREF="hurd_toc.html#TOC87">Store Classes</A></H3>

<P>
The store library comes with a number of standard store class
implementations:


<P>
<DL>
<DT><U>Variable:</U> extern const struct store_class *const <B>store_std_classes[]</B>
<DD><A NAME="IDX232"></A>
This is a null-terminated vector of the standard store classes
implemented by <CODE>libstore</CODE>.
</DL>


<P>
If you are building your own class vectors, the following function may
be useful:


<P>
<DL>
<DT><U>Variable:</U> error_t <B>store_concat_class_vectors</B> <I>(struct store_class **<VAR>cv1</VAR>, struct store_class **<VAR>cv2</VAR>, struct store_class ***<VAR>concat</VAR>)</I>
<DD><A NAME="IDX233"></A>
Concatenate the store class vectors in <VAR>cv1</VAR> and <VAR>cv2</VAR>, and
return a new (malloced) vector in <VAR>concat</VAR>.
</DL>




<H4><A NAME="SEC88" HREF="hurd_toc.html#TOC88"><CODE>query</CODE> store</A></H4>
<P>
<A NAME="IDX234"></A>


<P>
<DL>
<DT><U>Variable:</U> extern const struct store_class <B>store_query_class</B>
<DD><A NAME="IDX235"></A>
This store is a virtual store which queries a filesystem node, and
delegates control to an appropriate store class.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_open</B> <I>(const char *<VAR>name</VAR>, int <VAR>flags</VAR>, const struct store_class *const *<VAR>classes</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX236"></A>
Open the file <VAR>name</VAR>, and return a new store in <VAR>store</VAR>, which
refers to the storage underlying it.  <VAR>classes</VAR> is used to select
classes specified by the provider; if it is zero, then
<VAR>store_std_classes</VAR> is used.  <VAR>flags</VAR> is set with
<CODE>store_set_flags</CODE>.  A reference to the open file is created (but
may be destroyed with <CODE>store_close_source</CODE>).
</DL>




<H4><A NAME="SEC89" HREF="hurd_toc.html#TOC89"><CODE>typed_open</CODE> store</A></H4>
<P>
<A NAME="IDX237"></A>


<P>
<DL>
<DT><U>Variable:</U> extern const struct store_class <B>store_typed_open_class</B>
<DD><A NAME="IDX238"></A>
This store is special in that it doesn't correspond to any specific
store functions, rather it provides a way to interpret character strings
as specifications for other stores.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_typed_open</B> <I>(const char *<VAR>name</VAR>, int <VAR>flags</VAR>, const struct store_class *const *<VAR>classes</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX239"></A>
Open the store indicated by <VAR>name</VAR>, which should consist of a store
type name followed by a <SAMP>`:'</SAMP> and any type-specific name, returning the
new store in <VAR>store</VAR>.  <VAR>classes</VAR> is used to select classes
specified by the type name; if it is zero, <VAR>store_std_classes</VAR> is
used.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_open_children</B> <I>(const char *<VAR>name</VAR>, int <VAR>flags</VAR>, const struct store_class *const *<VAR>classes</VAR>, struct store ***<VAR>stores</VAR>, size_t *<VAR>num_stores</VAR>)</I>
<DD><A NAME="IDX240"></A>
Parse multiple store names in <VAR>name</VAR>, and open each individually,
returning all in the vector <VAR>stores</VAR>, and the number in
<VAR>num_stores</VAR>.  The syntax of <VAR>name</VAR> is a single non-alphanumeric
separator character, followed by each child store name separated by the
same separator; each child name is <SAMP>`<VAR>type</VAR>:<VAR>name</VAR>'</SAMP> notation
as parsed by <CODE>store_typed_open</CODE>.  If every child uses the same
<SAMP>`<VAR>type</VAR>:'</SAMP> prefix, then it may be factored out and put before
the child list instead (the two notations are differentiated by whether
or not the first character of <VAR>name</VAR> is alphanumeric).
</DL>




<H4><A NAME="SEC90" HREF="hurd_toc.html#TOC90"><CODE>device</CODE> store</A></H4>
<P>
<A NAME="IDX241"></A>


<P>
<A NAME="IDX242"></A>
<DL>
<DT><U>Variable:</U> extern const struct store_class <B>store_device_class</B>
<DD><A NAME="IDX243"></A>
This store is a simple wrapper for a microkernel device
driver.<A NAME="DOCF8" HREF="hurd_foot.html#FOOT8">(8)</A>
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_device_open</B> <I>(const char *<VAR>name</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX244"></A>
Open the device named <VAR>name</VAR>, and return the corresponding store in
<VAR>store</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_device_create</B> <I>(device_t <VAR>device</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX245"></A>
Return a new store in <VAR>store</VAR> referring to the microkernel device
<VAR>device</VAR>.  Consumes the <VAR>device</VAR> send right.
</DL>




<H4><A NAME="SEC91" HREF="hurd_toc.html#TOC91"><CODE>file</CODE> store</A></H4>
<P>
<A NAME="IDX246"></A>


<P>
<DL>
<DT><U>Variable:</U> extern const struct store_class <B>store_file_class</B>
<DD><A NAME="IDX247"></A>
This store reads and writes the contents of a Hurd file.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_file_open</B> <I>(const char *<VAR>name</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX248"></A>
Open the file <VAR>name</VAR>, and return the corresponding store in <VAR>store</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_file_create</B> <I>(file_t <VAR>file</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX249"></A>
Return a new store in <VAR>store</VAR> referring to the file <VAR>file</VAR>.
Unlike <CODE>store_create</CODE>, this will always use file I/O, even it would
be possible to be more direct.  This may work in more cases, for instance
if the file has holes.  Consumes the <VAR>file</VAR> send right.
</DL>




<H4><A NAME="SEC92" HREF="hurd_toc.html#TOC92"><CODE>task</CODE> store</A></H4>
<P>
<A NAME="IDX250"></A>


<P>
<DL>
<DT><U>Variable:</U> extern const struct store_class <B>store_task_class</B>
<DD><A NAME="IDX251"></A>
This store provides access to the contents of a microkernel task.
</DL>


<P>
<DL>
<DT><U>Variable:</U> error_t <B>store_task_open</B> <I>(const char *<VAR>name</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX252"></A>
Open the task <VAR>name</VAR> (<VAR>name</VAR> should be the task's pid), and
return the corresponding store in <VAR>store</VAR>.
</DL>


<P>
<DL>
<DT><U>Variable:</U> error_t <B>store_task_create</B> <I>(task_t <VAR>task</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX253"></A>
Return a new store in <VAR>store</VAR> referring to the task <VAR>task</VAR>,
consuming the <VAR>task</VAR> send right.
</DL>




<H4><A NAME="SEC93" HREF="hurd_toc.html#TOC93"><CODE>zero</CODE> store</A></H4>
<P>
<A NAME="IDX254"></A>


<P>
<DL>
<DT><U>Variable:</U> extern const struct store_class <B>store_zero_class</B>
<DD><A NAME="IDX255"></A>
Reads to this store always return zero-filled buffers, no matter what
has been written into it.  This store corresponds to the Unix
<TT>`/dev/zero'</TT> device node.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_zero_create</B> <I>(off_t <VAR>size</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX256"></A>
Return a new zero store <VAR>size</VAR> bytes long in <VAR>store</VAR>.
</DL>




<H4><A NAME="SEC94" HREF="hurd_toc.html#TOC94"><CODE>copy</CODE> store</A></H4>
<P>
<A NAME="IDX257"></A>


<P>
<DL>
<DT><U>Variable:</U> extern const struct store_class <B>store_copy_class</B>
<DD><A NAME="IDX258"></A>
This store provides a temporary copy of another store.  This is useful
if you want to provide writable data, but do not wish to modify the
underlying store.  All changes to a copy store are lost when it is
closed.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_copy_open</B> <I>(const char *<VAR>name</VAR>, int <VAR>flags</VAR>, const struct store_class *const *<VAR>classes</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX259"></A>
Open the copy store <VAR>name</VAR> (which consists of another store class
name, a <SAMP>`:'</SAMP>, and a name for the store class to open) and return the
corresponding store in <VAR>store</VAR>.  <VAR>classes</VAR> is used to select
classes specified by the type name; if it is zero,
<VAR>store_std_classes</VAR> is used.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_copy_create</B> <I>(struct store *<VAR>from</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX260"></A>
Return a new store in <VAR>store</VAR> which contains a snapshot of the
contents of the store <VAR>from</VAR>; <VAR>from</VAR> is consumed.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_buffer_create</B> <I>(void *<VAR>buf</VAR>, size_t <VAR>buf_len</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX261"></A>
Return a new store in <VAR>store</VAR> which contains the memory buffer
<VAR>buf</VAR>, of length <VAR>buf_len</VAR>.  <VAR>buf</VAR> must be allocated with
<CODE>vm_allocate</CODE>, and will be consumed.
</DL>




<H4><A NAME="SEC95" HREF="hurd_toc.html#TOC95"><CODE>gunzip</CODE> store</A></H4>
<P>
<A NAME="IDX262"></A>


<P>
<DL>
<DT><U>Variable:</U> extern const struct store_class <B>store_gunzip_class</B>
<DD><A NAME="IDX263"></A>
This store provides transparent GNU zip decompression of a substore.
Unfortunately, this store is currently read-only.
</DL>


<P>
<DL>
<DT><U>Variable:</U> error_t <B>store_gunzip_open</B> <I>(const char *<VAR>name</VAR>, int <VAR>flags</VAR>, const struct store_class *const *<VAR>classes</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX264"></A>
Open the gunzip store <VAR>name</VAR> (which consists of another store class
name, a <SAMP>`:'</SAMP>, and a name for that store class to open), and return
the corresponding store in <VAR>store</VAR>.  <VAR>classes</VAR> is used to select
classes specified by the type name; if it is zero,
<VAR>store_std_classes</VAR> is used.
</DL>


<P>
<DL>
<DT><U>Variable:</U> error_t <B>store_gunzip_create</B> <I>(struct store *<VAR>from</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX265"></A>
Return a new store in <VAR>store</VAR> which contains a snapshot of the
uncompressed contents of the store <VAR>from</VAR>; <VAR>from</VAR> is consumed.
<VAR>block_size</VAR> is the desired block size of the result.
</DL>




<H4><A NAME="SEC96" HREF="hurd_toc.html#TOC96"><CODE>concat</CODE> store</A></H4>
<P>
<A NAME="IDX266"></A>


<P>
<A NAME="IDX267"></A>
<A NAME="IDX268"></A>
<A NAME="IDX269"></A>
<A NAME="IDX270"></A>
<A NAME="IDX271"></A>
<DL>
<DT><U>Variable:</U> extern const struct store_class <B>store_concat_class</B>
<DD><A NAME="IDX272"></A>
This class provides a linear concatenation storage mode.  It creates a
new virtual store which consists of several different substores appended
to one another.


<P>
This mode is designed to increase storage capacity, so that when one
substore is filled, new data is transparently written to the next
substore.  Concatenation requires robust hardware, since a failure in
any single substore will wipe out a large section of the data.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_concat_open</B> <I>(const char *<VAR>name</VAR>, int <VAR>flags</VAR>, const struct store_class *const *<VAR>classes</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX273"></A>
Return a new store that concatenates the stores created by opening all
the individual stores described in <VAR>name</VAR>; for the syntax of
<VAR>name</VAR>, see <CODE>store_open_children</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_concat_create</B> <I>(struct store * const *<VAR>stores</VAR>, size_t <VAR>num_stores</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX274"></A>
Return a new store in <VAR>store</VAR> that concatenates all the stores in
<VAR>stores</VAR> (<VAR>num_stores</VAR> of them).  The stores in <VAR>stores</VAR> are
consumed; that is, they will be freed when this store is freed.  The
<VAR>stores</VAR> <EM>array</EM>, however, is copied, and so should be freed by
the caller.
</DL>




<H4><A NAME="SEC97" HREF="hurd_toc.html#TOC97"><CODE>ileave</CODE> store</A></H4>
<P>
<A NAME="IDX275"></A>


<P>
<A NAME="IDX276"></A>
<A NAME="IDX277"></A>
<A NAME="IDX278"></A>
<A NAME="IDX279"></A>
<A NAME="IDX280"></A>
<DL>
<DT><U>Variable:</U> extern const struct store_class <B>store_ileave_class</B>
<DD><A NAME="IDX281"></A>
This class provides a RAID-0<A NAME="DOCF9" HREF="hurd_foot.html#FOOT9">(9)</A> storage mode (also called <EM>disk striping</EM>).  It
creates a new virtual store by interleaving the contents of several
different substores.


<P>
This RAID mode is designed to increase storage performance, since I/O
will probably occur in parallel if the substores reside on different
physical devices.  Interleaving works best with evenly-yoked
substores... if the stores are different sizes, some space will be
not be used at the end of the larger stores; if the stores are different
speeds, then I/O will have to wait for the slowest store; if some stores
are not as reliable as others, failures will wipe out every <VAR>n</VAR>th
storage block, where <VAR>n</VAR> is the number of substores.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_ileave_create</B> <I>(struct store * const *<VAR>stripes</VAR>, size_t num_stripes, off_t <VAR>interleave</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX282"></A>
Return a new store in <VAR>store</VAR> that interleaves all the stores in
<VAR>stripes</VAR> (<VAR>num_stripes</VAR> of them) every <VAR>interleave</VAR> bytes;
<VAR>interleave</VAR> must be an integer multiple of each stripe's block
size.  The stores in <VAR>stripes</VAR> are consumed; that is, they will be
freed when this store is freed.  The <VAR>stripes</VAR> <EM>array</EM>,
however, is copied, and so should be freed by the caller.
</DL>




<H4><A NAME="SEC98" HREF="hurd_toc.html#TOC98"><CODE>mvol</CODE> store</A></H4>
<P>
<A NAME="IDX283"></A>


<P>
<DL>
<DT><U>Variable:</U> extern const struct store_class <B>store_mvol_class</B>
<DD><A NAME="IDX284"></A>
This store provides access to multiple volumes using a single-volume
device.  One use of this store would be to provide a store which
consists of multiple floppy disks when there is only a single disk
drive.  It works by remapping a single linear address range to multiple
address ranges, and keeping track of the currently active range.
Whenever a request maps to a range that is not active, a callback is
made in order to switch to the new range.


<P>
This class is not included in <VAR>store_std_classes</VAR>, because it
requires an application-specific callback.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_mvol_create</B> <I>(struct store *<VAR>phys</VAR>, error_t (*<VAR>swap_vols</VAR>) (struct store *<VAR>store</VAR>, size_t <VAR>new_vol</VAR>, ssize_t <VAR>old_vol</VAR>), int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX285"></A>
Return a new store in <VAR>store</VAR> that multiplexes multiple physical
volumes from <VAR>phys</VAR> as one larger virtual volume.  <VAR>swap_vols</VAR>
is a function that will be called whenever reads or writes refer to a
block which is not addressable on the currently active volume.
<VAR>phys</VAR> is consumed.
</DL>




<H4><A NAME="SEC99" HREF="hurd_toc.html#TOC99"><CODE>remap</CODE> store</A></H4>
<P>
<A NAME="IDX286"></A>


<P>
<DL>
<DT><U>Variable:</U> extern const struct store_class <B>store_remap_class</B>
<DD><A NAME="IDX287"></A>
This store translates I/O requests into different addresses on a
different store.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_remap_create</B> <I>(struct store *<VAR>source</VAR>, const struct store_run *<VAR>runs</VAR>, size_t <VAR>num_runs</VAR>, int <VAR>flags</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX288"></A>
Return a new store in <VAR>store</VAR> that reflects the blocks in <VAR>runs</VAR>
and <VAR>runs_len</VAR> from <VAR>source</VAR>; <VAR>source</VAR> is consumed, but
<VAR>runs</VAR> is not.  Unlike the <CODE>store_remap</CODE> function, this
function always operates by creating a new store of type <SAMP>`remap'</SAMP>
which has <VAR>source</VAR> as a child, and so may be less efficient than
<CODE>store_remap</CODE> for some types of stores.
</DL>




<H3><A NAME="SEC100" HREF="hurd_toc.html#TOC100">Store RPC Encoding</A></H3>

<P>
The store library also provides some functions which help transfer
stores between tasks via RPC:


<P>
<DL>
<DT><U>Structure:</U> struct <B>store_enc</B>
<DD><A NAME="IDX289"></A>
This structure is used to hold the various bits that make up the
representation of a store for transmission via RPC.  See
<CODE>&#60;hurd/hurd_types.h&#62;</CODE> for an explanation of the encodings for the
various storage types.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>store_enc_init</B> <I>(struct store_enc *<VAR>enc</VAR>, mach_port_t *<VAR>ports</VAR>, mach_msg_type_number_t <VAR>num_ports</VAR>, int *<VAR>ints</VAR>, mach_msg_type_number_t <VAR>num_ints</VAR>, off_t *<VAR>offsets</VAR>, mach_msg_type_number_t <VAR>num_offsets</VAR>, char *<VAR>data</VAR>, mach_msg_type_number_t <VAR>data_len</VAR>)</I>
<DD><A NAME="IDX290"></A>
Initialize <VAR>enc</VAR>.  The given vector and sizes will be used for the
encoding if they are big enough (otherwise new ones will be
automatically allocated).
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>store_enc_dealloc</B> <I>(struct store_enc *<VAR>enc</VAR>)</I>
<DD><A NAME="IDX291"></A>
Deallocate storage used by the fields in <VAR>enc</VAR> (but nothing is done
with <VAR>enc</VAR> itself).
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>store_enc_return</B> <I>(struct store_enc *<VAR>enc</VAR>, mach_port_t **<VAR>ports</VAR>, mach_msg_type_number_t *<VAR>num_ports</VAR>, int **<VAR>ints</VAR>, mach_msg_type_number_t *<VAR>num_ints</VAR>, off_t **<VAR>offsets</VAR>, mach_msg_type_number_t *<VAR>num_offsets</VAR>, char **<VAR>data</VAR>, mach_msg_type_number_t *<VAR>data_len</VAR>)</I>
<DD><A NAME="IDX292"></A>
Copy out the parameters from <VAR>enc</VAR> into the given variables suitably
for returning from a <CODE>file_get_storage_info</CODE> RPC, and deallocate
<VAR>enc</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_return</B> <I>(const struct store *<VAR>store</VAR>, mach_port_t **<VAR>ports</VAR>, mach_msg_type_number_t *<VAR>num_ports</VAR>, int **<VAR>ints</VAR>, mach_msg_type_number_t *<VAR>num_ints</VAR>, off_t **<VAR>offsets</VAR>, mach_msg_type_number_t *<VAR>num_offsets</VAR>, char **<VAR>data</VAR>, mach_msg_type_number_t *<VAR>data_len</VAR>)</I>
<DD><A NAME="IDX293"></A>
Encode <VAR>store</VAR> into the given return variables, suitably for
returning from a <CODE>file_get_storage_info</CODE> RPC.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_encode</B> <I>(const struct store *<VAR>store</VAR>, struct store_enc *<VAR>enc</VAR>)</I>
<DD><A NAME="IDX294"></A>
Encode <VAR>store</VAR> into <VAR>enc</VAR>, which should have been prepared with
<CODE>store_enc_init</CODE>, or return an error.  The contents of <VAR>enc</VAR>
may then be returned as the value of <CODE>file_get_storage_info</CODE>; if
for some reason this can't be done, <CODE>store_enc_dealloc</CODE> may be used
to deallocate the memory used by the unsent vectors.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_decode</B> <I>(struct store_enc *<VAR>enc</VAR>, const struct store_class *const *<VAR>classes</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX295"></A>
Decode <VAR>enc</VAR>, either returning a new store in <VAR>store</VAR>, or an
error.  <VAR>classes</VAR> is the mapping from Hurd storage class ids to store
classes; if it is zero, <VAR>store_std_classes</VAR> is used.  If nothing
else is to be done with <VAR>enc</VAR>, its contents may then be freed using
<CODE>store_enc_dealloc</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_allocate_child_encodings</B> <I>(const struct store *<VAR>store</VAR>, struct store_enc *<VAR>enc</VAR>)</I>
<DD><A NAME="IDX296"></A>
Calls the <CODE>allocate_encoding</CODE> method in each child store of
<VAR>store</VAR>, propagating any errors.  If any child does not have such a
method, <CODE>EOPNOTSUPP</CODE> is returned.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_encode_children</B> <I>(const struct store *<VAR>store</VAR>, struct store_enc *<VAR>enc</VAR>)</I>
<DD><A NAME="IDX297"></A>
Calls the encode method in each child store of <VAR>store</VAR>, propagating
any errors.  If any child does not have such a method, <CODE>EOPNOTSUPP</CODE>
is returned.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_decode_children</B> <I>(struct store_enc *<VAR>enc</VAR>, int <VAR>num_children</VAR>, const struct store_class *const *<VAR>classes</VAR>, struct store **<VAR>children</VAR>)</I>
<DD><A NAME="IDX298"></A>
Decodes <VAR>num_children</VAR> from <VAR>enc</VAR>, storing the results into
successive positions in <VAR>children</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_with_decoded_runs</B> <I>(struct store_enc *<VAR>enc</VAR>, size_t <VAR>num_runs</VAR>, error_t (*<VAR>fun</VAR>) (const struct store_run *<VAR>runs</VAR>, size_t <VAR>num_runs</VAR>))</I>
<DD><A NAME="IDX299"></A>
Call <VAR>fun</VAR> with the vector <VAR>runs</VAR> of length <VAR>num_runs</VAR>
extracted from <VAR>enc</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_std_leaf_allocate_encoding</B> <I>(const struct store *<VAR>store</VAR>, struct store_enc *<VAR>enc</VAR>)</I>
<DD><A NAME="IDX300"></A>
<DT><U>Function:</U> error_t <B>store_std_leaf_encode</B> <I>(const struct store *<VAR>store</VAR>, struct store_enc *<VAR>enc</VAR>)</I>
<DD><A NAME="IDX301"></A>
Standard encoding used for most data-providing (as opposed to filtering)
store classes.
</DL>


<P>
<DL>
<DT><U>Typedef:</U> typedef error_t (* <B>store_std_leaf_create_t</B> <I>)(mach_port_t <VAR>port</VAR>, int <VAR>flags</VAR>, size_t <VAR>block_size</VAR>, const struct store_run *<VAR>runs</VAR>, size_t <VAR>num_runs</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX302"></A>
Creation function used by <CODE>store_std_leaf_decode</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>store_std_leaf_decode</B> <I>(struct store_enc *<VAR>enc</VAR>, store_std_leaf_create_t <VAR>create</VAR>, struct store **<VAR>store</VAR>)</I>
<DD><A NAME="IDX303"></A>
Decodes the standard leaf encoding which is common to various builtin
formats, and calls <VAR>create</VAR> to actually create the store.
</DL>




<H1><A NAME="SEC101" HREF="hurd_toc.html#TOC101">Stored Filesystems</A></H1>
<P>
<A NAME="IDX304"></A>
<A NAME="IDX305"></A>


<P>
Stored filesystems allow users to save and load persistent data from any
random-access storage media, such as hard disks, floppy diskettes, and
CD-ROMs.  Stored filesystems are required for bootstrapping standalone
workstations, as well.




<H2><A NAME="SEC102" HREF="hurd_toc.html#TOC102">Repairing Filesystems</A></H2>
<P>
<A NAME="IDX306"></A>


<P>
FIXME: finish




<H2><A NAME="SEC103" HREF="hurd_toc.html#TOC103">Linux Extended 2 FS</A></H2>
<P>
<A NAME="IDX307"></A>


<P>
FIXME: finish




<H2><A NAME="SEC104" HREF="hurd_toc.html#TOC104">BSD Unix FS</A></H2>
<P>
<A NAME="IDX308"></A>


<P>
FIXME: finish




<H2><A NAME="SEC105" HREF="hurd_toc.html#TOC105">ISO-9660 CD-ROM FS</A></H2>
<P>
<A NAME="IDX309"></A>


<P>
FIXME: finish




<H2><A NAME="SEC106" HREF="hurd_toc.html#TOC106">Diskfs Library</A></H2>
<P>
<A NAME="IDX310"></A>
<A NAME="IDX311"></A>


<P>
The diskfs library is declared in <CODE>&#60;hurd/diskfs.h&#62;</CODE>, and does a lot
of the work of implementing stored filesystems.  <CODE>libdiskfs</CODE>
requires the threads, ports, iohelp, fshelp, and store libraries.  You
should understand all these libraries before you attempt to use diskfs,
and you should also be familiar with the pager library (see section <A HREF="hurd.html#SEC37">Pager Library</A>).


<P>
<A NAME="IDX312"></A>
For historical reasons, the library for implementing stored filesystems
is called <CODE>libdiskfs</CODE> instead of <CODE>libstorefs</CODE>.  Keep in mind,
however, that diskfs is useful for filesystems which are implemented on
any block-addressed storage device, since it uses the store library to
do I/O.


<P>
Note that stored filesystems can be tricky to implement, since the
diskfs callback interfaces are not trivial.  It really is best if you
examine the source code of a similar existing filesystem server, and
follow its example rather than trying to write your own from scratch.




<H3><A NAME="SEC107" HREF="hurd_toc.html#TOC107">Diskfs Startup</A></H3>

<P>
This subsection gives an outline of the general steps involved in
implementing a filesystem server, to help refresh your memory and to
offer explanations rather than to serve as a tutorial.


<P>
The first thing a filesystem server should do is parse its command-line
arguments (see section <A HREF="hurd.html#SEC108">Diskfs Arguments</A>).  Then, the standard output and
error streams should be redirected to the console, so that error
messages are not lost if this is the bootstrap filesystem:


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_console_stdio</B> <I>(void)</I>
<DD><A NAME="IDX313"></A>
Redirect error messages to the console, so that they can be seen by
users.
</DL>


<P>
The following is a list of the relevant functions which would be called
during the rest of the server initialization.  Again, you should refer
to the implementation of an already-working filesystem if you have any
questions about how these functions should be used:


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_init_diskfs</B> <I>(void)</I>
<DD><A NAME="IDX314"></A>
Call this function after arguments have been parsed to initialize the
library.  You must call this before calling any other diskfs functions,
and after parsing diskfs options.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_spawn_first_thread</B> <I>(void)</I>
<DD><A NAME="IDX315"></A>
Call this after all format-specific initialization is done (except for
setting <CODE>diskfs_root_node</CODE>); at this point the pagers should be
ready to go.
</DL>


<P>
<DL>
<DT><U>Function:</U> mach_port_t <B>diskfs_startup_diskfs</B> <I>(mach_port_t <VAR>bootstrap</VAR>, int <VAR>flags</VAR>)</I>
<DD><A NAME="IDX316"></A>
Call this once the filesystem is fully initialized, to advertise the new
filesystem control port to our parent filesystem.  If <VAR>bootstrap</VAR> is set,
diskfs will call <CODE>fsys_startup</CODE> on that port as appropriate and return
the <VAR>realnode</VAR> from that call; otherwise we call
<CODE>diskfs_start_bootstrap</CODE> and return <CODE>MACH_PORT_NULL</CODE>.
<VAR>flags</VAR> specifies how to open <VAR>realnode</VAR> (from the O_* set).
</DL>


<P>
You should not need to call the following function directly, since
<CODE>diskfs_startup_diskfs</CODE> will do it for you, when appropriate:


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_start_bootstrap</B> <I>(void)</I>
<DD><A NAME="IDX317"></A>
Start the Hurd bootstrap sequence as if we were the bootstrap filesystem
(that is, <CODE>diskfs_boot_flags</CODE> is nonzero).  All filesystem
initialization must be complete before you call this function.
</DL>




<H3><A NAME="SEC108" HREF="hurd_toc.html#TOC108">Diskfs Arguments</A></H3>

<P>
The following functions implement standard diskfs command-line and
runtime argument parsing, using argp (see section `Argp' in <CITE>The GNU C Library Reference Manual</CITE>):


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_set_options</B> <I>(char *<VAR>argz</VAR>, size_t <VAR>argz_len</VAR>)</I>
<DD><A NAME="IDX318"></A>
Parse and execute the runtime options specified by <VAR>argz</VAR> and
<VAR>argz_len</VAR>.  <CODE>EINVAL</CODE> is returned if some option is
unrecognized.  The default definition of this routine will parse them
using <CODE>diskfs_runtime_argp</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_append_args</B> <I>(char **<VAR>argz</VAR>, unsigned *<VAR>argz_len</VAR>)</I>
<DD><A NAME="IDX319"></A>
Append to the malloced string <CODE>*<VAR>argz</VAR></CODE> of length
<CODE>*<VAR>argz_len</VAR></CODE> a NUL-separated list of the arguments to this
translator.  The default definition of this routine simply calls
<CODE>diskfs_append_std_options</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_append_std_options</B> <I>(char **<VAR>argz</VAR>, unsigned *<VAR>argz_len</VAR>)</I>
<DD><A NAME="IDX320"></A>
<EM>Appends</EM> NUL-separated options describing the standard diskfs
option state to <VAR>argz</VAR> and increments <VAR>argz_len</VAR> appropriately.
Note that unlike <CODE>diskfs_get_options</CODE>, <VAR>argz</VAR> and
<VAR>argz_len</VAR> must already have sane values.
</DL>


<P>
<DL>
<DT><U>Variable:</U> struct argp * <B>diskfs_runtime_argp</B>
<DD><A NAME="IDX321"></A>
If this is defined or set to an argp structure, it will be used by the
default <CODE>diskfs_set_options</CODE> to handle runtime option parsing.  The
default definition is initialized to a pointer to
<CODE>diskfs_std_runtime_argp</CODE>.
</DL>


<P>
<DL>
<DT><U>Variable:</U> const struct argp <B>diskfs_std_runtime_argp</B>
<DD><A NAME="IDX322"></A>
An argp for the standard diskfs runtime options.  The default definition
of <CODE>diskfs_runtime_argp</CODE> points to this, although the user can
redefine that to chain this onto his own argp.
</DL>


<P>
<DL>
<DT><U>Variable:</U> const struct argp <B>diskfs_startup_argp</B>
<DD><A NAME="IDX323"></A>
An argp structure for the standard diskfs command line arguments.  The
user may call <CODE>argp_parse</CODE> on this to parse the command line, chain
it onto the end of his own argp structure, or ignore it completely.
</DL>


<P>
<DL>
<DT><U>Variable:</U> const struct argp <B>diskfs_store_startup_argp</B>
<DD><A NAME="IDX324"></A>
An argp structure for the standard diskfs command line arguments plus a
store specification.  The address of a location in which to return the
resulting <CODE>struct store_parsed</CODE> structure should be passed as the
input argument to <CODE>argp_parse</CODE>; FIXME xref the declaration for
STORE_ARGP.
</DL>




<H3><A NAME="SEC109" HREF="hurd_toc.html#TOC109">Diskfs Globals</A></H3>

<P>
The following functions and variables control the overall behaviour of
the library.  Your callback functions may need to refer to these, but
you should not need to modify or redefine them.


<P>
<DL>
<DT><U>Variable:</U> mach_port_t <B>diskfs_default_pager</B>
<DD><A NAME="IDX325"></A>
<DT><U>Variable:</U> mach_port_t <B>diskfs_exec_ctl</B>
<DD><A NAME="IDX326"></A>
<DT><U>Variable:</U> mach_port_t <B>diskfs_exec</B>
<DD><A NAME="IDX327"></A>
<DT><U>Variable:</U> auth_t <B>diskfs_auth_server_port</B>
<DD><A NAME="IDX328"></A>
These are the respective send rights to the default pager, execserver
control port, execserver itself, and authserver.
</DL>


<P>
<DL>
<DT><U>Variable:</U> mach_port_t <B>diskfs_fsys_identity</B>
<DD><A NAME="IDX329"></A>
The <CODE>io_identity</CODE> identity port for the filesystem.
</DL>


<P>
<DL>
<DT><U>Variable:</U> char ** <B>diskfs_argv</B>
<DD><A NAME="IDX330"></A>
The command line with which diskfs was started, set by the default argument parser.
If you don't use it, set this yourself.  This is only used for bootstrap
file systems, to give the procserver.
</DL>


<P>
<DL>
<DT><U>Variable:</U> char * <B>diskfs_boot_flags</B>
<DD><A NAME="IDX331"></A>
When this is a bootstrap filesystem, the command line options passed from
the kernel.  If not a bootstrap filesystem, it is zero, so it can be used to
distinguish between the two cases.
</DL>


<P>
<DL>
<DT><U>Variable:</U> struct rwlock <B>diskfs_fsys_lock</B>
<DD><A NAME="IDX332"></A>
Hold this lock while doing filesystem-level operations.  Innocuous users
can just hold a reader lock, but operations that might corrupt other
threads should hold a writer lock.
</DL>


<P>
<DL>
<DT><U>Variable:</U> volatile struct mapped_time_value * <B>diskfs_mtime</B>
<DD><A NAME="IDX333"></A>
The current system time, as used by the diskfs routines.  This is
converted into a <CODE>struct timeval</CODE> by the <CODE>maptime_read</CODE>
C library function (FIXME xref).
</DL>


<P>
<DL>
<DT><U>Variable:</U> int <B>diskfs_synchronous</B>
<DD><A NAME="IDX334"></A>
True if and only if we should do every operation synchronously.  It
is the format-specific code's responsibility to keep allocation
information permanently in sync if this is set; the rest will
be done by format-independent code.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_set_sync_interval</B> <I>(int <VAR>interval</VAR>)</I>
<DD><A NAME="IDX335"></A>
Establish a thread to sync the filesystem every <VAR>interval</VAR> seconds,
or never, if <VAR>interval</VAR> is zero.  If an error occurs creating the
thread, it is returned, otherwise zero.  Subsequent calls will create a
new thread and (eventually) get rid of the old one; the old thread won't
do any more syncs, regardless.
</DL>


<P>
<DL>
<DT><U>Variable:</U> spin_lock_t <B>diskfs_node_refcnt_lock</B>
<DD><A NAME="IDX336"></A>
Pager reference count lock.
</DL>


<P>
<DL>
<DT><U>Variable:</U> int <B>diskfs_readonly</B>
<DD><A NAME="IDX337"></A>
Set to zero if the filesystem is currently writable.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_set_readonly</B> <I>(int <VAR>readonly</VAR>)</I>
<DD><A NAME="IDX338"></A>
Change an active filesystem between read-only and writable modes,
setting the global variable <VAR>diskfs_readonly</VAR> to reflect the current
mode.  If an error is returned, nothing will have changed.
<VAR>diskfs_fsys_lock</VAR> should be held while calling this routine.
</DL>


<P>
<DL>
<DT><U>Function:</U> int <B>diskfs_check_readonly</B> <I>(void)</I>
<DD><A NAME="IDX339"></A>
Check if the filesystem is readonly before an operation that writes it.
Return nonzero if readonly, otherwise zero.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_remount</B> <I>(void)</I>
<DD><A NAME="IDX340"></A>
Reread all in-core data structures from disk.  This function can only be
successful if <VAR>diskfs_readonly</VAR> is true.  <VAR>diskfs_fsys_lock</VAR>
should be held while calling this routine.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_shutdown</B> <I>(int <VAR>flags</VAR>)</I>
<DD><A NAME="IDX341"></A>
Shutdown the filesystem; <VAR>flags</VAR> are as for <CODE>fsys_shutdown</CODE>.
</DL>




<H3><A NAME="SEC110" HREF="hurd_toc.html#TOC110">Diskfs Node Management</A></H3>

<P>
Every file or directory is a diskfs <EM>node</EM>.  The following functions
help your diskfs callbacks manage nodes and their references:


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_drop_node</B> <I>(struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX342"></A>
Node <VAR>np</VAR> now has no more references; clean all state.  The
<VAR>diskfs_node_refcnt_lock</VAR> must be held, and will be released upon
return.  <VAR>np</VAR> must be locked.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_node_update</B> <I>(struct node *<VAR>np</VAR>, int <VAR>wait</VAR>)</I>
<DD><A NAME="IDX343"></A>
Set disk fields from <CODE><VAR>np</VAR>-&#62;dn_stat</CODE>; update ctime, atime, and mtime
if necessary.  If <VAR>wait</VAR> is true, then return only after the
physical media has been completely updated.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_nref</B> <I>(struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX344"></A>
Add a hard reference to node <VAR>np</VAR>.  If there were no hard references
previously, then the node cannot be locked (because you must hold a hard
reference to hold the lock).
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_nput</B> <I>(struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX345"></A>
Unlock node <VAR>np</VAR> and release a hard reference; if this is the last
hard reference and there are no links to the file then request light
references to be dropped.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_nrele</B> <I>(struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX346"></A>
Release a hard reference on <VAR>np</VAR>.  If <VAR>np</VAR> is locked by anyone,
then this cannot be the last hard reference (because you must hold a
hard reference in order to hold the lock).  If this is the last hard
reference and there are no links, then request light references to be
dropped.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_nref_light</B> <I>(struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX347"></A>
Add a light reference to a node.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_nput_light</B> <I>(struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX348"></A>
Unlock node <VAR>np</VAR> and release a light reference.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_nrele_light</B> <I>(struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX349"></A>
Release a light reference on <VAR>np</VAR>.  If <VAR>np</VAR> is locked by anyone,
then this cannot be the last reference (because you must hold a hard
reference in order to hold the lock).
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_node_rdwr</B> <I>(struct node *<VAR>np</VAR>, char *<VAR>data</VAR>, off_t <VAR>off</VAR>, size_t <VAR>amt</VAR>, int <VAR>direction</VAR>, struct protid *<VAR>cred</VAR>, size_t *<VAR>amtread</VAR>)</I>
<DD><A NAME="IDX350"></A>
This is called by other filesystem routines to read or write files, and
extends them automatically, if necessary.  <VAR>np</VAR> is the node to be
read or written, and must be locked.  <VAR>data</VAR> will be written or
filled.  <VAR>off</VAR> identifies where in the file the I/O is to take place
(negative values are not allowed).  <VAR>amt</VAR> is the size of <VAR>data</VAR>
and tells how much to copy.  <VAR>dir</VAR> is zero for reading or nonzero
for writing.  <VAR>cred</VAR> is the user doing the access (only used to
validate attempted file extension).  For reads, <CODE>*<VAR>amtread</VAR></CODE> is
filled with the amount actually read.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_notice_dirchange</B> <I>(struct node *<VAR>dp</VAR>, enum dir_changed_type <VAR>type</VAR>, char *<VAR>name</VAR>)</I>
<DD><A NAME="IDX351"></A>
Send notifications to users who have requested them for directory
<VAR>dp</VAR> with <CODE>dir_notice_changes</CODE>.  The type of modification and
affected name are <VAR>type</VAR> and <VAR>name</VAR> respectively.  This should
be called by <CODE>diskfs_direnter</CODE>, <CODE>diskfs_dirremove</CODE>,
<CODE>diskfs_dirrewrite</CODE>, and anything else that changes the directory,
after the change is fully completed.
</DL>


<P>
<DL>
<DT><U>Function:</U> struct node * <B>diskfs_make_node</B> <I>(struct disknode *<VAR>dn</VAR>)</I>
<DD><A NAME="IDX352"></A>
Create a new node structure with <VAR>ds</VAR> as its physical disknode.  The
new node will have one hard reference and no light references.
</DL>


<P>
These next node manipulation functions are not generally useful, but may
come in handy if you need to redefine any diskfs functions.


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_create_node</B> <I>(struct node *<VAR>dir</VAR>, char *<VAR>name</VAR>, mode_t <VAR>mode</VAR>, struct node **<VAR>newnode</VAR>, struct protid *<VAR>cred</VAR>, struct dirstat *<VAR>ds</VAR>)</I>
<DD><A NAME="IDX353"></A>
Create a new node.  Give it <VAR>mode</VAR>: if <VAR>mode</VAR> includes
<CODE>IFDIR</CODE>, also initialize <TT>`.'</TT> and <TT>`..'</TT> in the new
directory.  Return the node in <VAR>npp</VAR>.  <VAR>cred</VAR> identifies the
user responsible for the call.  If <VAR>name</VAR> is nonzero, then link the
new node into <VAR>dir</VAR> with name <VAR>name</VAR>; <VAR>ds</VAR> is the result of
a prior <CODE>diskfs_lookup</CODE> for creation (and <VAR>dir</VAR> has been held
locked since).  <VAR>dir</VAR> must always be provided as at least a hint for
disk allocation strategies.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_set_node_times</B> <I>(struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX354"></A>
If <CODE><VAR>np</VAR>-&#62;dn_set_ctime</CODE> is set, then modify
<CODE><VAR>np</VAR>-&#62;dn_stat.st_ctime</CODE> appropriately; do the analogous
operations for atime and mtime as well.
</DL>


<P>
<DL>
<DT><U>Function:</U> struct node * <B>diskfs_check_lookup_cache</B> <I>(struct node *<VAR>dir</VAR>, char *<VAR>name</VAR>)</I>
<DD><A NAME="IDX355"></A>
Scan the cache looking for <VAR>name</VAR> inside <VAR>dir</VAR>.  If we don't
know any entries at all, then return zero.  If the entry is confirmed to
not exist, then return -1.  Otherwise, return <VAR>np</VAR> for the entry,
with a newly-allocated reference.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_cached_lookup</B> <I>(int <VAR>cache_id</VAR>, struct node **<VAR>npp</VAR>)</I>
<DD><A NAME="IDX356"></A>
Return the node corresponding to <VAR>cache_id</VAR> in <CODE>*<VAR>npp</VAR></CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_enter_lookup_cache</B> <I>(struct node *<VAR>dir</VAR>, struct node *<VAR>np</VAR>, char *<VAR>name</VAR>)</I>
<DD><A NAME="IDX357"></A>
Node <VAR>np</VAR> has just been found in <VAR>dir</VAR> with <VAR>name</VAR>.  If
<VAR>np</VAR> is null, that means that this name has been confirmed as absent
in the directory.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_purge_lookup_cache</B> <I>(struct node *<VAR>dp</VAR>, struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX358"></A>
Purge all references in the cache to <VAR>np</VAR> as a node inside directory
<VAR>dp</VAR>.
</DL>




<H3><A NAME="SEC111" HREF="hurd_toc.html#TOC111">Diskfs Callbacks</A></H3>

<P>
Like several other Hurd libraries, <CODE>libdiskfs</CODE> depends on you to
implement application-specific callback functions.  You <EM>must</EM>
define the following functions and variables, but you should also look
at section <A HREF="hurd.html#SEC112">Diskfs Options</A>, as there are several defaults which should be
modified to provide good filesystem support:


<P>
<DL>
<DT><U>Structure:</U> struct <B>dirstat</B>
<DD><A NAME="IDX359"></A>
You must define this type, which will hold information between a call to
<CODE>diskfs_lookup</CODE> and a call to one of <CODE>diskfs_direnter</CODE>,
<CODE>diskfs_dirremove</CODE>, or <CODE>diskfs_dirrewrite</CODE>.  It must contain
enough information so that those calls work as described below.
</DL>


<P>
<DL>
<DT><U>Variable:</U> size_t <B>diskfs_dirstat_size</B>
<DD><A NAME="IDX360"></A>
This must be the size in bytes of a <CODE>struct dirstat</CODE>.
</DL>


<P>
<DL>
<DT><U>Variable:</U> int <B>diskfs_link_max</B>
<DD><A NAME="IDX361"></A>
This is the maximum number of links to any one file, which must be a
positive integer.  The implementation of <CODE>dir_rename</CODE> does not know
how to succeed if this is only one allowed link; on such formats you
need to reimplement <CODE>dir_rename</CODE> yourself.
</DL>


<P>
<DL>
<DT><U>Variable:</U> int <B>diskfs_maxsymlinks</B>
<DD><A NAME="IDX362"></A>
This variable is a positive integer which is the maximum number of
symbolic links which can be traversed within a single call to
<CODE>dir_pathtrans</CODE>.  If this is exceeded, <CODE>dir_pathtrans</CODE> will
return <CODE>ELOOP</CODE>.
</DL>


<P>
<DL>
<DT><U>Variable:</U> struct node * <B>diskfs_root_node</B>
<DD><A NAME="IDX363"></A>
Set this to be the node of the root of the filesystem.
</DL>


<P>
<DL>
<DT><U>Variable:</U> char * <B>diskfs_server_name</B>
<DD><A NAME="IDX364"></A>
Set this to the name of the filesystem server.
</DL>


<P>
<DL>
<DT><U>Variable:</U> char * <B>diskfs_server_version</B>
<DD><A NAME="IDX365"></A>
Set this to be the server version string.
</DL>


<P>
<DL>
<DT><U>Variable:</U> char * <B>diskfs_disk_name</B>
<DD><A NAME="IDX366"></A>
This should be a string that somehow identifies the particular disk this
filesystem is interpreting.  It is generally only used to print messages
or to distinguish instances of the same filesystem type from one
another.  If this filesystem accesses no external media, then define
this to be zero.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_set_statfs</B> <I>(fsys_statfsbuf_t *<VAR>statfsbuf</VAR>)</I>
<DD><A NAME="IDX367"></A>
Set <CODE>*<VAR>statfsbuf</VAR></CODE> with appropriate values to reflect the
current state of the filesystem.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_lookup</B> <I>(struct node *<VAR>dp</VAR>, char *<VAR>name</VAR>, enum lookup_type <VAR>type</VAR>, struct node **<VAR>np</VAR>, struct dirstat *<VAR>ds</VAR>, struct protid *<VAR>cred</VAR>)</I>
<DD><A NAME="IDX368"></A>
<DT><U>Function:</U> error_t <B>diskfs_lookup_hard</B> <I>(struct node *<VAR>dp</VAR>, char *<VAR>name</VAR>, enum lookup_type <VAR>type</VAR>, struct node **<VAR>np</VAR>, struct dirstat *<VAR>ds</VAR>, struct protid *<VAR>cred</VAR>)</I>
<DD><A NAME="IDX369"></A>
You should not define <CODE>diskfs_lookup</CODE>, because it is simply a
wrapper for <CODE>diskfs_lookup_hard</CODE>, and is already defined in
<CODE>libdiskfs</CODE>.


<P>
Lookup in directory <VAR>dp</VAR> (which is locked) the name <VAR>name</VAR>.
<VAR>type</VAR> will either be <CODE>LOOKUP</CODE>, <CODE>CREATE</CODE>, <CODE>RENAME</CODE>,
or <CODE>REMOVE</CODE>.  <VAR>cred</VAR> identifies the user making the call.


<P>
If the name is found, return zero, and (if <VAR>np</VAR> is nonzero) set
<CODE>*<VAR>np</VAR></CODE> to point to the node for it, which should be locked.
If the name is not found, return <CODE>ENOENT</CODE>, and (if <VAR>np</VAR> is
nonzero) set <CODE>*<VAR>np</VAR></CODE> to zero.  If <VAR>np</VAR> is zero, then the
node found must not be locked, not even transitorily.  Lookups for
<CODE>REMOVE</CODE> and <CODE>RENAME</CODE> (which must often check permissions on
the node being found) will always set <VAR>np</VAR>.


<P>
If <VAR>ds</VAR> is nonzero then the behaviour varies depending on the
requested lookup <VAR>type</VAR>:


<DL COMPACT>

<DT><CODE>LOOKUP</CODE>
<DD>
Set <CODE>*<VAR>ds</VAR></CODE> to be ignored by <CODE>diskfs_drop_dirstat</CODE>

<DT><CODE>CREATE</CODE>
<DD>
On success, set <CODE>*<VAR>ds</VAR></CODE> to be ignored by
<CODE>diskfs_drop_dirstat</CODE>. <BR>
On failure, set <CODE>*<VAR>ds</VAR></CODE> for a future call to
<CODE>diskfs_direnter</CODE>.

<DT><CODE>RENAME</CODE>
<DD>
On success, set <CODE>*<VAR>ds</VAR></CODE> for a future call to
<CODE>diskfs_dirrewrite</CODE>. <BR>
On failure, set <CODE>*<VAR>ds</VAR></CODE> for a future call to
<CODE>diskfs_direnter</CODE>.

<DT><CODE>REMOVE</CODE>
<DD>
On success, set <CODE>*<VAR>ds</VAR></CODE> for a future call to
<CODE>diskfs_dirremove</CODE>. <BR>
On failure, set <CODE>*<VAR>ds</VAR></CODE> to be ignored by
<CODE>diskfs_drop_dirstat</CODE>.
</DL>

<P>
The caller of this function guarantees that if <VAR>ds</VAR> is nonzero, then
either the appropriate call listed above or <CODE>diskfs_drop_dirstat</CODE>
will be called with <VAR>ds</VAR> before the directory <VAR>dp</VAR> is unlocked,
and guarantees that no lookup calls will be made on this directory
between this lookup and the use (or destruction) of *DS.


<P>
If you use the library's versions of <CODE>diskfs_rename_dir</CODE>,
<CODE>diskfs_clear_directory</CODE>, and <CODE>diskfs_init_dir</CODE>, then lookups
for <TT>`..'</TT> might have the flag <CODE>SPEC_DOTDOT</CODE> ORed in.  This has a
special meaning depending on the requested lookup <VAR>type</VAR>:


<DL COMPACT>

<DT><CODE>LOOKUP</CODE>
<DD>
<VAR>dp</VAR> should be unlocked and its reference dropped before returning.

<DT><CODE>CREATE</CODE>
<DD>
Ignore this case, because <CODE>SPEC_DOTDOT</CODE> is guaranteed not to be
given.

<DT><CODE>RENAME</CODE>
<DD>
<DT><CODE>REMOVE</CODE>
<DD>
In both of these cases, the node being found (<CODE>*<VAR>np</VAR></CODE>) is
already held locked, so don't lock it or add a reference to it.
</DL>

<P>
Return <CODE>ENOENT</CODE> if <VAR>name</VAR> isn't in the directory.  Return
<CODE>EAGAIN</CODE> if <VAR>name</VAR> refers to the <TT>`..'</TT> of this filesystem's
root.  Return <CODE>EIO</CODE> if appropriate.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_direnter</B> <I>(struct node *<VAR>dp</VAR>, char *<VAR>name</VAR>, struct node *<VAR>np</VAR>, struct dirstat *<VAR>ds</VAR>, struct protid *<VAR>cred</VAR>)</I>
<DD><A NAME="IDX370"></A>
<DT><U>Function:</U> error_t <B>diskfs_direnter_hard</B> <I>(struct node *<VAR>dp</VAR>, char *<VAR>name</VAR>, struct node *<VAR>np</VAR>, struct dirstat *<VAR>ds</VAR>, struct protid *<VAR>cred</VAR>)</I>
<DD><A NAME="IDX371"></A>
You should not define <CODE>diskfs_direnter</CODE>, because it is simply a
wrapper for <CODE>diskfs_direnter_hard</CODE>, and is already defined in
<CODE>libdiskfs</CODE>.


<P>
Add <VAR>np</VAR> to directory <VAR>dp</VAR> under the name <VAR>name</VAR>.  This will
only be called after an unsuccessful call to <CODE>diskfs_lookup</CODE> of type
<CODE>CREATE</CODE> or <CODE>RENAME</CODE>; <VAR>dp</VAR> has been locked continuously
since that call and <VAR>ds</VAR> is as that call set it, <VAR>np</VAR> is locked.
<VAR>cred</VAR> identifies the user responsible for the call (to be used only
to validate directory growth).
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_dirrewrite</B> <I>(struct node *<VAR>dp</VAR>, struct node *<VAR>oldnp</VAR>, struct node *<VAR>np</VAR>, char *<VAR>name</VAR>, struct dirstat *<VAR>ds</VAR>)</I>
<DD><A NAME="IDX372"></A>
<DT><U>Function:</U> error_t <B>diskfs_dirrewrite_hard</B> <I>(struct node *<VAR>dp</VAR>, struct node *<VAR>np</VAR>, struct dirstat *<VAR>ds</VAR>)</I>
<DD><A NAME="IDX373"></A>
You should not define <CODE>diskfs_dirrewrite</CODE>, because it is simply a
wrapper for <CODE>diskfs_dirrewrite_hard</CODE>, and is already defined in
<CODE>libdiskfs</CODE>.


<P>
This will only be called after a successful call to <CODE>diskfs_lookup</CODE>
of type <CODE>RENAME</CODE>; this call should change the name found in
directory <VAR>dp</VAR> to point to node <VAR>np</VAR> instead of its previous
referent.  <VAR>dp</VAR> has been locked continuously since the call to
<CODE>diskfs_lookup</CODE> and <VAR>ds</VAR> is as that call set it; <VAR>np</VAR> is
locked.


<P>
<CODE>diskfs_dirrewrite</CODE> has some additional specifications: <VAR>name</VAR>
is the name within <VAR>dp</VAR> which used to correspond to the previous
referent, <VAR>oldnp</VAR>; it is this reference which is being rewritten.
<CODE>diskfs_dirrewrite</CODE> also calls <CODE>diskfs_notice_dirchange</CODE> if
<CODE><VAR>dp</VAR>-&#62;dirmod_reqs</CODE> is nonzero.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_dirremove</B> <I>(struct node *<VAR>dp</VAR>, struct node *<VAR>np</VAR>, char *<VAR>name</VAR>, struct dirstat *<VAR>ds</VAR>)</I>
<DD><A NAME="IDX374"></A>
<DT><U>Function:</U> error_t <B>diskfs_dirremove_hard</B> <I>(struct node *<VAR>dp</VAR>, struct dirstat *<VAR>ds</VAR>)</I>
<DD><A NAME="IDX375"></A>
You should not define <CODE>diskfs_dirremove</CODE>, because it is simply a
wrapper for <CODE>diskfs_dirremove_hard</CODE>, and is already defined in
<CODE>libdiskfs</CODE>.


<P>
This will only be called after a successful call to <CODE>diskfs_lookup</CODE>
of type <CODE>REMOVE</CODE>; this call should remove the name found from the
directory <VAR>ds</VAR>.  <VAR>dp</VAR> has been locked continuously since the
call to <CODE>diskfs_lookup</CODE> and <VAR>ds</VAR> is as that call set it.


<P>
<CODE>diskfs_dirremove</CODE> has some additional specifications: this routine
should call <CODE>diskfs_notice_dirchange</CODE> if
<CODE><VAR>dp</VAR>-&#62;dirmod_reqs</CODE> is nonzero.  The entry being removed has
name <VAR>name</VAR> and refers to <VAR>np</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_drop_dirstat</B> <I>(struct node *<VAR>dp</VAR>, struct dirstat *<VAR>ds</VAR>)</I>
<DD><A NAME="IDX376"></A>
<VAR>ds</VAR> has been set by a previous call to <CODE>diskfs_lookup</CODE> on
directory <VAR>dp</VAR>; this function is guaranteed to be called if
<CODE>diskfs_direnter</CODE>, <CODE>diskfs_dirrewrite</CODE>, and
<CODE>diskfs_dirremove</CODE> have not been called, and should free any state
retained by a <CODE>struct dirstat</CODE>.  <VAR>dp</VAR> has been locked
continuously since the call to <CODE>diskfs_lookup</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_null_dirstat</B> <I>(struct dirstat *<VAR>ds</VAR>)</I>
<DD><A NAME="IDX377"></A>
Initialize <VAR>ds</VAR> such that <CODE>diskfs_drop_dirstat</CODE> will ignore it.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_get_directs</B> <I>(struct node *<VAR>dp</VAR>, int <VAR>entry</VAR>, int <VAR>n</VAR>, char **<VAR>data</VAR>, u_int *<VAR>datacnt</VAR>, vm_size_t <VAR>bufsiz</VAR>, int *<VAR>amt</VAR>)</I>
<DD><A NAME="IDX378"></A>
Return <VAR>n</VAR> directory entries starting at <VAR>entry</VAR> from locked
directory node <VAR>dp</VAR>.  Fill <CODE>*<VAR>data</VAR></CODE> with the entries;
which currently points to <CODE>*<VAR>datacnt</VAR></CODE> bytes.  If it isn't big
enough, <CODE>vm_allocate</CODE> into <CODE>*<VAR>data</VAR></CODE>.  Set
<CODE>*<VAR>datacnt</VAR></CODE> with the total size used.  Fill <VAR>amt</VAR> with the
number of entries copied.  Regardless, never copy more than <VAR>bufsiz</VAR>
bytes.  If <VAR>bufsiz</VAR> is zero, then there is no limit on
<CODE>*<VAR>datacnt</VAR></CODE>; if <VAR>n</VAR> is -1, then there is no limit on
<VAR>amt</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> int <B>diskfs_dirempty</B> <I>(struct node *<VAR>dp</VAR>, struct protid *<VAR>cred</VAR>)</I>
<DD><A NAME="IDX379"></A>
Return nonzero if locked directory <VAR>dp</VAR> is empty.  If the user has
not redefined <CODE>diskfs_clear_directory</CODE> and
<CODE>diskfs_init_directory</CODE>, then `empty' means `only possesses entries
labelled <TT>`.'</TT> and <TT>`..'</TT>.  <VAR>cred</VAR> identifies the user making
the call... if this user cannot search the directory, then this
routine should fail.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_get_translator</B> <I>(struct node *<VAR>np</VAR>, char **<VAR>namep</VAR>, u_int *<VAR>namelen</VAR>)</I>
<DD><A NAME="IDX380"></A>
For locked node <VAR>np</VAR> (for which <CODE>diskfs_node_translated</CODE> is
true) look up the name of its translator.  Store the name into newly
malloced storage and set <CODE>*<VAR>namelen</VAR></CODE> to the total length.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_set_translator</B> <I>(struct node *<VAR>np</VAR>, char *<VAR>name</VAR>, u_int <VAR>namelen</VAR>, struct protid *<VAR>cred</VAR>)</I>
<DD><A NAME="IDX381"></A>
For locked node <VAR>np</VAR>, set the name of the translating program to be
<VAR>name</VAR>, which is <VAR>namelen</VAR> bytes long.  <VAR>cred</VAR> identifies
the user responsible for the call.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_truncate</B> <I>(struct node *<VAR>np</VAR>, off_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX382"></A>
Truncate locked node <VAR>np</VAR> to be <VAR>size</VAR> bytes long.  If <VAR>np</VAR>
is already less than or equal to <VAR>size</VAR> bytes long, do nothing.  If
this is a symlink (and <CODE>diskfs_shortcut_symlink</CODE> is set) then this
should clear the symlink, even if <CODE>diskfs_create_symlink_hook</CODE>
stores the link target elsewhere.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_grow</B> <I>(struct node *<VAR>np</VAR>, off_t <VAR>size</VAR>, struct protid *<VAR>cred</VAR>)</I>
<DD><A NAME="IDX383"></A>
Grow the disk allocated to locked node <VAR>np</VAR> to be at least
<VAR>size</VAR> bytes, and set <CODE><VAR>np</VAR>-&#62;allocsize</CODE> to the actual
allocated size.  If the allocated size is already <VAR>size</VAR> bytes, do
nothing.  <VAR>cred</VAR> identifies the user responsible for the call.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_node_reload</B> <I>(struct node *<VAR>node</VAR>)</I>
<DD><A NAME="IDX384"></A>
This function must reread all data specific to <VAR>node</VAR> from disk,
without writing anything.  It is always called with
<VAR>diskfs_readonly</VAR> set to true.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_reload_global_state</B> <I>(void)</I>
<DD><A NAME="IDX385"></A>
This function must invalidate all cached global state, and reread it as
necessary from disk, without writing anything.  It is always called with
<VAR>diskfs_readonly</VAR> set to true.  <CODE>diskfs_node_reload</CODE> is
subsequently called on all active nodes, so this call doesn't need to
reread any node-specific data.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_node_iterate</B> <I>(error_t (*<VAR>fun</VAR>) (struct node *<VAR>np</VAR>))</I>
<DD><A NAME="IDX386"></A>
For each active node <VAR>np</VAR>, call <VAR>fun</VAR>.  The node is to be locked
around the call to <VAR>fun</VAR>.  If <VAR>fun</VAR> returns nonzero for any
node, then stop immediately, and return that value.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_alloc_node</B> <I>(struct node *<VAR>dp</VAR>, mode_t <VAR>mode</VAR>, struct node **<VAR>np</VAR>)</I>
<DD><A NAME="IDX387"></A>
Allocate a new node to be of mode <VAR>mode</VAR> in locked directory
<VAR>dp</VAR>, but don't actually set the mode or modify the directory, since
that will be done by the caller.  The user responsible for the request
can be identified with <VAR>cred</VAR>.  Set <CODE>*<VAR>np</VAR></CODE> to be the newly
allocated node.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_free_node</B> <I>(struct node *<VAR>np</VAR>, mode_t <VAR>mode</VAR>)</I>
<DD><A NAME="IDX388"></A>
Free node <VAR>np</VAR>; the on-disk copy has already been synchronized with
<CODE>diskfs_node_update</CODE> (where <CODE><VAR>np</VAR>-&#62;dn_stat.st_mode</CODE> was
zero).  <VAR>np</VAR>'s mode used to be <VAR>mode</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_lost_hardrefs</B> <I>(struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX389"></A>
Locked node <VAR>np</VAR> has some light references but has just lost its
last hard reference.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_new_hardrefs</B> <I>(struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX390"></A>
Locked node <VAR>np</VAR> has just acquired a hard reference where it had
none previously.  Therefore, it is okay again to have light references
without real users.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_try_dropping_softrefs</B> <I>(struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX391"></A>
Node <VAR>np</VAR> has some light references, but has just lost its last hard
references.  Take steps so that if any light references can be freed,
they are.  Both <VAR>diskfs_node_refcnt_lock</VAR> and <VAR>np</VAR> are locked.
This function will be called after <CODE>diskfs_lost_hardrefs</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_node_norefs</B> <I>(struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX392"></A>
Node <VAR>np</VAR> has no more references; free local state, including
<CODE>*<VAR>np</VAR></CODE> if it shouldn't be retained.
<VAR>diskfs_node_refcnt_lock</VAR> is held.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_set_hypermetadata</B> <I>(int <VAR>wait</VAR>, int <VAR>clean</VAR>)</I>
<DD><A NAME="IDX393"></A>
Write any non-paged metadata from format-specific buffers to disk,
asynchronously unless <VAR>wait</VAR> is nonzero.  If <VAR>clean</VAR> is nonzero,
then after this is written the filesystem will be absolutely clean, and
it must be possible for the non-paged metadata to indicate that fact.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_write_disknode</B> <I>(struct node *<VAR>np</VAR>, int <VAR>wait</VAR>)</I>
<DD><A NAME="IDX394"></A>
Write the information in <CODE><VAR>np</VAR>-&#62;dn_stat</CODE> and any associated
format-specific information to the disk.  If <VAR>wait</VAR> is true, then
return only after the physical media has been completely updated.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_file_update</B> <I>(struct node *<VAR>np</VAR>, int <VAR>wait</VAR>)</I>
<DD><A NAME="IDX395"></A>
Write the contents and all associated metadata of file NP to disk.
Generally, this will involve calling <CODE>diskfs_node_update</CODE> for much
of the metadata.  If <VAR>wait</VAR> is true, then return only after the
physical media has been completely updated.
</DL>


<P>
<DL>
<DT><U>Function:</U> mach_port_t <B>diskfs_get_filemap</B> <I>(struct node *<VAR>np</VAR>, vm_prot_t <VAR>prot</VAR>)</I>
<DD><A NAME="IDX396"></A>
Return a memory object port (send right) for the file contents of
<VAR>np</VAR>.  <VAR>prot</VAR> is the maximum allowable access.  On errors,
return <CODE>MACH_PORT_NULL</CODE> and set <CODE>errno</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> struct pager * <B>diskfs_get_filemap_pager_struct</B> <I>(struct node *<VAR>np</VAR>)</I>
<DD><A NAME="IDX397"></A>
Return a <CODE>struct pager *</CODE> that refers to the pager returned by
diskfs_get_filemap for locked node NP, suitable for use as an argument
to <CODE>pager_memcpy</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> vm_prot_t <B>diskfs_max_user_pager_prot</B> <I>(void)</I>
<DD><A NAME="IDX398"></A>
Return the bitwise OR of the maximum <CODE>prot</CODE> parameter (the second
argument to <CODE>diskfs_get_filemap</CODE>) for all active user pagers.
</DL>


<P>
<DL>
<DT><U>Function:</U> int <B>diskfs_pager_users</B> <I>(void)</I>
<DD><A NAME="IDX399"></A>
Return nonzero if there are pager ports exported that might be in use by
users.  Further pager creation should be blocked before this function
returns zero.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_sync_everything</B> <I>(int <VAR>wait</VAR>)</I>
<DD><A NAME="IDX400"></A>
Sync all the pagers and write any data belonging on disk except for the
hypermetadata.  If <VAR>wait</VAR> is true, then return only after the
physical media has been completely updated.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_shutdown_pager</B> <I>(void)</I>
<DD><A NAME="IDX401"></A>
Shut down all pagers.  This is irreversible, and is done when the
filesystem is exiting.
</DL>




<H3><A NAME="SEC112" HREF="hurd_toc.html#TOC112">Diskfs Options</A></H3>

<P>
The functions and variables described in this subsection already have
default definitions in <CODE>libdiskfs</CODE>, so you are not forced to define
them; rather, they may be redefined on a case-by-case basis.


<P>
You should set the values of any option variables as soon as your program
starts (before you make any calls to diskfs, such as argument parsing).


<P>
<DL>
<DT><U>Variable:</U> int <B>diskfs_hard_readonly</B>
<DD><A NAME="IDX402"></A>
You should set this variable to nonzero if the filesystem media can
never be made writable.
</DL>


<P>
<DL>
<DT><U>Variable:</U> char * <B>diskfs_extra_version</B>
<DD><A NAME="IDX403"></A>
Set this to be any additional version specification that should be
printed for --version.
</DL>


<P>
<DL>
<DT><U>Variable:</U> int <B>diskfs_shortcut_symlink</B>
<DD><A NAME="IDX404"></A>
This should be nonzero if and only if the filesystem format supports
shortcutting symbolic link translation.  The library guarantees that
users will not be able to read or write the contents of the node
directly, and the library will only do so if the symlink hook functions
(<CODE>diskfs_create_symlink_hook</CODE> and <CODE>diskfs_read_symlink_hook</CODE>)
return <CODE>EINVAL</CODE> or are not defined.  The library knows that the
<CODE>dn_stat.st_size</CODE> field is the length of the symlink, even if the
hook functions are used.
</DL>


<P>
<DL>
<DT><U>Variable:</U> int <B>diskfs_shortcut_chrdev</B>
<DD><A NAME="IDX405"></A>
<DT><U>Variable:</U> int <B>diskfs_shortcut_blkdev</B>
<DD><A NAME="IDX406"></A>
<DT><U>Variable:</U> int <B>diskfs_shortcut_fifo</B>
<DD><A NAME="IDX407"></A>
<DT><U>Variable:</U> int <B>diskfs_shortcut_ifsock</B>
<DD><A NAME="IDX408"></A>
These variables should be nonzero if and only if the filesystem format
supports shortcutting character device node, block device node, FIFO, or
Unix-domain socket translation, respectively.
</DL>


<P>
<DL>
<DT><U>Variable:</U> int <B>diskfs_default_sync_interval</B>
<DD><A NAME="IDX409"></A>
<CODE>diskfs_set_sync_interval</CODE> is called with this value when the first
diskfs thread is started up (in <CODE>diskfs_spawn_first_thread</CODE>).  This
variable has a default default value of 30, which causes disk buffers to
be flushed at least every 30 seconds.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_validate_mode_change</B> <I>(struct node *<VAR>np</VAR>, mode_t <VAR>mode</VAR>)</I>
<DD><A NAME="IDX410"></A>
<DT><U>Function:</U> error_t <B>diskfs_validate_owner_change</B> <I>(struct node *<VAR>np</VAR>, uid_t <VAR>uid</VAR>)</I>
<DD><A NAME="IDX411"></A>
<DT><U>Function:</U> error_t <B>diskfs_validate_group_change</B> <I>(struct node *<VAR>np</VAR>, gid_t <VAR>gid</VAR>)</I>
<DD><A NAME="IDX412"></A>
<DT><U>Function:</U> error_t <B>diskfs_validate_author_change</B> <I>(struct node *<VAR>np</VAR>, uid_t <VAR>author</VAR>)</I>
<DD><A NAME="IDX413"></A>
<DT><U>Function:</U> error_t <B>diskfs_validate_flags_change</B> <I>(struct node *<VAR>np</VAR>, int <VAR>flags</VAR>)</I>
<DD><A NAME="IDX414"></A>
<DT><U>Function:</U> error_t <B>diskfs_validate_rdev_change</B> <I>(struct node *<VAR>np</VAR>, dev_t <VAR>rdev</VAR>)</I>
<DD><A NAME="IDX415"></A>
Return zero if for the node <VAR>np</VAR> can be changed as requested.  That
is, if <VAR>np</VAR>'s mode can be changed to <VAR>mode</VAR>, owner to <VAR>uid</VAR>,
group to <VAR>gid</VAR>, author to <VAR>author</VAR>, flags to <VAR>flags</VAR>, or raw
device number to <VAR>rdev</VAR>, respectively.  Otherwise, return an error
code.


<P>
It must always be possible to clear the mode or the flags; diskfs will
not ask for permission before doing so.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_readonly_changed</B> <I>(int <VAR>readonly</VAR>)</I>
<DD><A NAME="IDX416"></A>
This is called when the disk has been changed from read-only to
read-write mode or vice-versa.  <VAR>readonly</VAR> is the new state (which
is also reflected in <VAR>diskfs_readonly</VAR>).  This function is also
called during initial startup if the filesystem is to be writable.
</DL>


<P>
<DL>
<DT><U>Variable:</U> error_t (* <B>diskfs_create_symlink_hook</B> <I>) (struct node *<VAR>np</VAR>, char *<VAR>target</VAR>)</I>
<DD><A NAME="IDX417"></A>
If this function pointer is nonzero (and <CODE>diskfs_shortcut_symlink</CODE>
is set) it is called to set a symlink.  If it returns <CODE>EINVAL</CODE> or
isn't set, then the normal method (writing the contents into the file
data) is used.  If it returns any other error, it is returned to the
user.
</DL>


<P>
<DL>
<DT><U>Variable:</U> error_t (* <B>diskfs_read_symlink_hook</B> <I>) (struct node *<VAR>np</VAR>, char *<VAR>target</VAR>)</I>
<DD><A NAME="IDX418"></A>
If this function pointer is nonzero (and <CODE>diskfs_shortcut_symlink</CODE>
is set) it is called to read the contents of a symlink.  If it returns
<CODE>EINVAL</CODE> or isn't set, then the normal method (reading from the
file data) is used.  If it returns any other error, it is returned to
the user.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_rename_dir</B> <I>(struct node *<VAR>fdp</VAR>, struct node *<VAR>fnp</VAR>, char *<VAR>fromname</VAR>, struct node *<VAR>tdp</VAR>, char *<VAR>toname</VAR>, struct protid *<VAR>fromcred</VAR>, struct protid *<VAR>tocred</VAR>)</I>
<DD><A NAME="IDX419"></A>
Rename directory node <VAR>fnp</VAR> (whose parent is <VAR>fdp</VAR>, and which
has name <VAR>fromname</VAR> in that directory) to have name <VAR>toname</VAR>
inside directory <VAR>tdp</VAR>.  None of these nodes are locked, and none
should be locked upon return.  This routine is serialized, so it doesn't
have to be reentrant.  Directories will never be renamed except by this
routine.  <VAR>fromcred</VAR> is the user responsible for <VAR>fdp</VAR> and
<VAR>fnp</VAR>.  <VAR>tocred</VAR> is the user responsible for <VAR>tdp</VAR>.  This
routine assumes the usual convention where <TT>`.'</TT>  and <TT>`..'</TT> are
represented by ordinary links; if that is not true for your format, you
have to redefine this function.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_clear_directory</B> <I>(struct node *<VAR>dp</VAR>, struct node *<VAR>pdp</VAR>, struct protid *<VAR>cred</VAR>)</I>
<DD><A NAME="IDX420"></A>
Clear the <TT>`.'</TT> and <TT>`..'</TT> entries from directory <VAR>dp</VAR>.  Its
parent is <VAR>pdp</VAR>, and the user responsible for this is identified by
<VAR>cred</VAR>.  Both directories must be locked.  This routine assumes the
usual convention where <TT>`.'</TT> and <TT>`..'</TT> are represented by
ordinary links; if that is not true for your format, you have to
redefine this function.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_init_dir</B> <I>(struct node *<VAR>dp</VAR>, struct node *<VAR>pdp</VAR>, struct protid *<VAR>cred</VAR>)</I>
<DD><A NAME="IDX421"></A>
Locked node <VAR>dp</VAR> is a new directory; add whatever links are
necessary to give it structure; its parent is the (locked) node
<VAR>pdp</VAR>.  This routine may not call <CODE>diskfs_lookup</CODE> on <VAR>pdp</VAR>.
The new directory must be clear within the meaning of
<CODE>diskfs_dirempty</CODE>.  This routine assumes the usual convention where
<TT>`.'</TT> and <TT>`..'</TT> are represented by ordinary links; if that is not
true for your format, you have to redefine this function.  <VAR>cred</VAR>
identifies the user making the call.
</DL>




<H3><A NAME="SEC113" HREF="hurd_toc.html#TOC113">Diskfs Internals</A></H3>

<P>
The library also exports the following functions, but they are not
generally useful unless you are redefining other functions the library
provides.


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_create_protid</B> <I>(struct peropen *<VAR>po</VAR>, struct iouser *<VAR>user</VAR>, struct protid **<VAR>cred</VAR>)</I>
<DD><A NAME="IDX422"></A>
Create and return a protid for an existing peropen <VAR>po</VAR> in
<VAR>cred</VAR>, referring to user <VAR>user</VAR>.  The node <CODE><VAR>po</VAR>-&#62;np</CODE>
must be locked.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_start_protid</B> <I>(struct peropen *<VAR>po</VAR>, struct protid **<VAR>cred</VAR>)</I>
<DD><A NAME="IDX423"></A>
Build and return in <VAR>cred</VAR> a protid which has no user
identification, for peropen <VAR>po</VAR>.  The node <CODE><VAR>po</VAR>-&#62;np</CODE> must
be locked.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_finish_protid</B> <I>(struct protid *<VAR>cred</VAR>, struct iouser *<VAR>user</VAR>)</I>
<DD><A NAME="IDX424"></A>
Finish building protid <VAR>cred</VAR> started with <CODE>diskfs_start_protid</CODE>;
the user to install is <VAR>user</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_protid_rele</B> <I>(void *<VAR>arg</VAR>)</I>
<DD><A NAME="IDX425"></A>
Called when a protid <VAR>cred</VAR> has no more references.  Because
references to protids are maintained by the port management library,
this is installed in the clean routines list.  The ports library will
free the structure.
</DL>


<P>
<DL>
<DT><U>Function:</U> struct peropen * <B>diskfs_make_peropen</B> <I>(struct node *<VAR>np</VAR>, int <VAR>flags</VAR>, struct peropen *<VAR>context</VAR>)</I>
<DD><A NAME="IDX426"></A>
Create and return a new peropen structure on node <VAR>np</VAR> with open
flags <VAR>flags</VAR>.  The initial values for the <CODE>root_parent</CODE>,
<CODE>shadow_root</CODE>, and <CODE>shadow_root_parent</CODE> fields are copied from
<VAR>context</VAR> if it is nonzero, otherwise each of these values are
set to zero.
</DL>


<P>
<DL>
<DT><U>Function:</U> void <B>diskfs_release_peropen</B> <I>(struct peropen *<VAR>po</VAR>)</I>
<DD><A NAME="IDX427"></A>
Decrement the reference count on <VAR>po</VAR>.
</DL>


<P>
<DL>
<DT><U>Function:</U> error_t <B>diskfs_execboot_fsys_startup</B> <I>(mach_port_t <VAR>port</VAR>, int <VAR>flags</VAR>, mach_port_t <VAR>ctl</VAR>, mach_port_t *<VAR>real</VAR>, mach_msg_type_name_t *<VAR>realpoly</VAR>)</I>
<DD><A NAME="IDX428"></A>
This function is called by <CODE>S_fsys_startup</CODE> for execserver
bootstrap.  The execserver is able to function without a real node,
hence this fraud.  Arguments are as for <CODE>fsys_startup</CODE> in
<CODE>&#60;hurd/fsys.defs&#62;</CODE>.
</DL>


<P>
<DL>
<DT><U>Function:</U> int <B>diskfs_demuxer</B> <I>(mach_msg_header_t *<VAR>inp</VAR>, mach_msg_header_t *<VAR>outp</VAR>)</I>
<DD><A NAME="IDX429"></A>
Demultiplex incoming <CODE>libports</CODE> messages on diskfs ports.
</DL>


<P>
<A NAME="IDX430"></A>
The diskfs library also provides functions to demultiplex the fs, io,
fsys, interrupt, and notify interfaces.  All the server routines have
the prefix <CODE>diskfs_S_</CODE>.  For those routines, <CODE>in</CODE> arguments of
type <CODE>file_t</CODE> or <CODE>io_t</CODE> appear as <CODE>struct protid *</CODE> to
the stub.




<H1><A NAME="SEC114" HREF="hurd_toc.html#TOC114">Twisted Filesystems</A></H1>

<P>
In the Hurd, translators are capable of redirecting filesystem requests
to other translators, which makes it possible to implement alternative
views of the same underlying data.  The translators described in this
chapter do not provide direct access to any data; rather, they are
organizational tools to help you simplify an existing physical
filesystem layout.


<P>
Be prudent with these translators: you may accidentally injure people
who want their filesystems to be rigidly tree-structured.<A NAME="DOCF10" HREF="hurd_foot.html#FOOT10">(10)</A>


<P>
FIXME: finish




<H2><A NAME="SEC115" HREF="hurd_toc.html#TOC115">symlink, firmlink</A></H2>


<H2><A NAME="SEC116" HREF="hurd_toc.html#TOC116">hostmux, usermux</A></H2>


<H2><A NAME="SEC117" HREF="hurd_toc.html#TOC117">shadowfs</A></H2>



<H1><A NAME="SEC118" HREF="hurd_toc.html#TOC118">Distributed Filesystems</A></H1>

<P>
Distributed filesystems are designed to share files between separate
machines via a network connection of some sort.  Their design is
significantly different than stored filesystems (see section <A HREF="hurd.html#SEC101">Stored Filesystems</A>): they need to deal with the problems of network delays and
failures, and may require complex authentication and replication
protocols involving multiple file servers.




<H2><A NAME="SEC119" HREF="hurd_toc.html#TOC119">File Transfer Protocol</A></H2>
<P>
<A NAME="IDX431"></A>


<P>
FIXME: finish




<H3><A NAME="SEC120" HREF="hurd_toc.html#TOC120">ftpcp, ftpdir</A></H3>


<H3><A NAME="SEC121" HREF="hurd_toc.html#TOC121">ftpfs</A></H3>



<H3><A NAME="SEC122" HREF="hurd_toc.html#TOC122">FTP Connection Library</A></H3>
<P>
<A NAME="IDX432"></A>
<A NAME="IDX433"></A>


<P>
FIXME: finish




<H2><A NAME="SEC123" HREF="hurd_toc.html#TOC123">Network File System</A></H2>
<P>
<A NAME="IDX434"></A>


<P>
FIXME: finish




<H3><A NAME="SEC124" HREF="hurd_toc.html#TOC124">nfsd</A></H3>


<H3><A NAME="SEC125" HREF="hurd_toc.html#TOC125">nfs</A></H3>



<H1><A NAME="SEC126" HREF="hurd_toc.html#TOC126">Networking</A></H1>

<P>
FIXME: this subsystem is in flux 




<H2><A NAME="SEC127" HREF="hurd_toc.html#TOC127">pfinet</A></H2>


<H2><A NAME="SEC128" HREF="hurd_toc.html#TOC128">pflocal</A></H2>


<H2><A NAME="SEC129" HREF="hurd_toc.html#TOC129">libpipe</A></H2>



<H2><A NAME="SEC130" HREF="hurd_toc.html#TOC130">Socket Interface</A></H2>
<P>
<A NAME="IDX435"></A>


<P>
FIXME: net frobbing stuff may be added to socket.defs




<H1><A NAME="SEC131" HREF="hurd_toc.html#TOC131">Terminal Handling</A></H1>

<P>
FIXME: finish




<H2><A NAME="SEC132" HREF="hurd_toc.html#TOC132">term</A></H2>


<H2><A NAME="SEC133" HREF="hurd_toc.html#TOC133">term.defs</A></H2>



<H1><A NAME="SEC134" HREF="hurd_toc.html#TOC134">Running Programs</A></H1>

<P>
FIXME: finish




<H2><A NAME="SEC135" HREF="hurd_toc.html#TOC135">ps, w</A></H2>


<H2><A NAME="SEC136" HREF="hurd_toc.html#TOC136">libps</A></H2>


<H2><A NAME="SEC137" HREF="hurd_toc.html#TOC137">exec</A></H2>


<H2><A NAME="SEC138" HREF="hurd_toc.html#TOC138">proc</A></H2>


<H2><A NAME="SEC139" HREF="hurd_toc.html#TOC139">crash</A></H2>



<H1><A NAME="SEC140" HREF="hurd_toc.html#TOC140">Authentication</A></H1>

<P>
FIXME: finish




<H2><A NAME="SEC141" HREF="hurd_toc.html#TOC141">addauth, rmauth, setauth</A></H2>


<H2><A NAME="SEC142" HREF="hurd_toc.html#TOC142">su, sush, unsu</A></H2>


<H2><A NAME="SEC143" HREF="hurd_toc.html#TOC143">login, loginpr</A></H2>


<H2><A NAME="SEC144" HREF="hurd_toc.html#TOC144">auth</A></H2>



<H2><A NAME="SEC145" HREF="hurd_toc.html#TOC145">Auth Interface</A></H2>
<P>
<A NAME="IDX436"></A>


<P>
FIXME: finish




<H3><A NAME="SEC146" HREF="hurd_toc.html#TOC146">Auth Protocol</A></H3>

<P>
FIXME: finish




<H1><A NAME="SEC147" HREF="hurd_toc.html#TOC147">Index</A></H1>

<P>
Jump to:
<A HREF="#cindex_/">/</A>
-
<A HREF="#cindex_a">a</A>
-
<A HREF="#cindex_c">c</A>
-
<A HREF="#cindex_d">d</A>
-
<A HREF="#cindex_e">e</A>
-
<A HREF="#cindex_f">f</A>
-
<A HREF="#cindex_g">g</A>
-
<A HREF="#cindex_i">i</A>
-
<A HREF="#cindex_l">l</A>
-
<A HREF="#cindex_m">m</A>
-
<A HREF="#cindex_n">n</A>
-
<A HREF="#cindex_p">p</A>
-
<A HREF="#cindex_q">q</A>
-
<A HREF="#cindex_r">r</A>
-
<A HREF="#cindex_s">s</A>
-
<A HREF="#cindex_t">t</A>
-
<A HREF="#cindex_x">x</A>
-
<A HREF="#cindex_z">z</A>
<P>
<H2><A NAME="cindex_/">/</A></H2>
<DIR>
<LI><A HREF="hurd.html#IDX4">/boot/servers.boot</A>
</DIR>
<H2><A NAME="cindex_a">a</A></H2>
<DIR>
<LI><A HREF="hurd.html#IDX268">appending disks</A>
<LI><A HREF="hurd.html#IDX70">argp_program_bug_address</A>
</DIR>
<H2><A NAME="cindex_c">c</A></H2>
<DIR>
<LI><A HREF="hurd.html#IDX266"><CODE>concat</CODE> store</A>
<LI><A HREF="hurd.html#IDX271">concatenation, disk</A>
<LI><A HREF="hurd.html#IDX77">conch</A>
<LI><A HREF="hurd.html#IDX257"><CODE>copy</CODE> store</A>
</DIR>
<H2><A NAME="cindex_d">d</A></H2>
<DIR>
<LI><A HREF="hurd.html#IDX242"><CODE>device drivers</CODE></A>
<LI><A HREF="hurd.html#IDX241"><CODE>device</CODE> store</A>
<LI><A HREF="hurd.html#IDX359">dirstat</A>
<LI><A HREF="hurd.html#IDX270">disk concatenation</A>
<LI><A HREF="hurd.html#IDX278">disk striping</A>
<LI><A HREF="hurd.html#IDX304">disk-based filesystems</A>
<LI><A HREF="hurd.html#IDX387">diskfs_alloc_node</A>
<LI><A HREF="hurd.html#IDX319">diskfs_append_args</A>
<LI><A HREF="hurd.html#IDX320">diskfs_append_std_options</A>
<LI><A HREF="hurd.html#IDX330">diskfs_argv</A>
<LI><A HREF="hurd.html#IDX328">diskfs_auth_server_port</A>
<LI><A HREF="hurd.html#IDX331">diskfs_boot_flags</A>
<LI><A HREF="hurd.html#IDX356">diskfs_cached_lookup</A>
<LI><A HREF="hurd.html#IDX355">diskfs_check_lookup_cache</A>
<LI><A HREF="hurd.html#IDX339">diskfs_check_readonly</A>
<LI><A HREF="hurd.html#IDX420">diskfs_clear_directory</A>
<LI><A HREF="hurd.html#IDX313">diskfs_console_stdio</A>
<LI><A HREF="hurd.html#IDX353">diskfs_create_node</A>
<LI><A HREF="hurd.html#IDX422">diskfs_create_protid</A>
<LI><A HREF="hurd.html#IDX417">diskfs_create_symlink_hook</A>
<LI><A HREF="hurd.html#IDX325">diskfs_default_pager</A>
<LI><A HREF="hurd.html#IDX409">diskfs_default_sync_interval</A>
<LI><A HREF="hurd.html#IDX429">diskfs_demuxer</A>
<LI><A HREF="hurd.html#IDX379">diskfs_dirempty</A>
<LI><A HREF="hurd.html#IDX370">diskfs_direnter</A>
<LI><A HREF="hurd.html#IDX371">diskfs_direnter_hard</A>
<LI><A HREF="hurd.html#IDX374">diskfs_dirremove</A>
<LI><A HREF="hurd.html#IDX375">diskfs_dirremove_hard</A>
<LI><A HREF="hurd.html#IDX372">diskfs_dirrewrite</A>
<LI><A HREF="hurd.html#IDX373">diskfs_dirrewrite_hard</A>
<LI><A HREF="hurd.html#IDX360">diskfs_dirstat_size</A>
<LI><A HREF="hurd.html#IDX366">diskfs_disk_name</A>
<LI><A HREF="hurd.html#IDX376">diskfs_drop_dirstat</A>
<LI><A HREF="hurd.html#IDX342">diskfs_drop_node</A>
<LI><A HREF="hurd.html#IDX357">diskfs_enter_lookup_cache</A>
<LI><A HREF="hurd.html#IDX327">diskfs_exec</A>
<LI><A HREF="hurd.html#IDX326">diskfs_exec_ctl</A>
<LI><A HREF="hurd.html#IDX428">diskfs_execboot_fsys_startup</A>
<LI><A HREF="hurd.html#IDX403">diskfs_extra_version</A>
<LI><A HREF="hurd.html#IDX395">diskfs_file_update</A>
<LI><A HREF="hurd.html#IDX424">diskfs_finish_protid</A>
<LI><A HREF="hurd.html#IDX388">diskfs_free_node</A>
<LI><A HREF="hurd.html#IDX329">diskfs_fsys_identity</A>
<LI><A HREF="hurd.html#IDX332">diskfs_fsys_lock</A>
<LI><A HREF="hurd.html#IDX378">diskfs_get_directs</A>
<LI><A HREF="hurd.html#IDX396">diskfs_get_filemap</A>
<LI><A HREF="hurd.html#IDX397">diskfs_get_filemap_pager_struct</A>
<LI><A HREF="hurd.html#IDX380">diskfs_get_translator</A>
<LI><A HREF="hurd.html#IDX383">diskfs_grow</A>
<LI><A HREF="hurd.html#IDX402">diskfs_hard_readonly</A>
<LI><A HREF="hurd.html#IDX421">diskfs_init_dir</A>
<LI><A HREF="hurd.html#IDX314">diskfs_init_diskfs</A>
<LI><A HREF="hurd.html#IDX361">diskfs_link_max</A>
<LI><A HREF="hurd.html#IDX368">diskfs_lookup</A>
<LI><A HREF="hurd.html#IDX369">diskfs_lookup_hard</A>
<LI><A HREF="hurd.html#IDX389">diskfs_lost_hardrefs</A>
<LI><A HREF="hurd.html#IDX352">diskfs_make_node</A>
<LI><A HREF="hurd.html#IDX426">diskfs_make_peropen</A>
<LI><A HREF="hurd.html#IDX398">diskfs_max_user_pager_prot</A>
<LI><A HREF="hurd.html#IDX362">diskfs_maxsymlinks</A>
<LI><A HREF="hurd.html#IDX333">diskfs_mtime</A>
<LI><A HREF="hurd.html#IDX390">diskfs_new_hardrefs</A>
<LI><A HREF="hurd.html#IDX386">diskfs_node_iterate</A>
<LI><A HREF="hurd.html#IDX392">diskfs_node_norefs</A>
<LI><A HREF="hurd.html#IDX350">diskfs_node_rdwr</A>
<LI><A HREF="hurd.html#IDX336">diskfs_node_refcnt_lock</A>
<LI><A HREF="hurd.html#IDX384">diskfs_node_reload</A>
<LI><A HREF="hurd.html#IDX343">diskfs_node_update</A>
<LI><A HREF="hurd.html#IDX351">diskfs_notice_dirchange</A>
<LI><A HREF="hurd.html#IDX345">diskfs_nput</A>
<LI><A HREF="hurd.html#IDX348">diskfs_nput_light</A>
<LI><A HREF="hurd.html#IDX344">diskfs_nref</A>
<LI><A HREF="hurd.html#IDX347">diskfs_nref_light</A>
<LI><A HREF="hurd.html#IDX346">diskfs_nrele</A>
<LI><A HREF="hurd.html#IDX349">diskfs_nrele_light</A>
<LI><A HREF="hurd.html#IDX377">diskfs_null_dirstat</A>
<LI><A HREF="hurd.html#IDX399">diskfs_pager_users</A>
<LI><A HREF="hurd.html#IDX425">diskfs_protid_rele</A>
<LI><A HREF="hurd.html#IDX358">diskfs_purge_lookup_cache</A>
<LI><A HREF="hurd.html#IDX418">diskfs_read_symlink_hook</A>
<LI><A HREF="hurd.html#IDX337">diskfs_readonly</A>
<LI><A HREF="hurd.html#IDX416">diskfs_readonly_changed</A>
<LI><A HREF="hurd.html#IDX427">diskfs_release_peropen</A>
<LI><A HREF="hurd.html#IDX385">diskfs_reload_global_state</A>
<LI><A HREF="hurd.html#IDX340">diskfs_remount</A>
<LI><A HREF="hurd.html#IDX419">diskfs_rename_dir</A>
<LI><A HREF="hurd.html#IDX363">diskfs_root_node</A>
<LI><A HREF="hurd.html#IDX321">diskfs_runtime_argp</A>
<LI><A HREF="hurd.html#IDX430">diskfs_S_*</A>
<LI><A HREF="hurd.html#IDX364">diskfs_server_name</A>
<LI><A HREF="hurd.html#IDX365">diskfs_server_version</A>
<LI><A HREF="hurd.html#IDX393">diskfs_set_hypermetadata</A>
<LI><A HREF="hurd.html#IDX354">diskfs_set_node_times</A>
<LI><A HREF="hurd.html#IDX318">diskfs_set_options</A>
<LI><A HREF="hurd.html#IDX338">diskfs_set_readonly</A>
<LI><A HREF="hurd.html#IDX367">diskfs_set_statfs</A>
<LI><A HREF="hurd.html#IDX335">diskfs_set_sync_interval</A>
<LI><A HREF="hurd.html#IDX381">diskfs_set_translator</A>
<LI><A HREF="hurd.html#IDX406">diskfs_shortcut_blkdev</A>
<LI><A HREF="hurd.html#IDX405">diskfs_shortcut_chrdev</A>
<LI><A HREF="hurd.html#IDX407">diskfs_shortcut_fifo</A>
<LI><A HREF="hurd.html#IDX408">diskfs_shortcut_ifsock</A>
<LI><A HREF="hurd.html#IDX404">diskfs_shortcut_symlink</A>
<LI><A HREF="hurd.html#IDX341">diskfs_shutdown</A>
<LI><A HREF="hurd.html#IDX401">diskfs_shutdown_pager</A>
<LI><A HREF="hurd.html#IDX315">diskfs_spawn_first_thread</A>
<LI><A HREF="hurd.html#IDX317">diskfs_start_bootstrap</A>
<LI><A HREF="hurd.html#IDX423">diskfs_start_protid</A>
<LI><A HREF="hurd.html#IDX323">diskfs_startup_argp</A>
<LI><A HREF="hurd.html#IDX316">diskfs_startup_diskfs</A>
<LI><A HREF="hurd.html#IDX322">diskfs_std_runtime_argp</A>
<LI><A HREF="hurd.html#IDX324">diskfs_store_startup_argp</A>
<LI><A HREF="hurd.html#IDX400">diskfs_sync_everything</A>
<LI><A HREF="hurd.html#IDX334">diskfs_synchronous</A>
<LI><A HREF="hurd.html#IDX382">diskfs_truncate</A>
<LI><A HREF="hurd.html#IDX391">diskfs_try_dropping_softrefs</A>
<LI><A HREF="hurd.html#IDX413">diskfs_validate_author_change</A>
<LI><A HREF="hurd.html#IDX414">diskfs_validate_flags_change</A>
<LI><A HREF="hurd.html#IDX412">diskfs_validate_group_change</A>
<LI><A HREF="hurd.html#IDX410">diskfs_validate_mode_change</A>
<LI><A HREF="hurd.html#IDX411">diskfs_validate_owner_change</A>
<LI><A HREF="hurd.html#IDX415">diskfs_validate_rdev_change</A>
<LI><A HREF="hurd.html#IDX394">diskfs_write_disknode</A>
<LI><A HREF="hurd.html#IDX269">disks, appending</A>
<LI><A HREF="hurd.html#IDX280">disks, interleaving</A>
</DIR>
<H2><A NAME="cindex_e">e</A></H2>
<DIR>
<LI><A HREF="hurd.html#IDX307">ext2fs</A>
<LI><A HREF="hurd.html#IDX88">external pager (XP)</A>
</DIR>
<H2><A NAME="cindex_f">f</A></H2>
<DIR>
<LI><A HREF="hurd.html#IDX246"><CODE>file</CODE> store</A>
<LI><A HREF="hurd.html#IDX196">file_chauthor</A>
<LI><A HREF="hurd.html#IDX198">file_chflags</A>
<LI><A HREF="hurd.html#IDX197">file_chmod</A>
<LI><A HREF="hurd.html#IDX195">file_chown</A>
<LI><A HREF="hurd.html#IDX201">file_exec</A>
<LI><A HREF="hurd.html#IDX202">file_lock</A>
<LI><A HREF="hurd.html#IDX203">file_lock_stat</A>
<LI><A HREF="hurd.html#IDX200">file_set_size</A>
<LI><A HREF="hurd.html#IDX199">file_utimes</A>
<LI><A HREF="hurd.html#IDX305">filesystems, disk-based</A>
<LI><A HREF="hurd.html#IDX306">fsck</A>
<LI><A HREF="hurd.html#IDX186">fshelp_access</A>
<LI><A HREF="hurd.html#IDX187">fshelp_checkdirmod</A>
<LI><A HREF="hurd.html#IDX188">fshelp_delegate_translation</A>
<LI><A HREF="hurd.html#IDX184">fshelp_drop_transbox</A>
<LI><A HREF="hurd.html#IDX189">fshelp_exec_reauth</A>
<LI><A HREF="hurd.html#IDX183">fshelp_fetch_control</A>
<LI><A HREF="hurd.html#IDX180">fshelp_fetch_root</A>
<LI><A HREF="hurd.html#IDX178">fshelp_fetch_root_callback1_t</A>
<LI><A HREF="hurd.html#IDX179">fshelp_fetch_root_callback2_t</A>
<LI><A HREF="hurd.html#IDX190">fshelp_get_identity</A>
<LI><A HREF="hurd.html#IDX185">fshelp_isowner</A>
<LI><A HREF="hurd.html#IDX174">fshelp_open_fn_t</A>
<LI><A HREF="hurd.html#IDX191">fshelp_return_malloced_buffer</A>
<LI><A HREF="hurd.html#IDX182">fshelp_set_active</A>
<LI><A HREF="hurd.html#IDX192">fshelp_set_options</A>
<LI><A HREF="hurd.html#IDX176">fshelp_start_translator</A>
<LI><A HREF="hurd.html#IDX175">fshelp_start_translator_long</A>
<LI><A HREF="hurd.html#IDX193">fshelp_touch</A>
<LI><A HREF="hurd.html#IDX177">fshelp_transbox_init</A>
<LI><A HREF="hurd.html#IDX181">fshelp_translated</A>
<LI><A HREF="hurd.html#IDX431">FTP</A>
</DIR>
<H2><A NAME="cindex_g">g</A></H2>
<DIR>
<LI><A HREF="hurd.html#IDX2">GRand Unified Bootloader</A>
<LI><A HREF="hurd.html#IDX1">GRUB</A>
<LI><A HREF="hurd.html#IDX262"><CODE>gunzip</CODE> store</A>
</DIR>
<H2><A NAME="cindex_i">i</A></H2>
<DIR>
<LI><A HREF="hurd.html#IDX63">ihash_add</A>
<LI><A HREF="hurd.html#IDX60">ihash_create</A>
<LI><A HREF="hurd.html#IDX64">ihash_find</A>
<LI><A HREF="hurd.html#IDX61">ihash_free</A>
<LI><A HREF="hurd.html#IDX65">ihash_iterate</A>
<LI><A HREF="hurd.html#IDX67">ihash_locp_remove</A>
<LI><A HREF="hurd.html#IDX66">ihash_remove</A>
<LI><A HREF="hurd.html#IDX62">ihash_set_cleanup</A>
<LI><A HREF="hurd.html#IDX275"><CODE>ileave</CODE> store</A>
<LI><A HREF="hurd.html#IDX279">interleaving disks</A>
<LI><A HREF="hurd.html#IDX121">io_async</A>
<LI><A HREF="hurd.html#IDX120">io_clear_some_openmodes</A>
<LI><A HREF="hurd.html#IDX110">io_duplicate</A>
<LI><A HREF="hurd.html#IDX125">io_get_icky_async_id</A>
<LI><A HREF="hurd.html#IDX118">io_get_openmodes</A>
<LI><A HREF="hurd.html#IDX124">io_get_owner</A>
<LI><A HREF="hurd.html#IDX128">io_map</A>
<LI><A HREF="hurd.html#IDX123">io_mod_owner</A>
<LI><A HREF="hurd.html#IDX114">io_read</A>
<LI><A HREF="hurd.html#IDX116">io_readable</A>
<LI><A HREF="hurd.html#IDX112">io_reauthenticate</A>
<LI><A HREF="hurd.html#IDX111">io_restrict_auth</A>
<LI><A HREF="hurd.html#IDX115">io_seek</A>
<LI><A HREF="hurd.html#IDX122">io_select</A>
<LI><A HREF="hurd.html#IDX127">io_server_version</A>
<LI><A HREF="hurd.html#IDX117">io_set_all_openmodes</A>
<LI><A HREF="hurd.html#IDX119">io_set_some_openmodes</A>
<LI><A HREF="hurd.html#IDX126">io_stat</A>
<LI><A HREF="hurd.html#IDX113">io_write</A>
<LI><A HREF="hurd.html#IDX73">iohelp_create_iouser</A>
<LI><A HREF="hurd.html#IDX74">iohelp_dup_iouser</A>
<LI><A HREF="hurd.html#IDX83">iohelp_fetch_shared_data</A>
<LI><A HREF="hurd.html#IDX75">iohelp_free_iouser</A>
<LI><A HREF="hurd.html#IDX80">iohelp_get_conch</A>
<LI><A HREF="hurd.html#IDX79">iohelp_handle_io_get_conch</A>
<LI><A HREF="hurd.html#IDX81">iohelp_handle_io_release_conch</A>
<LI><A HREF="hurd.html#IDX78">iohelp_initialize_conch</A>
<LI><A HREF="hurd.html#IDX84">iohelp_put_shared_data</A>
<LI><A HREF="hurd.html#IDX76">iohelp_reauth</A>
<LI><A HREF="hurd.html#IDX82">iohelp_verify_user_conch</A>
<LI><A HREF="hurd.html#IDX309">isofs</A>
</DIR>
<H2><A NAME="cindex_l">l</A></H2>
<DIR>
<LI><A HREF="hurd.html#IDX267">linear concatenation</A>
</DIR>
<H2><A NAME="cindex_m">m</A></H2>
<DIR>
<LI><A HREF="hurd.html#IDX13">Microkernel Object Model</A>
<LI><A HREF="hurd.html#IDX12">MOM</A>
<LI><A HREF="hurd.html#IDX283"><CODE>mvol</CODE> store</A>
</DIR>
<H2><A NAME="cindex_n">n</A></H2>
<DIR>
<LI><A HREF="hurd.html#IDX434">NFS</A>
</DIR>
<H2><A NAME="cindex_p">p</A></H2>
<DIR>
<LI><A HREF="hurd.html#IDX107">pager_clear_user_data</A>
<LI><A HREF="hurd.html#IDX89">pager_create</A>
<LI><A HREF="hurd.html#IDX90">pager_demuxer</A>
<LI><A HREF="hurd.html#IDX108">pager_dropweak</A>
<LI><A HREF="hurd.html#IDX93">pager_flush</A>
<LI><A HREF="hurd.html#IDX94">pager_flush_some</A>
<LI><A HREF="hurd.html#IDX99">pager_get_error</A>
<LI><A HREF="hurd.html#IDX102">pager_get_port</A>
<LI><A HREF="hurd.html#IDX101">pager_get_upi</A>
<LI><A HREF="hurd.html#IDX100">pager_memcpy</A>
<LI><A HREF="hurd.html#IDX97">pager_offer_page</A>
<LI><A HREF="hurd.html#IDX103">pager_read_page</A>
<LI><A HREF="hurd.html#IDX106">pager_report_extent</A>
<LI><A HREF="hurd.html#IDX95">pager_return</A>
<LI><A HREF="hurd.html#IDX96">pager_return_some</A>
<LI><A HREF="hurd.html#IDX98">pager_shutdown</A>
<LI><A HREF="hurd.html#IDX91">pager_sync</A>
<LI><A HREF="hurd.html#IDX92">pager_sync_some</A>
<LI><A HREF="hurd.html#IDX105">pager_unlock_page</A>
<LI><A HREF="hurd.html#IDX104">pager_write_page</A>
<LI><A HREF="hurd.html#IDX39">ports_begin_rpc</A>
<LI><A HREF="hurd.html#IDX28">ports_bucket_iterate</A>
<LI><A HREF="hurd.html#IDX24">ports_claim_right</A>
<LI><A HREF="hurd.html#IDX33">ports_count_bucket</A>
<LI><A HREF="hurd.html#IDX32">ports_count_class</A>
<LI><A HREF="hurd.html#IDX16">ports_create_bucket</A>
<LI><A HREF="hurd.html#IDX17">ports_create_class</A>
<LI><A HREF="hurd.html#IDX18">ports_create_port</A>
<LI><A HREF="hurd.html#IDX19">ports_create_port_noinstall</A>
<LI><A HREF="hurd.html#IDX57">ports_dead_name</A>
<LI><A HREF="hurd.html#IDX38">ports_demuxer_type</A>
<LI><A HREF="hurd.html#IDX23">ports_destroy_right</A>
<LI><A HREF="hurd.html#IDX35">ports_enable_bucket</A>
<LI><A HREF="hurd.html#IDX34">ports_enable_class</A>
<LI><A HREF="hurd.html#IDX40">ports_end_rpc</A>
<LI><A HREF="hurd.html#IDX26">ports_get_right</A>
<LI><A HREF="hurd.html#IDX20">ports_import_port</A>
<LI><A HREF="hurd.html#IDX46">ports_inhibit_all_rpcs</A>
<LI><A HREF="hurd.html#IDX45">ports_inhibit_bucket_rpcs</A>
<LI><A HREF="hurd.html#IDX44">ports_inhibit_class_rpcs</A>
<LI><A HREF="hurd.html#IDX43">ports_inhibit_port_rpcs</A>
<LI><A HREF="hurd.html#IDX56">ports_interrupt_notified_rpcs</A>
<LI><A HREF="hurd.html#IDX53">ports_interrupt_rpc_on_notification</A>
<LI><A HREF="hurd.html#IDX51">ports_interrupt_rpcs</A>
<LI><A HREF="hurd.html#IDX54">ports_interrupt_self_on_notification</A>
<LI><A HREF="hurd.html#IDX55">ports_interrupt_self_on_port_death</A>
<LI><A HREF="hurd.html#IDX27">ports_lookup_port</A>
<LI><A HREF="hurd.html#IDX42">ports_manage_port_operations_multithread</A>
<LI><A HREF="hurd.html#IDX41">ports_manage_port_operations_one_thread</A>
<LI><A HREF="hurd.html#IDX31">ports_no_senders</A>
<LI><A HREF="hurd.html#IDX30">ports_port_deref</A>
<LI><A HREF="hurd.html#IDX37">ports_port_deref_weak</A>
<LI><A HREF="hurd.html#IDX29">ports_port_ref</A>
<LI><A HREF="hurd.html#IDX36">ports_port_ref_weak</A>
<LI><A HREF="hurd.html#IDX22">ports_reallocate_from_external</A>
<LI><A HREF="hurd.html#IDX21">ports_reallocate_port</A>
<LI><A HREF="hurd.html#IDX50">ports_resume_all_rpcs</A>
<LI><A HREF="hurd.html#IDX49">ports_resume_bucket_rpcs</A>
<LI><A HREF="hurd.html#IDX48">ports_resume_class_rpcs</A>
<LI><A HREF="hurd.html#IDX47">ports_resume_port_rpcs</A>
<LI><A HREF="hurd.html#IDX52">ports_self_interrupted</A>
<LI><A HREF="hurd.html#IDX25">ports_transfer_right</A>
</DIR>
<H2><A NAME="cindex_q">q</A></H2>
<DIR>
<LI><A HREF="hurd.html#IDX234"><CODE>query</CODE> store</A>
</DIR>
<H2><A NAME="cindex_r">r</A></H2>
<DIR>
<LI><A HREF="hurd.html#IDX276">RAID-0</A>
<LI><A HREF="hurd.html#IDX286"><CODE>remap</CODE> store</A>
</DIR>
<H2><A NAME="cindex_s">s</A></H2>
<DIR>
<LI><A HREF="hurd.html#IDX3">serverboot</A>
<LI><A HREF="hurd.html#IDX5">servers.boot</A>
<LI><A HREF="hurd.html#IDX129">settrans</A>
<LI><A HREF="hurd.html#IDX296">store_allocate_child_encodings</A>
<LI><A HREF="hurd.html#IDX209">store_argp</A>
<LI><A HREF="hurd.html#IDX208">store_argp_params</A>
<LI><A HREF="hurd.html#IDX261">store_buffer_create</A>
<LI><A HREF="hurd.html#IDX220">store_children_name</A>
<LI><A HREF="hurd.html#IDX225">store_clear_child_flags</A>
<LI><A HREF="hurd.html#IDX223">store_clear_flags</A>
<LI><A HREF="hurd.html#IDX227">store_clone</A>
<LI><A HREF="hurd.html#IDX215">store_close_source</A>
<LI><A HREF="hurd.html#IDX272">store_concat_class</A>
<LI><A HREF="hurd.html#IDX233">store_concat_class_vectors</A>
<LI><A HREF="hurd.html#IDX274">store_concat_create</A>
<LI><A HREF="hurd.html#IDX273">store_concat_open</A>
<LI><A HREF="hurd.html#IDX258">store_copy_class</A>
<LI><A HREF="hurd.html#IDX260">store_copy_create</A>
<LI><A HREF="hurd.html#IDX259">store_copy_open</A>
<LI><A HREF="hurd.html#IDX214">store_create</A>
<LI><A HREF="hurd.html#IDX295">store_decode</A>
<LI><A HREF="hurd.html#IDX298">store_decode_children</A>
<LI><A HREF="hurd.html#IDX243">store_device_class</A>
<LI><A HREF="hurd.html#IDX245">store_device_create</A>
<LI><A HREF="hurd.html#IDX244">store_device_open</A>
<LI><A HREF="hurd.html#IDX289">store_enc</A>
<LI><A HREF="hurd.html#IDX291">store_enc_dealloc</A>
<LI><A HREF="hurd.html#IDX290">store_enc_init</A>
<LI><A HREF="hurd.html#IDX292">store_enc_return</A>
<LI><A HREF="hurd.html#IDX294">store_encode</A>
<LI><A HREF="hurd.html#IDX297">store_encode_children</A>
<LI><A HREF="hurd.html#IDX247">store_file_class</A>
<LI><A HREF="hurd.html#IDX249">store_file_create</A>
<LI><A HREF="hurd.html#IDX248">store_file_open</A>
<LI><A HREF="hurd.html#IDX216">store_free</A>
<LI><A HREF="hurd.html#IDX263">store_gunzip_class</A>
<LI><A HREF="hurd.html#IDX265">store_gunzip_create</A>
<LI><A HREF="hurd.html#IDX264">store_gunzip_open</A>
<LI><A HREF="hurd.html#IDX281">store_ileave_class</A>
<LI><A HREF="hurd.html#IDX282">store_ileave_create</A>
<LI><A HREF="hurd.html#IDX226">store_is_securely_returnable</A>
<LI><A HREF="hurd.html#IDX229">store_map</A>
<LI><A HREF="hurd.html#IDX284">store_mvol_class</A>
<LI><A HREF="hurd.html#IDX285">store_mvol_create</A>
<LI><A HREF="hurd.html#IDX236">store_open</A>
<LI><A HREF="hurd.html#IDX240">store_open_children</A>
<LI><A HREF="hurd.html#IDX207">store_parsed</A>
<LI><A HREF="hurd.html#IDX212">store_parsed_append_args</A>
<LI><A HREF="hurd.html#IDX210">store_parsed_free</A>
<LI><A HREF="hurd.html#IDX213">store_parsed_name</A>
<LI><A HREF="hurd.html#IDX211">store_parsed_open</A>
<LI><A HREF="hurd.html#IDX235">store_query_class</A>
<LI><A HREF="hurd.html#IDX230">store_read</A>
<LI><A HREF="hurd.html#IDX228">store_remap</A>
<LI><A HREF="hurd.html#IDX287">store_remap_class</A>
<LI><A HREF="hurd.html#IDX288">store_remap_create</A>
<LI><A HREF="hurd.html#IDX293">store_return</A>
<LI><A HREF="hurd.html#IDX217">store_run</A>
<LI><A HREF="hurd.html#IDX224">store_set_child_flags</A>
<LI><A HREF="hurd.html#IDX219">store_set_children</A>
<LI><A HREF="hurd.html#IDX222">store_set_flags</A>
<LI><A HREF="hurd.html#IDX221">store_set_name</A>
<LI><A HREF="hurd.html#IDX218">store_set_runs</A>
<LI><A HREF="hurd.html#IDX232">store_std_classes[]</A>
<LI><A HREF="hurd.html#IDX300">store_std_leaf_allocate_encoding</A>
<LI><A HREF="hurd.html#IDX302">store_std_leaf_create_t</A>
<LI><A HREF="hurd.html#IDX303">store_std_leaf_decode</A>
<LI><A HREF="hurd.html#IDX301">store_std_leaf_encode</A>
<LI><A HREF="hurd.html#IDX251">store_task_class</A>
<LI><A HREF="hurd.html#IDX253">store_task_create</A>
<LI><A HREF="hurd.html#IDX252">store_task_open</A>
<LI><A HREF="hurd.html#IDX239">store_typed_open</A>
<LI><A HREF="hurd.html#IDX238">store_typed_open_class</A>
<LI><A HREF="hurd.html#IDX299">store_with_decoded_runs</A>
<LI><A HREF="hurd.html#IDX231">store_write</A>
<LI><A HREF="hurd.html#IDX255">store_zero_class</A>
<LI><A HREF="hurd.html#IDX256">store_zero_create</A>
<LI><A HREF="hurd.html#IDX277">striping, disk</A>
</DIR>
<H2><A NAME="cindex_t">t</A></H2>
<DIR>
<LI><A HREF="hurd.html#IDX250"><CODE>task</CODE> store</A>
<LI><A HREF="hurd.html#IDX166">trivfs_add_control_port_class</A>
<LI><A HREF="hurd.html#IDX164">trivfs_add_port_bucket</A>
<LI><A HREF="hurd.html#IDX167">trivfs_add_protid_port_class</A>
<LI><A HREF="hurd.html#IDX148">trivfs_allow_open</A>
<LI><A HREF="hurd.html#IDX134">trivfs_append_args</A>
<LI><A HREF="hurd.html#IDX138">trivfs_begin_using_control</A>
<LI><A HREF="hurd.html#IDX139">trivfs_begin_using_protid</A>
<LI><A HREF="hurd.html#IDX158">trivfs_check_open_hook</A>
<LI><A HREF="hurd.html#IDX170">trivfs_clean_cntl</A>
<LI><A HREF="hurd.html#IDX171">trivfs_clean_protid</A>
<LI><A HREF="hurd.html#IDX157">trivfs_cntl_nportclasses</A>
<LI><A HREF="hurd.html#IDX156">trivfs_cntl_portclasses[]</A>
<LI><A HREF="hurd.html#IDX136">trivfs_create_control</A>
<LI><A HREF="hurd.html#IDX137">trivfs_demuxer</A>
<LI><A HREF="hurd.html#IDX140">trivfs_end_using_control</A>
<LI><A HREF="hurd.html#IDX141">trivfs_end_using_protid</A>
<LI><A HREF="hurd.html#IDX147">trivfs_fsid</A>
<LI><A HREF="hurd.html#IDX146">trivfs_fstype</A>
<LI><A HREF="hurd.html#IDX163">trivfs_getroot_hook</A>
<LI><A HREF="hurd.html#IDX153">trivfs_goaway</A>
<LI><A HREF="hurd.html#IDX152">trivfs_modify_stat</A>
<LI><A HREF="hurd.html#IDX142">trivfs_open</A>
<LI><A HREF="hurd.html#IDX160">trivfs_peropen_create_hook</A>
<LI><A HREF="hurd.html#IDX162">trivfs_peropen_destroy_hook</A>
<LI><A HREF="hurd.html#IDX159">trivfs_protid_create_hook</A>
<LI><A HREF="hurd.html#IDX161">trivfs_protid_destroy_hook</A>
<LI><A HREF="hurd.html#IDX143">trivfs_protid_dup</A>
<LI><A HREF="hurd.html#IDX155">trivfs_protid_nportclasses</A>
<LI><A HREF="hurd.html#IDX154">trivfs_protid_portclasses[]</A>
<LI><A HREF="hurd.html#IDX168">trivfs_remove_control_port_class</A>
<LI><A HREF="hurd.html#IDX165">trivfs_remove_port_bucket</A>
<LI><A HREF="hurd.html#IDX169">trivfs_remove_protid_port_class</A>
<LI><A HREF="hurd.html#IDX132">trivfs_runtime_argp</A>
<LI><A HREF="hurd.html#IDX144">trivfs_set_atime</A>
<LI><A HREF="hurd.html#IDX145">trivfs_set_mtime</A>
<LI><A HREF="hurd.html#IDX133">trivfs_set_options</A>
<LI><A HREF="hurd.html#IDX135">trivfs_startup</A>
<LI><A HREF="hurd.html#IDX151">trivfs_support_exec</A>
<LI><A HREF="hurd.html#IDX149">trivfs_support_read</A>
<LI><A HREF="hurd.html#IDX150">trivfs_support_write</A>
<LI><A HREF="hurd.html#IDX237"><CODE>typed_open</CODE> store</A>
</DIR>
<H2><A NAME="cindex_x">x</A></H2>
<DIR>
<LI><A HREF="hurd.html#IDX87">XP (external pager)</A>
</DIR>
<H2><A NAME="cindex_z">z</A></H2>
<DIR>
<LI><A HREF="hurd.html#IDX254"><CODE>zero</CODE> store</A>
</DIR>


<P><HR><P>
This document was generated on 29 June 1999 using
<A HREF="http://wwwinfo.cern.ch/dis/texi2html/">texi2html</A>&nbsp;1.56k.
</BODY>
</HTML>

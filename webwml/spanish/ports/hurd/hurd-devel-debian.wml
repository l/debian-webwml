#use wml::debian::template title="Debian GNU/Hurd --- Desarrollo" NOHEADER="yes"
#use wml::debian::translation-check translation="1.24"
#include "$(ENGLISHDIR)/ports/hurd/menu.inc"

<h1>
Debian GNU/Hurd</h1>
<h2>
Desarrollo de la Distribución</h2>
<h3>
Boot Disks</h3>
<p>
Actualmente estamos investigando los distintos modos de arrancar un sistema
Hurd mínimo y cómo crear floppies de arranque. En <code><a
href="ftp://alpha.gnu.org/gnu/hurd/contrib/marcus/">ftp://alpha.gnu.org/gnu/hurd/contrib/marcus</a></code>
hay disponible un disco de arranque provisional en el fichero
<code>boot-YYYYMMDD</code>. Este disco contiene el Mach de GNU,
el servidor <code>ext2fs</code>, el enlazador <code>ld.so</code>, el
programa de arranque <code>serverboot</code> y una copia de GRUB. Este 
disco arranca y espera un disco raíz, que no está disponible todavía.</p>

<h3>
Adaptando Paquetes de Debian</h3>
<p>
Si quiere ayudar con la arquitectura GNU/Hurd, debería familiarizarse
con el sistema de empaquetado de Debian. Una vez que lo haya hecho, 
leyendo la documentación disponible y visitando el <a
href="../../devel/">Rincón de los Desarrolladores</a> debería saber
cómo extraer los fuentes de los paquetes de Debian y construir un
paquete Debian. He aquí un curso acelerado para los muy perezosos:</p>

<h3>
Obtener el Código Fuente y Construir Paquetes</h3>
<p>
Para extraer el contenido de un paquete de fuentes de Debian se necesita
el fichero
<code>package_version.dsc</code> y los ficheros listados en él. El 
directorio de compilación de Debian se construye con la orden
 <code>dpkg-source -x package_version.dsc</code></p>
<p>
La construcción de un paquete se lleva a cabo en el nuevo directorio
de construcción Debian 
<code>package-version</code> con la orden <code>dpkg-buildpackage -B -rsudo
"-mMiNombre &lt;MiCorreo&gt;"</code>. En lugar de <code>-B</code> se puede
usar 
<code>-b</code> si también quiere construir las partes del paquete que 
son independientes de la arquitectura. Puede utilizar
 <code>-rfakeroot</code> en lugar de
<code>-rsudo</code>, si utiliza el paquete fakeroot. Si está construyendo
como usuario root, puede hacerlo sin <code>-r</code>. Puede añadir
<code>-uc</code> para evitar firmar el paquete con su clave pgp.</p>

<h3>
Escoja Uno</h3>
<p>
¿En que paquetes se necesita trabajar? Bien, lo mejor que puedo
hacer ahora es decir en qué paquetes no debería trabajar.</p>
<p>
La lista actualizada de paquetes que aún no han sido adaptados está
disponible en el <a href="http://hurd.sourceforge.net/turtle/">estado del
archivo de Debian hurd-i386</a>.</p>

<h4>
Paquetes que No Van a Ser Adaptados
</h4>
<p>
Algunos de estos paquetes, o partes de ellos, podrían ser adaptables
más adelante, pero, al menos actualmente, se consideran inadaptables.</p>

<ul>
<li>
<code>base/update</code>, porque el Hurd no necesita un demonio
update (los sistemas de archivos se sincronizan ellos mismos). Para 
cambiar el intervalo de sincronización, puede utilizar
 <code>fsysopts</code> para ajustar la opción <code>--sync</code>. 
¡Se puede establecer diferentes intervalos de sincronización para cada
sistema de archivos! Para sincronizar manualmente, utilice la utilidad <a
href="hurd-doc-utils#syncfs"><code>syncfs</code></a>.</li>
<li>
<code>base/makedev</code>, porque el Hurd viene con su propia versión de
este guión. El paquete de fuentes de Debian sólo contiene una versión
específica para Linux.</li>
<li>
<code>base/ld.so</code>, porque el Hurd no utiliza el enlazador que se
distribuye con la biblioteca de C de GNU.</li>
<li>
<code>base/modconf</code> y <code>base/modutils</code>, porque el concepto
de módulo es específico de Linux.</li>
<li>
<code>base/netbase</code>, porque el resto de cosas que hay en él es 
muy específico del núcleo Linux. El Hurd, en su lugar, utiliza
<code>inetutils</code>.</li>
<li>
<code>base/pcmcia-cs</code>, porque el Hurd no da soporte para PCMCIA
(e incluso si lo tuviese, este paquete es probablemente específico para
Linux).</li>
<li>
<code>base/procps</code>, porque este código es específico para el sistema
de ficheros proc de Linux.</li>
<li>
<code>base/ppp</code> y <code>base/pppconfig</code>, porque el Hurd no 
da ningún soporte para PPP (e incluso si lo tuviese, este paquete es 
probablemente muy específico para Linux).</li>
<li>
<code>base/setserial</code>, porque es específico para el núcleo de Linux.
Sin embargo, con la adaptación de los gestores de dispositivos de 
caracteres al Mach de GNU, quizá podamos utilizarlo.</li>
</ul>

<h3>
 Generalidades de la Adaptación
</h3>
<p>
He aquí una lista de incompatibilidades comunes que puede encontrar 
cuando compile en el Hurd programas no suficientemente portables.</p>
<p>
<ul>
<li>
<code>Descriptor de Archivo Erróneo</code>
<p>
Si ve el error <code>Bad File Descriptor</code> cuando intenta leer
un archivo (o acceder a él de algún modo), compruebe la llamada a
 <code>open()</code>. El segundo argumento es el método de acceso.
Si tiene un número en lugar de uno de los símbolos definidos en los
ficheros estándar de cabecera, el código es malo, y se debería
arreglar o usar
<code>O_RDONLY</code>, <code>O_WRONLY</code> o
<code>O_RDWR</code>. Este error se ha observado en los paquetes
<code>fortunes</code> y <code>mtools</code>, por ejemplo.</p></li>
<li>
<code>PATH_MAX</code>
<p>
Cada uso sin condiciones de <code>PATH_MAX</code> es una incompatibilidad
con POSIX. Si no hay límite superior para la longitud de un camino, este
símbolo no está definido en ningún archivo de cabecera. En su lugar, 
necesita usar una implementación diferente que no dependa de la
longitud de una cadena, o usar <code>sysconf()</code> para preguntar
la longitud durante la ejecución. Si <code>sysconf()</code> devuelve
<code>-1</code>, ha de usar <code>realloc()</code> para reservar de
modo dinámico la memoria necesaria.</p></li>
<li>
<code>MAXHOSTNAMELEN</code>
<p>
véase <code>PATH_MAX</code></p></li>
<li>
<code>MAXPATHLEN</code>
<p>
véase <code>PATH_MAX</code></p></li>
<li>
<code>NOFILE</code>
<p>
véase <code>PATH_MAX</code></p></li>
<li>
<code>#define</code> específico del Hurd
<p>
Si necesita incluir código específico para el Hurd utilizando
<code>#if...#endif</code>, entonces puede usar el símbolo
 <code>__GNU__</code> para hacerlo. !Pero antes piénselo (al menos) tres veces!
En la 
<em>mayoría</em> de las situaciones, es completamente innecesario y creará
más problemas de los que puede resolver. Mejor pregunte en las listas
de correo cómo hacerlo correctamente si no se le ocurre una solución
mejor.</p></li>
<li>
<code>sys_errlist[]</code> vs. <code>strerror()</code>
<p>
Si un programa sólo tiene soporte para <code>sys_errlist[]</code> tendrá
que hacer algún trabajo para hacerlo compatible en el Hurd, que ha
dejado de dar soporte para esto y sólo proporciona <code>strerror()</code>. 
Steinar Hamre escribió lo siguiente acerca de <code>strerror():</code></p>
<blockquote>
<p>
Se debería usar<code>strerror()</code> porque :
<ul>
<li>
Es la forma moderna y POSIX.</li>
<li>
Está localizada.</li>
<li>
Gestiona señales/número no válidos fuera de rango. (mejor gestión de
error y no un candidato a desbordamiento de buffer/riesgo de seguridad)</li></ul>
<p>
Si está disponible, se debería usar siempre <code>strerror()</code>.
Desafortunadamente, todavía hay algunos <em>viejos</em> sistemas
no POSIX que no tienen <code>strerror()</code>, sólo
<code>sys_errlist[]</code>.</p>
<p>
Hoy, dar soporte sólo a <code>strerror()</code> es mucho mejor que dar
soporte sólo a
<code>sys_errlist[]</code>. Lo mejor (desde el punto de vista de la
portabilidad), sin embargo, es dar soporte a ambos. Para
<code>configure.in</code>, necesitará:</p>
<p>
<code>AC_CHECK_FUNCS(strerror)</code></p>
<p>
Para <code>config.h.in</code>, necesitará añadir:</p>
<p>
<code>#undef HAVE_STRERROR</code></p>
<p>
Luego, algo como:
<pre>
        \#ifndef HAVE_STRERROR
        static char *
        private_strerror (errnum)
             int errnum;
        {
          extern char *sys_errlist[];
          extern int sys_nerr;

          if (errnum &gt; 0 &amp;&amp; errnum &lt;= sys_nerr)
            return sys_errlist[errnum];
          return "Unknown system error";
        }
        \#define strerror private_strerror
        \#endif /* HAVE_STRERROR */
</pre>
<p>
Por ejemplo, puede mirar en el último fileutils (lo anterior es una
versión simplificada de lo que encontré ahí.) Por supuesto, los parches
se deberían enviar a los mantenedores principales, esto es muy útil 
incluso para sistemas en los que funciona <code>sys_errlist[]</code>.</blockquote>
<li>
Nombres De Fichero Que Terminan En `/'
<p>
Son malvados si no existen y quiere darle un nombre así a un directorio.
Por ejemplo, <code>mkdir foobar/</code> <em>no</em> funcionará en
el Hurd. Esto es compatible con POSIX. POSIX dice que el camino
de un directorio puede tener `/' concatenados. Pero el directorio no
existe todavía, así que el camino no se refiere a un directorio,
y de ahí que no se garantice que los `/' al final funcionen. Simplemente,
descarte los `/', y le irá bien.
</ul>

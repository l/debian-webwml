#! /usr/bin/perl

# cvs-mailcommit - Send CVS commitments via mail
# Copyright (c) 1998,2004  Martin Schulze <joey@infodrom.org>
#
# $Id$
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111, USA.

# For testing, call this program like:
#   echo "Logmsg" | CVSROOT=/cvs/webwml ./cvs-mailcommit -m $LOGNAME --from "$LOGNAME@`hostname -f`" --cvs 'CVSROOT loginfo,1.10,1.11' --diff

# To extract the inline documentation, run the following command:
#   pod2html cvs-mailcommit > cvs-mailcommit.1
# To read this documentation, just type
#   perldoc cvs-mailcommit

=head1 NAME

cvs-mailcommit - Send CVS commitments via mail

=head1 SYNOPSIS

B<cvs-mailcommit> [options]

=head1 DESCRIPTION

B<cvs-mailcommit> is a helper application to CVS to help people keep
track of CVS repositories via mail.  It is hooked into the CVS system
via the B<CVSROOT>/I<loginfo> file.  It will read modification
information from CVS via B<stdin> and require version information via
the commandline.

B<cvs-mailcommit> will send differences of modified files or entire
new files via mail to the denoted address.

You'll have to hook it into CVS for each module in a repository that
you want to monitor via mail.  See B<INSTALLATION> below

=cut

$sendmail = "/usr/sbin/sendmail";

$opt_xloop = '';
$opt_cvs = '';
$opt_from = '';
$opt_approved = '';
$opt_diff = 0;
$opt_full = 0;
$opt_maxlines = 400;
@opt_mailto = ();
while (@ARGV) {
    $arg = shift;

    if ($arg eq "-m" || $arg eq "--mailto") {
	if (@ARGV) {
	    $tmp = shift;
	    push (@opt_mailto, $tmp);
	}
    } elsif ($arg eq "--diff") {
	$opt_diff = 1;
    } elsif ($arg eq "--full") {
	$opt_full = 1;
    } elsif ($arg eq "--xloop") {
	$opt_xloop = shift if (@ARGV);
    } elsif ($arg eq "--from") {
	$opt_from = shift if (@ARGV);
    } elsif ($arg eq "--approved") {
	$opt_approved = shift if (@ARGV);
    } elsif ($arg eq "--maxlines") {
	$opt_maxlines = shift if (@ARGV);
    } elsif ($arg eq "--cvs") {
	if (@ARGV) {
	    $tmp = shift;
	    $opt_cvs = $tmp;
	}
    }
}

=head1 OPTIONS

This program supports the following arguments.  When the arguments
don't make sense the program won't do anything.

=over 6

=item B<-m> I<address>, B<--mailto> I<address>

Send the mail to the specified I<address>.

=item B<--diff>

Generate unified diffs for all modified files.

=item B<--full>

Include the entire fill for newly created files that were added to the
repository.

=item B<--maxlines> I<nnn>

You can specify how many lines per file may be quoted in the resulting
mail.  Limiting the number of quoted lines may be useful for
repositories with excessive changes that are similar.  The default is
to copy 400 lines.

=item B<--xloop> I<address>

Include a special B<X-Loop> header in the generated mail.  This is
intended for users to be able to filter CVS mails by a common header
line.  The line will look like

X-Loop: I<address>

=item B<--from> I<address>

Generate a useful B<From:>-line of the form

From: I<address>

=item B<--approved> I<address>

Include a special B<Approved:>-line in the mail.  This header is
intended for moderated mailing-lists to pass the SmartList moderation
mechanism.  The created header will look like

Approved: I<address>

=item B<--cvs> I<version string>

This option carries the CVS version info from CVS into the program.
It will be added automatically by CVS.  When installing this program
into the B<loginfo> file of a CVS repository, you will need to add the
following option:

B<--cvs> %{sVv}

If you want to test this program manually you'll have to supply the
module directory and the modified files including the old and new
versions.  This will look like

--cvs 'CVSROOT loginfo,1.1,1.2'

=back

=cut

exit 0 if (!@opt_mailto);

# $opt_cvs looks like
#   foo/waz bar,1.4,1.5 foo,1.2,1.3
# or
#   foo gnatz,1.3,1.4
#
@cvs_arr = split (/ /,$opt_cvs);
$module_dir = shift(@cvs_arr);

$login = $ENV{'CVS_USER'} || $ENV{'LOGNAME'}|| getlogin || (getpwuid($<))[0] || "nobody";

if (open (M, "|$sendmail -t")) {
# if (open (M, ">-")) {
    printf M "To: %s\n", join(",",@opt_mailto);
    printf M "Subject: CVS %s\n", $module_dir;
    printf M "From: \"CVS User %s\" <%s>\n", $login, $opt_from if ($opt_from);
    printf M "Approved: %s\n", $opt_approved if ($opt_approved);
    printf M "X-Loop: %s\n", $opt_xloop if ($opt_xloop);
    print  M "\n";
    print M while (<>);

    if ($opt_diff) {
	print  M "\n";
	foreach $cstr (@cvs_arr) {
	    ($file,$oldver,$newver) = split (/,/,$cstr);
	    next if ($oldver eq "" || $newver eq "");
	    if ($oldver ne "NONE") {
		# print "rcsdiff -r$oldver -r$newver -u $ENV{'CVSROOT'}/$module_dir/$file|\n";
		if (open (R, "rcsdiff -r$oldver -r$newver -u $ENV{'CVSROOT'}/$module_dir/$file 2>/dev/null |")) {
		    $lines = 0;
		    while (<R>) {
			$lines++;
			print M if ($lines <= $opt_maxlines);
		    }
		    close (R);
		    printf M "\n[%d lines skipped]\n", $lines - $opt_maxlines if ($lines > $opt_maxlines);
		}
	    }
	}
    }

    # Process new files
    if ($opt_full) {
	print  M "\n";
	foreach $cstr (@cvs_arr) {
	    ($file,$oldver,$newver) = split (/,/,$cstr);
	    next if ($oldver ne "NONE" || $newver ne "1.1");

	    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)
		= gmtime(time);

	    my $date = sprintf ("%4d/%02d/%02d %02d:%02d:%02d",
				$year+1900, $mon+1, $mday, $hour,$min,$sec);

	    if (open (R, "co -p -r$newver $ENV{'CVSROOT'}/$module_dir/$file 2>/dev/null |")) {
		printf M "--- %s/%s/%s\t%s\tNONE\n", $ENV{'CVSROOT'}, $module_dir, $file, $date;
		printf M "+++ %s/%s/%s\t%s\t%s\n", $ENV{'CVSROOT'}, $module_dir, $file, $date, $newver;
		while (<R>) {
		    $lines++;
		    print M if ($lines <= $opt_maxlines);
		}
		close (R);
		printf M "\n[%d lines skipped]\n", $lines - $opt_maxlines if ($lines > $opt_maxlines);
	    } else {
		print M "Cannot open, huh, $!\n";
	    }
	}
    }

    close (M);
}

=head1 INSTALLATION

The B<CVSROOT>/I<loginfo> file controls where B<cvs commit> log
information is sent.  The first entry on a line is a regular
expression which must match the directory (alias module) that the
change is being made to, relative to the $B<CVSROOT>.  If a match is
found, then the remainder of the line is a filter program that should
expect log information on its standard input.

A I<loginfo> line looks like

<directory>    <command> --<option> --<option>

=head1 EXAMPLE

Assume you want to monitor changes in the B<CVSROOT> module, then you
may want to use the following line.

    CVSROOT	cvs-mailcommit \
      --mailto master@host.org \
      --from cvs@cvshost.com \
      --cvs %{sVv} --diff --full

If you want to distribute changes in a module via a mailing list where
only these log messages should appear you may have to add an X-Loop:
or Approved: header line.

    webwml	cvs-mailcommit \
      --mailto master@host.org \
      --from cvs@cvshost.com \
      --approved cvsmaster@cvshost.com \
      --cvs %{sVv} --diff --full

To improve readability, the above lines were broken up into several
lines using normal continuation lines.  This is not supported by CVS.
You will have to write it in one single line.

=head1 WARNING

CVS does not support continuation lines (multiple lines per command)
in the B<CVSROOT>/I<loginfo> file.  You'll have to write each filter
in a single line of its own.

=head1 SOURCE

http://www.infodrom.org/Infodrom/tools/cvs-mailcommit.html

=cut
